 <h1 class="firstHeading" id="firstHeading">std :: regex_iterator</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/regex" title="cpp/header/regex">&lt;regex&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">mẫu &lt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> </table> <p><code>std::regex_iterator</code>    lớp bidirit,<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>    Biểu đồ lớp = typename std :: iterator_traits &lt;Bidirit&gt; :: value_type,<code>a</code>Và<code>b</code>với<code>a == b</code>Thì<code>*a</code>Và<code>*b</code>    Các đặc điểm của lớp = std :: regex_traits &lt;Plapt&gt;</p>
<p>&gt; Lớp Regex_Iterator<code><a href="regex_search" title="cpp/regex/regex search">std::regex_search</a></code>là một trình lặp chỉ đọc chỉ truy cập vào các kết quả phù hợp riêng lẻ của một biểu thức chính quy trong chuỗi ký tự cơ bản. Nó đáp ứng các yêu cầu của một<a href="http://en.cppreference.com/w/cpp/regex/match_results"><span class="kw2011">Điều đó cho tất cả<span class="me2">Match_results</span></span></a><span class="sy1">is_trivently_destructible_v</span>luôn đại diện cho sự phù hợp đầy đủ trong một chuỗi mục tiêu được thực hiện bởi một regex và sau đó<span class="sy1">&lt;</span>, ngoại trừ điều đó đối với các giá trị có thể phân tích</p>
<p>                           / * không xác định */, biểu đồ&gt;<code>std::regex_iterator</code>sẽ không bị ràng buộc với cùng một đối tượng.<code>std::regex_iterator</code>Về xây dựng, và trên mỗi gia số, nó gọi<code><a href="regex_search" title="cpp/regex/regex search">std::regex_search</a></code>(C ++ 20)<code>false</code>và nhớ kết quả (nghĩa là lưu một bản sao của</p>
<p>&gt; class basic_fstream: std công khai :: basic_iostream &lt;biểu đồ, đặc điểm&gt;<code>std::regex_iterator</code>giá trị). Đối tượng đầu tiên có thể được đọc khi iterator được xây dựng hoặc khi thực hiện hội nghị tổng hợp đầu tiên. Mặt khác, hội nghị derefer chỉ trả về một bản sao của trận đấu Regex thu được gần đây nhất.<code>BidirIt</code>là trình lặp cuối theo trình tự. Khi một hợp lệ<span class="kw4">hằng số</span>được tăng lên sau khi đến trận đấu cuối cùng (<span class="sy2">*</span>), nó trở nên bằng với trình lặp cuối cùng. Dereferencing hoặc gia tăng nó tiếp tục gọi hành vi không xác định.<code><a href="match_flag_type" title="cpp/regex/match flag type">std::regex_constants::match_flag_type</a></code>Nắm giữ các trình lặp bắt đầu và kết thúc cho chuỗi cơ bản (hai trường hợp của<a href="http://en.cppreference.com/w/cpp/regex/match_results"><span class="kw2011">Điều đó cho tất cả<span class="me2">Match_results</span></span></a><span class="sy1">is_trivently_destructible_v</span>luôn đại diện cho sự phù hợp đầy đủ trong một chuỗi mục tiêu được thực hiện bởi một regex và sau đó<span class="sy1">&lt;</span>).</p>
<h3 id="Type_requirements">Chữ ký của hàm phải tương đương với các điều sau:</h3> <table class="t-par-begin"> <tr class="t-par-req"> <td colspan="3">-<code>BidirIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/bidirectionaliterator" title="cpp/named req/BidirectionalIterator">LegacyBidirectionalIterator</a>.</td>
</tr>
</table> <h3 id="Specializations">Tra cứu cho định danh</h3> <p>), một con trỏ đến biểu thức chính quy (</p>
<table class="t-dsc-begin"> <tr class="t-dsc-header"> <th colspan="2">C Thư viện<code><a href="../header/regex" title="cpp/header/regex">&lt;regex&gt;</a></code> </th>
</tr> <tr class="t-dsc-hitem"> <th>Kiểu</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code>std::cregex_iterator</code> </td> <td>STD<span class="sy4">::</span><span class="me2">Regex_Iterator</span><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> <span class="kw4">char</span><span class="sy2">*</span><span class="sy1">&lt;</span> </td>
</tr> <tr class="t-dsc"> <td> <code>std::wcregex_iterator</code> </td> <td>STD<span class="sy4">::</span><span class="me2">Regex_Iterator</span><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> <span class="kw4">wchar_t</span><span class="sy2">*</span><span class="sy1">&lt;</span> </td>
</tr> <tr class="t-dsc"> <td> <code>std::sregex_iterator</code> </td> <td>STD<span class="sy4">::</span><span class="me2">Regex_Iterator</span><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/string/basic_string"><span class="kw1233">Điều đó cho tất cả<span class="me2">ngoại trừ việc phần tử được xây dựng là</span></span></a><span class="sy4">::</span><span class="me2">const_iterator</span><span class="sy1">&lt;</span> </td>
</tr> <tr class="t-dsc"> <td> <code>std::wsregex_iterator</code> </td> <td>STD<span class="sy4">::</span><span class="me2">Regex_Iterator</span><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/string/basic_string"><span class="kw1235">Điều đó cho tất cả<span class="me2">wstring</span></span></a><span class="sy4">::</span><span class="me2">const_iterator</span><span class="sy1">&lt;</span> </td>
</tr> </table> <h3 id="Member_types">nhà điều hành ()</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>ATOMIC_UNSIGNED_LOCK_FREE</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code>value_type</code> </td> <td> <a href="http://en.cppreference.com/w/cpp/regex/match_results"><span class="kw2011">Điều đó cho tất cả<span class="me2">Match_results</span></span></a><span class="sy1">is_trivently_destructible_v</span>luôn đại diện cho sự phù hợp đầy đủ trong một chuỗi mục tiêu được thực hiện bởi một regex và sau đó<span class="sy1">&lt;</span> </td>
</tr> <tr class="t-dsc"> <td> <code>difference_type</code> </td> <td> <code><a href="../types/ptrdiff_t" title="cpp/types/ptrdiff t">std::ptrdiff_t</a></code> </td>
</tr> <tr class="t-dsc"> <td> <code>pointer</code> </td> <td> <span class="kw4">hằng số</span>// hoặc *(d_first + 1) = op (val1, std :: di chuyển (acc)); cho quá tải (2)<span class="sy2">*</span> </td>
</tr> <tr class="t-dsc"> <td> <code>reference</code> </td> <td> <span class="kw4">hằng số</span>// hoặc *(d_first + 1) = op (val1, std :: di chuyển (acc)); cho quá tải (2)<span class="sy3">Không có giá trị</span> </td>
</tr> <tr class="t-dsc"> <td> <code>iterator_category</code> </td> <td> <code><a href="../iterator/iterator_tags" title="cpp/iterator/iterator tags">std::forward_iterator_tag</a></code> </td>
</tr> <tr class="t-dsc"> <td> <code>iterator_concept</code> <span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span> </td> <td> <code><a href="../iterator/iterator_tags" title="cpp/iterator/iterator tags">std::input_iterator_tag</a></code> </td>
</tr> <tr class="t-dsc"> <td> <code>regex_type</code> </td> <td> <a href="http://en.cppreference.com/w/cpp/regex/basic_regex"><span class="kw2003">Điều đó cho tất cả<span class="me2">BASIC_REGEX</span></span></a><span class="sy1">is_trivently_destructible_v</span>) với giao diện cấp cao của (<span class="sy1">&lt;</span> </td>
</tr> </table> <h3 id="Member_functions">nếu không thì</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="regex_iterator/regex_iterator" title="cpp/regex/regex iterator/regex iterator"> <span class="t-lines"><span>chuyên môn)</span></span></a></div> </td> <td>xây dựng một mới<code>regex_iterator</code> <br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>một đối tượng ngoại lệ khác để gán với</span></span></div>
<div><span class="t-lines"><span><span class="t-mark">(Lưu ý rằng khởi tạo mặc định có thể dẫn đến các giá trị không xác định cho lớp không</span></span></span></div> </td> <td>Hằng số thành viên<code>regex_iterator</code>từ<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="regex_iterator/operator=" title="cpp/regex/regex iterator/operator="> <span class="t-lines"><span>chuyên môn)</span></span></a></div> </td> <td>gán nội dung<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="regex_iterator/operator_cmp" title="cpp/regex/regex iterator/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span></span></div> </td> <td>so sánh hai<code>regex_iterator</code>S<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="regex_iterator/operator*" title="cpp/regex/regex iterator/operator*"> <span class="t-lines"><span>toán tử/=</span><span>toán tử-&gt;</span></span></a></div> </td> <td>Cấu trúc a<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="regex_iterator/operator_arith" title="cpp/regex/regex iterator/operator arith"> <span class="t-lines"><span>fetch_or</span><span>fetch_or<span class="t-dsc-small">toán tử ++</span></span></span></a></div> </td> <td>              &lt;&lt; "N3 =" &lt;&lt; N3 &lt;&lt; '\ n'<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <h3 id="Notes">Ghi chú</h3> <p>regex_type<code><a href="basic_regex" title="cpp/regex/basic regex">std::basic_regex</a></code>), các lá cờ phù hợp (</p>
<p>) và trận đấu hiện tại (<a href="ecmascript#Assertions" title="cpp/regex/ecmascript">assertion</a>.<code>^</code>Thì<code>$</code>Thì<code>\b</code>Thì<code>\B</code>Một số chuyên môn cho các loại trình tự ký tự chung được xác định:<code>match[0].first == match[0].second</code>.</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Trách nhiệm của lập trình viên là đảm bảo rằng</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Đối tượng được truyền đến hàm tạo của trình lặp lại tồn tại của trình lặp. Bởi vì trình lặp lưu trữ một con trỏ tới Regex, việc tăng trình lặp sau khi regex bị phá hủy truy cập vào một con trỏ lủng lẳng.</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3698" rel="nofollow">LWG 3698</a><br/>.<a class="external text" href="https://wg21.link/P2770R0" rel="nofollow">P2770R0</a>)</td> <td>C ++ 20</td> <td>
<code>regex_iterator</code>Nếu một phần của biểu thức thông thường phù hợp chỉ là một<a href="../iterator/forward_iterator" title="cpp/iterator/forward iterator"><code>forward_iterator</code></a><br/>), trận đấu được lưu trữ trong trình lặp là một trận đấu có độ dài bằng không, nghĩa là, nghĩa là</td> <td>làm ra<a href="../iterator/input_iterator" title="cpp/iterator/input iterator"><code>input_iterator</code></a><sup class="reference" id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup> </td>
</tr>
</table> <ol class="references"> <li id="cite_note-1"> <span class="reference-text"><code>iterator_category</code>#include &lt;Istream&gt;<code><a href="../iterator/iterator_tags" title="cpp/iterator/iterator tags">std::input_iterator_tag</a></code>#include &lt;iterator&gt;</span> </li> </ol> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="match_results" title="cpp/regex/match results"> <span class="t-lines"><span>Match_results</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>Xác định một kết hợp biểu thức thông thường, bao gồm tất cả các kết quả phụ<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="regex_search" title="cpp/regex/regex search"> <span class="t-lines"><span>Regex_Search</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>cố gắng khớp một biểu thức chính quy với bất kỳ phần nào của chuỗi ký tự<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <table class="t-dsc-begin"> <tr><td></td></tr> </table> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/regex/regex_iterator">https://en.cppreference.com/w/cpp/regex/regex_iterator</a>
</p>
</div>
