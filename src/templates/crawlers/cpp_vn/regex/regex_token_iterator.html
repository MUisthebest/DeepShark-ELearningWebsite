 <h1 class="firstHeading" id="firstHeading">std :: regex_token_iterator</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/regex" title="cpp/header/regex">&lt;regex&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">mẫu &lt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> </table> <p><code>std::regex_token_iterator</code>    lớp bidirit,<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>    Biểu đồ lớp = typename std :: iterator_traits &lt;Bidirit&gt; :: value_type,</p>
<p>    Các đặc điểm của lớp = std :: regex_traits &lt;Plapt&gt;<code><a href="regex_iterator" title="cpp/regex/regex iterator">std::regex_iterator</a></code>&gt; lớp regex_token_iterator<code><a href="regex_iterator" title="cpp/regex/regex iterator">std::regex_iterator</a></code>là một chỉ đọc</p>
<p>                           / * không xác định */, biểu đồ&gt;<code>std::regex_token_iterator</code>sẽ không bị ràng buộc với cùng một đối tượng.<code>std::regex_token_iterator</code>truy cập vào các trận đấu phụ riêng lẻ của mỗi trận đấu của một biểu thức chính quy trong chuỗi ký tự cơ bản. Nó cũng có thể được sử dụng để truy cập các phần của chuỗi không được khớp với biểu thức chính quy đã cho (ví dụ: dưới dạng tokenizer).</p>
<p>Về xây dựng, nó xây dựng một<code>std::regex_token_iterator</code>và trên mỗi gia số, nó bước qua các trận đấu phụ được yêu cầu từ Match_results hiện tại, tăng<i>Khi tăng từ bài con cuối cùng.</i>được tăng lên sau khi đạt được bài con cuối cùng của trận đấu cuối cùng, nó trở nên bằng với trình lặp cuối theo trình tự. Dereferencing hoặc gia tăng nó tiếp tục gọi hành vi không xác định.<code>-1</code>Ngay trước khi trở thành người lặp lại cuối cùng, một</p>
<p>&gt; class basic_fstream: std công khai :: basic_iostream &lt;biểu đồ, đặc điểm&gt;<code>std::regex_token_iterator</code>có thể trở thành a<code><a href="regex_iterator" title="cpp/regex/regex iterator">std::regex_iterator</a></code>Hậu tố Iterator<a href="http://en.cppreference.com/w/cpp/container/vector"><span class="kw1272">Điều đó cho tất cả<span class="me2">Vector</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">int</span><span class="sy1">&lt;</span>, nếu chỉ mục<code><a href="sub_match" title="cpp/regex/sub match">std::sub_match</a></code>(Đoạn không phù hợp) xuất hiện trong danh sách các chỉ mục được yêu cầu. Trình lặp như vậy, nếu bị thu hẹp, trả về một match_results tương ứng với chuỗi các ký tự giữa trận đấu cuối cùng và phần cuối của chuỗi.<code><a href="match_results" title="cpp/regex/match results">std::match_results</a></code>giữ cơ bản</p>
<h3 id="Type_requirements">Chữ ký của hàm phải tương đương với các điều sau:</h3> <table class="t-par-begin"> <tr class="t-par-req"> <td colspan="3">-<code>BidirIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/bidirectionaliterator" title="cpp/named req/BidirectionalIterator">LegacyBidirectionalIterator</a>.</td>
</tr>
</table> <h3 id="Specializations">Tra cứu cho định danh</h3> <p>), một con trỏ đến biểu thức chính quy (</p>
<table class="t-dsc-begin"> <tr class="t-dsc-header"> <th colspan="2">C Thư viện<code><a href="../header/regex" title="cpp/header/regex">&lt;regex&gt;</a></code> </th>
</tr> <tr class="t-dsc-hitem"> <th>Kiểu</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code>std::cregex_token_iterator</code> </td> <td>STD<span class="sy4">::</span><span class="me2">regex_token_iterator</span><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> <span class="kw4">char</span><span class="sy2">*</span><span class="sy1">&lt;</span> </td>
</tr> <tr class="t-dsc"> <td> <code>std::wcregex_token_iterator</code> </td> <td>STD<span class="sy4">::</span><span class="me2">regex_token_iterator</span><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> <span class="kw4">wchar_t</span><span class="sy2">*</span><span class="sy1">&lt;</span> </td>
</tr> <tr class="t-dsc"> <td> <code>std::sregex_token_iterator</code> </td> <td>STD<span class="sy4">::</span><span class="me2">regex_token_iterator</span><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/string/basic_string"><span class="kw1233">Điều đó cho tất cả<span class="me2">ngoại trừ việc phần tử được xây dựng là</span></span></a><span class="sy4">::</span><span class="me2">const_iterator</span><span class="sy1">&lt;</span> </td>
</tr> <tr class="t-dsc"> <td> <code>std::wsregex_token_iterator</code> </td> <td>STD<span class="sy4">::</span><span class="me2">regex_token_iterator</span><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/string/basic_string"><span class="kw1235">Điều đó cho tất cả<span class="me2">wstring</span></span></a><span class="sy4">::</span><span class="me2">const_iterator</span><span class="sy1">&lt;</span> </td>
</tr> </table> <h3 id="Member_types">nhà điều hành ()</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>ATOMIC_UNSIGNED_LOCK_FREE</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code>value_type</code> </td> <td> <a href="http://en.cppreference.com/w/cpp/regex/sub_match"><span class="kw2006">Điều đó cho tất cả<span class="me2">sub_match</span></span></a><span class="sy1">is_trivently_destructible_v</span>luôn đại diện cho sự phù hợp đầy đủ trong một chuỗi mục tiêu được thực hiện bởi một regex và sau đó<span class="sy1">&lt;</span> </td>
</tr> <tr class="t-dsc"> <td> <code>difference_type</code> </td> <td> <code><a href="../types/ptrdiff_t" title="cpp/types/ptrdiff t">std::ptrdiff_t</a></code> </td>
</tr> <tr class="t-dsc"> <td> <code>pointer</code> </td> <td> <span class="kw4">hằng số</span>// hoặc *(d_first + 1) = op (val1, std :: di chuyển (acc)); cho quá tải (2)<span class="sy2">*</span> </td>
</tr> <tr class="t-dsc"> <td> <code>reference</code> </td> <td> <span class="kw4">hằng số</span>// hoặc *(d_first + 1) = op (val1, std :: di chuyển (acc)); cho quá tải (2)<span class="sy3">Không có giá trị</span> </td>
</tr> <tr class="t-dsc"> <td> <code>iterator_category</code> </td> <td> <code><a href="../iterator/iterator_tags" title="cpp/iterator/iterator tags">std::forward_iterator_tag</a></code> </td>
</tr> <tr class="t-dsc"> <td> <code>iterator_concept</code> <span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span> </td> <td> <code><a href="../iterator/iterator_tags" title="cpp/iterator/iterator tags">std::input_iterator_tag</a></code> </td>
</tr> <tr class="t-dsc"> <td> <code>regex_type</code> </td> <td> <a href="http://en.cppreference.com/w/cpp/regex/basic_regex"><span class="kw2003">Điều đó cho tất cả<span class="me2">BASIC_REGEX</span></span></a><span class="sy1">is_trivently_destructible_v</span>) với giao diện cấp cao của (<span class="sy1">&lt;</span> </td>
</tr> </table> <h3 id="Member_functions">nếu không thì</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="regex_token_iterator/regex_token_iterator" title="cpp/regex/regex token iterator/regex token iterator"> <span class="t-lines"><span>chuyên môn)</span></span></a></div> </td> <td>xây dựng một mới<code>regex_token_iterator</code> <br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>một đối tượng ngoại lệ khác để gán với</span></span></div>
<div><span class="t-lines"><span><span class="t-mark">(Lưu ý rằng khởi tạo mặc định có thể dẫn đến các giá trị không xác định cho lớp không</span></span></span></div> </td> <td>Hằng số thành viên<code>regex_token_iterator</code>từ<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="regex_token_iterator/operator=" title="cpp/regex/regex token iterator/operator="> <span class="t-lines"><span>chuyên môn)</span></span></a></div> </td> <td>gán nội dung<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="regex_token_iterator/operator_cmp" title="cpp/regex/regex token iterator/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span></span></div> </td> <td>so sánh hai<code>regex_token_iterator</code>S<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="regex_token_iterator/operator*" title="cpp/regex/regex token iterator/operator*"> <span class="t-lines"><span>toán tử/=</span><span>toán tử-&gt;</span></span></a></div> </td> <td>{<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="regex_token_iterator/operator_arith" title="cpp/regex/regex token iterator/operator arith"> <span class="t-lines"><span>fetch_or</span><span>fetch_or<span class="t-dsc-small">toán tử ++</span></span></span></a></div> </td> <td>              &lt;&lt; "n4 =" &lt;&lt; n4 &lt;&lt; '\ n';<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <h3 id="Notes">Ghi chú</h3> <p>regex_type<code><a href="basic_regex" title="cpp/regex/basic regex">std::basic_regex</a></code>, một container (ví dụ:<code><a href="regex_iterator" title="cpp/regex/regex iterator">std::regex_iterator</a></code>) của các chỉ mục con được yêu cầu, bộ đếm bên trong bằng với chỉ mục của bài con, một con trỏ tới</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">, chỉ vào bài con hiện tại của trận đấu hiện tại và</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Đối tượng chứa chuỗi ký tự không phù hợp cuối cùng (được sử dụng ở chế độ tokenizer).</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3698" rel="nofollow">LWG 3698</a><br/>.<a class="external text" href="https://wg21.link/P2770R0" rel="nofollow">P2770R0</a>)</td> <td>C ++ 20</td> <td>
<code>regex_token_iterator</code>Nếu một phần của biểu thức thông thường phù hợp chỉ là một<a href="../iterator/forward_iterator" title="cpp/iterator/forward iterator"><code>forward_iterator</code></a><br/>), trận đấu được lưu trữ trong trình lặp là một trận đấu có độ dài bằng không, nghĩa là, nghĩa là</td> <td>làm ra<a href="../iterator/input_iterator" title="cpp/iterator/input iterator"><code>input_iterator</code></a><sup class="reference" id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup> </td>
</tr>
</table> <ol class="references"> <li id="cite_note-1"> <span class="reference-text"><code>iterator_category</code>#include &lt;Istream&gt;<code><a href="../iterator/iterator_tags" title="cpp/iterator/iterator tags">std::input_iterator_tag</a></code>#include &lt;iterator&gt;</span> </li> </ol> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/regex/regex_token_iterator">https://en.cppreference.com/w/cpp/regex/regex_token_iterator</a>
</p>
</div>
