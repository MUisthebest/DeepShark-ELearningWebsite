 <h1 class="firstHeading" id="firstHeading">std :: biến thể &lt;loại ...&gt; :: biến thể</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Biến thể ConstExpr () NoExcept (/ * Xem bên dưới */);</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Biến thể ConstExPR (biến thể const &amp; khác);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Biến thể constexpr (biến thể &amp;&amp; khác) NOExcept (/ * xem bên dưới */);</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt;</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Biến thể ConstExpr (T &amp;&amp; T) NoExcept (/ * Xem bên dưới */);</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;Lớp T,</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">          Lớp ... Args&gt;</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Biến thể rõ ràng của Consexpr (STD :: IN_PLO_TYPE_T &lt;T&gt;,</pre>
</td> <td>            Nhị phân p);</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <p>Xây dựng một mới<code>variant</code>Giống như các tài liệu tham khảo ngôn ngữ, sự ổn định là nông cạn đối với</p>
<span class="t-li">1)</span>Hàm tạo mặc định. Xây dựng a<code>variant</code>std::basic_format_args::get<a href="../../language/value_initialization" title="cpp/language/value initialization">value-initialized</a>                            Args &amp;&amp; ... args);<code><a href="index" title="cpp/utility/variant/index">index()</a></code>Epoch (tức là,<ul>
<li>chỉ từ phạm vi động, tất cả các giá trị được lưu trữ hoặc từ tất cả các phạm vi với một điều kiện tiên quyết.<span class="kw4">constexpr</span>Mẫu &lt;Lớp T,<code>T_0</code>          lớp u,<a href="../../language/constexpr" title="cpp/language/constexpr">constexpr function</a>.</li>
<li>                const std :: chrono :: sys_time &lt;thời gian&gt; &amp; tp);<code><a href="http://en.cppreference.com/w/cpp/types/is_default_constructible"><span class="kw534">Điều đó cho tất cả<span class="me2">is_default_constructible_v</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_0<span class="sy1">&lt;</span></code>khoảng cách<span class="kw2">ĐÚNG VẬY</span>.</li>
</ul> <span class="t-li">2)</span>Sau mã sau:<code>other</code># Elif __has_include (&lt;thử nghiệm/tùy chọn&gt;) // Kiểm tra phiên bản thử nghiệm<code><a href="valueless_by_exception" title="cpp/utility/variant/valueless by exception">valueless_by_exception</a></code>, xây dựng a<code>variant</code>          Lớp ... Args&gt;<code>other</code>Và<a href="../../language/direct_initialization" title="cpp/language/direct initialization">direct-initializes</a>Biến thể rõ ràng của Consexpr (STD :: IN_PLO_INDEX_T &lt;i&gt;,<code><span class="sy2">*</span><a href="http://en.cppreference.com/w/cpp/utility/variant/get_if"><span class="kw1091">Điều đó cho tất cả<span class="me2">get_if</span></span></a><span class="sy1">is_trivently_destructible_v</span>other.<span class="me1">Chỉ mục</span><span class="br0">.</span><span class="br0">)</span><span class="sy1">&lt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw759">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span>other<span class="br0">)</span><span class="br0">)</span></code>                            Args &amp;&amp; ... args);<code><a href="valueless_by_exception" title="cpp/utility/variant/valueless by exception">valueless_by_exception</a></code>Mẫu &lt;std :: size_t i,<ul>
<li>Mẫu &lt;class ... args&gt;<code><a href="http://en.cppreference.com/w/cpp/types/is_copy_constructible"><span class="kw540">Điều đó cho tất cả<span class="me2">(c)</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_i<span class="sy1">&lt;</span></code>khoảng cách<span class="kw2">ĐÚNG VẬY</span>cho tất cả<code>T_i</code>TRONG<code>Types...</code>.</li>
<li>          lớp u,<code><a href="http://en.cppreference.com/w/cpp/types/is_copy_constructible"><span class="kw542">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_i<span class="sy1">&lt;</span></code>khoảng cách<span class="kw2">ĐÚNG VẬY</span>cho tất cả<code>T_i</code>TRONG<code>Types...</code>.</li>
</ul> <span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>(T là<code>other</code># Elif __has_include (&lt;thử nghiệm/tùy chọn&gt;) // Kiểm tra phiên bản thử nghiệm<code><a href="valueless_by_exception" title="cpp/utility/variant/valueless by exception">valueless_by_exception</a></code>, xây dựng a<code>variant</code>          Lớp ... Args&gt;<code>other</code>Và<a href="../../language/direct_initialization" title="cpp/language/direct initialization">direct-initializes</a>Biến thể rõ ràng của Consexpr (STD :: IN_PLO_INDEX_T &lt;i&gt;,<code>std<span class="sy4">::</span><span class="me2">(Niebloid)</span><span class="br0">.</span><span class="sy2">*</span><a href="http://en.cppreference.com/w/cpp/utility/variant/get_if"><span class="kw1091">Điều đó cho tất cả<span class="me2">get_if</span></span></a><span class="sy1">is_trivently_destructible_v</span>other.<span class="me1">Chỉ mục</span><span class="br0">.</span><span class="br0">)</span><span class="sy1">&lt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw759">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span>other<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span></code>                            Args &amp;&amp; ... args);<code><a href="valueless_by_exception" title="cpp/utility/variant/valueless by exception">valueless_by_exception</a></code>Mẫu &lt;std :: size_t i,<ul>
<li>                const std :: chrono :: sys_time &lt;thời gian&gt; &amp; tp);<code><a href="http://en.cppreference.com/w/cpp/types/is_move_constructible"><span class="kw546">Điều đó cho tất cả<span class="me2">hoán đổi void (t2 (&amp; a) [n], t2 (&amp; b) [n]) noExcept ( / * xem bên dưới * /);</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_i<span class="sy1">&lt;</span></code>khoảng cách<span class="kw2">ĐÚNG VẬY</span>cho tất cả<code>T_i</code>TRONG<code>Types...</code>.</li>
<li>          lớp u,<code><a href="http://en.cppreference.com/w/cpp/types/is_move_constructible"><span class="kw548">Điều đó cho tất cả<span class="me2">Hàm tạo mặc định. Nếu như</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_i<span class="sy1">&lt;</span></code>khoảng cách<span class="kw2">ĐÚNG VẬY</span>cho tất cả<code>T_i</code>TRONG<code>Types...</code>.</li>
</ul> <div class="t-li1">
<span class="t-li">là trong</span>          Lớp ... Args&gt;<code>variant</code>Biến thể rõ ràng của Consexpr (STD :: IN_PLO_INDEX_T &lt;i&gt;,<code>T_j</code>Chuyển đổi bài tập.<code>F<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="br0">.</span>t<span class="br0">)</span><span class="br0">)</span></code>Xác định loại thay thế<code>F(T_i)</code>constexpr outputit exclusive_scan (đầu vào đầu tiên, đầu vào cuối cùng,<code>T_i</code>từ<code>Types...</code>sẽ được chọn bởi độ phân giải quá tải cho biểu thức<ul><li>Nếu có quá tải chức năng tưởng tượng<code>F(T_i)</code>trong phạm vi cùng một lúc, ngoại trừ điều đó:<code>T_i x<span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span><span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span> <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <span class="br0">danh tính</span> <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="br0">.</span>t<span class="br0">)</span> <span class="br0">{</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>Một quá tải<code>x</code>.</li></ul>
</div> <a href="../../language/direct_initialization" title="cpp/language/direct initialization">Direct-initializes</a>                            std :: initizer_list &lt;u&gt; il,<code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="br0">.</span>t<span class="br0">)</span></code>.<ul>
<li>                const std :: chrono :: sys_time &lt;thời gian&gt; &amp; tp);<ul>
<li> <code>sizeof...(Types) &gt; 0</code>Thì</li>
<li> <span class="t-rev-inl t-until-cxx20"><span><code><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code></span><span><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></span></span><span class="t-rev-inl t-since-cxx20"><span><code><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2644">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code></span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>                            Args &amp;&amp; ... args);<code>variant</code>Nếu và chỉ khi khởi tạo giá trị của loại thay thế<code><a href="../in_place" title="cpp/utility/in place">std::in_place_type_t</a></code>Nếu và chỉ khi khởi tạo giá trị của loại thay thế<code><a href="../in_place" title="cpp/utility/in place">std::in_place_index_t</a></code>Thì</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw528">Điều đó cho tất cả<span class="me2">, sao chép-khởi tạo phần tử tương ứng của kết quả với</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_j, T<span class="sy1">&lt;</span></code>khoảng cách<span class="kw2">ĐÚNG VẬY</span>Thì</li>
<li>Xây dựng một trình bao bọc tham khảo mới.<code>F<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="br0">.</span>t<span class="br0">)</span><span class="br0">)</span></code>Không trở thành vô giá trị: Giá trị phụ thuộc vào bảo đảm an toàn ngoại lệ của nhiệm vụ được gọi là.</li>
</ul> </li>
<li>sẽ đáp ứng các yêu cầu cho một<span class="kw4">constexpr</span>giữ cùng một giải pháp thay thế như<code>T_j</code>giá trị chứa với</li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">. Nếu không, khởi tạo a</pre></div> <span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>variant</code>khác nhau.<code>T</code>std :: biến thể &lt;std :: chuỗi, std :: chuỗi&gt; w ("abc"); // không hình thành<code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span>args<span class="br0">)</span>...</code>.<ul>
<li>Nếu như<code>T</code>std :: biến thể &lt;std :: chuỗi, const char*&gt; x ("abc"); // ok, chọn const char*<span class="kw4">constexpr</span>std :: biến thể &lt;std :: chuỗi, bool&gt; y ("abc"); // OK, chọn chuỗi; Bool không phải là ứng cử viên<span class="kw4">constexpr</span>người xây dựng.</li>
<li>giá trị chứa như thể do không bắt đầu không theo danh sách trực tiếp từ<code>T</code>TRONG<code>Types...</code>Và<code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw528">Điều đó cho tất cả<span class="me2">, sao chép-khởi tạo phần tử tương ứng của kết quả với</span></span></a><span class="sy1">is_trivently_destructible_v</span>T, Args...<span class="sy1">&lt;</span></code>khoảng cách<span class="kw2">ĐÚNG VẬY</span>.</li>
</ul> <span class="t-li">từ_sys</span>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>variant</code>khác nhau.<code>T</code>std :: biến thể &lt;std :: chuỗi, std :: chuỗi&gt; w ("abc"); // không hình thành<code>il, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span>args<span class="br0">)</span>...</code>.<ul>
<li>Nếu như<code>T</code>std :: biến thể &lt;std :: chuỗi, const char*&gt; x ("abc"); // ok, chọn const char*<span class="kw4">constexpr</span>std :: biến thể &lt;std :: chuỗi, bool&gt; y ("abc"); // OK, chọn chuỗi; Bool không phải là ứng cử viên<span class="kw4">constexpr</span>người xây dựng.</li>
<li>giá trị chứa như thể do không bắt đầu không theo danh sách trực tiếp từ<code>T</code>TRONG<code>Types...</code>Và<code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw528">Điều đó cho tất cả<span class="me2">, sao chép-khởi tạo phần tử tương ứng của kết quả với</span></span></a><span class="sy1">is_trivently_destructible_v</span>T, initializer_list<span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">&lt;</span><span class="sy3">Không có giá trị</span>, Args...<span class="sy1">&lt;</span></code>khoảng cách<span class="kw2">ĐÚNG VẬY</span>.</li>
</ul> <span class="t-li">6)</span>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>variant</code>Hàm tạo được chọn là hàm tạo Consexpr.<code>T_i</code>std :: biến thể &lt;std :: chuỗi&gt; v ("abc"); // ĐƯỢC RỒI<code>I</code>std :: biến thể &lt;std :: chuỗi, std :: chuỗi&gt; w ("abc"); // không hình thành<code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span>args<span class="br0">)</span>...</code>.<ul>
<li>Nếu như<code>T_i</code>std :: biến thể &lt;std :: chuỗi, const char*&gt; x ("abc"); // ok, chọn const char*<span class="kw4">constexpr</span>std :: biến thể &lt;std :: chuỗi, bool&gt; y ("abc"); // OK, chọn chuỗi; Bool không phải là ứng cử viên<span class="kw4">constexpr</span>người xây dựng.</li>
<li>                const std :: chrono :: sys_time &lt;thời gian&gt; &amp; tp);<code>I &lt; sizeof...(Types)</code>Và<code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw528">Điều đó cho tất cả<span class="me2">, sao chép-khởi tạo phần tử tương ứng của kết quả với</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_i, Args...<span class="sy1">&lt;</span></code>khoảng cách<span class="kw2">ĐÚNG VẬY</span>.</li>
</ul> <span class="t-li">. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu biểu thức</span>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>variant</code>Hàm tạo được chọn là hàm tạo Consexpr.<code>T_i</code>std :: biến thể &lt;std :: chuỗi&gt; v ("abc"); // ĐƯỢC RỒI<code>I</code>std :: biến thể &lt;std :: chuỗi, std :: chuỗi&gt; w ("abc"); // không hình thành<code>il, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span>args<span class="br0">)</span>...</code>.<ul>
<li>Nếu như<code>T_i</code>std :: biến thể &lt;std :: chuỗi, const char*&gt; x ("abc"); // ok, chọn const char*<span class="kw4">constexpr</span>std :: biến thể &lt;std :: chuỗi, bool&gt; y ("abc"); // OK, chọn chuỗi; Bool không phải là ứng cử viên<span class="kw4">constexpr</span>người xây dựng.</li>
<li>                const std :: chrono :: sys_time &lt;thời gian&gt; &amp; tp);<code>I &lt; sizeof...(Types)</code>Và<code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw528">Điều đó cho tất cả<span class="me2">, sao chép-khởi tạo phần tử tương ứng của kết quả với</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_i, <a href="http://en.cppreference.com/w/cpp/utility/initializer_list"><span class="kw962">Điều đó cho tất cả<span class="me2">Khởi tạo_list</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">&lt;</span><span class="sy3">Không có giá trị</span>, Args...<span class="sy1">&lt;</span></code>khoảng cách<span class="kw2">ĐÚNG VẬY</span>.</li>
</ul> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>khác</td> <td>-</td> <td>khác<code>variant</code>std :: biến thể &lt;float, dài, double&gt; z = 0; // ok, giữ lâu</td>
</tr> <tr class="t-par"> <td>Chuyển đổi đối số</td> <td>-</td> <td>Xây dựng một đối tượng có nội dung ban đầu một đối tượng thuộc loại</td>
</tr> <tr class="t-par"> <td>, không cho phép định dạng định dạng.</td> <td>-</td> <td>                                         // float và gấp đôi không phải là ứng cử viên</td>
</tr> <tr class="t-par"> <td>Dữ liệu của constexpr t* (t (&amp; mảng) [n]) noexcept;</td> <td>-</td> <td>với giải pháp thay thế được chỉ định</td>
</tr>
</table> <h3 id="Exceptions">Ngoại lệ</h3> <div class="t-li1">
<span class="t-li">1)</span>và khởi tạo giá trị chứa với các đối số<div class="t-noexcept-full">
<a href="../../language/noexcept_spec" title="cpp/language/noexcept spec"><code>noexcept</code></a>Đặc điểm kỹ thuật:<div class="t-noexcept-box"><span class="t-cc"><code><span class="kw1">Noexcept</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/types/is_default_constructible"><span class="kw538">Điều đó cho tất cả<span class="me2">để sao chép/di chuyển từ</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_0<span class="sy1">&lt;</span><span class="br0">)</span></code></span></div>
</div>
</div> <div class="t-li1">
<span class="t-li">2)</span>Chất xây dựng được chọn là một<code>T_i</code>TRONG<code>Types...</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>hàm tạo, hàm tạo này cũng là một<code>T_i</code>TRONG<code>Types...</code>.<div class="t-noexcept-full">
<a href="../../language/noexcept_spec" title="cpp/language/noexcept spec"><code>noexcept</code></a>Đặc điểm kỹ thuật:<div class="t-noexcept-box"><span class="t-cc"><code><span class="kw1">Noexcept</span><span class="br0">.</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/types/is_move_constructible"><span class="kw550">Điều đó cho tất cả<span class="me2">    lớp accessorpolicy = std :: default_accessor &lt;t&gt;</span></span></a><span class="sy1">is_trivently_destructible_v</span>Types<span class="sy1">&lt;</span> <span class="sy3">. Trong các cuộc gọi có hiệu lực</span> ...<span class="br0">)</span><span class="br0">)</span></code></span></div>
</div>
</div> <div class="t-li1">
<span class="t-li">là trong</span>Sự quá tải này chỉ tham gia vào độ phân giải quá tải nếu có chính xác một lần xảy ra<code>T_j</code>.<div class="t-noexcept-full">
<a href="../../language/noexcept_spec" title="cpp/language/noexcept spec"><code>noexcept</code></a>Đặc điểm kỹ thuật:<div class="t-noexcept-box"><span class="t-cc"><code><span class="kw1">Noexcept</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw532">Điều đó cho tất cả<span class="me2">là một gói tham số sao cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_j, T<span class="sy1">&lt;</span><span class="br0">)</span></code></span></div>
</div>
</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit1, class inputIt2, class BinaryPredicate&gt;</span>với giải pháp thay thế được chỉ định</div> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">và khởi tạo giá trị chứa với các đối số</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Chất xây dựng được chọn là một</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2901" rel="nofollow">LWG 2901</a> </td> <td>C ++ 17</td> <td>hàm tạo, hàm tạo này cũng là một<br/><code>variant</code>Sự quá tải này chỉ tham gia vào độ phân giải quá tải nếu có chính xác một lần xảy ra</td> <td>với sự thay thế</td>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/P0739R0" rel="nofollow">P0739R0</a> </td> <td>C ++ 17</td> <td>được chỉ định bởi chỉ mục<br/>và khởi tạo giá trị chứa với các đối số</td> <td>Đôi khi hành xử sai lầm như thể nó không thể mô hình hóa khái niệm đó. Hành vi không chính xác này được thực hiện trong libstdc ++ trước 10,4 và trong MSVC STL trước VS 2022 17.0 Xem trước 3.</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3024" rel="nofollow">LWG 3024</a> </td> <td>C ++ 17</td> <td>Chất xây dựng được chọn là một<br/>hàm tạo, hàm tạo này cũng là một</td> <td>v3 = "ABC"; // OK, chọn chuỗi; Bool không phải là ứng cử viên</td>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/P0602R4" rel="nofollow">P0602R4</a> </td> <td>C ++ 17</td> <td>với sự thay thế<br/>được chỉ định bởi chỉ mục</td> <td>. Biểu thức đầu tiên xây dựng một trống</td>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/P0608R3" rel="nofollow">P0608R3</a> </td> <td>C ++ 17</td> <td>và khởi tạo giá trị chứa với các đối số<br/>Chất xây dựng được chọn là một</td> <td>hàm tạo, hàm tạo này cũng là một</td>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/P1957R2" rel="nofollow">P1957R2</a> </td> <td>C ++ 17</td> <td>đối tượng có giá trị chứa/di chuyển<span class="kw4">bool</span>đối số để khởi tạo giá trị chứa với<br/>Danh sách khởi tạo để khởi tạo giá trị chứa với</td> <td>là một biểu hiện phụ hằng số lvalue.<span class="kw4">bool</span>Có thể ném bất kỳ ngoại lệ nào được ném bằng cách khởi tạo giá trị của phương án đầu tiên.<br/>Có thể ném bất kỳ ngoại lệ nào được ném bằng cách khởi tạo trực tiếp bất kỳ<br/>Có thể ném bất kỳ ngoại lệ nào được ném bằng cách kiểm soát di chuyển bất kỳ<span class="kw4">bool</span> </td>
</tr>
</table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/utility/variant/variant">https://en.cppreference.com/w/cpp/utility/variant/variant</a>
</p>
</div>
