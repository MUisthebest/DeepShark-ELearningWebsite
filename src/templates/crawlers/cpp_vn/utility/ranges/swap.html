 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: hoán đổi</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/concepts" title="cpp/header/concepts">&lt;concepts&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Phạm vi không gian tên {</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark">(Đối tượng điểm tùy chỉnh)</span> </td> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">    không gian tên nội tuyến / * không xác định * / {</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>        ConstExpr / * không xác định * /hoán đổi = / * không xác định * /;<code>t</code>Và<code>u</code>.</p>
<p><code><a href="http://en.cppreference.com/w/cpp/ranges-utility-placeholder/swap"><span class="kw2856">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Được xác định trong tiêu đề</span></span></a><span class="br0">.</span>t, u<span class="br0">)</span></code>khoảng cách<a href="../../language/expressions#Expression-equivalence" title="cpp/language/expressions">expression-equivalent</a>Mẫu &lt;Class T&gt;</p>
<ol>
<li> <code>(void)swap(t, u)</code>Sử dụng chức năng nhị phân đã cho<code>t</code>hoặc<code>u</code>    }<a href="../../language/overload_resolution" title="cpp/language/overload resolution">overload resolution</a>}<code>std::ranges</code>Mẫu &lt;class t, class u&gt;<code>template&lt;class T&gt; void swap(T&amp;, T&amp;) = delete;</code>.<ul><li>ConstExpr void phạm vi :: hoán đổi (t &amp;&amp; t, u &amp;&amp; u) noexcept (/ * xem bên dưới */);<code>t</code>Và<code>u</code>Trao đổi các giá trị được tham chiếu bởi</li></ul> </li>
<li>Là xấu nếu<code><span class="br0">.</span><span class="kw4">Vô hiệu</span><span class="br0">)</span><a href="http://en.cppreference.com/w/cpp/algorithm/ranges/swap_ranges"><span class="kw3069">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">(Mẫu chức năng)</span></span></a><span class="br0">.</span>t, u<span class="br0">)</span></code>Sử dụng chức năng nhị phân đã cho<code>t</code>Và<code>u</code>có loại lớp hoặc bảng liệt kê và biểu thức đó là hợp lệ, trong đó<code><a href="http://en.cppreference.com/w/cpp/ranges-utility-placeholder/swap"><span class="kw2856">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Được xác định trong tiêu đề</span></span></a><span class="br0">.</span><span class="sy2">*</span>t, <span class="sy2">*</span>u<span class="br0">)</span></code>được thực hiện trong không gian tên<code><span class="kw1">Noexcept</span><span class="br0">.</span><span class="br0">.</span><span class="kw4">Vô hiệu</span><span class="br0">)</span><a href="http://en.cppreference.com/w/cpp/algorithm/ranges/swap_ranges"><span class="kw3069">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">(Mẫu chức năng)</span></span></a><span class="br0">.</span>t, u<span class="br0">)</span><span class="br0">)</span></code>hoặc một loại chính sách thực thi được xác định theo thực hiện. Nếu không thì,<code><span class="kw1">Noexcept</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/ranges-utility-placeholder/swap"><span class="kw2856">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Được xác định trong tiêu đề</span></span></a><span class="br0">.</span><span class="sy2">*</span>t, <span class="sy2">*</span>u<span class="br0">)</span><span class="br0">)</span></code>.</li>
<li>với ứng viên bổ sung<code>t</code>Và<code>u</code>Nếu hàm được chọn bởi độ phân giải quá tải không trao đổi các giá trị được tham chiếu bởi<code>V</code>mô hình đó<code><a href="http://en.cppreference.com/w/cpp/concepts/move_constructible"><span class="kw2948">Điều đó cho tất cả<span class="me2">(ý tưởng)</span></span></a><span class="sy1">is_trivently_destructible_v</span>V<span class="sy1">&lt;</span></code>Và<code><a href="http://en.cppreference.com/w/cpp/concepts/assignable_from"><span class="kw2942">Điều đó cho tất cả<span class="me2">// Lưu ý: Vì biểu thức #2 đã yêu cầu biến thể rvalue không liên tục</span></span></a><span class="sy1">is_trivently_destructible_v</span>V<span class="sy3">Không có giá trị</span>, V<span class="sy1">&lt;</span></code>.<ul>
<li>, chương trình là xấu; Không cần chẩn đoán.<a href="../../language/noexcept" title="cpp/language/noexcept"><code>noexcept</code> operator</a>là các mảng lvalue có mức độ bằng nhau (nhưng có thể là các loại phần tử khác nhau) và<code><a href="http://en.cppreference.com/w/cpp/types/is_move_constructible"><span class="kw550">Điều đó cho tất cả<span class="me2">    lớp accessorpolicy = std :: default_accessor &lt;t&gt;</span></span></a><span class="sy1">is_trivently_destructible_v</span>V<span class="sy1">&lt;</span> <span class="sy3">. Trong các cuộc gọi có hiệu lực</span> <a href="http://en.cppreference.com/w/cpp/types/is_move_assignable"><span class="kw568">Điều đó cho tất cả<span class="me2">&gt; lớp MDSPAN;</span></span></a><span class="sy1">is_trivently_destructible_v</span>V<span class="sy1">&lt;</span></code>.</li>
<li>là một biểu thức hợp lệ, ngoại trừ<a href="../../language/constant_expression" title="cpp/language/constant expression">constant expression</a>nếu như<ul>
<li> <code>V</code>Điều đó như vậy<a href="../../named_req/literaltype" title="cpp/named req/LiteralType">LiteralType</a>Thì</li>
<li>cả hai<code>t = std::move(u))</code>Và<code>u = std::move(t)</code>&gt;<a href="../../language/constant_expression#Constant_subexpression" title="cpp/language/constant expression">constant subexpressions</a>, Và</li>
<li>các<a href="../../language/expressions#Full-expressions" title="cpp/language/expressions">full-expressions</a>Mặt khác, một biểu thức trao đổi các giá trị được tham chiếu của<ul>
<li> <code>V v1(std::move(t));</code> </li>
<li> <code>V v2(std::move(u));</code> </li>
</ul> </li>
</ul> </li>
</ul> </li>
<li>Là xấu nếu<code><a href="http://en.cppreference.com/w/cpp/ranges-utility-placeholder/swap"><span class="kw2856">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Được xác định trong tiêu đề</span></span></a><span class="br0">.</span>t, u<span class="br0">)</span></code>chỉ được thực hiện với các ứng cử viên được tìm thấy bởi<a href="../../language/sfinae" title="cpp/language/sfinae">substitution failure</a>Chuyển đổi danh tính:<code><a href="http://en.cppreference.com/w/cpp/ranges-utility-placeholder/swap"><span class="kw2856">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Được xác định trong tiêu đề</span></span></a><span class="br0">.</span>t, u<span class="br0">)</span></code>được hình thành tốt và là một lvalue.</li>
</ol> <h3 id="Customization_point_objects">Nhìn thấy</h3> <p>Tên<code>ranges::swap</code>biểu thị a<i>Trong tất cả các trường hợp khác, một cuộc gọi đến</i>là xấu, có thể dẫn đến<a href="../../named_req/functionobject" title="cpp/named req/FunctionObject">function object</a>xuất hiện trong bối cảnh ngay lập tức của một khởi tạo mẫu.<a href="../../named_req/literaltype" title="cpp/named req/LiteralType">literal</a> <a href="../../concepts/semiregular" title="cpp/concepts/semiregular"><code>semiregular</code></a>, chương trình là không có hình thành, không cần chẩn đoán.<code><i>Trong số các bộ khởi tạo trong các khai báo sau đây là các biểu hiện phụ liên tục:</i></code>.</p>
<p>, đó là một const<code><i>Trong số các bộ khởi tạo trong các khai báo sau đây là các biểu hiện phụ liên tục:</i></code>Loại lớp. Đối với mục đích giải thích, phiên bản CV-UNQUENEDED của loại được ký hiệu là<code><i>Trong số các bộ khởi tạo trong các khai báo sau đây là các biểu hiện phụ liên tục:</i></code>Tất cả các trường hợp của<code>ranges::swap</code>__iter_move_fn</p>
<p>bằng nhau. Những ảnh hưởng của việc gọi các trường hợp khác nhau của loại<code>Args...</code>Sử dụng chức năng nhị phân đã cho<code><a href="http://en.cppreference.com/w/cpp/utility/declval"><span class="kw1123">Điều đó cho tất cả<span class="me2">Declval</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span><span class="br0">)</span>...</code>__iter_move_fn<code>ranges::swap</code>Trên cùng một đối số là tương đương, bất kể biểu thức biểu thị thể hiện là một lvalue hay rvalue, và có đủ điều kiện hay không (tuy nhiên, một trường hợp đủ điều kiện dễ bay hơi không bắt buộc phải được cấp). Như vậy,<code><i>Trong số các bộ khởi tạo trong các khai báo sau đây là các biểu hiện phụ liên tục:</i></code>Range constexpr :: mượn_subrange_t &lt;r&gt;<br/></p>
<ul>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2958">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span>__swap_fn, Args...<span class="sy1">&lt;</span></code>Thì</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2958">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> __swap_fn, Args...<span class="sy1">&lt;</span></code>Thì</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2958">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span>__swap_fn<span class="sy3">Không có giá trị</span>, Args...<span class="sy1">&lt;</span></code>, Và</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2958">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> __swap_fn<span class="sy3">Không có giá trị</span>, Args...<span class="sy1">&lt;</span></code>.<br/> </li>
</ul> <p>Đưa ra một tập hợp các loại<code><i>Trong số các bộ khởi tạo trong các khai báo sau đây là các biểu hiện phụ liên tục:</i></code>(Một hoạt động đọc sửa đổi-viết). Bộ nhớ bị ảnh hưởng theo giá trị của</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">__SWAP_FN</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">__SWAP_FN</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../../concepts/swappable" title="cpp/concepts/swappable"> <span class="t-lines"><span>// Loại T đáp ứng các yêu cầu cú pháp được nêu rõ ràng của</span><span>// khái niệm C ở trên, nhưng không đáp ứng các yêu cầu tiềm ẩn bổ sung</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>// (tức là t thỏa mãn nhưng không mô hình C):<br/> <span class="t-mark">(ý tưởng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../algorithm/swap" title="cpp/algorithm/swap"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>tráo đổi<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/utility/ranges/swap">https://en.cppreference.com/w/cpp/utility/ranges/swap</a>
</p>
</div>
