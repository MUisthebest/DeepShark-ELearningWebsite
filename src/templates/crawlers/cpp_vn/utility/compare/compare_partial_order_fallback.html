 <h1 class="firstHeading" id="firstHeading">std :: compare_partial_order_fallback</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/compare" title="cpp/header/compare">&lt;compare&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">không gian tên nội tuyến / * không xác định * / {</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">    Constrexpr / * không xác định * /</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>        compare_partial_order_fallback = / * không xác định * /;<a href="../../language/expressions#Full-expressions" title="cpp/language/expressions">subexpressions</a> <code>t</code>Và<code>u</code>}<a href="partial_ordering" title="cpp/utility/compare/partial ordering"><code>std::partial_ordering</code></a>Mẫu &lt;class t, class u&gt;<code>&lt;=&gt;</code>    yêu cầu / * xem bên dưới * /</p>
<p>Nếu như<a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span>Và<a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">2,4)</span>là cùng loại,<code>std::compare_partial_order_fallback(t, u)</code>khoảng cách<a href="../../language/expressions#Expression-equivalence" title="cpp/language/expressions">expression-equivalent</a>Mẫu &lt;Class T&gt;</p>
<ul>
<li> <code><a href="http://en.cppreference.com/w/cpp/utility/compare/partial_order"><span class="kw2658">Điều đó cho tất cả<span class="me2">Partial_order</span></span></a><span class="br0">.</span>t, u<span class="br0">)</span></code>Consexpr std :: Partial_ordering</li>
<li>    toán tử &gt;&gt; (basic_istream &lt;char, đặc điểm&gt; &amp; st, không dấu char* s);<code>t == u ? std::partial_ordering::equivalent :t &lt; u ? std::partial_ordering::less :u &lt; t ? std::partial_ordering::greater : std::partial_ordering::unordered</code> </li>
</ul>    compare_partial_order_fallback (t &amp;&amp; t, u &amp;&amp; u) noExcept (/ * xem bên dưới */);<code>t == u</code>Thì<code>t &lt; u</code>Và<code>u &lt; t</code>Thực hiện so sánh ba chiều trên<span class="br0">.</span>Chuyển đổi đối số<span class="sy1">==</span>                       std :: chuyển tiếp &lt;declType (args1)&gt; (args1) ...);<span class="br0">)</span>__end_fn<span class="br0">.</span>Chuyển đổi đối số<span class="sy1">is_trivently_destructible_v</span>                       std :: chuyển tiếp &lt;declType (args1)&gt; (args1) ...);<span class="br0">)</span>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../../concepts/boolean-testable" title="cpp/concepts/boolean-testable"><code>boolean-testable</code></a>, và sau đó gọi<code>t</code>Và<code>u</code>và tạo ra kết quả của loại<p>, ngay cả khi người vận hành<code>std::compare_partial_order_fallback(t, u)</code>chỉ được thực hiện với các ứng cử viên được tìm thấy bởi<a href="../../language/sfinae" title="cpp/language/sfinae">substitution failure</a>không có sẵn.</p>
<h3 id="Customization_point_objects">Nhìn thấy</h3> <p>Tên<code>std::compare_partial_order_fallback</code>biểu thị a<i>Trong tất cả các trường hợp khác, một cuộc gọi đến</i>là xấu, có thể dẫn đến<a href="../../named_req/functionobject" title="cpp/named req/FunctionObject">function object</a>xuất hiện trong bối cảnh ngay lập tức của một khởi tạo mẫu.<a href="../../named_req/literaltype" title="cpp/named req/LiteralType">literal</a> <a href="../../concepts/semiregular" title="cpp/concepts/semiregular"><code>semiregular</code></a>, chương trình là không có hình thành, không cần chẩn đoán.<code><i>Trong tất cả các trường hợp khác,</i></code>.</p>
<p>, đó là một const<code><i>Trong tất cả các trường hợp khác,</i></code>Loại lớp. Đối với mục đích giải thích, phiên bản CV-UNQUENEDED của loại được ký hiệu là<code><i>Trong tất cả các trường hợp khác,</i></code>Tất cả các trường hợp của<code>std::compare_partial_order_fallback</code>__iter_move_fn</p>
<p>bằng nhau. Những ảnh hưởng của việc gọi các trường hợp khác nhau của loại<code>Args...</code>Sử dụng chức năng nhị phân đã cho<code><a href="http://en.cppreference.com/w/cpp/utility/declval"><span class="kw1123">Điều đó cho tất cả<span class="me2">Declval</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span><span class="br0">)</span>...</code>__iter_move_fn<code>std::compare_partial_order_fallback</code>Trên cùng một đối số là tương đương, bất kể biểu thức biểu thị thể hiện là một lvalue hay rvalue, và có đủ điều kiện hay không (tuy nhiên, một trường hợp đủ điều kiện dễ bay hơi không bắt buộc phải được cấp). Như vậy,<code><i>Trong tất cả các trường hợp khác,</i></code>Range constexpr :: mượn_subrange_t &lt;r&gt;<br/></p>
<ul>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2958">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span>__compare_partial_order_fallback_fn, Args...<span class="sy1">&lt;</span></code>Thì</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2958">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> __compare_partial_order_fallback_fn, Args...<span class="sy1">&lt;</span></code>Thì</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2958">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span>__compare_partial_order_fallback_fn<span class="sy3">Không có giá trị</span>, Args...<span class="sy1">&lt;</span></code>, Và</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2958">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> __compare_partial_order_fallback_fn<span class="sy3">Không có giá trị</span>, Args...<span class="sy1">&lt;</span></code>.<br/> </li>
</ul> <p>Đưa ra một tập hợp các loại<code><i>Trong tất cả các trường hợp khác,</i></code>(Một hoạt động đọc sửa đổi-viết). Bộ nhớ bị ảnh hưởng theo giá trị của</p>
<h3 id="Example">Ví dụ</h3> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2114" rel="nofollow">LWG 2114</a><br/>.<a class="external text" href="https://wg21.link/P2167R3" rel="nofollow">P2167R3</a>)</td> <td>C ++ 20</td> <td>Khi nó xuất hiện trong bối cảnh ngay lập tức của một khởi tạo mẫu.<br/>__compare_partial_order_fallback_fn<span class="kw4">bool</span> </td> <td>__compare_partial_order_fallback_fn</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3465" rel="nofollow">LWG 3465</a> </td> <td>C ++ 20</td> <td>__compare_partial_order_fallback_fn<code>u &lt; t</code>__compare_partial_order_fallback_fn</td> <td>Thực hiện quá tải</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="partial_order" title="cpp/utility/compare/partial order"> <span class="t-lines"><span>Partial_order</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>thực hiện so sánh 3 chiều và tạo ra kết quả của loại<code>std::partial_ordering</code><br/><span class="t-mark">(Đối tượng điểm tùy chỉnh)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/utility/compare/compare_partial_order_fallback">https://en.cppreference.com/w/cpp/utility/compare/compare_partial_order_fallback</a>
</p>
</div>
