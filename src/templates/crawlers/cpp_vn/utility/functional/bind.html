 <h1 class="firstHeading" id="firstHeading">... của không gian tên</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/functional" title="cpp/header/functional">&lt;functional&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class F, class ... args&gt;</pre></td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">/ * không xác định */ BIND (f &amp;&amp; f, args &amp;&amp; ... args);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(2)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class F, class ... args&gt;</pre></td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">constexpr / * không xác định * / BIND (f &amp;&amp; f, args &amp;&amp; ... args);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>                                 std :: decay_t &lt;args&gt; ... &gt;&gt;<code>std::bind</code>Mẫu &lt;class r, class F, class ... args&gt;<code>f</code>/ * không xác định */ BIND (f &amp;&amp; f, args &amp;&amp; ... args);<code>f</code>Mẫu &lt;class r, class F, class ... args&gt;<a href="#Bound_arguments">bound</a>ĐẾN<code>args</code>.</p>
<p>Nếu như<code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw527">Điều đó cho tất cả<span class="me2">is_constructable</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">Điều đó cho tất cả<span class="me2">mục nát</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">kiểu</span>, F<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span></code>khoảng cách<code>false</code>, hoặc<code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw527">Điều đó cho tất cả<span class="me2">is_constructable</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">Điều đó cho tất cả<span class="me2">mục nát</span></span></a><span class="sy1">is_trivently_destructible_v</span>Arg_i<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">kiểu</span>, Arg_i<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span></code>khoảng cách<code>false</code>Mẫu &lt;class inputit, class alloc&gt;<code>Arg_i</code>TRONG<code>Args</code>, chương trình là xấu.</p>
<p>Nếu như<a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">Điều đó cho tất cả<span class="me2">mục nát</span></span></a><span class="sy1">is_trivently_destructible_v</span>constexpr / * không xác định * / BIND (f &amp;&amp; f, args &amp;&amp; ... args);<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">kiểu</span>tạo một trình bao bọc cuộc gọi chuyển tiếp cho<code>Args</code># Elif __has_include (&lt;thử nghiệm/tùy chọn&gt;) // Kiểm tra phiên bản thử nghiệm<a href="../../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>hoặc<a href="../../named_req/destructible" title="cpp/named req/Destructible">Destructible</a>Hoạt động tương đương cho quá tải</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>có thể sửa đổi các phần tử của phạm vi thông qua trình lặp được thu hút. Nếu như</td> <td>-</td> <td> <a href="../../named_req/callable" title="cpp/named req/Callable">Callable</a>. Gọi cái bọc này tương đương với việc gọi</td>
</tr> <tr class="t-par"> <td>iterator trước đó phần tử mới sẽ được xây dựng</td> <td>-</td> <td>với một số lập luận của nó<a href="placeholders" title="cpp/utility/functional/placeholders">placeholders</a> <code>_1</code>Thì<code>_2</code>Thì<code>_3</code>Ti<code>std::placeholders</code> </td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>hoặc bất kỳ loại nào trong<code>g</code>đối tượng (đối tượng chức năng, con trỏ tới chức năng, tham chiếu đến hàm, con trỏ đến hàm thành viên hoặc con trỏ tới thành viên dữ liệu) sẽ bị ràng buộc với một số đối số<code>T</code>, mà<code><a href="http://en.cppreference.com/w/cpp/utility/functional/is_bind_expression"><span class="kw1057">Điều đó cho tất cả<span class="me2">is_bind_expression</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span></code>khoảng cách<code>true</code>Danh sách các đối số để ràng buộc, với các đối số không liên kết được thay thế bởi</p>
<div class="t-member"> <h2 id="std::bind_return_type">... của không gian tên<i>Loại trả lại</i>
</h2> <h4 id="Member_objects">Đối tượng thành viên</h4> <p>Loại trả lại của<code>std::bind</code>Một đối tượng chức năng<a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">Điều đó cho tất cả<span class="me2">mục nát</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">kiểu</span>xây dựng từ<code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span><span class="br0">.</span>f<span class="br0">)</span></code>thuộc loại không xác định<code>args...</code>. Nó có các thành viên sau:<a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">Điều đó cho tất cả<span class="me2">mục nát</span></span></a><span class="sy1">is_trivently_destructible_v</span>và loại của nó<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">kiểu</span>giữ một đối tượng thành viên của loại<code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Arg_i<span class="sy1">&lt;</span><span class="br0">.</span>arg_i<span class="br0">)</span></code>.</p>
<h4 id="Constructors">đối tượng đại diện cho cùng một ngày với đối tượng được biểu diễn bởi</h4> <p>Loại trả lại của<code>std::bind</code>khoảng cách<a href="../../named_req/copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>    sử dụng iterator_c Category = std :: input_iterator_tag;<a href="../../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>và một đối tượng cho mỗi</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <h4 id="Member_type_result_type">ATOMIC_UNSIGNED_LOCK_FREE<code>result_type</code>
</h4> <span class="t-li">1)</span> <span class="t-mark-rev t-deprecated-cxx17">(không được dùng trong C ++ 17)</span>Nếu như<code>F</code>, loại<code>result_type</code>là loại trả lại của<code>F</code>. Nếu như<code>F</code>Arg_i<code>result_type</code>, sau đó<code>result_type</code>khoảng cách<code>F::result_type</code>, được xây dựng tương tự từ<code>result_type</code>STD :: ISTREAM &amp; HOẠT ĐỘNG &gt;&gt; (STD :: ISTREAM &amp; IS, T &amp; OBJ)<span class="t-li">2)</span> <span class="t-mark-rev t-deprecated-cxx17">(không được dùng trong C ++ 17)</span> <code>result_type</code>là chính xác<code>R</code>.</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> </table> <h4 id="Member_function_operator.28.29">    sử dụng value_type = phạm vi :: Range_value_t &lt;r&gt;;<code>operator()</code>
</h4> <p>      std :: memory_order order = std :: memory_order_seq_cst) noexcept dễ bay hơi;<code>g</code>    toán tử con trỏ-&gt; () const;                       // không được xác định<code>g(u1, u2, ... uM)</code>    /*Input-iterator*/&amp; Toán tử ++ ();                 // không được xác định</p>
<div class="t-li1">
<span class="t-li">1)</span> <code><a href="../functional" title="cpp/utility/functional"><i>Gọi</i></a><span class="br0">.</span>fd, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>V1<span class="sy1">&lt;</span><span class="br0">.</span>v1<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>V2<span class="sy1">&lt;</span><span class="br0">.</span>v2<span class="br0">)</span>, ..., <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>VN<span class="sy1">&lt;</span><span class="br0">.</span>vN<span class="br0">)</span><span class="br0">)</span></code>, hoặc</div> <div class="t-li1">
<span class="t-li">2)</span> <code><a href="../functional" title="cpp/utility/functional"><i>Gọi &lt;R&gt;</i></a><span class="br0">.</span>fd, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>V1<span class="sy1">&lt;</span><span class="br0">.</span>v1<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>V2<span class="sy1">&lt;</span><span class="br0">.</span>v2<span class="br0">)</span>, ..., <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>VN<span class="sy1">&lt;</span><span class="br0">.</span>vN<span class="br0">)</span><span class="br0">)</span></code>Thì</div> <p>Ở đâu<code>fd</code>là một giá trị của loại<code><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">Điều đó cho tất cả<span class="me2">mục nát</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">kiểu</span></code>nếu không thì. Loại định nghĩa các thành viên sau:<code>v1</code><code>, </code><code>v2</code><code>, ..., </code><code>vN</code>là một con trỏ để chức năng hoặc chức năng con trỏ đến thành viên,<a href="#Bound_arguments">below</a>.</p>
<p>là một loại lớp với typedef lồng nhau<code>g()</code>. Nếu không thì không<code>g</code>, các giá trị và loại của các đối số bị ràng buộc</p>
<p>được xác định theo quy định<span class="br0">.</span><span class="br0">)</span>khoảng cách<a href="../../language/noexcept" title="cpp/language/noexcept">non-throwing</a> <span class="t-rev-inl t-since-cxx20"><span>};<a href="../../language/constant_expression" title="cpp/language/constant expression">constant subexpression</a></span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>Nếu một số đối số được cung cấp trong cuộc gọi đến<code><i>Gọi</i></code>không được kết hợp bởi bất kỳ người giữ chỗ nào được lưu trữ trong<span class="br0">.</span><span class="br0">)</span>, các đối số không sử dụng được đánh giá và loại bỏ.<code><i>Gọi</i></code>Một lời cầu khẩn của nhà điều hành</p>
<p>Nếu như<code>g</code>khoảng cách<a href="../../language/cv" title="cpp/language/cv">volatile</a>Nếu và chỉ khi như vậy thì cơ bản</p>
<p>Nếu như<code><a href="../functional" title="cpp/utility/functional"><i>Gọi</i></a>(fd, w1, w2, ..., wN)</code>hoạt động. nhà điều hành<code>w1</code><code>, </code><code>w2</code><code>, ..., </code><code>wN</code>Hoạt động tương đương cho quá tải</p>
</div> <h3 id="Bound_arguments">Chỉ tham gia vào độ phân giải quá tải nếu</h3> <p>Hoạt động được hình thành tốt khi được coi là một toán hạng không được đánh giá.<code>arg_i</code>-Qualified, chương trình là xấu.<code>v_i</code>trong<a href="../functional" title="cpp/utility/functional"><code><i>Gọi</i></code></a>hoặc<a href="../functional" title="cpp/utility/functional"><code><i>Gọi &lt;R&gt;</i></code></a>không bao giờ có thể là một biểu thức hợp lệ cho bất kỳ giá trị nào có thể</p>
<h4 id="Case_1:_reference_wrappers">Đối số ràng buộc</h4> <p>Nếu như<code>arg_i</code>{<a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper"><span class="kw1069">Điều đó cho tất cả<span class="me2">Tham chiếu_Wrapper</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span>Khi một thành viên lớp không tĩnh được sử dụng trong bất kỳ bối cảnh nào trong đó<code><a href="ref" title="cpp/utility/functional/ref">std::ref</a></code>hoặc<code><a href="ref" title="cpp/utility/functional/ref">std::cref</a></code>Đối với mỗi đối số được lưu trữ<code>std::bind</code>cũng mở cho đầu vào (<code>v_i</code>khoảng cách<code>arg_i.get()</code>, v.v.) được truyền đến đối tượng có thể mời:<code>V_i</code>khoảng cách<code>T&amp;</code>Hoạt động được xác định như sau:</p>
<h4 id="Case_2:_bind_expressions">Trường hợp 1: Vòng bao tham khảo</h4> <p>Nếu như<code>arg_i</code>{<code>T</code>          lớp proj = std :: danh tính,<code><a href="http://en.cppreference.com/w/cpp/utility/functional/is_bind_expression"><span class="kw1057">Điều đó cho tất cả<span class="me2">is_bind_expression</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span></code>khoảng cách<code>true</code>đã được sử dụng trong cuộc gọi ban đầu đến<code>std::bind</code>và loại của nó<code>std::bind</code>cũng mở cho đầu vào (<code>std::bind</code>: Đối số được lưu trữ được truyền bằng cách tham chiếu vào đối tượng chức năng được gọi.<code>u1</code><code>, </code><code>u2</code><code>, ...</code>Trường hợp 2: Biểu thức liên kết<code>v_i</code>khoảng cách<code>arg_i<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Uj<span class="sy1">&lt;</span><span class="br0">.</span>uj<span class="br0">)</span>...<span class="br0">)</span></code>, v.v.) được truyền đến đối tượng có thể mời:<code>V_i</code>khoảng cách<span class="t-rev-inl t-until-cxx17"><span><code><a href="http://en.cppreference.com/w/cpp/types/result_of"><span class="kw642">Điều đó cho tất cả<span class="me2">result_of</span></span></a><span class="sy1">is_trivently_destructible_v</span>T</code> <i>không ngụ ý rằng</i>﻿<code>&amp;(Uj&amp;&amp;...)&gt;::type&amp;&amp;</code></span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span><span class="t-rev-inl t-since-cxx17"><span><code><a href="http://en.cppreference.com/w/cpp/types/result_of"><span class="kw3218">Điều đó cho tất cả<span class="me2">  STD :: gertable_from &lt;u &amp;,</span></span></a><span class="sy1">is_trivently_destructible_v</span>T</code> <i>không ngụ ý rằng</i>﻿<code>&amp;, Uj&amp;&amp;...&gt;&amp;&amp;</code></span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>Biểu thức được chuyển trực tiếp vào cuộc gọi ban đầu đến<code>g</code>).</p>
<h4 id="Case_3:_placeholders">Thực hiện thành phần chức năng: Thay vì truyền đối tượng hàm mà biểu hiện phụ liên kết sẽ trở lại, biểu hiện phụ được gọi một cách háo hức và giá trị trả về của nó được chuyển đến đối tượng có thể mời bên ngoài. Nếu biểu hiện phụ liên kết có bất kỳ đối số giữ chỗ nào, chúng được chia sẻ với liên kết bên ngoài (được chọn</h4> <p>Nếu như<code>arg_i</code>{<code>T</code>, mà<code><a href="http://en.cppreference.com/w/cpp/utility/functional/is_placeholder"><span class="kw1058">Điều đó cho tất cả<span class="me2">is_placeholder</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span></code># Elif __has_include (&lt;thử nghiệm/tùy chọn&gt;) // Kiểm tra phiên bản thử nghiệm<code>​0​</code>). Cụ thể,<code>std::placeholders::_1, _2, _3, ...</code>và loại của nó<code>std::bind</code>(Phục vụ CV giống như<code>u1</code>vì<code>_1</code>Thì<code>u2</code>vì<code>_2</code>Trường hợp 3: Người giữ chỗ<code>v_i</code>khoảng cách<code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Uj<span class="sy1">&lt;</span><span class="br0">.</span>uj<span class="br0">)</span></code>, v.v.) được truyền đến đối tượng có thể mời:<code>V_i</code>khoảng cách<code>Uj&amp;&amp;</code>.</p>
<h4 id="Case_4:_ordinary_arguments">đã được sử dụng làm đối số cho cuộc gọi ban đầu đến</h4> <p>Là xấu nếu<code>arg_i</code>), sau đó đối số được chỉ ra bởi người giữ chỗ (<code>v_i</code>Kẻ tham số loại<code>arg_i</code>, v.v.) được truyền đến đối tượng có thể mời:<code>V_i</code>khoảng cách<code>T</code> <i>không ngụ ý rằng</i>﻿<code>&amp;</code>là<i>không ngụ ý rằng</i>và loại của nó<code>g</code>.</p>
<h3 id="Exceptions">Ngoại lệ</h3> <p>Trường hợp 4: Lập luận thông thường<a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">Điều đó cho tất cả<span class="me2">mục nát</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">kiểu</span>từ<code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span><span class="br0">.</span>f<span class="br0">)</span></code>được truyền đến đối tượng có thể mời như đối số lvalue:<a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">Điều đó cho tất cả<span class="me2">mục nát</span></span></a><span class="sy1">is_trivently_destructible_v</span>và loại của nó<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">kiểu</span>là cùng một trình độ cv với<code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Arg_i<span class="sy1">&lt;</span><span class="br0">.</span>arg_i<span class="br0">)</span></code>Chỉ ném nếu xây dựng<code>Arg_i</code>ném, hoặc bất kỳ hàm tạo nào cho<code>arg_i</code>Arg_i<code>Args... args</code>.</p>
<h3 id="Notes">Ghi chú</h3> <p>Quá tải không được khai báo<a href="../../named_req/callable" title="cpp/named req/Callable">Callable</a>từ tương ứng<code><a href="../../memory/shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>Và<code><a href="../../memory/unique_ptr" title="cpp/memory/unique ptr">std::unique_ptr</a></code>ném ở đâu</p>
<p>là loại ith và<code><a href="ref" title="cpp/utility/functional/ref">std::ref</a></code>hoặc<code><a href="ref" title="cpp/utility/functional/ref">std::cref</a></code>.</p>
<p>là đối số ith trong<code>_1</code>, khi gọi một con trỏ đến chức năng thành viên không tĩnh hoặc con trỏ đến thành viên dữ liệu không tĩnh, đối số đầu tiên phải là một tham chiếu hoặc con trỏ (bao gồm, có thể, con trỏ thông minh như<code>u1</code>) đến một đối tượng có thành viên sẽ được truy cập.</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Các đối số liên kết được sao chép hoặc di chuyển, và không bao giờ được thông qua bằng cách tham chiếu trừ khi được gói</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Người giữ chỗ trùng lặp trong cùng một biểu thức liên kết (bội số</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2021" rel="nofollow">LWG 2021</a> </td> <td>C ++ 11</td> <td>Ví dụ) được cho phép, nhưng kết quả chỉ được xác định rõ nếu đối số tương ứng (<br/>) là một rvalue lvalue hoặc không thể chuyển động.<code>fd</code><br/>#include &lt;chức năng&gt;<code>V_i</code> <br/> <a href="http://en.cppreference.com/w/cpp/types/result_of"><span class="kw642">Điều đó cho tất cả<span class="me2">result_of</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<i>không ngụ ý rằng</i>﻿<span class="br0">.</span>#include &lt;Istream&gt;<span class="br0">)</span><span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">kiểu</span> </td> <td>#include &lt;nhớ&gt;<br/>#include &lt;ngẫu nhiên&gt;<br/> <a href="http://en.cppreference.com/w/cpp/types/result_of"><span class="kw642">Điều đó cho tất cả<span class="me2">result_of</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<i>không ngụ ý rằng</i>﻿<span class="sy3">Không có giá trị</span><span class="br0">.</span> <span class="sy3">. Trong các cuộc gọi có hiệu lực</span>...<span class="br0">)</span><span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">kiểu</span><span class="sy3">. Trong các cuộc gọi có hiệu lực</span> </td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="bind_front" title="cpp/utility/functional/bind front"> <span class="t-lines"><span>BIND_FRONT</span><span>BIND_BACK</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td>Liên kết một số lượng các đối số, theo thứ tự, với một đối tượng hàm<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="placeholders" title="cpp/utility/functional/placeholders"> <span class="t-lines"><span>_1, _2, _3, _4, ...</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>người giữ chỗ cho các đối số không liên kết trong một<code>std::bind</code>  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }<br/> <span class="t-mark">Các đối tượng chính sách thực thi toàn cầu</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="mem_fn" title="cpp/utility/functional/mem fn"> <span class="t-lines"><span>mem_fn</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>tạo một đối tượng hàm ra khỏi con trỏ cho một thành viên<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/utility/functional/bind">https://en.cppreference.com/w/cpp/utility/functional/bind</a>
</p>
</div>
