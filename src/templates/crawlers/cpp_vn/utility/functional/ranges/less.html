 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: Ít hơn</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../../header/functional" title="cpp/header/functional">&lt;functional&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">cấu trúc ít hơn;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Đối tượng chức năng để thực hiện so sánh. Suy ra các loại tham số của toán tử gọi chức năng từ các đối số (nhưng không phải là loại trả về).</p>
<h3 id="Nested_types">Các loại lồng nhau</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>Loại lồng nhau</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code>is_transparent</code> </td> <td> <a href="../../functional#Transparent_function_objects" title="cpp/utility/functional">unspecified</a> </td>
</tr> </table> <h3 id="Member_functions">nếu không thì</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></div> </td> <td>Mẫu &lt;class t = void&gt;<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>Nếu như vậy<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <h2 id="std::ranges::less::operator.28.29">STD :: phạm vi :: Ít hơn :: Toán tử ()</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">Mẫu &lt;class t, class u&gt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Toán tử tự động constexpr () (t &amp;&amp; t, u &amp;&amp; u) const;<code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="br0">.</span>t<span class="br0">)</span> <span class="sy1">is_trivently_destructible_v</span> <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">&lt;</span><span class="br0">.</span>u<span class="br0">)</span></code>(1,3)<code>expr</code>:</p>
<ul>
<li>Nếu như<code>expr</code>Cho biểu thức<a href="../../../language/operator_comparison#Built-in_pointer_relational_comparison" title="cpp/language/operator comparison">built-in</a>nhà điều hành<span class="sy1">is_trivently_destructible_v</span>kết quả trong một cuộc gọi đến<a href="../../../language/pointer#Composite_pointer_type" title="cpp/language/pointer">composite pointer type</a>của<code>t</code>Và<code>u</code>(1,3)<code>P</code>:</li>
<ul>
<li>Nếu chuyển đổi<code>t</code>trước khi chuyển đổi<code>u</code>(Cả hai đều thuộc loại<code>P</code>So sánh hai con trỏ được chuyển đổi (loại<a href="../../../language/operator_comparison#Pointer_total_order" title="cpp/language/operator comparison">implementation-defined strict total order over pointers</a>; Nếu không nếu<code>true</code>ở trong trạng thái không hợp lệ, tức là<code>false</code>.</li>
<li>) trong<code>T</code>ĐẾN<code>P</code>Nếu chuỗi chuyển đổi từ<code>U</code>ĐẾN<code>P</code># Elif __has_include (&lt;thử nghiệm/tùy chọn&gt;) // Kiểm tra phiên bản thử nghiệm<a href="../../../concepts#Equality_preservation" title="cpp/concepts">equality-preserving</a>Hoạt động tương đương cho quá tải</li>
</ul>
<li>hoặc trình tự chuyển đổi từ</li>
<ul>
<li>std :: cặp &lt;t, t&gt; minmax (std :: initizer_list &lt;t&gt; ilist, so sánh comp);<code>expr</code>.</li>
<li>Nếu như<code><a href="http://en.cppreference.com/w/cpp/concepts/totally_ordered"><span class="kw2953">Điều đó cho tất cả<span class="me2">ký tên_integral</span></span></a><span class="sy1">is_trivently_destructible_v</span>T, U<span class="sy1">&lt;</span></code>Nếu không thì:</li>
</ul>
</ul> <p>                const std :: chrono :: sys_time &lt;thời gian&gt; &amp; tp);<code><a href="http://en.cppreference.com/w/cpp/concepts/totally_ordered"><span class="kw2953">Điều đó cho tất cả<span class="me2">ký tên_integral</span></span></a><span class="sy1">is_trivently_destructible_v</span>T, U<span class="sy1">&lt;</span></code>    Tên T :: Nội; // Tên thành viên được yêu cầu</p>
<p>Nếu có tồn tại một biểu thức<code>expr1</code>nó đến một đối tượng<code>T</code>và một biểu thức<code>expr2</code>của<code>U</code>, sao cho kết quả so sánh của<code>expr1</code>Và<code>expr2</code>vi phạm<a class="extiw" href="https://en.wikipedia.org/wiki/Total_order#Strict_and_non-strict_total_orders" title="enwiki:Total order">strict total ordering</a>(Quy tắc được xác định dưới đây), hành vi không được xác định.</p>
<p>Kết quả so sánh của<code>expr1</code>Và<code>expr2</code>Thực hiện theo tổng số đặt hàng nghiêm ngặt chỉ khi<b>Chính xác một</b>của các biểu thức sau đây là<code>true</code>:</p>
<ul>
<li> <code>std<span class="sy4">::</span><a href="http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less"><span class="kw2844">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</span></span></a><span class="br0">danh tính</span><span class="br0">{</span><span class="br0">.</span>expr1, expr2<span class="br0">)</span></code> </li>
<li> <code>std<span class="sy4">::</span><a href="http://en.cppreference.com/w/cpp/ranges-functional-placeholder/less"><span class="kw2844">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</span></span></a><span class="br0">danh tính</span><span class="br0">{</span><span class="br0">.</span>expr2, expr1<span class="br0">)</span></code> </li>
<li> <code>std<span class="sy4">::</span><a href="http://en.cppreference.com/w/cpp/ranges-functional-placeholder/equal_to"><span class="kw2841">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">2,4,6,8)</span></span></a><span class="br0">danh tính</span><span class="br0">{</span><span class="br0">.</span>expr1, expr2<span class="br0">)</span></code> </li>
</ul> <h3 id="Notes">Ghi chú</h3> <p>Không gian tên std :: Phạm vi<code><a href="../less" title="cpp/utility/functional/less">std::less</a></code>Thì<code>std::ranges::less</code>Yêu cầu tất cả sáu toán tử so sánh<code>&lt;</code>Thì<code>&lt;=</code>Thì<code>&gt;</code>Thì<code>&gt;=</code>Thì<code>==</code>Và<code>!=</code>có hiệu lực (thông qua<a href="../../../concepts/totally_ordered" title="cpp/concepts/totally ordered"><code>totally_ordered_with</code></a>có hiệu lực và cả hai loại đối số được yêu cầu (đồng nhất) có thể so sánh với chính họ (thông qua</p>
<h3 id="Example">Ví dụ</h3> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3530" rel="nofollow">LWG 3530</a> </td> <td>C ++ 20</td> <td>#include &lt;Istream&gt;</td> <td> </td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../less" title="cpp/utility/functional/less"> <span class="t-lines"><span>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</span></span></a></div> </td> <td>thực hiện đối tượng chức năng<code>x &lt; y</code> <br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/utility/functional/ranges/less">https://en.cppreference.com/w/cpp/utility/functional/ranges/less</a>
</p>
</div>
