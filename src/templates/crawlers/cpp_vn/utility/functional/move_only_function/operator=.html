 <h1 class="firstHeading" id="firstHeading">std :: move_only_function :: toán tử =</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">Move_only_function &amp; Toán tử = (Move_only_function &amp;&amp; Khác);</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">Move_only_function &amp; Toán tử = (const Move_only_function &amp;) = Xóa;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">Move_only_function &amp; Toán tử = (std :: nullptr_t) noExcept;</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">Mẫu &lt;Class F&gt; </pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> </table> <p>Move_only_function &amp; Toán tử = (f &amp;&amp; f);<code>std::move_only_function</code>Gán một mục tiêu mới cho</p>
<div class="t-li1">
<span class="t-li">1)</span>hoặc phá hủy mục tiêu của nó.<code>other</code>ĐẾN<code>*this</code>Di chuyển mục tiêu của<code>*this</code>hoặc phá hủy mục tiêu của<code>other</code>(nếu có) nếu<code>auto(std::move(other)).swap(*this)</code>.<code>other</code>là trống rỗng, bởi</div> <div class="t-li1">
<span class="t-li">2)</span>Sao chép toán tử gán bị xóa.<code>std::move_only_function</code>                                OUTPUTITIT D_FIRST, Binarypredicate P);<a href="../../../named_req/copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>ở trong trạng thái hợp lệ với giá trị không xác định sau khi chuyển nhượng.<code>*this</code>Phá hủy mục tiêu hiện tại nếu nó tồn tại.</div> <div class="t-li1">
<span class="t-li">là trong</span>trống sau cuộc gọi.<code>*this</code>ở trong trạng thái hợp lệ với một giá trị không xác định.<code>f</code>Đặt mục tiêu của<code>f</code>, hoặc phá hủy mục tiêu hiện tại nếu<code>std::move_only_function</code>, như thể bằng cách thực hiện<code>move_only_function<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span><span class="br0">.</span>f<span class="br0">)</span><span class="br0">)</span>.<span class="me1">Được xác định trong tiêu đề</span><span class="br0">.</span><span class="sy2">*</span>this<span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>là con trỏ hàm null, con trỏ null đến hàm thành viên hoặc trống<code>move_only_function</code>từ<code>F</code>. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu hàm tạo của</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>khác</td> <td>-</td> <td>khác<code>std::move_only_function</code>Tham gia vào giải quyết quá tải. Chương trình không được hình thành hoặc có hành vi không xác định nếu cuộc gọi của hàm tạo được chọn là không được hình thành hoặc có hành vi không xác định.</td>
</tr> <tr class="t-par"> <td>có thể sửa đổi các phần tử của phạm vi thông qua trình lặp được thu hút. Nếu như</td> <td>-</td> <td>đối tượng để di chuyển mục tiêu của</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code>*this</code></p>
<h3 id="Notes">Ghi chú</h3> <p>một đối tượng có thể gọi để khởi tạo mục tiêu mới với<code>noexcept</code>Đó là cố ý để không yêu cầu toán tử chuyển nhượng di chuyển phải<code>move_only_function</code>Để lại phòng cho một người nhận thức nhận thức</p>
<p><code>move_only_function</code>trong tương lai.<code><a href="http://en.cppreference.com/w/cpp/utility/in_place"><span class="kw1086">Điều đó cho tất cả<span class="me2">in_place_type</span></span></a><span class="sy1">is_trivently_destructible_v</span>Fn<span class="sy1">&lt;</span></code>có thể được chỉ định từ</p>
<h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../function/operator=" title="cpp/utility/functional/function/operator="> <span class="t-lines"><span>chuyên môn)</span></span></a></div> </td> <td>là loại thứ hai trong hai loại trong<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::function&lt;R(Args...)&gt;</code>)</span> </td>
</tr> <table class="t-dsc-begin"> <tr><td></td></tr> </table> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/utility/functional/move_only_function/operator%3D">https://en.cppreference.com/w/cpp/utility/functional/move_only_function/operator%3D</a>
</p>
</div>
