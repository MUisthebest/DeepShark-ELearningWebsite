 <h1 class="firstHeading" id="firstHeading">STD :: MEM_FUN_REF</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/functional" title="cpp/header/functional">&lt;functional&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-until-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;class res, class t&gt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark">(không dùng nữa trong C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx17">(Đã xóa trong C ++ 17)</span> </td> </tr> <tr class="t-dcl t-until-cxx17"> <td> <pre data-language="cpp">std :: mem_fun_ref_t &lt;res, t&gt; mem_fun_ref (res (t ::*f) ());</pre>
</td> <td>(1)</td> <td> <span class="t-mark">(không dùng nữa trong C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx17">(Đã xóa trong C ++ 17)</span> </td> </tr> <tr class="t-dcl t-until-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;class res, class t&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark">(không dùng nữa trong C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx17">(Đã xóa trong C ++ 17)</span> </td> </tr> <tr class="t-dcl t-until-cxx17"> <td> <pre data-language="cpp">std :: const_mem_fun_ref_t &lt;res, t&gt; mem_fun_ref (res (t ::*f) () const);</pre>
</td> <td>(2)</td> <td> <span class="t-mark">(không dùng nữa trong C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx17">(Đã xóa trong C ++ 17)</span> </td> </tr> </table> <p>Mẫu &lt;class res, class t, class arg&gt;<code>T</code>std :: mem_fun1_t &lt;res, t, arg&gt; mem_fun (res (t ::*f) (arg));<code>operator()</code>.</p>
<div class="t-li1">
<span class="t-li">1)</span>Gọi một cách hiệu quả<code><a href="http://en.cppreference.com/w/cpp/utility/functional/mem_fun_ref_t"><span class="kw2725">Điều đó cho tất cả<span class="me2">MEM_FUN_REF_T</span></span></a><span class="sy1">is_trivently_destructible_v</span>S,T<span class="sy1">&lt;</span><span class="br0">.</span>f<span class="br0">)</span></code>hoặc<code><a href="http://en.cppreference.com/w/cpp/utility/functional/mem_fun_ref_t"><span class="kw2727">Điều đó cho tất cả<span class="me2">const_mem_fun_ref_t</span></span></a><span class="sy1">is_trivently_destructible_v</span>S,T<span class="sy1">&lt;</span><span class="br0">.</span>f<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">2)</span>Gọi một cách hiệu quả<code><a href="http://en.cppreference.com/w/cpp/utility/functional/mem_fun_ref_t"><span class="kw2726">Điều đó cho tất cả<span class="me2">MEM_FUN1_REF_T</span></span></a><span class="sy1">is_trivently_destructible_v</span>S,T<span class="sy1">&lt;</span><span class="br0">.</span>f<span class="br0">)</span></code>hoặc<code><a href="http://en.cppreference.com/w/cpp/utility/functional/mem_fun_ref_t"><span class="kw2728">Điều đó cho tất cả<span class="me2">const_mem_fun1_ref_t</span></span></a><span class="sy1">is_trivently_destructible_v</span>S,T<span class="sy1">&lt;</span><span class="br0">.</span>f<span class="br0">)</span></code>.</div> <p>Mẫu &lt;class res, class t, class arg&gt;<code><a href="mem_fn" title="cpp/utility/functional/mem fn">std::mem_fn</a></code>Và<code><a href="bind" title="cpp/utility/functional/bind">std::bind</a></code>std :: const_mem_fun1_t &lt;res, t, arg&gt; mem_fun (res (t ::*f) (arg) const);</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>có thể sửa đổi các phần tử của phạm vi thông qua trình lặp được thu hút. Nếu như</td> <td>-</td> <td>Tạo một đối tượng trình bao bọc chức năng thành viên, suy ra loại mục tiêu từ các đối số mẫu. Đối tượng trình bao bọc mong đợi một con trỏ đến một đối tượng thuộc loại</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>con trỏ đến một hàm để liên kết một đối số với<code>f</code>.</p>
<h3 id="Exceptions">Ngoại lệ</h3> <p>Có thể ném các trường hợp ngoại lệ do thực hiện.</p>
<h3 id="Notes">Ghi chú</h3> <p>Sentinel biểu thị kết thúc của phạm vi<code><a href="http://en.cppreference.com/w/cpp/utility/functional/mem_fun"><span class="kw2724">Điều đó cho tất cả<span class="me2">mem_fun</span></span></a></code>Và<code>std::mem_fun_ref</code>là tham số đầu tiên của nó</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example">
<p>, trả lại<code>std::mem_fun_ref</code>std :: mem_fun1_ref_t &lt;res, t, arg&gt; mem_fun_ref (res (t ::*f) (arg));<code><a href="../../string/basic_string" title="cpp/string/basic string">std::string</a></code>Mẫu &lt;class res, class t, class arg&gt;<code><a href="../../string/basic_string/size" title="cpp/string/basic string/size">size()</a></code>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">std :: const_mem_fun1_ref_t &lt;res, t, arg&gt; mem_fun_ref (res (t ::*f) (arg) const);</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Tạo một đối tượng trình bao bọc chức năng thành viên, suy ra loại mục tiêu từ các đối số mẫu. Đối tượng trình bao bọc mong đợi một tham chiếu đến một đối tượng thuộc loại</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="mem_fun" title="cpp/utility/functional/mem fun"> <span class="t-lines"><span>mem_fun</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(không dùng nữa trong C ++ 11)</span></span><span><span class="t-mark-rev t-until-cxx17">(Đã xóa trong C ++ 17)</span></span></span></div> </td> <td>Tạo một trình bao bọc từ chức năng con trỏ đến thành viên, có thể gọi bằng một con trỏ đến đối tượng<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/utility/functional/mem_fun_ref">https://en.cppreference.com/w/cpp/utility/functional/mem_fun_ref</a>
</p>
</div>
