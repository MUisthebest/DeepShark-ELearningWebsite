 <h1 class="firstHeading" id="firstHeading">    {<small>Thuật toán</small>
</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/memory" title="cpp/header/memory">&lt;memory&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;class T&gt; struct std :: Atomic &lt;std :: stress_ptr &lt;t &gt;&gt;;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>struct std :: Atomic &lt;std :: shared_ptr &lt;t &gt;&gt;;<code><a href="../../atomic/atomic" title="cpp/atomic/atomic">std::atomic</a></code>vì<code><a href="http://en.cppreference.com/w/cpp/memory/weak_ptr"><span class="kw743">Điều đó cho tất cả<span class="me2">yếu_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>Cho phép người dùng thao tác các đối tượng yếu_ptr về mặt nguyên tử.</p>
<p>    .<code><a href="../weak_ptr" title="cpp/memory/weak ptr">std::weak_ptr</a></code>      std :: memory_order mo);<code>weak_ptr</code>đối tượng nguyên tử.<code><a href="http://en.cppreference.com/w/cpp/atomic/atomic"><span class="kw2070">Điều đó cho tất cả<span class="me2">nguyên tử</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/memory/weak_ptr"><span class="kw743">Điều đó cho tất cả<span class="me2">yếu_ptr</span></span></a><span class="sy1">&lt;</span></code>.</p>
<p>để truy cập nguyên tử vào<code>use_count</code>Có liên quan<code>use_count</code>Sự gia tăng được đảm bảo là một phần của hoạt động nguyên tử. Có liên quan<code>use_count</code>Giảm được giải trình tự sau hoạt động nguyên tử, nhưng không bắt buộc phải là một phần của nó, ngoại trừ<code>expected</code>thay đổi khi ghi đè</p>
<p>Lưu ý rằng khối điều khiển được sử dụng bởi<code><a href="../weak_ptr" title="cpp/memory/weak ptr">std::weak_ptr</a></code>Và<code><a href="../shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>trong một CAS thất bại. Bất kỳ xóa và xử lý liên quan nào được giải trình tự sau bước cập nhật nguyên tử và không phải là một phần của hoạt động nguyên tử.<code><a href="../weak_ptr" title="cpp/memory/weak ptr">std::weak_ptr</a></code>là an toàn cho chủ đề: không phải nguyên tử khác nhau<code>operator=</code>hoặc<code>reset</code>, đồng thời bởi nhiều luồng, ngay cả khi các trường hợp này là bản sao hoặc chia sẻ cùng một khối điều khiển bên trong.</p>
<p>phạm vi của các yếu tố để tạo<code>T</code>có thể là một loại không đầy đủ.</p>
<h3 id="Member_types">nhà điều hành ()</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>ATOMIC_UNSIGNED_LOCK_FREE</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code>value_type</code> </td> <td> <code><a href="http://en.cppreference.com/w/cpp/memory/weak_ptr"><span class="kw743">Điều đó cho tất cả<span class="me2">yếu_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code> </td>
</tr> </table> <h3 id="Member_functions">nếu không thì</h3> <p>Loại T có thể là một loại không đầy đủ.<code><a href="../../atomic/atomic" title="cpp/atomic/atomic">std::atomic</a></code>Tất cả không chuyên hóa</p>
<div class="t-member"> <h2 id="atomic.3Cweak_ptr.3CT.3E.3E::atomic">Nguyên tử &lt;yếu_ptr &lt;t &gt;&gt; :: Atomic</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">Nguyên tử &lt;Shared_ptr &lt;t &gt;&gt; :: Atomic</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Atomic (std :: stress_ptr &lt;t&gt; mong muốn) noExcept;</pre>
</td> <td>(2)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">nguyên tử (const nguyên tử &amp;) = xóa;</pre>
</td> <td>(3)</td> <td class="t-dcl-nopad"> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>đến giá trị null.<code>weak_ptr&lt;T&gt;</code>đến giá trị được xây dựng mặc định.</div> <div class="t-li1">
<span class="t-li">2)</span>đến giá trị null.<code>weak_ptr&lt;T&gt;</code>Khởi tạo cơ bản<code>desired</code>đến một bản sao của<code><a href="../../atomic/atomic" title="cpp/atomic/atomic">std::atomic</a></code>. Như với bất kỳ</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Loại, khởi tạo không phải là một hoạt động nguyên tử.</div>
</div> <div class="t-member"> <h2 id="atomic.3Cweak_ptr.3CT.3E.3E::operator.3D">Nguyên tử &lt;yếu_ptr &lt;t &gt;&gt; :: Toán tử =</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">toán tử void = (const Atomic &amp;) = xóa;</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">toán tử void = (std :: stress_ptr &lt;t&gt; mong muốn) noExcept;</pre>
</td> <td>(2)</td> <td class="t-dcl-nopad"> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>toán tử void = (std :: nullptr_t) noExcept;</div> <div class="t-li1">
<span class="t-li">2)</span>Các loại nguyên tử không được sao chép/di chuyển có thể gán.<code>store(desired)</code>.</div>
</div> <div class="t-member"> <h2 id="atomic.3Cweak_ptr.3CT.3E.3E::is_lock_free">Nguyên tử &lt;yếu_ptr &lt;t &gt;&gt; :: is_lock_free</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool is_lock_free () const noexcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Trả về true nếu các hoạt động nguyên tử trên tất cả các đối tượng thuộc loại này không có khóa, sai nếu không.</p>
</div> <div class="t-member"> <h2 id="atomic.3Cweak_ptr.3CT.3E.3E::store">Nguyên tử &lt;yếu_ptr &lt;t &gt;&gt; :: Lưu trữ</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">Void Store (STD :: yếu_ptr &lt;t&gt; mong muốn,</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Void Store (STD :: Shared_ptr &lt;t&gt; mong muốn,<code>*this</code>                            STD :: Memory_order Order) NoExcept;<code>desired</code>Mẫu &lt;Class T&gt;<code>p.swap(desired)</code>Ở đâu<code>p</code>std :: Shared_ptr &lt;t&gt; exchange (std :: shared_ptr &lt;t&gt; mong muốn,<code><a href="http://en.cppreference.com/w/cpp/memory/weak_ptr"><span class="kw743">Điều đó cho tất cả<span class="me2">yếu_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>Thay thế nguyên tử giá trị của<code>order</code>    sao chép (r &amp;&amp; r, o kết quả);<code>order</code>khoảng cách<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_consume</a></code>Thì<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_acquire</a></code>, hoặc<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_acq_rel</a></code>.</p>
</div> <div class="t-member"> <h2 id="atomic.3Cweak_ptr.3CT.3E.3E::load">           std :: memory_order order = std :: memory_order_seq_cst) noExcept;</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">Nguyên tử &lt;yếu_ptr &lt;t &gt;&gt; :: Tải</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>std :: weak_ptr &lt;t&gt; load (std :: memory_order order = std :: memory_order_seq_cst) const noexcept;<code><a href="http://en.cppreference.com/w/cpp/memory/weak_ptr"><span class="kw743">Điều đó cho tất cả<span class="me2">yếu_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>Thay thế nguyên tử giá trị của<code>order</code>    sao chép (r &amp;&amp; r, o kết quả);<code>order</code>khoảng cách<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_release</a></code>hoặc<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_acq_rel</a></code>.</p>
</div> <div class="t-member"> <h2 id="atomic.3Cweak_ptr.3CT.3E.3E::operator_std::weak_ptr.3CT.3E">Trả lại nguyên tử một bản sao của cơ bản</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">Nguyên tử &lt;yếu_ptr &lt;t &gt;&gt; :: Toán tử std :: stress_ptr &lt;t&gt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Mẫu &lt;class inputit1, class inputit2,<code>return load();</code>.</p>
</div> <div class="t-member"> <h2 id="atomic.3Cweak_ptr.3CT.3E.3E::exchange">toán tử std :: weak_ptr &lt;t&gt; () const noexcept;</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">Nguyên tử &lt;yếu_ptr &lt;t &gt;&gt; :: Exchange</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Nguyên tử &lt;Shared_ptr &lt;t &gt;&gt; :: Exchange<code><a href="http://en.cppreference.com/w/cpp/memory/weak_ptr"><span class="kw743">Điều đó cho tất cả<span class="me2">yếu_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>với<code>desired</code>Mẫu &lt;Class T&gt;<code>p.swap(desired)</code>Ở đâu<code>p</code>std :: Shared_ptr &lt;t&gt; exchange (std :: shared_ptr &lt;t&gt; mong muốn,<code><a href="http://en.cppreference.com/w/cpp/memory/weak_ptr"><span class="kw743">Điều đó cho tất cả<span class="me2">yếu_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>std :: stress_ptr &lt;t&gt; exchange (std :: stress_ptr &lt;t&gt; mong muốn,<code>p</code>Thay thế nguyên tử<code>order</code>là cơ bản</p>
</div> <div class="t-member"> <h2 id="atomic.3Cweak_ptr.3CT.3E.3E::compare_exchange_weak.2C_compare_exchange_strong">                          std :: memory_order order = std :: memory_order_seq_cst) noExcept;</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">và trả về một bản sao của giá trị</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Nguyên tử &lt;yếu_ptr &lt;t &gt;&gt; :: compare_exchange_weak, compare_exchange_strong</pre>
</td> <td>(2)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">bool compare_exchange_strong (std :: weak_ptr &lt;t&gt; &amp; mong đợi, std :: stress_ptr &lt;t&gt; mong muốn,</pre>
</td> <td>(3)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">                             std :: memory_order thành công, std :: memory_order thất bại) NoExcept;</pre>
</td> <td>(4)</td> <td class="t-dcl-nopad"> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>                              std :: memory_order thành công, std :: memory_order thất bại) NoExcept;<code><a href="http://en.cppreference.com/w/cpp/memory/weak_ptr"><span class="kw743">Điều đó cho tất cả<span class="me2">yếu_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>bool compare_exchange_weak (std :: weak_ptr &lt;t&gt; &amp; mong đợi, std :: stress_ptr &lt;t&gt; mong muốn,<code>expected</code>                            std :: memory_order thành công, std :: memory_order thất bại) NoExcept;<code>expected</code>bool compare_exchange_strong (std :: shared_ptr &lt;t&gt; &amp; mong đợi, std :: shared_ptr &lt;t&gt; mong muốn,<code>desired</code>                              std :: memory_order order = std :: memory_order_seq_cst) noExcept;<code><a href="http://en.cppreference.com/w/cpp/memory/weak_ptr"><span class="kw743">Điều đó cho tất cả<span class="me2">yếu_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>; Nếu không nếu<code>true</code>Nếu cơ bản<code>success</code>                            std :: memory_order order = std :: memory_order_seq_cst) noExcept;<code><a href="http://en.cppreference.com/w/cpp/memory/weak_ptr"><span class="kw743">Điều đó cho tất cả<span class="me2">yếu_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>ĐẾN<code>expected</code>; Nếu không nếu<code>false</code>Nếu cơ bản<code>failure</code>    sao chép (r &amp;&amp; r, o kết quả);<code>failure</code>khoảng cách<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_release</a></code>hoặc<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_acq_rel</a></code>Lưu trữ giống nhau<code>*this</code>Và<code>expected</code>và chia sẻ quyền sở hữu với nó, hoặc nếu cả cơ bản và<code>*this</code>Và<code>expected</code>trống rỗng, gán từ<code>expected</code>                           std :: memory_order thành công, std :: memory_order thất bại) NoExcept;</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>, và đặt hàng bộ nhớ theo</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>                                                  Inputit2 First2, Inputit2 Last2);<code>return compare_exchange_strong(expected, desired, order, fail_order);</code>là<code>fail_order</code>giống như<code>order</code>Ngoại trừ điều đó<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_acq_rel</a></code>không được truy cập sau bản cập nhật nguyên tử. Về thất bại, hoạt động là một hoạt động tải nguyên tử trên<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_acquire</a></code>Và<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_release</a></code>không được truy cập sau bản cập nhật nguyên tử. Về thất bại, hoạt động là một hoạt động tải nguyên tử trên<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_relaxed</a></code>.</div> <div class="t-li1">
<span class="t-li">là trong</span>                                                  Inputit2 First2, Inputit2 Last2);<code>return compare_exchange_weak(expected, desired, order, fail_order);</code>là<code>fail_order</code>giống như<code>order</code>Ngoại trừ điều đó<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_acq_rel</a></code>không được truy cập sau bản cập nhật nguyên tử. Về thất bại, hoạt động là một hoạt động tải nguyên tử trên<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_acquire</a></code>Và<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_release</a></code>không được truy cập sau bản cập nhật nguyên tử. Về thất bại, hoạt động là một hoạt động tải nguyên tử trên<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_relaxed</a></code>.</div>
</div> <div class="t-member"> <h2 id="atomic.3Cweak_ptr.3CT.3E.3E::wait">bool compare_exchange_strong (std :: weak_ptr &lt;t&gt; &amp; mong đợi, std :: stress_ptr &lt;t&gt; mong muốn,</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">                             std :: memory_order order = std :: memory_order_seq_cst) noExcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>, nhưng cũng có thể thất bại một cách mạnh mẽ.</p>
<p>void Atomic_flag_wait_explicit (đối tượng Atomic_flag* dễ bay hơi<code>load(order)</code>với<code>old</code>được thay thế bởi<code>*this</code>Thực hiện các hoạt động chờ đợi nguyên tử.<code>notify_one()</code>hoặc<code>notify_all()</code>được thay thế bởi<code>load(order)</code>được thay thế bởi</p>
<p>được thay thế bởi<code>order</code>    sao chép (r &amp;&amp; r, o kết quả);<code>order</code>khoảng cách<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_release</a></code>hoặc<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_acq_rel</a></code>.</p>
<p>Nguyên tử &lt;Shared_ptr &lt;T &gt;&gt; :: Đợi đã<code><a href="../weak_ptr" title="cpp/memory/weak ptr">std::weak_ptr</a></code>void Wait (std :: Shared_ptr &lt;t&gt; cũ,</p>
</div> <div class="t-member"> <h2 id="atomic.3Cweak_ptr.3CT.3E.3E::notify_one">bool compare_exchange_weak (std :: weak_ptr &lt;t&gt; &amp; mong đợi, std :: stress_ptr &lt;t&gt; mong muốn,</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">void notify_one () noExcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Bộ nhớ được đặt hàng theo</p>
<p>và nếu chúng tương đương thì các khối cho đến khi<code>wait()</code>) TRÊN<code>*this</code>. Điều này được lặp lại cho đến khi</p>
</div> <div class="t-member"> <h2 id="atomic.3Cweak_ptr.3CT.3E.3E::notify_all">                           std :: memory_order order = std :: memory_order_seq_cst) noExcept;</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">void notify_all () noExcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Bộ nhớ được đặt hàng theo</p>
<p>Hút tất cả các luồng bị chặn trong các hoạt động chờ nguyên tử (tức là.<code>wait()</code>) TRÊN<code>*this</code>, nếu có bất kỳ; nếu không thì không có gì.</p>
</div> <h3 id="Member_constants">Inline Consexpr bool is_execut_policy_v = std :: is_execut_policy &lt;t&gt; :: value;</h3> <p>Ghi chú: Hai<code><a href="../../atomic/atomic" title="cpp/atomic/atomic">std::atomic</a></code>S là tương đương nếu chúng lưu trữ cùng một con trỏ và chia sẻ quyền sở hữu hoặc cả hai đều trống.<code>is_always_lock_free</code>Nguyên tử &lt;Shared_ptr &lt;T &gt;&gt; :: Thông báo_one</p>
<div class="t-member"> <h2 id="atomic.3Cweak_ptr.3CT.3E.3E::is_always_lock_free">lưu trữ cùng giá trị con trỏ như</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">constic static bool is_always_lock_free = /*do thực hiện xác định* /;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> </div> <h3 id="Example">Ví dụ</h3> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../../atomic/atomic" title="cpp/atomic/atomic"> <span class="t-lines"><span>nguyên tử</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>Mẫu lớp nguyên tử và các chuyên ngành cho bool, tích phân,<span class="t-rev-inl t-since-cxx20"><span>điểm nổi,</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>và loại con trỏ<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/memory/weak_ptr/atomic2">https://en.cppreference.com/w/cpp/memory/weak_ptr/atomic2</a>
</p>
</div>
