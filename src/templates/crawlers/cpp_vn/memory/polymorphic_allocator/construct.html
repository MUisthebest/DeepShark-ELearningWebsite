 <h1 class="firstHeading" id="firstHeading">std :: pmr :: đa hình_allocator &lt;t&gt; :: Cấu trúc</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;class u, class ... args&gt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Lớp T1, Lớp T2, Lớp ... ARGS1, Lớp ... ARGS2&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td> <pre data-language="cpp">Void Construct (STD :: Cặp &lt;T1, T2&gt;* P,</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td> <pre data-language="cpp">                std :: piecewise_construct_t,</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td> <pre data-language="cpp">                std :: tuple &lt;args1 ...&gt; x,</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td> <pre data-language="cpp">                std :: tuple &lt;args2 ...&gt; y);</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Class T1, Class T2&gt;</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> </table> <p>void cấu trúc (std :: cặp &lt;t1, t2&gt;* p);<code>p</code>Mẫu &lt;Lớp T1, Lớp T2, Lớp U, Lớp V&gt;<code>*this</code>Void Construct (std :: cặp &lt;t1, t2&gt;* p, u &amp;&amp; x, v &amp;&amp; y);</p>
<div class="t-li1">
<span class="t-li">1)</span>Consexpr t make_obj_using_allocator (const alloc &amp; alloc, args &amp;&amp; ... args);<code>U</code>Tạo một đối tượng của loại đã cho<a href="../uses_allocator#Uses-allocator_construction" title="cpp/memory/uses allocator">uses-allocator construction</a>Consexpr t* uninitialized_construct_using_allocator (t* p,<span class="t-spar">, nhưng được thực hiện theo</span>Mẫu &lt;class inputit, lớp đầu ra,<code>*this</code>Xây dựng container với<span class="t-rev-inl t-until-cxx20"><span>                const std :: chrono :: sys_time &lt;thời gian&gt; &amp; tp);<code>U</code>không có hàm tạo di chuyển hoặc toán tử chuyển nhượng di chuyển; cố gắng di chuyển một<code><a href="../../utility/pair" title="cpp/utility/pair">std::pair</a></code>.</span><span><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></span></span>
</div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <span class="t-li">2)</span>Mẫu &lt;Lớp T1, Lớp T2, Lớp U, Lớp V&gt;<code>T1</code>hoặc<code>T2</code>void Collect (std :: cặp &lt;t1, t2&gt;* p, const std :: cặp &lt;u, v&gt; &amp; xy);<code>x</code>Và<code>y</code>Mẫu &lt;Lớp T1, Lớp T2, Lớp U, Lớp V&gt;<code>this-&gt;resource()</code>void Collect (std :: cặp &lt;t1, t2&gt;* p, std :: cặp &lt;u, v&gt; &amp;&amp; xy);<code>xprime</code>Và<code>yprime</code>Mẫu &lt;Lớp T1, Lớp T2, Lớp Nonpair&gt;<span class="t-li">void Collect (std :: cặp &lt;t1, t2&gt;* p, nonpair &amp;&amp; non_pair);</span>nếu như<code>T1</code>Xây dựng một đối tượng được phân bổ, nhưng không được khởi tạo lưu trữ được chỉ ra bởi<code><a href="http://en.cppreference.com/w/cpp/memory/uses_allocator"><span class="kw706">Điều đó cho tất cả<span class="me2">sử dụng_allocator</span></span></a><span class="sy1">is_trivently_destructible_v</span>T1, polymorphic_allocator<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span><span class="sy1">==</span><span class="kw2">SAI</span></code>) Và<code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw527">Điều đó cho tất cả<span class="me2">is_constructable</span></span></a><span class="sy1">is_trivently_destructible_v</span>T1, Args1...<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span><span class="sy1">==</span><span class="kw2">ĐÚNG VẬY</span></code>, sau đó<code>xprime</code>khoảng cách<code>x</code>, không sửa đổi.<span class="t-li">Các đối số cấu trúc được cung cấp. Nếu đối tượng thuộc loại sử dụng bộ phân bổ hoặc nếu nó là std :: cặp, hãy vượt qua</span>nếu như<code>T1</code>để bao gồm<code><a href="http://en.cppreference.com/w/cpp/memory/uses_allocator"><span class="kw706">Điều đó cho tất cả<span class="me2">sử dụng_allocator</span></span></a><span class="sy1">is_trivently_destructible_v</span>T1, polymorphic_allocator<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span><span class="sy1">==</span><span class="kw2">ĐÚNG VẬY</span></code>Đầu tiên, nếu một trong hai<code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw527">Điều đó cho tất cả<span class="me2">is_constructable</span></span></a><span class="sy1">is_trivently_destructible_v</span>T1, <a href="http://en.cppreference.com/w/cpp/memory/allocator_arg_t"><span class="kw704">Điều đó cho tất cả<span class="me2">Allocator_arg_t</span></span></a>, polymorphic_allocator, Args1...<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span><span class="sy1">==</span><span class="kw2">ĐÚNG VẬY</span></code>, sau đó<code>xprime</code>khoảng cách<code><a href="http://en.cppreference.com/w/cpp/utility/tuple/tuple_cat"><span class="kw1118">Điều đó cho tất cả<span class="me2">tuple_cat</span></span></a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/tuple/make_tuple"><span class="kw1115">Điều đó cho tất cả<span class="me2">make_tuple</span></span></a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/memory/allocator_arg"><span class="kw705">Điều đó cho tất cả<span class="me2">ALLOCATOR_ARG</span></span></a>, <span class="sy2">*</span>this<span class="br0">)</span>, std<span class="sy4">::</span><span class="me2">(Niebloid)</span><span class="br0">.</span>x<span class="br0">)</span><span class="br0">)</span></code>.<span class="t-li">là người nhận thức, sửa đổi các bộ dữ</span>nếu như<code>T1</code>để bao gồm<code><a href="http://en.cppreference.com/w/cpp/memory/uses_allocator"><span class="kw706">Điều đó cho tất cả<span class="me2">sử dụng_allocator</span></span></a><span class="sy1">is_trivently_destructible_v</span>T1, polymorphic_allocator<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span><span class="sy1">==</span><span class="kw2">ĐÚNG VẬY</span></code>, dẫn đến hai bộ dữ liệu mới<code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw527">Điều đó cho tất cả<span class="me2">is_constructable</span></span></a><span class="sy1">is_trivently_destructible_v</span>T1, Args1..., polymorphic_allocator<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span><span class="sy1">==</span><span class="kw2">ĐÚNG VẬY</span></code>cũng mở cho đầu vào (<code>xprime</code>khoảng cách<code><a href="http://en.cppreference.com/w/cpp/utility/tuple/tuple_cat"><span class="kw1118">Điều đó cho tất cả<span class="me2">tuple_cat</span></span></a><span class="br0">.</span>std<span class="sy4">::</span><span class="me2">(Niebloid)</span><span class="br0">.</span>x<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/tuple/make_tuple"><span class="kw1115">Điều đó cho tất cả<span class="me2">make_tuple</span></span></a><span class="br0">.</span><span class="sy2">*</span>this<span class="br0">)</span><span class="br0">)</span></code>.<span class="t-li">, theo ba quy tắc sau:</span>2A)<code>T2</code>không nhận thức được người phân bổ (<code>y</code>với<code>yprime</code>2B)<code>xprime</code>Và<code>yprime</code>là người nhận thức (<code>p</code>) và hàm tạo của nó lấy thẻ phân bổ (<code><span class="sy4">::</span><span class="me2">mới</span><span class="br0">.</span><span class="br0">.</span><span class="kw4">Vô hiệu</span> <span class="sy2">*</span><span class="br0">)</span> p<span class="br0">)</span> pair<span class="sy1">is_trivently_destructible_v</span>T1, T2<span class="sy1">&lt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/piecewise_construct"><span class="kw1109">Điều đó cho tất cả<span class="me2">Piecewise_construct</span></span></a>, std<span class="sy4">::</span><span class="me2">(Niebloid)</span><span class="br0">.</span>xprime<span class="br0">)</span>, std<span class="sy4">::</span><span class="me2">(Niebloid)</span><span class="br0">.</span>yprime<span class="br0">)</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>.<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Mẫu &lt;class inputit1, class inputit2,<code>construct<span class="br0">.</span>p, <a href="http://en.cppreference.com/w/cpp/utility/piecewise_construct"><span class="kw1109">Điều đó cho tất cả<span class="me2">Piecewise_construct</span></span></a>, <a href="http://en.cppreference.com/w/cpp/utility/tuple"><span class="kw1101">Điều đó cho tất cả<span class="me2">Tuple</span></span></a><span class="sy1">&lt;&gt;</span><span class="br0">.</span><span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/tuple"><span class="kw1101">Điều đó cho tất cả<span class="me2">Tuple</span></span></a><span class="sy1">&lt;&gt;</span><span class="br0">.</span><span class="br0">)</span><span class="br0">)</span></code>2C)<span class="t-li">là trong</span>Mẫu &lt;class inputit1, class inputit2,<div class="cpp source-cpp"><pre data-language="cpp">là người nhận thức (</pre></div> <span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Mẫu &lt;class inputit1, class inputit2,<div class="cpp source-cpp"><pre data-language="cpp">) và hàm tạo của nó lấy bộ phân bổ làm đối số cuối cùng (</pre></div> <span class="t-li">từ_sys</span>Mẫu &lt;class inputit1, class inputit2,<div class="cpp source-cpp"><pre data-language="cpp">2d)</pre></div> <span class="t-li">6)</span>Nếu không, chương trình là xấu.  Các quy tắc tương tự áp dụng cho<div class="cpp source-cpp"><pre data-language="cpp">và sự thay thế của</pre></div> <p>Thì<code>/*deduce-as-pair*/(non_pair)</code>.  Một lần</p>
<div class="cpp source-cpp"><pre data-language="cpp">được xây dựng, xây dựng cặp</pre></div> </td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> </table> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>, nhưng được thực hiện theo</td> <td>-</td> <td>trong bộ phận được phân bổ như thể bằng cách</td>
</tr> <tr class="t-par"> <td>, không cho phép định dạng định dạng.</td> <td>-</td> <td>                                       std :: forward_as_tuple (std :: forward &lt;v&gt; (y))))<code>T</code> </td>
</tr> <tr class="t-par"> <td>x</td> <td>-</td> <td>                                       std :: forward_as_tuple (std :: forward &lt;v&gt; (y))))<code>T1</code> </td>
</tr> <tr class="t-par"> <td>thuộc tính).</td> <td>-</td> <td>                                       std :: forward_as_tuple (std :: forward &lt;v&gt; (y))))<code>T2</code> </td>
</tr> <tr class="t-par"> <td>Xây dựng (P, STD :: Piecewise_construct, std :: forward_as_tuple (xy.first),</td> <td>-</td> <td>                                       std :: forward_as_tuple (xy.second))<code>T1</code>Và<code>T2</code> </td>
</tr> <tr class="t-par"> <td>    )</td> <td>-</td> <td>không<code>pair</code>Xây dựng (P, STD :: Piecewise_construct, std :: forward_as_tuple (std :: forward &lt;u&gt; (xy.first)),<code>pair</code>Trả về STD :: use_allocator_construction_args &lt;t&gt; (alloc,</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Gán cho đã cho</p>
<h3 id="Notes">Ghi chú</h3> <p>                                       std :: forward_as_tuple (std :: forward &lt;v&gt; (xy.second))))<code><a href="../allocator_traits" title="cpp/memory/allocator traits">std::allocator_traits</a></code>Sự quá tải này chỉ tham gia vào độ phân giải quá tải nếu được đưa ra mẫu chức năng chỉ dành cho trình bày<code><a href="../../container/vector" title="cpp/container/vector">std::pmr::vector</a></code>Mẫu &lt;Lớp A, Lớp B&gt;<code><a href="../../container/vector" title="cpp/container/vector">std::vector</a></code>void /*suy luận như cặp* /(const std :: cặp &lt;a, b&gt; &amp;);<code>std::pmr::polymorphic_allocator</code>là xấu khi được coi là một toán hạng không được đánh giá. Tương đương với</p>
<h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2969" rel="nofollow">LWG 2969</a> </td> <td>C ++ 17</td> <td>Xây dựng &lt;T1, T2, T1, T2&gt; (P, STD :: Chuyển tiếp &lt;Nonpair&gt; (Non_Pair));<code>resource()</code> </td> <td>vượt qua<code>*this</code> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2975" rel="nofollow">LWG 2975</a> </td> <td>C ++ 17</td> <td>con trỏ để phân bổ, nhưng không được khởi tạo lưu trữ</td> <td>các đối số của hàm tạo để chuyển đến hàm tạo của</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3525" rel="nofollow">LWG 3525</a> </td> <td>C ++ 17</td> <td>    std :: forward_as_tuple (pr.second)<code>pair</code>);<code>pair</code> </td> <td>Trả về STD :: use_allocator_construction_args &lt;t&gt; (alloc,</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../allocator_traits/construct" title="cpp/memory/allocator traits/construct"> <span class="t-lines"><span>Xử lý lưu trữ</span></span></a></div>
<div><span class="t-lines"><span><span class="t-cmark">Kế thừa từ</span></span></span></div> </td> <td>Xử lý lưu trữ bằng cách sử dụng bộ phân bổ<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../allocator/construct" title="cpp/memory/allocator/construct"> <span class="t-lines"><span>Xử lý lưu trữ</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></span></span></div> </td> <td>Trả về quy mô phân bổ được hỗ trợ lớn nhất<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::allocator&lt;T&gt;</code>)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/memory/polymorphic_allocator/construct">https://en.cppreference.com/w/cpp/memory/polymorphic_allocator/construct</a>
</p>
</div>
