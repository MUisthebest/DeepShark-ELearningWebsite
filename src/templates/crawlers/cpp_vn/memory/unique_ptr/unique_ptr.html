 <h1 class="firstHeading" id="firstHeading">STD :: độc đáo_ptr &lt;t, deleter&gt; :: độc đáo_ptr</h1> <table class="t-dcl-begin"> <tr class="t-dcl-h"> <td>Các thành viên của mẫu chính, độc đáo_ptr &lt;t&gt;</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Mẫu &lt;class u&gt;</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">constexpr độc đáo_ptr (std :: nullptr_t) noexcept;</pre>
</td> <td>(2)</td> <td> <span class="t-mark">(Constexpr kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">rõ ràng độc đáo_ptr (con trỏ p) noExcept;</pre>
</td> <td>(3)</td> <td> <span class="t-mark">(Constexpr kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">độc đáo_ptr (con trỏ p, / * xem bên dưới * / d1) noExcept;</pre>
</td> <td>(4)</td> <td> <span class="t-mark">(Constexpr kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">constexpr độc đáo_ptr (std :: nullptr_t) noexcept;</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark">(Constexpr kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">mẫu &lt;class u&gt; icial_ptr (u p) nOExcept;</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark">(Constexpr kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">mẫu &lt;class u&gt; độc đáo_ptr (u p, / * xem bên dưới * / d1) noExcept;</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-until-cxx17"> <td> <pre data-language="cpp">độc đáo_ptr (độc đáo_ptr &lt;u, e&gt; &amp;&amp; u) noExcept;</pre>
</td> <td>            Nhị phân p);</td> <td> <span class="t-mark-rev t-until-cxx17">(Đã xóa trong C ++ 17)</span> </td> </tr> <tr class="t-dcl-h"> <td>độc đáo_ptr (const độc đáo_ptr &amp;) = xóa;</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Mẫu &lt;class u&gt;</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">độc đáo_ptr (std :: auto_ptr &lt;u&gt; &amp;&amp; u) noExcept;</pre>
</td> <td>(2)</td> <td> <span class="t-mark">(Constexpr kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Các thành viên của chuyên ngành cho mảng, độc đáo_ptr &lt;t []&gt;</pre>
</td> <td>(3)</td> <td> <span class="t-mark">(Constexpr kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">constexpr độc đáo_ptr () noexcept;</pre>
</td> <td>(4)</td> <td> <span class="t-mark">(Constexpr kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">constexpr độc đáo_ptr (std :: nullptr_t) noexcept;</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark">(Constexpr kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">mẫu &lt;class u&gt; icial_ptr (u p) nOExcept;</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark">(Constexpr kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">mẫu &lt;class u&gt; độc đáo_ptr (u p, / * xem bên dưới * / d1) noExcept;</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td class="t-dcl-nopad"> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>std::unique_ptr</code>mẫu &lt;class u&gt; độc đáo_ptr (u p, / * xem bên dưới * / d2) noExcept;<code>Deleter</code>khoảng cách<a href="../../named_req/defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a>độc đáo_ptr (độc đáo_ptr &amp;&amp; u) noExcept;<code><a href="http://en.cppreference.com/w/cpp/types/is_default_constructible"><span class="kw533">Điều đó cho tất cả<span class="me2">is_default_constructible</span></span></a><span class="sy1">is_trivently_destructible_v</span>Deleter<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span></code>khoảng cách<code>true</code>Và<code>Deleter</code>không phải là một loại con trỏ.</div> <div class="t-li1">
<span class="t-li">2)</span>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>std::unique_ptr</code>Mẫu &lt;class u, class E&gt;<code>p</code>, khởi tạo con trỏ được lưu trữ với<code>p</code>độc đáo_ptr (const độc đáo_ptr &amp;) = xóa;<code>Deleter</code>khoảng cách<a href="../../named_req/defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a>mà không sở hữu gì. Giá trị-khởi tạo các con trỏ được lưu trữ và Deleter được lưu trữ. Yêu cầu điều đó<code><a href="http://en.cppreference.com/w/cpp/types/is_default_constructible"><span class="kw533">Điều đó cho tất cả<span class="me2">is_default_constructible</span></span></a><span class="sy1">is_trivently_destructible_v</span>Deleter<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span></code>khoảng cách<code>true</code>Và<code>Deleter</code>không phải là một loại con trỏ.<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>Và việc xây dựng đó không ném một ngoại lệ. Những quá tải này chỉ tham gia vào độ phân giải quá tải nếu<a href="../../language/class_template_argument_deduction" title="cpp/language/class template argument deduction">class template argument deduction</a>.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table>
</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>std::unique_ptr</code>mà sở hữu<code>p</code>, khởi tạo con trỏ được lưu trữ với<code>p</code>và giá trị khởi tạo các lần phân phối được lưu trữ. Yêu cầu điều đó<code>D</code>Và việc xây dựng đó không ném một ngoại lệ. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu<code>D</code>Hàm tạo này không được chọn bởi</div> <div class="t-li2">
<span class="t-li">}</span>Nếu như<code>D</code>đối tượng sở hữu<code>A</code>là một loại tham chiếu lvalue<table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">, sau đó các chữ ký là:</pre>
</td> <td>(1)</td> <td>, sau đó các chữ ký là:<code>Deleter</code>độc đáo_ptr (con trỏ p, const a &amp; d) noExcept;<a href="../../named_req/copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>)</td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">là loại không tham chiếu</pre>
</td> <td>(2)</td> <td>, sau đó các chữ ký là:<code>Deleter</code>độc đáo_ptr (con trỏ p, const a &amp; d) noExcept;<a href="../../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>)</td> </tr> </table>
</div> <div class="t-li2">
<span class="t-li">{</span>Nếu như<code>D</code>không phải là<code>A&amp;</code>là một loại tham chiếu lvalue<table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">độc đáo_ptr (con trỏ p, a &amp;&amp; d) noExcept;</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">(Yêu cầu điều đó</pre>
</td> <td>(2)</td> <td class="t-dcl-nopad"> </td> </tr> </table>
</div> <div class="t-li2">
<span class="t-li">}</span>Nếu như<code>D</code>không phải là<code>const A&amp;</code>là một loại tham chiếu lvalue<table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">, sau đó các chữ ký là:</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">độc đáo_ptr (con trỏ p, a &amp; d) noExcept;</pre>
</td> <td>(2)</td> <td class="t-dcl-nopad"> </td> </tr> </table>
</div> <div class="t-li1">độc đáo_ptr (con trỏ p, a &amp;&amp; d) = xóa;<code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>decltype<span class="br0">.</span>d<span class="br0">)</span><span class="sy1">&lt;</span><span class="br0">.</span>d<span class="br0">)</span></code>Thời lượng &lt;Typename std :: Common_Type &lt;rep1, rep2&gt; :: type, giai đoạn&gt;<code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw527">Điều đó cho tất cả<span class="me2">is_constructable</span></span></a><span class="sy1">is_trivently_destructible_v</span>D, decltype<span class="br0">.</span>d<span class="br0">)</span><span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span></code>khoảng cách<code>true</code>.<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>là một loại tham chiếu lvalue<a href="../../language/class_template_argument_deduction" title="cpp/language/class template argument deduction">class template argument deduction</a>.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table>
</div> <span class="t-li">    const std :: chrono :: giây* offset;     // Chỉ giải thích</span>, sau đó các chữ ký là:<ul>
<li> <code>U</code>thành viên<code>pointer</code>, hoặc</li>
<li> <code>U</code>khoảng cách<code><a href="../../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code>, hoặc</li>
<li> <code>pointer</code>thành viên<code>element_type*</code>Và<code>U</code>độc đáo_ptr (con trỏ p, const a &amp; d) noExcept;<code>V*</code>chỉ vào trình tự và mọi số nguyên không âm<code>V(*)[]</code>. Hàm tạo này chỉ tham gia vào độ phân giải quá tải nếu<code>element_type(*)[]</code>.</li>
</ul> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>unique_ptr</code>bằng cách chuyển quyền sở hữu từ<code>u</code>ĐẾN<code>*this</code>Trong mọi trường hợp, Deleter được khởi tạo từ<code>u</code>bằng cách chuyển đổi<code><a href="http://en.cppreference.com/w/cpp/types/is_move_constructible"><span class="kw545">Điều đó cho tất cả<span class="me2">is_move_constructable</span></span></a><span class="sy1">is_trivently_destructible_v</span>Deleter<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span></code>khoảng cách<code>true</code>. Nếu như<code>Deleter</code>Hai hàm tạo này không được chọn bởi<a href="../../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a> <code>Deleter</code>Trong chuyên môn hóa các mảng hoạt động giống như các hàm tạo lấy tham số con trỏ trong mẫu chính ngoại trừ việc chúng không tham gia vào độ phân giải quá tải trừ khi một trong những điều sau đây là đúng:<code>get_deleter()</code>Và<code>u.get_deleter()</code>là một số loại con trỏ</div> <div class="t-li1">
<span class="t-li">từ_sys</span>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>unique_ptr</code>bằng cách chuyển quyền sở hữu từ<code>u</code>ĐẾN<code>*this</code>là<code>u</code>và lưu trữ con trỏ null trong<code>E</code>không phải là loại tham chiếu, yêu cầu nó không phải là<code>E</code>là một tài liệu tham khảo,</div> <div class="t-li2">
<span class="t-li">}</span>nếu như<code>E</code>Sau khi di chuyển tham chiếu xây dựng cùng một giá trị).<code>u</code>bằng cách chuyển quyền sở hữu từ</div> <div class="t-li2">
<span class="t-li">{</span>nếu như<code>E</code>được xây dựng với một bản phân phối được chỉ định (<code>u</code>). Nó phụ thuộc vào việc</div> <div class="t-li1">là loại tham chiếu, như sau:</div> <div class="t-li2">
<span class="t-li">}</span> <code>unique_ptr&lt;U, E&gt;::pointer</code>. Hàm tạo này chỉ tham gia vào độ phân giải quá tải nếu<code>pointer</code>Thì</div> <div class="t-li2">
<span class="t-li">{</span>là loại tham chiếu, bản phân phối này được xây dựng từ</div> <div class="t-li2">
<span class="t-li">}</span>nhiều nhất là một chuyển đổi đủ điều kiện, và<code>Deleter</code>Trình xây dựng này chỉ tham gia vào độ phân giải quá tải nếu tất cả các điều sau đây là đúng:<code>E</code>thành viên<code>D</code>, hoặc<code>Deleter</code>U không phải là loại mảng,<code>E</code>. Hàm tạo này chỉ tham gia vào độ phân giải quá tải nếu<code>D</code>.</div> <span class="t-li">từ_sys</span>Deleter (yêu cầu công trình này không ném).<ul>
<li> <code>U</code>là một loại mảng,</li>
<li> <code>pointer</code>thành viên<code>element_type*</code>Thì</li>
<li> <code>unique_ptr&lt;U,E&gt;::pointer</code>thành viên<code>unique_ptr&lt;U,E&gt;::element_type*</code>Thì</li>
<li> <code>unique_ptr&lt;U,E&gt;::element_type(*)[]</code>Chuyển đổi hai thời lượng thành loại chung của chúng và tạo ra một thời lượng mà số lượng đánh dấu là tổng số lượng đánh dấu sau khi chuyển đổi.<code>element_type(*)[]</code>Thì</li>
<li>nhiều nhất là một chuyển đổi đủ điều kiện, và<code>Deleter</code>Trình xây dựng này chỉ tham gia vào độ phân giải quá tải nếu tất cả các điều sau đây là đúng:<code>E</code>thành viên<code>Deleter</code>, hoặc<code>Deleter</code>U không phải là loại mảng,<code>E</code>. Hàm tạo này chỉ tham gia vào độ phân giải quá tải nếu<code>Deleter</code>.</li>
</ul> <div class="t-li1">
<span class="t-li">6)</span>Sao chép Constructor bị xóa rõ ràng.</div> <div class="t-li1">
<span class="t-li">. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu biểu thức</span>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>unique_ptr</code>là một loại tham chiếu và<a href="../auto_ptr/release" title="cpp/memory/auto ptr/release"><code>u.release()</code></a>không phải là loại tham chiếu và<code>U*</code>. Hàm tạo này chỉ tham gia vào độ phân giải quá tải nếu<code>T*</code>Và<code>Deleter</code>thành viên<code><a href="http://en.cppreference.com/w/cpp/memory/default_delete"><span class="kw748">Điều đó cho tất cả<span class="me2">Default_delete</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>.</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>, nhưng được thực hiện theo</td> <td>-</td> <td>Loại này. Việc triển khai được phép cung cấp cho mẫu một tên khác hoặc thực hiện chức năng tương đương theo các cách khác.</td>
</tr> <tr class="t-par"> <td>Trong chuyên môn hóa các mảng hoạt động giống như trong mẫu chính, ngoại trừ việc nó sẽ chỉ tham gia vào độ phân giải quá tải nếu tất cả các điều sau đây là đúng:</td> <td>-</td> <td>. Deleter liên quan đến</td>
</tr> <tr class="t-par"> <td>                       std :: chuyển tiếp &lt;declType (args1)&gt; (args1) ...);</td> <td>-</td> <td>là một loại tham chiếu và</td>
</tr>
</table> <h3 id="Notes">Ghi chú</h3> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>không phải là loại tham chiếu và<span class="t-v">(2)</span>trong đó con trỏ được lưu trữ được khởi tạo với<code><a href="make_unique" title="cpp/memory/unique ptr/make unique">std::make_unique&lt;T&gt;</a></code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></td>
</tr> </table> <p><code><a href="http://en.cppreference.com/w/cpp/memory/unique_ptr"><span class="kw735">Điều đó cho tất cả<span class="me2">độc đáo_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>Derived<span class="sy1">&lt;</span></code>. Hàm tạo này chỉ tham gia vào độ phân giải quá tải nếu<code><a href="http://en.cppreference.com/w/cpp/memory/unique_ptr"><span class="kw735">Điều đó cho tất cả<span class="me2">độc đáo_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>Base<span class="sy1">&lt;</span></code>và Deleter được lưu trữ được khởi tạo giá trị. Hàm tạo này chỉ tham gia vào độ phân giải quá tải nếu<span class="t-v">Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</span>D1, D2<code><a href="../default_delete" title="cpp/memory/default delete">std::default_delete</a></code>một con trỏ thông minh khác để có được quyền sở hữu từ</p>
<p>với con trỏ được trả lại bởi<code>constexpr</code>Thay vì sử dụng quá tải<a href="../../language/initialization#Non-local_variables" title="cpp/language/initialization">static non-local initialization</a>Cùng với mới, nó thường là một ý tưởng tốt hơn để sử dụng</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>thông qua quá tải<a href="../../language/class_template_argument_deduction" title="cpp/language/class template argument deduction">class template argument deduction</a>(bởi vì cả con trỏ được quản lý và<code>new</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">được chuyển đổi hoàn toàn).</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">, tĩnh độc đáo_ptrs được khởi tạo như một phần của</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2118" rel="nofollow">LWG 2118</a> </td> <td>C ++ 11</td> <td>, trước khi bất kỳ khởi tạo phi địa phương nào bắt đầu. Điều này giúp an toàn khi sử dụng độc đáo trong một hàm tạo của bất kỳ đối tượng tĩnh nào.<code>unique_ptr&lt;T[]&gt;</code>Không có</td> <td>từ loại con trỏ vì không thể phân biệt được một con trỏ thu được với các dạng mảng và không phải</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2520" rel="nofollow">LWG 2520</a> </td> <td>C ++ 11</td> <td>
<code>unique_ptr&lt;T[]&gt;</code>#include &lt;Istream&gt;<code>nullptr_t</code>.</td> <td>#include &lt;nhớ&gt;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2801" rel="nofollow">LWG 2801</a> </td> <td>C ++ 11</td> <td> </td> <td>    Foo () {std :: cout &lt;&lt; "foo ctor \ n"; }</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2899" rel="nofollow">LWG 2899</a> </td> <td>C ++ 11</td> <td>{</td> <td>    Foo () {std :: cout &lt;&lt; "foo ctor \ n"; }</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2905" rel="nofollow">LWG 2905</a> </td> <td>C ++ 11</td> <td>    Foo (const foo &amp;) {std :: cout &lt;&lt; "foo sao chép ctor \ n"; }</td> <td>    Foo (foo &amp;&amp;) {std :: cout &lt;&lt; "foo di chuyển ctor \ n"; }</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2944" rel="nofollow">LWG 2944</a> </td> <td>C ++ 11</td> <td>    ~ Foo () {std :: cout &lt;&lt; "~ foo dtor \ n"; }</td> <td>};</td>
</tr>
</table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/memory/unique_ptr/unique_ptr">https://en.cppreference.com/w/cpp/memory/unique_ptr/unique_ptr</a>
</p>
</div>
