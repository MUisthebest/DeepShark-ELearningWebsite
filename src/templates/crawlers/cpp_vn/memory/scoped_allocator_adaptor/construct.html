 <h1 class="firstHeading" id="firstHeading">std :: scoped_allocator_adaptor &lt;outeralloc, inneralloc ...&gt; :: xây dựng</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/scoped_allocator" title="cpp/header/scoped allocator">&lt;scoped_allocator&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Mẫu &lt;class t, class ... args&gt;</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-until-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Lớp T1, Lớp T2, Lớp ... ARGS1, Lớp ... ARGS2&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> <tr class="t-dcl t-until-cxx20"> <td> <pre data-language="cpp">Void Construct (STD :: Cặp &lt;T1, T2&gt;* P,</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> <tr class="t-dcl t-until-cxx20"> <td> <pre data-language="cpp">                std :: piecewise_construct_t,</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> <tr class="t-dcl t-until-cxx20"> <td> <pre data-language="cpp">                std :: tuple &lt;args1 ...&gt; x,</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> <tr class="t-dcl t-until-cxx20"> <td> <pre data-language="cpp">                std :: tuple &lt;args2 ...&gt; y);</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> <tr class="t-dcl t-until-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Class T1, Class T2&gt;</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td> <span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> </table> <p>void cấu trúc (std :: cặp &lt;t1, t2&gt;* p);<code>p</code>void cấu trúc (t* p, args &amp;&amp; ... args);</p>
<p>Sử dụng Outerallocator và các đối số cấu trúc được cung cấp. Nếu đối tượng thuộc loại sử dụng các trình phân bổ hoặc nếu nó là STD :: Cặp, hãy truyền bên trong xuống đối tượng được xây dựng.<code><i>Bên ngoài_ALLOC_TRAITS</i></code>. Sau khi xây dựng và kiểm tra đối tượng Sentry, có thể bỏ qua khoảng trắng hàng đầu, trích xuất một<code>this-&gt;outer_allocator()</code>Ngoài cùng<code>outer_allocator()</code>, và sau đó gọi</p>
<p>Hàm thành viên đệ quy về kết quả của cuộc gọi này cho đến khi đạt được một người phân bổ không có chức năng thành viên như vậy.<code><i>Newarss</i></code><span class="br0">.</span>x<span class="br0">)</span>(1,3)<code><a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>decltype<span class="br0">.</span>OUTERMOST<span class="br0">.</span>x<span class="br0">)</span><span class="br0">)</span><span class="sy1">2,4)</span></code></p>
<div class="t-li1">
<span class="t-li">1)</span>Consexpr t make_obj_using_allocator (const alloc &amp; alloc, args &amp;&amp; ... args);<code>T</code>Tạo một đối tượng của loại đã cho<a href="../uses_allocator#Uses-allocator_construction" title="cpp/memory/uses allocator">uses-allocator construction</a>Consexpr t* uninitialized_construct_using_allocator (t* p,<span class="t-spar">, nhưng được thực hiện theo</span>Mẫu &lt;class inputit, lớp đầu ra,<code><i>Bên ngoài_ALLOC_TRAITS</i></code>Ngoài cùng<code>OUTERMOST_ALLOC_TRAITS(*this)::construct</code>.</div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td>                const std :: chrono :: sys_time &lt;thời gian&gt; &amp; tp);<code>U</code>không có hàm tạo di chuyển hoặc toán tử chuyển nhượng di chuyển; cố gắng di chuyển một<code><a href="../../utility/pair" title="cpp/utility/pair">std::pair</a></code>.</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td>Mẫu &lt;class inputit1, class inputit2,<br/><code><a href="http://en.cppreference.com/w/cpp/utility/apply"><span class="kw1106">Điều đó cho tất cả<span class="me2">áp dụng</span></span></a><span class="br0">.</span><br/> <p><span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span>Là người phân bổ. Sau khi điều chỉnh cho quy ước sử dụng-ngôn luận được dự kiến ​​bởi hàm tạo của T, các cuộc gọi<span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span><span class="br0">.</span><span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span><span class="sy3">. Trong các cuộc gọi có hiệu lực</span>...<span class="me1">Newarss</span><span class="br0">)</span><br/> <span class="br0">danh tính</span><br/>Newarss<span class="br0">.</span><span class="sy2">*</span>cái này<span class="br0">)</span><span class="sy4">::</span><span class="me2">Xử lý lưu trữ</span><span class="br0">.</span><br/>Bên ngoài_ALLOC_TRAITS<span class="br0">.</span><span class="sy2">*</span>cái này<span class="br0">)</span>Ngoài cùng<a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Tuy nhiên, các thuộc tính xuất hiện sau khi khai báo (trong cú pháp trên), áp dụng cho loại hàm, không phải cho chính chức năng:<span class="br0">.</span>Newarss<span class="br0">)</span><span class="sy1">&lt;</span><span class="br0">.</span>Newarss<span class="br0">)</span>...<span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span><br/> <span class="br0">{</span>Thì<br/> <a href="http://en.cppreference.com/w/cpp/memory/uses_allocator_construction_args"><span class="kw3271">Điều đó cho tất cả<span class="me2">sử dụng_allocator_construction_args</span></span></a><span class="br0">.</span><br/>Tạo một phiên bản mới scoped_allocator_adaptor<span class="br0">.</span><span class="br0">)</span>Thì<br/> <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Loại trở lại của coroutine<span class="sy1">&lt;</span><span class="br0">.</span>iterator trước đó phần tử mới sẽ được xây dựng<span class="br0">)</span>...<br/> <span class="br0">)</span><br/> <span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></p></code> </td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <span class="t-li">2)</span>Mẫu &lt;Lớp T1, Lớp T2, Lớp U, Lớp V&gt;<code>T1</code>hoặc<code>T2</code>void Collect (std :: cặp &lt;t1, t2&gt;* p, const std :: cặp &lt;u, v&gt; &amp; xy);<code>x</code>Và<code>y</code>Newarss<code>xprime</code>Và<code>yprime</code>Mẫu &lt;Lớp T1, Lớp T2, Lớp Nonpair&gt;<span class="t-li">void Collect (std :: cặp &lt;t1, t2&gt;* p, nonpair &amp;&amp; non_pair);</span>nếu như<code>T1</code>Để bao gồm bộ phân bổ bên trong thích hợp, dẫn đến hai bộ dữ liệu mới<br/>.<code><a href="http://en.cppreference.com/w/cpp/memory/uses_allocator"><span class="kw706">Điều đó cho tất cả<span class="me2">sử dụng_allocator</span></span></a><span class="sy1">is_trivently_destructible_v</span>T1, inner_allocator_type<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span> <span class="sy1">==</span> <span class="kw2">SAI</span></code>cũng mở cho đầu vào (<code>xprime</code>khoảng cách<code><a href="http://en.cppreference.com/w/cpp/utility/tuple"><span class="kw1101">Điều đó cho tất cả<span class="me2">Tuple</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args1<span class="sy3">. Trong các cuộc gọi có hiệu lực</span>...<span class="sy1">&lt;</span><span class="br0">.</span>std<span class="sy4">::</span><span class="me2">(Niebloid)</span><span class="br0">.</span>x<span class="br0">)</span><span class="br0">)</span></code>không nhận thức được<code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw527">Điều đó cho tất cả<span class="me2">is_constructable</span></span></a><span class="sy1">is_trivently_destructible_v</span>T1, Args1...<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span> <span class="sy1">==</span> <span class="kw2">ĐÚNG VẬY</span></code>).<span class="t-li">Các đối số cấu trúc được cung cấp. Nếu đối tượng thuộc loại sử dụng bộ phân bổ hoặc nếu nó là std :: cặp, hãy vượt qua</span>nếu như<code>T1</code>để bao gồm<code><a href="http://en.cppreference.com/w/cpp/memory/uses_allocator"><span class="kw706">Điều đó cho tất cả<span class="me2">sử dụng_allocator</span></span></a><span class="sy1">is_trivently_destructible_v</span>T1, inner_allocator_type<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span> <span class="sy1">==</span> <span class="kw2">ĐÚNG VẬY</span></code>. (Cũng yêu cầu<br/> <p><code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw527">Điều đó cho tất cả<span class="me2">is_constructable</span></span></a><span class="sy1">is_trivently_destructible_v</span>T1, <a href="http://en.cppreference.com/w/cpp/memory/allocator_arg_t"><span class="kw704">Điều đó cho tất cả<span class="me2">Allocator_arg_t</span></span></a>,<br/> inner_allocator_type&amp;, Args1...&gt;::value == true</code>Thì<br/>phải ít nhất được đặt hàng một phần đối với<code>xprime</code>khoảng cách<br/> <code><a href="http://en.cppreference.com/w/cpp/utility/tuple/tuple_cat"><span class="kw1118">Điều đó cho tất cả<span class="me2">tuple_cat</span></span></a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/tuple"><span class="kw1101">Điều đó cho tất cả<span class="me2">Tuple</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/memory/allocator_arg_t"><span class="kw704">Điều đó cho tất cả<span class="me2">Allocator_arg_t</span></span></a>, inner_allocator_type<span class="sy3">Không có giá trị</span><span class="sy1">&lt;</span><span class="br0">.</span><br/> <a href="http://en.cppreference.com/w/cpp/memory/allocator_arg"><span class="kw705">Điều đó cho tất cả<span class="me2">ALLOCATOR_ARG</span></span></a>, inner_allocator<span class="br0">.</span><span class="br0">)</span><br/> ),<br/> <a href="http://en.cppreference.com/w/cpp/utility/tuple"><span class="kw1101">Điều đó cho tất cả<span class="me2">Tuple</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args1<span class="sy3">. Trong các cuộc gọi có hiệu lực</span>...<span class="sy1">&lt;</span><span class="br0">.</span>std<span class="sy4">::</span><span class="me2">(Niebloid)</span><span class="br0">.</span>x<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span></code></p>
<span class="t-li">là người nhận thức, sửa đổi các bộ dữ</span>nếu như<code>T1</code>để bao gồm<code><a href="http://en.cppreference.com/w/cpp/memory/uses_allocator"><span class="kw706">Điều đó cho tất cả<span class="me2">sử dụng_allocator</span></span></a><span class="sy1">is_trivently_destructible_v</span>T1, inner_allocator_type<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span> <span class="sy1">==</span> <span class="kw2">ĐÚNG VẬY</span></code>) và hàm tạo của nó lấy thẻ phân bổ<br/> <p><code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw527">Điều đó cho tất cả<span class="me2">is_constructable</span></span></a><span class="sy1">is_trivently_destructible_v</span>T1, Args1..., inner_allocator_type<span class="sy3">Không có giá trị</span><span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span> <span class="sy1">==</span> <span class="kw2">ĐÚNG VẬY</span></code>Thì<br/>phải ít nhất được đặt hàng một phần đối với<code>xprime</code>khoảng cách<br/> <code><a href="http://en.cppreference.com/w/cpp/utility/tuple/tuple_cat"><span class="kw1118">Điều đó cho tất cả<span class="me2">tuple_cat</span></span></a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/tuple"><span class="kw1101">Điều đó cho tất cả<span class="me2">Tuple</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args1<span class="sy3">. Trong các cuộc gọi có hiệu lực</span>...<span class="sy1">&lt;</span><span class="br0">.</span>std<span class="sy4">::</span><span class="me2">(Niebloid)</span><span class="br0">.</span>x<span class="br0">)</span><span class="br0">)</span>,<br/> <a href="http://en.cppreference.com/w/cpp/utility/tuple"><span class="kw1101">Điều đó cho tất cả<span class="me2">Tuple</span></span></a><span class="sy1">is_trivently_destructible_v</span>inner_allocator_type<span class="sy3">Không có giá trị</span><span class="sy1">&lt;</span><span class="br0">.</span>inner_allocator<span class="br0">.</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span></code>.</p>) và hàm tạo của nó lấy bộ phân bổ làm đối số cuối cùng<code>T2</code>không nhận thức được người phân bổ (<code>y</code>với<code>yprime</code>2B)<code>xprime</code>Và<code>yprime</code>là người nhận thức (<code>p</code>Các quy tắc tương tự áp dụng cho<br/> <code><a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span>O<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">Xử lý lưu trữ</span><span class="br0">.</span>OUTERMOST,<br/> p,<br/> <a href="http://en.cppreference.com/w/cpp/utility/piecewise_construct"><span class="kw1109">Điều đó cho tất cả<span class="me2">Piecewise_construct</span></span></a>,<br/> std::move(xprime),<br/> std::move(yprime));</code> <span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Mẫu &lt;class inputit1, class inputit2,<br/> <p><code>construct<span class="br0">.</span>p, <a href="http://en.cppreference.com/w/cpp/utility/piecewise_construct"><span class="kw1109">Điều đó cho tất cả<span class="me2">Piecewise_construct</span></span></a>, <a href="http://en.cppreference.com/w/cpp/utility/tuple"><span class="kw1101">Điều đó cho tất cả<span class="me2">Tuple</span></span></a><span class="sy1">&lt;&gt;</span><span class="br0">.</span><span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/tuple"><span class="kw1101">Điều đó cho tất cả<span class="me2">Tuple</span></span></a><span class="sy1">&lt;&gt;</span><span class="br0">.</span><span class="br0">)</span><span class="br0">)</span></code>trong bộ lưu trữ được phân bổ bằng cách gọi</p>
<span class="t-li">là trong</span>Mẫu &lt;class inputit1, class inputit2,<br/> <code>construct<span class="br0">.</span>p, <a href="http://en.cppreference.com/w/cpp/utility/piecewise_construct"><span class="kw1109">Điều đó cho tất cả<span class="me2">Piecewise_construct</span></span></a>, <a href="http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple"><span class="kw1117">Điều đó cho tất cả<span class="me2">forward_as_tuple</span></span></a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">&lt;</span><span class="br0">.</span>x<span class="br0">)</span><span class="br0">)</span>,<br/> <a href="http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple"><span class="kw1117">Điều đó cho tất cả<span class="me2">forward_as_tuple</span></span></a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>V<span class="sy1">&lt;</span><span class="br0">.</span>y<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span></code> <span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Mẫu &lt;class inputit1, class inputit2,<br/> <code>construct<span class="br0">.</span>p, <a href="http://en.cppreference.com/w/cpp/utility/piecewise_construct"><span class="kw1109">Điều đó cho tất cả<span class="me2">Piecewise_construct</span></span></a>, <a href="http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple"><span class="kw1117">Điều đó cho tất cả<span class="me2">forward_as_tuple</span></span></a><span class="br0">.</span>xy.<span class="me1">đến phạm vi bắt đầu tại</span><span class="br0">)</span>,<br/> <a href="http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple"><span class="kw1117">Điều đó cho tất cả<span class="me2">forward_as_tuple</span></span></a><span class="br0">.</span>xy.<span class="me1">thứ hai</span><span class="br0">)</span><span class="br0">)</span></code> <span class="t-li">từ_sys</span>Mẫu &lt;class inputit1, class inputit2,<br/> <code>construct<span class="br0">.</span>p, <a href="http://en.cppreference.com/w/cpp/utility/piecewise_construct"><span class="kw1109">Điều đó cho tất cả<span class="me2">Piecewise_construct</span></span></a>,<br/> <a href="http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple"><span class="kw1117">Điều đó cho tất cả<span class="me2">forward_as_tuple</span></span></a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">&lt;</span><span class="br0">.</span>xy.<span class="me1">đến phạm vi bắt đầu tại</span><span class="br0">)</span><span class="br0">)</span>,<br/> <a href="http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple"><span class="kw1117">Điều đó cho tất cả<span class="me2">forward_as_tuple</span></span></a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>V<span class="sy1">&lt;</span><span class="br0">.</span>xy.<span class="me1">thứ hai</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span></code> <span class="t-li">6)</span>Nếu không, chương trình là xấu.  Các quy tắc tương tự áp dụng cho<br/> <p><code>template&lt;class A, class B&gt;<br/><span class="kw4">Vô hiệu</span> <span class="coMULTI">, nghĩa là, chuyển bộ phân bổ bên trong cho các loại thành viên của cặp nếu họ chấp nhận chúng.</span><span class="br0">.</span><span class="kw4">hằng số</span> <a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1099">Điều đó cho tất cả<span class="me2">đôi</span></span></a><span class="sy1">is_trivently_destructible_v</span>A, B<span class="sy1">&lt;</span><span class="sy3">Không có giá trị</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>Thì<br/> <code>/*deduce-as-pair*/(non_pair)</code>    std :: cặp &lt;u, v&gt; &amp;&amp; pr) noExcept;<br/>Mẫu &lt;class inputit1, class inputit2,<code>construct<span class="sy1">is_trivently_destructible_v</span>T1, T2, T1, T2<span class="sy1">&lt;</span><span class="br0">.</span>p, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>NonPair<span class="sy1">&lt;</span><span class="br0">.</span>non_pair<span class="br0">)</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> </table> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>, nhưng được thực hiện theo</td> <td>-</td> <td>trong bộ phận được phân bổ như thể bằng cách</td>
</tr> <tr class="t-par"> <td>, không cho phép định dạng định dạng.</td> <td>-</td> <td>                                       std :: forward_as_tuple (std :: forward &lt;v&gt; (y))))<code>T</code> </td>
</tr> <tr class="t-par"> <td>x</td> <td>-</td> <td>                                       std :: forward_as_tuple (std :: forward &lt;v&gt; (y))))<code>T1</code> </td>
</tr> <tr class="t-par"> <td>thuộc tính).</td> <td>-</td> <td>                                       std :: forward_as_tuple (std :: forward &lt;v&gt; (y))))<code>T2</code> </td>
</tr> <tr class="t-par"> <td>Xây dựng (P, STD :: Piecewise_construct, std :: forward_as_tuple (xy.first),</td> <td>-</td> <td>                                       std :: forward_as_tuple (xy.second))<code>T1</code>Và<code>T2</code> </td>
</tr> <tr class="t-par"> <td>    )</td> <td>-</td> <td>không<code>pair</code>Xây dựng (P, STD :: Piecewise_construct, std :: forward_as_tuple (std :: forward &lt;u&gt; (xy.first)),<code>pair</code>Trả về STD :: use_allocator_construction_args &lt;t&gt; (alloc,</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Gán cho đã cho</p>
<h3 id="Notes">Ghi chú</h3> <p>                                       std :: forward_as_tuple (std :: forward &lt;v&gt; (xy.second))))<code><a href="../allocator_traits" title="cpp/memory/allocator traits">std::allocator_traits</a></code>Sự quá tải này chỉ tham gia vào độ phân giải quá tải nếu được đưa ra mẫu chức năng chỉ dành cho trình bày<code><a href="../../container/vector" title="cpp/container/vector">std::vector</a></code>/*suy luận như cặp đôi*/<code><a href="../scoped_allocator_adaptor" title="cpp/memory/scoped allocator adaptor">std::scoped_allocator_adaptor</a></code>, đó đã được đưa ra một<code>inner_allocator</code>như người phân bổ để sử dụng. Từ<code><a href="../scoped_allocator_adaptor" title="cpp/memory/scoped allocator adaptor">std::scoped_allocator_adaptor</a></code>bản thân nó là một ví dụ của</p>
<h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2975" rel="nofollow">LWG 2975</a> </td> <td>C ++ 11</td> <td>con trỏ để phân bổ, nhưng không được khởi tạo lưu trữ</td> <td>các đối số của hàm tạo để chuyển đến hàm tạo của</td>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/P0475R1" rel="nofollow">P0475R1</a> </td> <td>C ++ 11</td> <td>, chức năng này cũng sẽ được gọi khi các đối tượng nhận biết phân bổ được xây dựng thông qua chức năng này bắt đầu xây dựng các thành viên của chính họ.</td> <td>Cặp đôi xây dựng có thể sao chép các đối số</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3525" rel="nofollow">LWG 3525</a> </td> <td>C ++ 11</td> <td>    std :: forward_as_tuple (pr.second)<code>pair</code>);<code>pair</code> </td> <td>Trả về STD :: use_allocator_construction_args &lt;t&gt; (alloc,</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../allocator_traits/construct" title="cpp/memory/allocator traits/construct"> <span class="t-lines"><span>Xử lý lưu trữ</span></span></a></div>
<div><span class="t-lines"><span><span class="t-cmark">Kế thừa từ</span></span></span></div> </td> <td>Xử lý lưu trữ bằng cách sử dụng bộ phân bổ<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../allocator/construct" title="cpp/memory/allocator/construct"> <span class="t-lines"><span>Xử lý lưu trữ</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></span></span></div> </td> <td>Trả về quy mô phân bổ được hỗ trợ lớn nhất<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::allocator&lt;T&gt;</code>)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/memory/scoped_allocator_adaptor/construct">https://en.cppreference.com/w/cpp/memory/scoped_allocator_adaptor/construct</a>
</p>
</div>
