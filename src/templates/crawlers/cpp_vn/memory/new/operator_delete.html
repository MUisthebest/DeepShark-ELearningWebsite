 <h1 class="firstHeading" id="firstHeading">Xóa toán tử, Xóa toán tử []</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/new" title="cpp/header/new">&lt;new&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Các chức năng giải quyết thông thường có thể thay thế</td> <td></td> <td></td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx11"> <td><pre data-language="cpp">void toán tử xóa (void* ptr) ném ();</pre></td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">void toán tử xóa (void* ptr) noExcept;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(2)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx11"> <td><pre data-language="cpp">void toán tử xóa [] (void* ptr) ném ();</pre></td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">void toán tử xóa [] (void* ptr) noExcept;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td><pre data-language="cpp">void toán tử xóa (void* ptr, std :: align_val_t al) noexcept;</pre></td> <td>(3)</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td> </tr> <tr class="t-dcl t-since-cxx17"> <td><pre data-language="cpp">void toán tử xóa [] (void* ptr, std :: align_val_t al) noexcept;</pre></td> <td>(4)</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td> </tr> <tr class="t-dcl t-since-cxx14"> <td><pre data-language="cpp">void toán tử xóa (void* ptr, std :: size_t sz) noExcept;</pre></td> <td>             Không có p);</td> <td><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></td> </tr> <tr class="t-dcl t-since-cxx14"> <td><pre data-language="cpp">void toán tử xóa [] (void* ptr, std :: size_t sz) noexcept;</pre></td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></td> </tr> <tr class="t-dcl t-since-cxx17"> <td><pre data-language="cpp">Void toán tử xóa (void* ptr, std :: size_t sz,</pre></td> <td>            Chuyển tiếp 2 First2);</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td> </tr> <tr class="t-dcl t-since-cxx17"> <td><pre data-language="cpp">                        std :: align_val_t al) noExcept;</pre></td> <td>            Nhị phân p);</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td> </tr> <tr class="t-dcl-h"> <td>void toán tử xóa [] (void* ptr, std :: size_t sz,</td> <td></td> <td></td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(9)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx11"> <td><pre data-language="cpp">                        std :: align_val_t al) noExcept;</pre></td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Chức năng giải quyết vị trí có thể thay thế</pre>
</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(10)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx11"> <td><pre data-language="cpp">void toán tử xóa (void* ptr, const std :: nothrow_t &amp; tag) ném ();</pre></td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">void toán tử xóa (void* ptr, const std :: nothrow_t &amp; tag) noexcept;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td><pre data-language="cpp">void toán tử xóa [] (void* ptr, const std :: nothrow_t &amp; tag) ném ();</pre></td> <td>(11)</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td> </tr> <tr class="t-dcl t-since-cxx17"> <td><pre data-language="cpp">void toán tử xóa [] (void* ptr, const std :: nothrow_t &amp; tag) noexcept;</pre></td> <td>(12)</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td> </tr> <tr class="t-dcl-h"> <td>Void Toán tử Xóa (void* ptr, std :: align_val_t al,</td> <td></td> <td></td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(13)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx11"> <td><pre data-language="cpp">                        const std :: nothrow_t &amp; tag) noExcept;</pre></td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">void toán tử xóa [] (void* ptr, std :: align_val_t al,</pre>
</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(14)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx11"> <td><pre data-language="cpp">                        const std :: nothrow_t &amp; tag) noExcept;</pre></td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Các chức năng giải quyết vị trí không phân tán</pre>
</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl-h"> <td>void toán tử xóa (void* ptr, void* Place) ném ();</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td><pre data-language="cpp">void toán tử xóa (void* ptr, void* Place) noExcept;</pre></td> <td>(15)</td> <td class="t-dcl-nopad"></td> </tr> <tr class="t-dcl"> <td><pre data-language="cpp">void toán tử xóa [] (void* ptr, void* place) ném ();</pre></td> <td>(16)</td> <td class="t-dcl-nopad"></td> </tr> <tr class="t-dcl-h"> <td>void toán tử xóa [] (void* ptr, void* Place) noExcept;</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td><pre data-language="cpp">Các chức năng giải quyết vị trí do người dùng xác định</pre></td> <td>Nhà điều hành Auto Auto của Const</td> <td class="t-dcl-nopad"></td> </tr> <tr class="t-dcl"> <td><pre data-language="cpp">void toán tử xóa (void* ptr, args ...);</pre></td> <td>    -&gt; std :: Chrono :: tháng_day_last;</td> <td class="t-dcl-nopad"></td> </tr> <tr class="t-dcl t-since-cxx17"> <td><pre data-language="cpp">void toán tử xóa [] (void* ptr, args ...);</pre></td> <td>    -&gt; std :: Chrono :: tháng_day_last;</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td> </tr> <tr class="t-dcl t-since-cxx17"> <td><pre data-language="cpp">Các chức năng giải quyết thông thường dành riêng cho lớp học</pre></td> <td>                          const std :: Chrono :: tháng &amp; m) Noexcept</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td> </tr> <tr class="t-dcl"> <td><pre data-language="cpp">void t :: Distening Delete (void* ptr);</pre></td> <td>Toán tử Auto Auto của Const</td> <td class="t-dcl-nopad"></td> </tr> <tr class="t-dcl"> <td><pre data-language="cpp">void t :: Date District [] (void* ptr);</pre></td> <td>Nhà điều hành Auto Auto của Const</td> <td class="t-dcl-nopad"></td> </tr> <tr class="t-dcl t-since-cxx17"> <td><pre data-language="cpp">void t :: Xóa toán tử (void* ptr, std :: align_val_t al);</pre></td> <td>    -&gt; std :: Chrono :: tháng_weekday;</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td> </tr> <tr class="t-dcl t-since-cxx17"> <td><pre data-language="cpp">void T :: Trình vận hành xóa [] (void* ptr, std :: align_val_t al);</pre></td> <td>    -&gt; std :: Chrono :: tháng_weekday;</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td> </tr> <tr class="t-dcl-h"> <td>void t :: Dopy Delete (void* ptr, std :: size_t sz);</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td><pre data-language="cpp">void t :: Trình vận hành xóa [] (void* ptr, std :: size_t sz);</pre></td> <td>                          const std :: Chrono :: tháng &amp; m) Noexcept</td> <td class="t-dcl-nopad"></td> </tr> <tr class="t-dcl"> <td><pre data-language="cpp">void t :: Xóa toán tử (void* ptr, std :: size_t sz, std :: align_val_t al);</pre></td> <td>Nhà điều hành Auto Auto của Const</td> <td class="t-dcl-nopad"></td> </tr> <tr class="t-dcl-h"> <td>void T :: Trình vận hành xóa [] (void* ptr, std :: size_t sz, std :: align_val_t al);</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td><pre data-language="cpp">Các chức năng giải quyết vị trí cụ thể của lớp</pre></td> <td>Nhà điều hành Auto Auto Constexpr/(const std :: Chrono :: tháng &amp; m,</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td><pre data-language="cpp">void t :: Xóa toán tử (void* ptr, args ...);</pre></td> <td>    -&gt; std :: Chrono :: tháng_weekday_last;</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td><pre data-language="cpp">void t :: Trình vận hành xóa [] (void* ptr, args ...);</pre></td> <td>    -&gt; std :: Chrono :: tháng_weekday_last;</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td><pre data-language="cpp">Các chức năng phá hủy phá hủy thông thường cụ thể của lớp</pre></td> <td>Nhà điều hành Auto Auto của Const</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td> </tr> </table> <p>void t :: Xóa toán tử (t* ptr, std :: phá hủy_delete_t);<code><a href="operator_new" title="cpp/memory/new/operator new">operator new</a></code>Void T :: Xóa toán tử (T* PTR, STD :: phá hủy_delete_t,<a href="../../language/delete" title="cpp/language/delete">delete-expressions</a>                         std :: align_val_t al);<a href="../../language/new" title="cpp/language/new">new-expressions</a>void t :: Xóa toán tử (t* ptr, std :: debstring_delete_t, std :: size_t sz);</p>
<div class="t-li1">
<span class="t-li">1)</span>Và bởi<a href="../../language/delete" title="cpp/language/delete">delete-expressions</a>                         std :: size_t sz, std :: align_val_t al);</div> <div class="t-li1">Được gọi bởi<code>ptr</code>Để giải quyết việc lưu trữ được phân bổ trước đây cho một đối tượng.<code><a href="http://en.cppreference.com/w/cpp/memory/new/operator_new"><span class="kw690">nhà điều hành mới</span></a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">Điều đó cho tất cả<span class="me2">size_t</span></span></a><span class="br0">)</span></code>hoặc<code><a href="http://en.cppreference.com/w/cpp/memory/new/operator_new"><span class="kw690">nhà điều hành mới</span></a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">Điều đó cho tất cả<span class="me2">size_t</span></span></a>, <a href="http://en.cppreference.com/w/cpp/memory/new/nothrow_t"><span class="kw696">Điều đó cho tất cả<span class="me2">nothrow_t</span></span></a><span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">2)</span>Và bởi<a href="../../language/delete" title="cpp/language/delete">delete[]-expressions</a>Để giải quyết bộ nhớ sau khi phá hủy (hoặc không xây dựng) các đối tượng với thời lượng lưu trữ động. Chúng cũng có thể được gọi bằng cú pháp gọi chức năng thông thường.</div> <div class="t-li1">Được gọi bởi<code>ptr</code>Để giải quyết việc lưu trữ được phân bổ trước đây cho một đối tượng.<code><a href="http://en.cppreference.com/w/cpp/memory/new/operator_new"><span class="kw690">nhà điều hành mới</span></a><span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span><span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">Điều đó cho tất cả<span class="me2">size_t</span></span></a><span class="br0">)</span></code>hoặc<code><a href="http://en.cppreference.com/w/cpp/memory/new/operator_new"><span class="kw690">nhà điều hành mới</span></a><span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span><span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">Điều đó cho tất cả<span class="me2">size_t</span></span></a>, <a href="http://en.cppreference.com/w/cpp/memory/new/nothrow_t"><span class="kw696">Điều đó cho tất cả<span class="me2">nothrow_t</span></span></a><span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>                                   Nhị phân p);<span class="t-v">Outputit adjacent_difference (đầu vào đầu tiên, đầu vào cuối cùng, </span>Được gọi bởi đối tượng đơn không ném<code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>.</div> <div class="t-li1">
<span class="t-li">    trả về std :: find_if_not (đầu tiên, cuối cùng, p) == cuối cùng;</span>là một con trỏ null hoặc là một con trỏ trước đây thu được từ việc triển khai thư viện tiêu chuẩn của<span class="t-v">Outputit adjacent_difference (đầu vào đầu tiên, đầu vào cuối cùng, </span>Được gọi bởi<span class="t-v">Outputit adjacent_difference (đầu vào đầu tiên, đầu vào cuối cùng, </span>hoặc<span class="t-v">Mẫu &lt;Class execPolicy, class forwardit1, class forwardit2,</span>Để phân loại lưu trữ trước đây được phân bổ cho một mảng các đối tượng.</div> <div class="t-li1">Hành vi của việc thực hiện thư viện tiêu chuẩn của chức năng này không được xác định trừ khi<span class="t-v">Outputit adjacent_difference (đầu vào đầu tiên, đầu vào cuối cùng, </span>.</div> <div class="t-li1">
<span class="t-li">      std :: memory_order thành công, std :: memory_order thất bại) NoExcept;</span>                                   Nhị phân p);<span class="t-v">Mẫu &lt;Class execPolicy, class forwardit1, class forwardit2,</span>Được gọi bởi đối tượng đơn không ném<code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>.</div> <div class="t-li1">
<span class="t-li">được hình thành tốt. Chương trình không được hình thành nếu</span>, ngoại trừ được gọi nếu yêu cầu căn chỉnh vượt quá<a href="../../language/new" title="cpp/language/new">new-expressions</a>Được gọi là thay vì</div> <div class="t-li1">, ngoại trừ được gọi nếu yêu cầu căn chỉnh vượt quá<span class="t-v">(1)</span>.</div> <div class="t-li1">
<span class="t-li">Toán tử bool constexpr&gt; (const std :: Chrono :: sys_time &lt;fending&gt; &amp; x,</span>được gọi là khi xóa các đối tượng thuộc loại không đầy đủ và các mảng của các loại lớp không bị phá hủy và không thể phá hủy. Một bộ phân bổ bộ nhớ có thể sử dụng kích thước đã cho để hiệu quả hơn.<a href="../../language/new" title="cpp/language/new">new[]-expressions</a>Các triển khai thư viện tiêu chuẩn giống hệt</div> <div class="t-li1">, ngoại trừ được gọi nếu yêu cầu căn chỉnh vượt quá<span class="t-v">(2)</span>.</div> <div class="t-li1">
<span class="t-li">               const key_equal &amp; bằng = key_equal (),</span>                                   Nhị phân p);<span class="t-v">(9,10)</span>Được gọi bởi đối tượng đơn không ném<code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>.</div> <div class="t-li1">
<span class="t-li">. Di chuyển-constructs</span>Nếu một hàm tạo của đối tượng ném một ngoại lệ.<a href="../../language/new" title="cpp/language/new">placement new</a>Việc triển khai thư viện tiêu chuẩn hoạt động giống như</div> <div class="t-li1">, ngoại trừ được gọi nếu yêu cầu căn chỉnh vượt quá</div> <div class="t-li1">
<span class="t-li">Các hàm tạo cặp lặp mở rộng phân bổ. Giống như</span>Nếu một hàm tạo của bất kỳ đối tượng nào ném một ngoại lệ (sau khi thực hiện các bộ hủy của tất cả các đối tượng trong mảng được xây dựng thành công).<a href="../../language/new" title="cpp/language/new">placement new[]</a>Việc triển khai thư viện tiêu chuẩn hoạt động giống như</div> <div class="t-li1">, ngoại trừ được gọi nếu yêu cầu căn chỉnh vượt quá</div> <div class="t-li1">
<span class="t-li">, ngoại trừ điều đó</span>Nếu giải quyết một mảng các đối tượng thuộc loại<a href="../../language/new" title="cpp/language/new">placement new</a>23,24)</div> <div class="t-li1">Nếu một phiên bản dành riêng cho lớp<span class="t-v">                          const std :: Chrono :: tháng &amp; m) Noexcept</span>được xác định, nó được gọi theo sở thích<span class="t-v">(9)</span>.</div> <div class="t-li1">Nếu không<span class="t-v">                          const std :: Chrono :: tháng &amp; m) Noexcept</span>constexpr outputit độc đáo_copy (đầu vào đầu tiên, đầu vào cuối cùng,<span class="t-v">(15)</span>được cung cấp bởi người dùng, không có chức năng giải quyết nào được gọi.</div> <div class="t-li1">
<span class="t-li">Như trong</span>không được xác định, được gọi là ưu tiên cho các thành viên phân bổ-không biết nếu yêu cầu liên kết vượt quá<a href="../../language/new" title="cpp/language/new">placement new[]</a>25)</div> <div class="t-li1">Nếu một phiên bản dành riêng cho lớp<span class="t-v">Nhà điều hành Auto Auto của Const</span>được xác định, nó được gọi theo sở thích<span class="t-v">(10)</span>.</div> <div class="t-li1">Nếu không<span class="t-v">Nhà điều hành Auto Auto của Const</span>constexpr outputit độc đáo_copy (đầu vào đầu tiên, đầu vào cuối cùng,<span class="t-v">(16)</span>được cung cấp bởi người dùng, không có chức năng giải quyết nào được gọi.</div> <div class="t-li1">
<span class="t-li">1-16,18)</span>Nếu được xác định, được gọi bởi dạng mảng tùy chỉnh của<a href="../../language/delete" title="cpp/language/delete">delete-expressions</a>19,20)<code>T</code>.</div> <div class="t-li1">
<span class="t-li">là một thao tác I/O.</span>Nếu một phiên bản dành riêng cho lớp<a href="../../language/delete" title="cpp/language/delete">delete[]-expressions</a>Nếu yêu cầu căn chỉnh vượt quá<code>T</code>.</div> <div class="t-li1">
<span class="t-li">Nếu không</span>được cung cấp bởi người dùng, không có chức năng giải quyết nào được gọi.<span class="t-v">Nếu được xác định, được gọi bởi đối tượng đơn thông thường</span>Nếu xử lý một đối tượng thuộc loại<code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>.</div> <div class="t-li1">
<span class="t-li">                          const std :: Chrono :: weekday_indexed &amp; wdi) NoExcept</span>không được định nghĩa, được gọi bởi đối tượng đơn thông thường<span class="t-v">Nhà điều hành Auto Auto của Const</span>Nếu giải quyết một mảng các đối tượng thuộc loại<a href="../../language/delete" title="cpp/language/delete">delete-expressions</a>19,20)<code>T</code>.</div> <div class="t-li1">
<span class="t-li">Cấu trúc container cơ bản bằng cách sử dụng</span>không được định nghĩa, được gọi bởi đối tượng đơn thông thường<span class="t-v">    -&gt; std :: Chrono :: tháng_day_last;</span>(17,18)<a href="../../language/delete" title="cpp/language/delete">delete[]-expressions</a>Nếu yêu cầu căn chỉnh vượt quá<code>T</code>.</div> <div class="t-li1">
<span class="t-li">Nếu được xác định và nếu</span>không được định nghĩa, được gọi bởi đối tượng đơn thông thường<span class="t-v">Nếu xử lý một đối tượng thuộc loại</span>Nếu được xác định và nếu<code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>.</div> <div class="t-li1">
<span class="t-li">không được định nghĩa, được gọi bởi mảng thông thường</span>Nếu giải quyết một mảng các đối tượng thuộc loại<a href="../../language/new" title="cpp/language/new">placement new</a>23,24)</div> <div class="t-li1">Nếu được xác định, được gọi bởi đối tượng đơn tùy chỉnh<span class="t-v">(15)</span>Biểu thức với chữ ký phù hợp nếu hàm tạo của đối tượng ném một ngoại lệ.</div> <div class="t-li1">
<span class="t-li">Nhà điều hành Auto Auto của Const</span>không được xác định, được gọi là ưu tiên cho các thành viên phân bổ-không biết nếu yêu cầu liên kết vượt quá<a href="../../language/new" title="cpp/language/new">placement new[]</a>25)</div> <div class="t-li1">Nếu được xác định, được gọi bởi đối tượng đơn tùy chỉnh<span class="t-v">(16)</span>Biểu thức với chữ ký phù hợp nếu hàm tạo của đối tượng ném một ngoại lệ.</div> <div class="t-li1">
<span class="t-li">Nếu chức năng này không được cung cấp, và phù hợp</span>cũng không được cung cấp, không có chức năng giải quyết nào được gọi.<a href="../../language/delete" title="cpp/language/delete">delete-expressions</a>Nếu được xác định, được gọi bởi dạng mảng tùy chỉnh của<code>*p</code>Biểu thức với chữ ký phù hợp nếu bất kỳ hàm tạo nào của đối tượng ném một ngoại lệ (sau khi thực hiện các bộ hủy diệt cho tất cả các đối tượng được xây dựng thành công).<code>operator delete</code>Nếu chức năng này không được cung cấp, và phù hợp<code>p-&gt;~T();</code>cũng không được cung cấp, không có chức năng giải quyết nào được gọi.</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>(Raco).<a href="../../language/delete" title="cpp/language/delete">delete-expression</a>27-30)</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <p>Nếu được xác định,<code>ptr</code>không thực hiện bộ hủy diệt cho</p>
<p>Trước khi thực hiện một cuộc gọi đến</p>
<p>. Thay vào đó, việc gọi trực tiếp của chất hủy diệt như</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Nếu mảng chứa một số yếu tố</td> <td>-</td> <td>Trở thành trách nhiệm của nhà điều hành do người dùng xác định xóa này.</td>
</tr> <tr class="t-par"> <td>Để biết chi tiết chính xác về các quy tắc độ phân giải quá tải giữa các chức năng giải quyết liên kết và liên kết không biết của các chức năng giải quyết thông thường (không định vị).</td> <td>-</td> <td>Trong mọi trường hợp, nếu</td>
</tr> <tr class="t-par"> <td>là một con trỏ null, các chức năng giải quyết thư viện tiêu chuẩn không làm gì cả. Nếu con trỏ được chuyển đến chức năng giải quyết thư viện tiêu chuẩn không được lấy từ chức năng phân bổ thư viện tiêu chuẩn tương ứng, hành vi không được xác định.</td> <td>-</td> <td>Sau khi chức năng giao dịch thư viện tiêu chuẩn trở lại, tất cả các gợi ý đề cập đến bất kỳ phần nào của bộ lưu trữ bị giao dịch trở nên không hợp lệ.</td>
</tr> <tr class="t-par"> <td>Sự gián tiếp thông qua một con trỏ trở nên không hợp lệ theo cách này và chuyển nó đến một chức năng định vị (xử lý kép) là hành vi không xác định. Bất kỳ sử dụng khác là thực hiện được xác định.</td> <td>-</td> <td>Con trỏ đến một khối bộ nhớ để phân loại hoặc con trỏ null</td>
</tr> <tr class="t-par"> <td>SZ</td> <td>-</td> <td>Kích thước được chuyển đến hàm phân bổ phù hợp</td>
</tr> <tr class="t-par"> <td>iterator trước đó phần tử mới sẽ được xây dựng</td> <td>-</td> <td>địa điểm<code><a href="../../types/size_t" title="cpp/types/size t">std::size_t</a></code>Và<code><a href="align_val_t" title="cpp/memory/new/align val t">std::align_val_t</a></code>)</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Gán cho đã cho</p>
<h3 id="Exceptions">Ngoại lệ</h3> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>con trỏ được sử dụng làm tham số vị trí trong vị trí phù hợp mới<span class="kw1">Noexcept</span><span class="br0">.</span><span class="kw2">ĐÚNG VẬY</span><span class="br0">)</span>nhãn</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <p>Thẻ quá tải khớp khớp với thẻ được sử dụng bởi toán tử không ném mới<span class="t-rev-inl t-since-cxx11"><span>al<code>noexcept(false)</code></span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>.</p>
<h3 id="Global_replacements">Căn chỉnh của phần tử đối tượng hoặc mảng được phân bổ</h3> <p>Các tham số tùy ý phù hợp với chức năng phân bổ vị trí (có thể bao gồm<span class="t-v">.<a href="#Version_1">1-12</a>)</span>Tất cả các chức năng giải quyết là<a href="../../header/new" title="cpp/header/new"><code>&lt;new&gt;</code></a>trừ khi được chỉ định khác trong Tuyên bố.<i>Nếu chức năng giải quyết chấm dứt bằng cách ném một ngoại lệ, hành vi không được xác định</i>, ngay cả khi nó được tuyên bố với</p>
<p>Thay thế toàn cầu<a href="../../language/inline" title="cpp/language/inline"><code>inline</code> specifier</a>Các chức năng giải quyết có thể thay thế</p>
<p>được tuyên bố ngầm trong mỗi đơn vị dịch ngay cả khi<span class="t-v">.<a href="#Version_9">9,10</a>)</span>Không bao gồm tiêu đề. Những chức năng này là<span class="t-v">.<a href="#Version_1">1,2</a>)</span>có thể thay thế<span class="t-v">.<a href="#Version_5">5-8</a>)</span>: Một chức năng không phải thành viên do người dùng cung cấp với cùng chữ ký được xác định ở bất cứ đâu trong chương trình, trong bất kỳ tệp nguồn nào, thay thế phiên bản ẩn tương ứng cho toàn bộ chương trình. Tuyên bố của nó không cần phải nhìn thấy.<span class="t-v">.<a href="#Version_1">1-4</a>)</span>Chương trình không được hình thành, không cần chẩn đoán nếu có nhiều hơn một thay thế được cung cấp trong chương trình hoặc nếu một người thay thế được khai báo với<span class="t-v">.<a href="#Version_2">2,4</a>)</span>. Chương trình không được hình thành nếu một sự thay thế được xác định trong không gian tên khác ngoài không gian tên toàn cầu hoặc nếu nó được định nghĩa là hàm không thành viên tĩnh ở phạm vi toàn cầu.<span class="t-v">.<a href="#Version_1">1,3</a>)</span>Các triển khai thư viện tiêu chuẩn của các phiên bản Nothrow<span class="t-v">.<a href="#Version_1">1,3</a>)</span>gọi trực tiếp các phiên bản ném tương ứng</p>
<div class="t-example">
<p>. Các triển khai thư viện tiêu chuẩn của các chức năng giải quyết nhận biết kích thước<code>operator</code>Gọi trực tiếp các chức năng giải quyết không biết kích thước tương ứng</p>
<div class="cpp source-cpp"><pre data-language="cpp">. Các triển khai thư viện tiêu chuẩn của các mẫu mảng ném kích thước không biết</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">gọi trực tiếp các biểu mẫu đối tượng đơn tương ứng</pre></div> </div> <p>    str.width (n);<code>operator delete</code>Và<code>operator delete[]</code>        trả lại ptr;<span class="t-v">.<a href="#Version_15">15,16</a>)</span>là đủ để xử lý tất cả các giao dịch.<i>Toàn cầu</i>S Thay thế mới/Xóa:</p>
<p>#include &lt;Cstdio&gt;<code>operator delete</code> <span class="t-v">.<a href="#Version_13">13,14</a>)</span>#include &lt;CstDlib&gt;<span class="sy4">::</span><span class="me2">mới</span>#include &lt;New&gt;<span class="t-v">.<a href="#Version_25">25,26</a>)</span> <span class="kw4">Vô hiệu</span>T<span class="sy4">::</span><span class="me2">nhà điều hành</span>        trả lại ptr;<span class="br0">.</span><span class="kw4">Vô hiệu</span><span class="sy2">*</span>Thì<span class="kw4">Vô hiệu</span><span class="sy2">*</span><span class="br0">)</span>hoặc<span class="kw4">Vô hiệu</span>T<span class="sy4">::</span><span class="me2">nhà điều hành</span>        trả lại ptr;<span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span><span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span><span class="br0">.</span><span class="kw4">Vô hiệu</span><span class="sy2">*</span>Thì<span class="kw4">Vô hiệu</span><span class="sy2">*</span><span class="br0">)</span>.</p>
<h3 id="Class-specific_overloads">{</h3> <p>    std :: printf ("1) mới (size_t), size = %zu \ n", sz);<span class="t-v">.<a href="#Version_17">17-24</a>)</span>    if (sz == 0)<a href="../../language/delete" title="cpp/language/delete">delete-expressions</a>        ++ SZ; // Tránh std :: malloc (0) có thể trả lại nullptr khi thành công<span class="t-v">.<a href="#Version_17">17,19,21</a>)</span> <span class="t-v">.<a href="#Version_18">18,20,22</a>)</span>    if (void *ptr = std :: malloc (sz))<span class="sy4">::</span><span class="me2">        trả lại ptr;</span> <span class="kw4">năng động</span>    ném std :: bad_alloc {}; // Yêu cầu bởi [new.delete.single]/3</p>
<p>}<a href="../../language/lookup" title="cpp/language/lookup">name lookup rules</a> </p>
<p>// không nội tuyến, được yêu cầu bởi [thay thế.fifts]/3<a href="../../language/object" title="cpp/language/object">polymorphic</a>void* toán tử mới [] (std :: size_t sz)</p>
<p>{<span class="t-v">.<a href="#Version_17">17,18</a>)</span>    std :: printf ("2) mới [] (size_t), size = %zu \ n", sz);<code><a href="../../types/size_t" title="cpp/types/size t">std::size_t</a></code>    if (sz == 0)<span class="t-v">.<a href="#Version_21">21,22</a>)</span>        ++ SZ; // Tránh std :: malloc (0) có thể trả lại nullptr khi thành công</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp"> </pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">    if (void *ptr = std :: malloc (sz))</pre></div> </div> <p>    str.width (n);<code>operator delete</code>Và<code>operator delete[]</code>        trả lại ptr;<span class="t-v">.<a href="#Version_25">25,26</a>)</span> </p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">    ném std :: bad_alloc {}; // Yêu cầu bởi [new.delete.single]/3</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">}</pre></div> </div> <p> <code>operator delete</code>Void toán tử xóa (void* ptr) Noexcept<span class="kw4">Vô hiệu</span>{<span class="kw4">Vô hiệu</span><span class="sy2">*</span>    std :: đặt ("3) xóa (void*)");<a href="../../language/template_argument_deduction" title="cpp/language/template argument deduction">template argument deduction</a>.</p>
<h3 id="Notes">Ghi chú</h3> <p>    STD :: Miễn phí (PTR);<span class="sy4">::</span><span class="me2">nhà điều hành</span>}</p>
<p> </p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>Các chức năng sau được yêu cầu là an toàn cho luồng:</p>
<ul>
<li>Các phiên bản thư viện của<a href="operator_new" title="cpp/memory/new/operator new"><code>operator new</code></a>Và<strong class="selflink"><code>operator delete</code></strong> </li>
<li>Phiên bản thay thế người dùng của toàn cầu<a href="operator_new" title="cpp/memory/new/operator new"><code>operator new</code></a>Và<strong class="selflink"><code>operator delete</code></strong> </li>
<li> <code><a href="../c/calloc" title="cpp/memory/c/calloc">std::calloc</a></code>Thì<code><a href="../c/malloc" title="cpp/memory/c/malloc">std::malloc</a></code>Thì<code><a href="../c/realloc" title="cpp/memory/c/realloc">std::realloc</a></code><span class="t-rev-inl t-since-cxx17"><span>Thì<code><a href="../c/aligned_alloc" title="cpp/memory/c/aligned alloc">std::aligned_alloc</a></code></span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>Thì<code><a href="../c/free" title="cpp/memory/c/free">std::free</a></code> </li>
</ul> <p>Các cuộc gọi đến các chức năng này phân bổ hoặc xử lý một đơn vị lưu trữ cụ thể xảy ra trong một đơn đặt hàng duy nhất và mỗi cuộc gọi giải quyết như vậy<a href="../../atomic/memory_order" title="cpp/atomic/memory order">happens-before</a>Phân bổ tiếp theo (nếu có) theo thứ tự này.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <table class="wikitable sortable ftm-begin ftm-has-value"> <tr> <th>
<a href="../../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../../feature_test#cpp_sized_deallocation" title="cpp/feature test"><code>__cpp_sized_deallocation</code></a></td> <td><span class="nu0">Void toán tử xóa (void* ptr, std :: size_t size) NoExcept</span></td> <td><span class="t-mark">(C ++ 14)</span></td> <td>{</td>
</tr> <tr> <td><a href="../../feature_test#cpp_impl_destroying_delete" title="cpp/feature test"><code>__cpp_impl_destroying_delete</code></a></td> <td><span class="nu0">201806L</span></td> <td><span class="t-mark">Phạm vi :: Construct_at</span></td> <td>    std :: printf ("4) xóa (void*, size_t), size = %zu \ n", size);</td>
</tr> <tr> <td><a href="../../feature_test#cpp_lib_destroying_delete" title="cpp/feature test"><code>__cpp_lib_destroying_delete</code></a></td> <td><span class="nu0">201806L</span></td> <td><span class="t-mark">Phạm vi :: Construct_at</span></td> <td>    STD :: Miễn phí (PTR);</td>
</tr>
</table> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/220.html" rel="nofollow">CWG 220</a> </td> <td>C ++ 98</td> <td>}</td> <td> <br/>Void toán tử xóa [] (void* ptr) Noexcept</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1438.html" rel="nofollow">CWG 1438</a> </td> <td>C ++ 98</td> <td>{</td> <td>    std :: đặt ("5) xóa [] (void* ptr)");</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue206" rel="nofollow">LWG 206</a> </td> <td>C ++ 98</td> <td>    STD :: Miễn phí (PTR);</td> <td>Void toán tử xóa [] (void* ptr, std :: size_t size) NoExcept</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue298" rel="nofollow">LWG 298</a> </td> <td>C ++ 98</td> <td> </td> <td>Void toán tử xóa [] (void* ptr, std :: size_t size) NoExcept</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue404" rel="nofollow">LWG 404</a> </td> <td>C ++ 98</td> <td>{<br/>    std :: printf ("6) xóa [] (void*, size_t), size = %zu \ n", size);<span class="kw1">};</span> </td> <td>    STD :: Miễn phí (PTR);</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2458" rel="nofollow">LWG 2458</a> </td> <td>C ++ 14</td> <td>}<span class="br0">.</span><span class="kw4">Vô hiệu</span><span class="sy2">*</span>Thì<a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">Điều đó cho tất cả<span class="me2">size_t</span></span></a>Thì<span class="kw4">hằng số</span><br/><a href="http://en.cppreference.com/w/cpp/memory/new/nothrow_t"><span class="kw696">Điều đó cho tất cả<span class="me2">nothrow_t</span></span></a><span class="sy3">Không có giá trị</span><span class="br0">)</span> </td> <td>int main ()</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="operator_new" title="cpp/memory/new/operator new"> <span class="t-lines"><span>nhà điều hành mới</span><span>nhà điều hành mới []</span></span></a></div> </td> <td>chức năng phân bổ<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../return_temporary_buffer" title="cpp/memory/return temporary buffer"> <span class="t-lines"><span>return_temden_buffer</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(không được dùng trong C ++ 17)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span></span></div> </td> <td>Giải phóng lưu trữ không chính thức<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../c/free" title="cpp/memory/c/free"> <span class="t-lines"><span>    STD :: UINTMAX_T có sẵn; </span></span></a></div> </td> <td>Giải quyết bộ nhớ được phân bổ trước đây<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/memory/new/operator_delete">https://en.cppreference.com/w/cpp/memory/new/operator_delete</a>
</p>
</div>
