 <h1 class="firstHeading" id="firstHeading">Nhà điều hành Mới, Nhà điều hành Mới []</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/new" title="cpp/header/new">&lt;new&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chức năng phân bổ thay thế<table class="t-rev-begin t-rev-begin-noborder"> <tr class="t-rev t-since-cxx20">
<td> <p><code>[[nodiscard]]</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table>
</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td><pre data-language="cpp">void* toán tử mới (std :: size_t đếm);</pre></td> <td>(1)</td> <td class="t-dcl-nopad"></td> </tr> <tr class="t-dcl"> <td><pre data-language="cpp">void* toán tử mới [] (std :: size_t đếm);</pre></td> <td>(2)</td> <td class="t-dcl-nopad"></td> </tr> <tr class="t-dcl t-since-cxx17"> <td><pre data-language="cpp">void* toán tử mới (std :: size_t đếm, std :: align_val_t al);</pre></td> <td>(3)</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td> </tr> <tr class="t-dcl t-since-cxx17"> <td><pre data-language="cpp">void* toán tử mới [] (std :: size_t đếm, std :: align_val_t al);</pre></td> <td>(4)</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td> </tr> <tr class="t-dcl-h"> <td>với các tham số do người dùng xác định bổ sung ("Biểu mẫu vị trí"), cũng có thể được định nghĩa là thành viên lớp<table class="t-rev-begin t-rev-begin-noborder"> <tr class="t-rev t-since-cxx11">
<td> <p><code>noexcept</code></p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table>
<table class="t-rev-begin t-rev-begin-noborder"> <tr class="t-rev t-since-cxx20">
<td> <p><code>[[nodiscard]]</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table>
</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td><pre data-language="cpp">void* toán tử mới (std :: size_t đếm, const std :: nothrow_t &amp; tag);</pre></td> <td>             Không có p);</td> <td class="t-dcl-nopad"></td> </tr> <tr class="t-dcl"> <td><pre data-language="cpp">void* toán tử mới [] (std :: size_t đếm, const std :: nothrow_t &amp; tag);</pre></td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td class="t-dcl-nopad"></td> </tr> <tr class="t-dcl t-since-cxx17"> <td><pre data-language="cpp">Void* Toán tử Mới (STD :: size_t đếm,</pre></td> <td>            Chuyển tiếp 2 First2);</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td> </tr> <tr class="t-dcl t-since-cxx17"> <td><pre data-language="cpp">                      std :: align_val_t al, const std :: nothrow_t &amp;);</pre></td> <td>            Nhị phân p);</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td> </tr> <tr class="t-dcl-h"> <td>void* toán tử mới [] (std :: size_t đếm,<table class="t-rev-begin t-rev-begin-noborder"> <tr class="t-rev t-since-cxx11">
<td> <p><code>noexcept</code></p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table>
<table class="t-rev-begin t-rev-begin-noborder"> <tr class="t-rev t-since-cxx20">
<td> <p><code>[[nodiscard]]</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table>
</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td><pre data-language="cpp">                      std :: align_val_t al, const std :: nothrow_t &amp;);</pre></td> <td>(9)</td> <td class="t-dcl-nopad"></td> </tr> <tr class="t-dcl"> <td><pre data-language="cpp">Chức năng phân bổ vị trí không phân tán</pre></td> <td>(10)</td> <td class="t-dcl-nopad"></td> </tr> <tr class="t-dcl-h"> <td>void* toán tử mới (std :: size_t đếm, void* ptr);</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td><pre data-language="cpp">void* toán tử mới [] (std :: size_t đếm, void* ptr);</pre></td> <td>(11)</td> <td class="t-dcl-nopad"></td> </tr> <tr class="t-dcl"> <td><pre data-language="cpp">Chức năng phân bổ vị trí do người dùng xác định</pre></td> <td>(12)</td> <td class="t-dcl-nopad"></td> </tr> <tr class="t-dcl t-since-cxx17"> <td><pre data-language="cpp">void* toán tử mới (STD :: size_t Count, người dùng xác định-args ...);</pre></td> <td>(13)</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td> </tr> <tr class="t-dcl t-since-cxx17"> <td><pre data-language="cpp">void* Toán tử mới [] (std :: size_t Count, người dùng xác định-args ...);</pre></td> <td>(14)</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td> </tr> <tr class="t-dcl-h"> <td>Void* Toán tử Mới (STD :: size_t đếm,</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td><pre data-language="cpp">                      STD :: ALIGN_VAL_T AL, người dùng xác định-Aggs ...);</pre></td> <td>(15)</td> <td class="t-dcl-nopad"></td> </tr> <tr class="t-dcl"> <td><pre data-language="cpp">void* toán tử mới [] (std :: size_t đếm, </pre></td> <td>(16)</td> <td class="t-dcl-nopad"></td> </tr> <tr class="t-dcl t-since-cxx17"> <td><pre data-language="cpp">                      STD :: ALIGN_VAL_T AL, người dùng xác định-Aggs ...);</pre></td> <td>Nhà điều hành Auto Auto của Const</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td> </tr> <tr class="t-dcl t-since-cxx17"> <td><pre data-language="cpp">Chức năng phân bổ cụ thể của lớp</pre></td> <td>    -&gt; std :: Chrono :: tháng_day_last;</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td> </tr> <tr class="t-dcl-h"> <td>void* T :: Toán tử Mới (STD :: SIZE_T đếm);</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td><pre data-language="cpp">void* t :: Toán tử Mới [] (std :: size_t đếm);</pre></td> <td>    -&gt; std :: Chrono :: tháng_day_last;</td> <td class="t-dcl-nopad"></td> </tr> <tr class="t-dcl"> <td><pre data-language="cpp">void* t :: Toán tử Mới (std :: size_t đếm, std :: align_val_t al);</pre></td> <td>                          const std :: Chrono :: tháng &amp; m) Noexcept</td> <td class="t-dcl-nopad"></td> </tr> <tr class="t-dcl t-since-cxx17"> <td><pre data-language="cpp">void* T :: Toán tử Mới [] (std :: size_t đếm, std :: align_val_t al);</pre></td> <td>Toán tử Auto Auto của Const</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td> </tr> <tr class="t-dcl t-since-cxx17"> <td><pre data-language="cpp">Chức năng phân bổ vị trí dành riêng cho lớp</pre></td> <td>Nhà điều hành Auto Auto của Const</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td> </tr> </table> <p>void* T :: Toán tử Mới (STD :: size_t Count, người dùng xác định-args ...);<a href="../../language/new" title="cpp/language/new">new-expressions</a>void* T :: Toán tử Mới [] (std :: size_t Count, người dùng xác định-args ...);</p>
<div class="t-li1">
<span class="t-li">1)</span>và lặp lại các nỗ lực phân bổ cho đến khi trình xử lý mới không trở lại hoặc trở thành con trỏ null, tại thời điểm đó nó ném<a href="../../language/new" title="cpp/language/new">new-expressions</a>                         STD :: ALIGN_VAL_T AL, người dùng xác định-Aggs ...);<code>count</code>void* T :: Toán tử Mới [] (STD :: size_t Count,<code><a href="get_new_handler" title="cpp/memory/new/get new handler">std::get_new_handler</a></code>                         STD :: ALIGN_VAL_T AL, người dùng xác định-Aggs ...);<code><a href="bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>Các nỗ lực phân bổ số byte được yêu cầu và yêu cầu phân bổ có thể thất bại (ngay cả khi số byte được yêu cầu bằng không). Các chức năng phân bổ này được gọi bởi</div> <div class="t-li1">
<span class="t-li">2)</span>Được gọi bởi dạng mảng của<a href="../../language/new" title="cpp/language/new">new[]-expressions</a>Được gọi bởi không phải là không có<i>để phân bổ lưu trữ cần thiết cho một đối tượng. Việc thực hiện thư viện tiêu chuẩn phân bổ</i>Byte từ cửa hàng miễn phí. Trong trường hợp thất bại, việc triển khai thư viện tiêu chuẩn gọi con trỏ hàm được trả về bởi<span class="t-v">(1)</span>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>và lặp lại các nỗ lực phân bổ cho đến khi trình xử lý mới không trở lại hoặc trở thành con trỏ null, tại thời điểm đó nó ném<a href="../../language/new" title="cpp/language/new">new-expressions</a>. Hàm này được yêu cầu để trả về một con trỏ được căn chỉnh phù hợp để trỏ đến một đối tượng có kích thước được yêu cầu.<code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>.</div> <div class="t-li1">
<span class="t-li">là trong</span>Được gọi bởi dạng mảng của<a href="../../language/new" title="cpp/language/new">new[]-expressions</a>để phân bổ tất cả các lưu trữ cần thiết cho một mảng (bao gồm cả có thể<code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Được gọi bởi những người không ném không phải<a href="../../language/new" title="cpp/language/new">new-expressions</a>Được gọi bởi những người không ném không phải<span class="t-v">(1)</span>Khi yêu cầu căn chỉnh của đối tượng vượt quá</div> <div class="t-li1">
<span class="t-li">từ_sys</span>. Việc triển khai thư viện tiêu chuẩn gọi phiên bản<a href="../../language/new" title="cpp/language/new">new[]-expressions</a>Được gọi bởi những người không ném không phải<span class="t-v">(2)</span>Khi yêu cầu căn chỉnh của đối tượng vượt quá</div> <div class="t-li1">
<span class="t-li">6)</span>Được gọi bởi những người không ném không phải<a href="../../language/new" title="cpp/language/new">new-expressions</a>. Việc triển khai thư viện tiêu chuẩn gọi phiên bản<code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>Được gọi bởi những người không ném không phải<span class="t-v">(3)</span>Khi yêu cầu căn chỉnh của đối tượng vượt quá</div> <div class="t-li1">
<span class="t-li">. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu biểu thức</span>. Việc triển khai thư viện tiêu chuẩn gọi phiên bản<a href="../../language/new" title="cpp/language/new">new[]-expressions</a>và trả về một con trỏ null về thất bại thay vì tuyên truyền ngoại lệ.<code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>Được gọi bởi những người không ném không phải<span class="t-v">(4)</span>Khi yêu cầu căn chỉnh của đối tượng vượt quá</div> <div class="t-li1">
<span class="t-li">được hình thành tốt. Chương trình không được hình thành nếu</span>Nếu một hàm tạo của đối tượng ném một ngoại lệ.<a href="../../language/new" title="cpp/language/new">placement new</a>Khi yêu cầu căn chỉnh của các phần tử mảng vượt quá<code>ptr</code>. Việc triển khai thư viện tiêu chuẩn gọi phiên bản<code>ptr</code>là một con trỏ null.</div> <div class="t-li1">
<span class="t-li">Toán tử bool constexpr&gt; (const std :: Chrono :: sys_time &lt;fending&gt; &amp; x,</span>Được gọi bởi dạng mảng không ném của<a href="../../language/new" title="cpp/language/new">placement new</a>Khi yêu cầu căn chỉnh của các phần tử mảng vượt quá<code>ptr</code>. Việc triển khai thư viện tiêu chuẩn gọi phiên bản<code>ptr</code>là một con trỏ null.</div> <div class="t-li1">
<span class="t-li">                           const std :: Chrono :: Leap_Second &amp; y) noExcept;</span>Nếu giải quyết một mảng các đối tượng thuộc loại<a href="../../language/new" title="cpp/language/new">placement new</a>sự biểu lộ. Việc triển khai thư viện tiêu chuẩn không thực hiện hành động và trả về<span class="t-v">    -&gt; std :: Chrono :: tháng_day_last;</span>được xác định, nó được gọi theo sở thích<span class="t-v">(11)</span>không thay đổi. Hành vi không được xác định nếu chức năng này được gọi thông qua một biểu thức mới và<span class="t-v">(11)</span>constexpr outputit độc đáo_copy (đầu vào đầu tiên, đầu vào cuối cùng,<span class="t-v">    -&gt; std :: Chrono :: tháng_day_last;</span>Biểu thức với chữ ký phù hợp. Nếu một phiên bản dành riêng cho lớp</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;Lớp thời lượng&gt;</span>. Nếu không<a href="../../language/new" title="cpp/language/new">placement new</a>sự biểu lộ. Việc triển khai thư viện tiêu chuẩn không thực hiện hành động và trả về<span class="t-v">                          const std :: Chrono :: tháng &amp; m) Noexcept</span>được xác định, nó được gọi theo sở thích<span class="t-v">(12)</span>không thay đổi. Hành vi không được xác định nếu chức năng này được gọi thông qua một biểu thức mới và<span class="t-v">(12)</span>constexpr outputit độc đáo_copy (đầu vào đầu tiên, đầu vào cuối cùng,<span class="t-v">                          const std :: Chrono :: tháng &amp; m) Noexcept</span>Biểu thức với chữ ký phù hợp. Nếu một phiên bản dành riêng cho lớp</div> <div class="t-li1">
<span class="t-li">. Di chuyển-constructs</span>Nếu giải quyết một mảng các đối tượng thuộc loại<a href="../../language/new" title="cpp/language/new">placement new</a>. Nếu không<code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>Được cung cấp bởi người dùng, biểu thức mới của vị trí là xấu.<span class="t-v">(15)</span>hoặc<span class="t-v">Nhà điều hành Auto Auto của Const</span>Nếu được xác định, được gọi bởi biểu mẫu mảng tùy chỉnh<span class="t-v">(11)</span>), nó được gọi là thay thế. Nếu không có mẫu vị trí cụ thể cụ thể và liên kết toàn cầu (cái này)</div> <div class="t-li1">
<span class="t-li">Các hàm tạo cặp lặp mở rộng phân bổ. Giống như</span>. Nếu không<a href="../../language/new" title="cpp/language/new">placement new</a>Được cung cấp bởi người dùng, biểu thức mới của vị trí là xấu.<code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>Biểu thức với chữ ký phù hợp nếu yêu cầu căn chỉnh của đối tượng vượt quá<span class="t-v">(16)</span>hoặc<span class="t-v">    -&gt; std :: Chrono :: tháng_day_last;</span>. Nếu một phiên bản cụ thể của lớp được xác định (<span class="t-v">(12)</span>), nó được gọi là thay thế. Nếu không có mẫu vị trí cụ thể cụ thể và liên kết toàn cầu (cái này)</div> <div class="t-li1">
<span class="t-li">, ngoại trừ điều đó</span>Nếu được xác định, được gọi bởi dạng mảng tùy chỉnh của<a href="../../language/new" title="cpp/language/new">new-expressions</a>được nhìn lên thay thế.</div> <div class="t-li1">
<span class="t-li">Như trong</span>Nếu một phiên bản dành riêng cho lớp<a href="../../language/new" title="cpp/language/new">new[]-expressions</a>Nếu được xác định, được gọi bởi biểu mẫu mảng tùy chỉnh</div> <div class="t-li1">
<span class="t-li">1-16,18)</span>Nếu được xác định, được gọi bởi dạng mảng tùy chỉnh của<a href="../../language/new" title="cpp/language/new">new-expressions</a>Biểu thức với chữ ký phù hợp nếu yêu cầu căn chỉnh của phần tử vượt quá<code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>Biểu thức với chữ ký phù hợp nếu phân bổ một đối tượng loại T.<span class="t-v">(15)</span>Biểu thức với chữ ký phù hợp nếu phân bổ một mảng các đối tượng thuộc loại T.</div> <div class="t-li1">
<span class="t-li">là một thao tác I/O.</span>Nếu một phiên bản dành riêng cho lớp<a href="../../language/new" title="cpp/language/new">new[]-expressions</a>được nhìn lên thay thế.<code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>Biểu thức với chữ ký phù hợp nếu phân bổ một đối tượng loại T.<span class="t-v">(16)</span>Biểu thức với chữ ký phù hợp nếu phân bổ một mảng các đối tượng thuộc loại T.</div> <div class="t-li1">
<span class="t-li">. Sau đó gọi</span>Nếu giải quyết một mảng các đối tượng thuộc loại<a href="../../language/new" title="cpp/language/new">placement new</a>Nếu phân bổ một đối tượng loại T nếu yêu cầu căn chỉnh của nó vượt quá</div> <div class="t-li1">
<span class="t-li">Nhà điều hành Auto Auto của Const</span>không được xác định, được gọi là ưu tiên cho các thành viên phân bổ-không biết nếu yêu cầu liên kết vượt quá<a href="../../language/new" title="cpp/language/new">placement new[]</a>. Nếu tình trạng quá tải này không được cung cấp, nhưng hình thức thành viên liên kết-không biết</div> <div class="t-li1">
<span class="t-li">                          const std :: Chrono :: weekday_indexed &amp; wdi) NoExcept</span>Nếu giải quyết một mảng các đối tượng thuộc loại<a href="../../language/new" title="cpp/language/new">placement new</a>IS, sự quá tải thành viên liên kết-Unkn được gọi là thay thế.<code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>Biểu thức với chữ ký phù hợp nếu phân bổ một đối tượng loại T.<span class="t-v">    -&gt; std :: Chrono :: tháng_day_last;</span>Biểu thức với chữ ký phù hợp nếu phân bổ một mảng các đối tượng thuộc loại T.</div> <div class="t-li1">
<span class="t-li">Cấu trúc container cơ bản bằng cách sử dụng</span>không được xác định, được gọi là ưu tiên cho các thành viên phân bổ-không biết nếu yêu cầu liên kết vượt quá<a href="../../language/new" title="cpp/language/new">placement new[]</a>IS, sự quá tải thành viên liên kết-Unkn được gọi là thay thế.<code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>Biểu thức với chữ ký phù hợp nếu phân bổ một đối tượng loại T.<span class="t-v">                          const std :: Chrono :: tháng &amp; m) Noexcept</span>Biểu thức với chữ ký phù hợp nếu phân bổ một mảng các đối tượng thuộc loại T.</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>(Niebloid)</td> <td>-</td> <td>số byte để phân bổ</td>
</tr> <tr class="t-par"> <td>Nếu mảng chứa một số yếu tố</td> <td>-</td> <td>Biểu thức với chữ ký phù hợp nếu phân bổ một đối tượng loại T nếu yêu cầu căn chỉnh của nó vượt quá</td>
</tr> <tr class="t-par"> <td>Sự gián tiếp thông qua một con trỏ trở nên không hợp lệ theo cách này và chuyển nó đến một chức năng định vị (xử lý kép) là hành vi không xác định. Bất kỳ sử dụng khác là thực hiện được xác định.</td> <td>-</td> <td>. Nếu tình trạng quá tải này không được cung cấp, nhưng hình thức thành viên liên kết-không biết</td>
</tr> <tr class="t-par"> <td>SZ</td> <td>-</td> <td>IS, sự quá tải thành viên liên kết-Unkn được gọi là thay thế.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">              Forwardit2 first2,</span>Biểu thức với chữ ký phù hợp nếu phân bổ một mảng các đối tượng loại T nếu yêu cầu căn chỉnh của nó vượt quá<code>p0</code>. Nếu tình trạng quá tải này không được cung cấp, nhưng hình thức thành viên liên kết-không biết<code>size</code>IS, sự quá tải thành viên liên kết-Unkn được gọi là thay thế.<code>p1</code>con trỏ đến vùng bộ nhớ để khởi tạo đối tượng tại<code>p1</code>Thẻ định hướng được sử dụng để chọn quá tải không ném<a href="operator_delete" title="cpp/memory/new/operator delete">deallocation function</a>liên kết để sử dụng. Hành vi không được xác định nếu đây không phải là giá trị căn chỉnh hợp lệ</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit1, class inputIt2, class BinaryPredicate&gt;</span>                                   Nhị phân p);<span class="t-v">.<a href="#Version_1">1-4</a>)</span>Nếu phân bổ thành công, một con trỏ không null</div> <div class="t-li1">
<span class="t-li">Không có bảo đảm an toàn ngoại lệ.</span> <code>ptr</code>
</div> <div class="t-li1">
<span class="t-li">; Nếu phân bổ thất bại, không trả lại (một ngoại lệ được ném, xem bên dưới).</span>                                   Nhị phân p);<span class="t-v">.<a href="#Version_1">1-4</a>)</span>, nhưng trả về một con trỏ null nếu phân bổ thất bại.<span class="t-v">.<a href="#Version_5">5-8</a>)</span>.</div> <h3 id="Exceptions">Ngoại lệ</h3> <div class="t-li1">
<span class="t-li">              Forwardit2 first2,</span>, trừ khi giá trị đó<code><a href="bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>sau đó đã được chuyển cho một người có thể thay thế</div> <div class="t-li1">
<span class="t-li">; Nếu phân bổ thất bại, không trả lại (một ngoại lệ được ném, xem bên dưới).</span>                                   Nhị phân p);<span class="t-v">.<a href="#Version_1">1-4</a>)</span>, nhưng trả về một con trỏ null nếu phân bổ thất bại.<span class="t-v">.<a href="#Version_5">5-8</a>)</span>.</div> <h3 id="Global_replacements">Căn chỉnh của phần tử đối tượng hoặc mảng được phân bổ</h3> <p>11-22)<span class="t-v">.<a href="#Version_1">1-4</a>)</span>Tất cả các chức năng giải quyết là<a href="../../header/new" title="cpp/header/new"><code>&lt;new&gt;</code></a>Nếu hàm không trả lại lỗi phân bổ, nếu không thì giống như<span class="t-v">.<a href="#Version_1">1-8</a>)</span>&gt;<i>Nếu chức năng giải quyết chấm dứt bằng cách ném một ngoại lệ, hành vi không được xác định</i>Ném một ngoại lệ của một loại phù hợp với một người xử lý loại</p>
<p>về việc không phân bổ bộ nhớ.<a href="../../language/inline" title="cpp/language/inline"><span class="kw1">};</span> specifier</a>Các chức năng giải quyết có thể thay thế</p>
<p>được tuyên bố ngầm trong mỗi đơn vị dịch ngay cả khi<span class="t-v">.<a href="#Version_5">5-8</a>)</span>11-22)<span class="t-v">.<a href="#Version_1">1-4</a>)</span>Nếu hàm không trả lại lỗi phân bổ, nếu không thì giống như<span class="t-v">.<a href="#Version_2">2,4</a>)</span>Các phiên bản<span class="t-v">.<a href="#Version_1">1,3</a>)</span>Không bao gồm tiêu đề. Phiên bản</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx26">
<td> <p>: Một chức năng không phải thành viên do người dùng cung cấp với cùng chữ ký được xác định ở bất cứ đâu trong chương trình, trong bất kỳ tệp nguồn nào, thay thế phiên bản mặc định. Tuyên bố của nó không cần phải nhìn thấy.<a href="../../freestanding" title="cpp/freestanding">freestanding implementations</a>Chương trình không được hình thành, không cần chẩn đoán nếu có nhiều hơn một thay thế được cung cấp trong chương trình cho bất kỳ chức năng phân bổ có thể thay thế nào hoặc nếu thay thế được khai báo với<span class="t-v">.<a href="#Version_1">1-8</a>)</span>gọi trực tiếp các phiên bản ném tương ứng</p>
</td> <td><span class="t-mark-rev t-since-cxx26">(kể từ C ++ 26)</span></td>
</tr> </table> <div class="t-example">
<p>. Các triển khai thư viện tiêu chuẩn của các chức năng giải quyết nhận biết kích thước<code>operator</code>Gọi trực tiếp các chức năng giải quyết không biết kích thước tương ứng</p>
<div class="cpp source-cpp"><pre data-language="cpp">. Các triển khai thư viện tiêu chuẩn của các mẫu mảng ném kích thước không biết</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">gọi trực tiếp các biểu mẫu đối tượng đơn tương ứng</pre></div> </div> <p>    str.width (n);<code>operator new</code>Và<code>operator new[]</code>. Việc triển khai thư viện tiêu chuẩn của các phiên bản mảng ném<span class="t-v">.<a href="#Version_11">11-14</a>)</span>là đủ để xử lý tất cả các giao dịch.<i>Toàn cầu</i>.</p>
<p>trực tiếp gọi phiên bản đơn lẻ tương ứng<code>operator new</code> <span class="t-v">.<a href="#Version_9">9,10</a>)</span>#include &lt;CstDlib&gt;<span class="sy4">::</span><span class="me2">mới</span>. Do đó, việc thay thế các hàm phân bổ đối tượng duy nhất ném là đủ để xử lý tất cả các phân bổ.<span class="t-v">.<a href="#Version_19">19,20</a>)</span> <span class="kw4">Vô hiệu</span><span class="sy2">*</span>T<span class="sy4">::</span><span class="me2">nhà điều hành</span>mới<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">Điều đó cho tất cả<span class="me2">size_t</span></span></a>Thì<span class="kw4">Vô hiệu</span><span class="sy2">*</span><span class="br0">)</span>hoặc<span class="kw4">Vô hiệu</span><span class="sy2">*</span>T<span class="sy4">::</span><span class="me2">nhà điều hành</span>mới<span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span><span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">Điều đó cho tất cả<span class="me2">size_t</span></span></a>Thì<span class="kw4">Vô hiệu</span><span class="sy2">*</span><span class="br0">)</span>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>TRÊN<span class="kw4">Vô hiệu</span><span class="sy2">*</span>nhà điều hành mới<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">Điều đó cho tất cả<span class="me2">size_t</span></span></a>Thì<a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">Điều đó cho tất cả<span class="me2">size_t</span></span></a><span class="br0">)</span>, nó được xác định là xác định xem các phiên bản mặc định của<span class="kw4">Vô hiệu</span> <a href="http://en.cppreference.com/w/cpp/memory/new/operator_delete"><span class="kw690">Xóa toán tử</span></a><span class="br0">.</span><span class="kw4">Vô hiệu</span><span class="sy2">*</span>Thì<a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">Điều đó cho tất cả<span class="me2">size_t</span></span></a><span class="br0">)</span>thỏa mãn các hành vi cần thiết ở trên. Việc triển khai tự do được khuyến nghị rằng nếu bất kỳ phiên bản mặc định nào đáp ứng các yêu cầu của việc triển khai được lưu trữ, tất cả đều nên.</p>
</td> <td><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></td>
</tr> </table> <h3 id="Class-specific_overloads">{</h3> <p>với các tham số do người dùng xác định bổ sung ("biểu mẫu vị trí", các phiên bản<span class="t-v">.<a href="#Version_15">15-18</a>)</span>Các hình thức vị trí không phân bổ của thư viện tiêu chuẩn của<a href="../../language/new" title="cpp/language/new">new-expressions</a>cú pháp, bằng cách cung cấp một vị trí cụ thể của lớp mới<span class="sy4">::</span><span class="me2">mới</span> <a href="../../keyword/static" title="cpp/keyword/static"><code>static</code></a>Hình thức vị trí</p>
<p>không được phép vì chữ ký phù hợp của chức năng Deallocation,<a href="../../language/lookup" title="cpp/language/lookup">name lookup rules</a>, là một chức năng giải quyết thông thường (không phải vị trí).</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>Khi phân bổ các đối tượng và mảng các đối tượng có sự liên kết không vượt quá<code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>). Nếu được xác định, các chức năng phân bổ này được gọi bởi</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>#include &lt;CstDdef&gt;<code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>là tùy chọn cho các chức năng này: dù được sử dụng hay không, hàm phân bổ là hàm thành viên tĩnh.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Biểu thức mới tìm kiếm tên của hàm phân bổ phù hợp trước tiên trong phạm vi lớp và sau đó trong phạm vi toàn cầu. Lưu ý rằng theo</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">, Bất kỳ chức năng phân bổ nào được tuyên bố trong phạm vi lớp đều che giấu tất cả các hàm phân bổ toàn cầu cho các biểu hiện mới cố gắng phân bổ các đối tượng của lớp này.</pre></div> </div> <p>    str.width (n);<code>operator new</code>Và<code>operator new[]</code>Khi phân bổ các đối tượng và mảng các đối tượng có sự liên kết vượt quá<span class="t-v">.<a href="#Version_19">19-22</a>)</span>, độ phân giải quá tải được thực hiện hai lần: đầu tiên, để liên kết chữ ký chức năng nhận biết, sau đó để liên kết chữ ký chức năng liên kết. Điều này có nghĩa là nếu một lớp có căn chỉnh mở rộng có hàm phân bổ cụ thể của lớp liên kết, thì đó là hàm sẽ được gọi, chứ không phải hàm phân bổ nhận biết liên kết toàn cầu. Đây là cố ý: Thành viên lớp dự kiến ​​sẽ biết tốt nhất cách xử lý lớp đó.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>Khi phân bổ các đối tượng và mảng các đối tượng có sự liên kết không vượt quá<code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>, độ phân giải quá tải được thực hiện hai lần: đầu tiên, cho các chữ ký chức năng liên kết-không biết, sau đó cho các chữ ký chức năng nhận biết căn chỉnh.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>#include &lt;CstDdef&gt;<code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>#include &lt;Istream&gt;</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp"> </pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">// Các chức năng phân bổ cụ thể theo lớp</pre></div> </div> <p> <code>operator new</code>Void toán tử xóa (void* ptr) Noexcept<span class="kw4">Vô hiệu</span><span class="sy2">*</span>{<code><a href="../../types/size_t" title="cpp/types/size t">std::size_t</a></code>Cấu trúc x</p>
<h3 id="Notes">Ghi chú</h3> <p>{<span class="t-v">.<a href="#Version_9">9,10</a>)</span>    Tĩnh Void* Toán tử Mới (STD :: size_t Count)<code><a href="../allocator/construct" title="cpp/memory/allocator/construct">std::allocator::construct</a></code>    {<span class="sy4">::</span><span class="me2">mới</span>        std :: cout &lt;&lt; "tùy chỉnh mới cho kích thước" &lt;&lt; đếm &lt;&lt; '\ n';<span class="kw4">Vô hiệu</span><span class="sy2">*</span>.</p>
<p> </p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>Các chức năng sau được yêu cầu là an toàn cho luồng:</p>
<ul>
<li>Các phiên bản thư viện của<strong class="selflink"><code>operator new</code></strong>Và<a href="operator_delete" title="cpp/memory/new/operator delete"><code>operator delete</code></a> </li>
<li>Phiên bản thay thế người dùng của toàn cầu<strong class="selflink"><code>operator new</code></strong>Và<a href="operator_delete" title="cpp/memory/new/operator delete"><code>operator delete</code></a> </li>
<li> <code><a href="../c/calloc" title="cpp/memory/c/calloc">std::calloc</a></code>Thì<code><a href="../c/malloc" title="cpp/memory/c/malloc">std::malloc</a></code>Thì<code><a href="../c/realloc" title="cpp/memory/c/realloc">std::realloc</a></code><span class="t-rev-inl t-since-cxx17"><span>Thì<code><a href="../c/aligned_alloc" title="cpp/memory/c/aligned alloc">std::aligned_alloc</a></code></span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>Thì<code><a href="../c/free" title="cpp/memory/c/free">std::free</a></code> </li>
</ul> <p>Các cuộc gọi đến các chức năng này phân bổ hoặc xử lý một đơn vị lưu trữ cụ thể xảy ra trong một đơn đặt hàng duy nhất và mỗi cuộc gọi giải quyết như vậy<a href="../../atomic/memory_order" title="cpp/atomic/memory order">happens-before</a>Phân bổ tiếp theo (nếu có) theo thứ tự này.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <p>        return :: nhà điều hành mới (đếm);<code>operator new</code>    }<code><a href="../c/malloc" title="cpp/memory/c/malloc">std::malloc</a></code><span class="t-rev-inl t-since-cxx17"><span>hoặc<code><a href="../c/aligned_alloc" title="cpp/memory/c/aligned alloc">std::aligned_alloc</a></code></span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>.</p>
<p>Để tải một tệp lớn, ánh xạ tệp qua các chức năng dành riêng cho hệ điều hành, ví dụ:<a class="external text" href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/mmap.html" rel="nofollow"><code>mmap</code></a>trên posix hoặc<code>CreateFileMapping</code>.<a class="external text" href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga" rel="nofollow"><code>A</code></a>/<a class="external text" href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-createfilemappingw" rel="nofollow"><code>W</code></a>) cùng với<a class="external text" href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile" rel="nofollow"><code>MapViewOfFile</code></a>Trên Windows, tốt hơn là phân bổ bộ đệm để đọc tệp.</p>
<table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td rowspan="2"><a href="../../feature_test#cpp_lib_freestanding_operator_new" title="cpp/feature test"><code>__cpp_lib_freestanding_operator_new</code></a></td> <td><span class="nu0">202306L</span></td> <td><span class="t-mark">(C ++ 26)</span></td> <td> <sup class="reference" id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup> </td>
</tr> <tr> <td>hơn thứ hai và không nếu các đối số là tương đương.<span class="nu0">. Không làm gì khác.</span>hơn thứ hai và không nếu các đối số là tương đương.</td> <td><span class="t-mark">(C ++ 26)</span></td> <td>    Trình điều khiển void tĩnh* Mới [] (STD :: size_t Count)</td>
</tr>
</table> <ol class="references"> <li id="cite_note-1"> <span class="reference-text">    {<code>202306L</code>        std :: cout &lt;&lt; "tùy chỉnh mới [] cho kích thước" &lt;&lt; đếm &lt;&lt; '\ n';</span> </li> </ol> <h3 id="Defect_Reports">&gt; Multiset lớp;</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/521.html" rel="nofollow">CWG 521</a> </td> <td>C ++ 98</td> <td>        return :: nhà điều hành mới [] (đếm);<code><a href="bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>    }<br/>};<code><a href="bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code> </td> <td>int main ()<br/>{<code><a href="bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue9" rel="nofollow">LWG 9</a> </td> <td>C ++ 98</td> <td>    X* p1 = new x;<br/>    Xóa P1;</td> <td>    X* p2 = new x [10];<br/>    Xóa [] P2;<br/>}</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue206" rel="nofollow">LWG 206</a> </td> <td>C ++ 98</td> <td>tùy chỉnh mới cho kích thước 1<br/>tùy chỉnh mới [] cho kích thước 10<br/>với các tham số do người dùng xác định bổ sung ("Biểu mẫu vị trí"), cũng có thể được định nghĩa là thành viên lớp</td> <td>). Khi vị trí biểu thức mới với chữ ký phù hợp tìm kiếm hàm phân bổ tương ứng để gọi, nó bắt đầu ở phạm vi lớp trước khi kiểm tra phạm vi toàn cầu và nếu vị trí cụ thể của lớp được cung cấp, nó được gọi là.<br/>Khi phân bổ các đối tượng và mảng các đối tượng có sự liên kết vượt quá</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue404" rel="nofollow">LWG 404</a> </td> <td>C ++ 98</td> <td>, Độ phân giải quá tải cho các hình thức vị trí được thực hiện hai lần như cho các hình thức thông thường: đầu tiên, đối với chữ ký chức năng nhận biết căn chỉnh, sau đó cho chữ ký chức năng liên kết-không biết.<br/>    std :: printf ("6) xóa [] (void*, size_t), size = %zu \ n", size);<span class="kw1">};</span> </td> <td>    STD :: Miễn phí (PTR);</td>
</tr>
</table> <h3 id="References">Tài liệu tham khảo</h3> <ul>
<li>C ++ 23 Tiêu chuẩn (ISO/IEC 14882: 2023):</li>
<ul><li>Khi phân bổ các đối tượng và mảng các đối tượng có sự liên kết không vượt quá</li></ul>
<li>Tiêu chuẩn C ++ 20 (ISO/IEC 14882: 2020):</li>
<ul><li>, Độ phân giải quá tải cho các hình thức vị trí được thực hiện hai lần giống như các hình thức thông thường: đầu tiên, đối với chữ ký chức năng liên kết-không biết, sau đó để liên kết chữ ký chức năng nhận biết.</li></ul>
<li>Tiêu chuẩn C ++ 17 (ISO/IEC 14882: 2017):</li>
<ul><li>#include &lt;CstDdef&gt;</li></ul>
<li>Tiêu chuẩn C ++ 14 (ISO/IEC 14882: 2014):</li>
<ul><li>#include &lt;stdexcept&gt;</li></ul>
<li>Tiêu chuẩn C ++ 11 (ISO/IEC 14882: 2011):</li>
<ul><li>#include &lt;stdexcept&gt;</li></ul>
</ul> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="operator_delete" title="cpp/memory/new/operator delete"> <span class="t-lines"><span>Xóa toán tử</span><span>Xóa toán tử []</span></span></a></div> </td> <td>chức năng giải quyết<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="get_new_handler" title="cpp/memory/new/get new handler"> <span class="t-lines"><span>get_new_handler</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>có được trình xử lý mới hiện tại<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="set_new_handler" title="cpp/memory/new/set new handler"> <span class="t-lines"><span>set_new_handler</span></span></a></div> </td> <td>Đăng ký một trình xử lý mới<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../get_temporary_buffer" title="cpp/memory/get temporary buffer"> <span class="t-lines"><span>get_temden_buffer</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(không được dùng trong C ++ 17)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span></span></div> </td> <td>Có được lưu trữ không chính thức<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../c/malloc" title="cpp/memory/c/malloc"> <span class="t-lines"><span>MALLOC</span></span></a></div> </td> <td>phân bổ bộ nhớ<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../c/aligned_alloc" title="cpp/memory/c/aligned alloc"> <span class="t-lines"><span>căn chỉnh_alloc</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>Phân bổ bộ nhớ căn chỉnh<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/memory/new/operator_new">https://en.cppreference.com/w/cpp/memory/new/operator_new</a>
</p>
</div>
