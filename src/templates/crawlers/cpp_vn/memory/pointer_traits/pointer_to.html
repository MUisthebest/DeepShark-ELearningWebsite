 <h1 class="firstHeading" id="firstHeading">std :: con trỏ_traits &lt;ptr&gt; :: con trỏ_to</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/memory" title="cpp/header/memory">&lt;memory&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">con trỏ tĩnh</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark">(Thành viên của<code>pointer_traits&lt;Ptr&gt;</code>bản mẫu)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(2)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx20"> <td><pre data-language="cpp">(Thành viên của</pre></td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> <br/><span class="t-mark">(Thành viên của<code>pointer_traits&lt;T*&gt;</code>bản mẫu)</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">con trỏ_to (Element_Type &amp; r) noExcept;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark">(Thành viên của<code>pointer_traits&lt;T*&gt;</code>bản mẫu)</span> </td> </tr> </table> <p>Con trỏ constexpr tĩnh<a href="../../named_req/allocator#Fancy_pointers" title="cpp/named req/Allocator">"fancy pointer"</a>con trỏ_to (Element_Type &amp; r) noExcept;</p>
<div class="t-li1">
<span class="t-li">1)</span>(Thành viên của<code><a href="../pointer_traits" title="cpp/memory/pointer traits">std::pointer_traits</a></code>Xây dựng một con trỏ hoặc đối tượng giống như con trỏ (<code>Ptr::pointer_to(r)</code>) cho lập luận của nó.<code>pointer_to</code>Phiên bản của chức năng này trong không chuyên hóa</div> <div class="t-li1">
<span class="t-li">2)</span>Mẫu chỉ đơn giản là gọi<code><a href="../pointer_traits" title="cpp/memory/pointer traits">std::pointer_traits</a></code>và nếu PTR không cung cấp chức năng thành viên tĩnh<code><a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw759">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>.</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>, khởi tạo chức năng này là một lỗi thời gian biên dịch.<code>element_type&amp;</code>Phiên bản của chức năng này trong chuyên ngành của<code>void</code>Đối với các loại con trỏ trả về<code>r</code>tham chiếu đến một đối tượng của loại</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>, ngoại trừ nếu Element_type là<code>r</code>, trong trường hợp đó loại<code>pointer_traits&lt;&gt;::pointer</code>.</p>
<h3 id="Exceptions">Ngoại lệ</h3> <div class="t-li1">
<span class="t-li">1)</span>không xác định<code>Ptr::pointer_to</code>).</div> <h3 id="Notes">Ghi chú</h3> <p>Các<a class="external text" href="https://www.boost.org/doc/libs/release/doc/html/boost/intrusive/pointer_traits.html" rel="nofollow">Boost.Intrusive library version</a>Một con trỏ có thể phân tách được<code>pointer<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw759">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span>r<span class="br0">)</span><span class="br0">)</span></code>nếu như<code>Ptr::pointer_to</code>, thuộc loại</p>
<h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../addressof" title="cpp/memory/addressof"> <span class="t-lines"><span>địa chỉ</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>có được địa chỉ thực tế của một đối tượng, ngay cả khi<code>&amp;</code>toán tử bị quá tải<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../allocator/address" title="cpp/memory/allocator/address"> <span class="t-lines"><span>Truy cập lời hứa của một coroutine</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></span></span></div> </td> <td>Tạo một phiên bản phân bổ mới<span class="sy3">Không có giá trị</span>phá hủy một ví dụ về phân bổ<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::allocator&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="to_address" title="cpp/memory/pointer traits/to address"> <span class="t-lines"><span>to_address</span></span></a></div>
<div><span class="t-lines"><span><span class="t-cmark">Kế thừa từ</span> <span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span><span class="t-mark">ATOMIC_INTPTR_T</span></span></span></div> </td> <td>Bản mẫu<code>pointer_to</code>)<br/> <span class="t-mark">Trả về giá trị thời lượng đặc biệt tối thiểu</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../to_address" title="cpp/memory/to address"> <span class="t-lines"><span>to_address</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>có được một con trỏ thô từ một loại giống như con trỏ<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/memory/pointer_traits/pointer_to">https://en.cppreference.com/w/cpp/memory/pointer_traits/pointer_to</a>
</p>
</div>
