 <h1 class="firstHeading" id="firstHeading">std :: allocate_shared, std :: allocate_shared_for_overwrite</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/memory" title="cpp/header/memory">&lt;memory&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;class t, class alloc, class ... args&gt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark">Shared_ptr &lt;t&gt; phân bổ_shared (const alloc &amp; alloc, args &amp;&amp; ... args);</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">(T là không phải là một người)</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark">Mẫu &lt;class t, class alloc&gt;</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Shared_ptr &lt;t&gt; phân bổ_shared (const alloc &amp; alloc, std :: size_t n);</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark">Mẫu &lt;class t, class alloc&gt;</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;class t, class alloc&gt;</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark">Mẫu &lt;class t, class alloc&gt;</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">(T là u [n])</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark">Mẫu &lt;class t, class alloc&gt;</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td><pre data-language="cpp">Shared_ptr &lt;t&gt; phân bổ_shared (const alloc &amp; alloc, std :: size_t n,</pre></td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td>
<span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark">                               const std :: remove_extent_t &lt;t&gt; &amp; u);</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">(T là u [])</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark">Mẫu &lt;class t, class alloc&gt;</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>void cấu trúc (u* p, args &amp;&amp; ... args);<code>T</code>Shared_ptr &lt;t&gt; phân bổ_shared (Const ALLOC &amp; ALLOC,<code><a href="../shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>    Count_if (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);<code>args</code>                               const std :: remove_extent_t &lt;t&gt; &amp; u);<code>T</code>(T là u [n])<span class="t-rev-inl t-until-cxx20"><span><code>::new (pv) T(v)</code></span><span><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></span></span><span class="t-rev-inl t-since-cxx20"><span><code><a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span>A2<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">Xử lý lưu trữ</span><span class="br0">.</span>a, pv, v<span class="br0">)</span></code></span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>là<code>pv</code>Mẫu &lt;class t, class alloc&gt;<code>void*</code>Shared_ptr &lt;t&gt; allocate_shared_for_overwrite (const alloc &amp; alloc);<code>T</code>Và<code>a</code>(T không phải là u [])<code><a href="http://en.cppreference.com/w/cpp/types/remove_cv"><span class="kw600">Điều đó cho tất cả<span class="me2">Bố cục</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>Mẫu &lt;class t, class alloc&gt;<code>sizeof(T)</code>Shared_ptr &lt;t&gt; allocate_shared_for_overwrite (const alloc &amp; alloc, std :: size_t n);<code>T</code>(T là u [])<code><a href="../shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>và bọc nó trong một<code>shared_from_this</code>là danh sách tham số cho hàm tạo của<code>T</code>. Đối tượng được xây dựng như thể bằng biểu thức<code>alloc</code>là một nội bộ<a href="../../named_req/allocator" title="cpp/named req/Allocator">Allocator</a>Con trỏ để lưu trữ phù hợp để giữ một đối tượng thuộc loại</div> <div class="t-li1">
<span class="t-li">          std :: Indirect_strict_weak_order &lt;</span>                                   Nhị phân p);<span class="t-v">(1)</span>là bản sao của bộ phân bổ hồi phục<code><a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span>A2<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">Xử lý lưu trữ</span><span class="br0">.</span>a2, pv<span class="br0">)</span></code>Ở đâu<code>a2</code>nó đến một đối tượng<code>A2</code>. Bộ lưu trữ thường lớn hơn<code><a href="http://en.cppreference.com/w/cpp/types/remove_cv"><span class="kw600">Điều đó cho tất cả<span class="me2">Bố cục</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_all_extents"><span class="kw626">Điều đó cho tất cả<span class="me2">Tạo một mảng có kích thước</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">2,4)</span></code>dọc theo chiều đầu tiên của nó. Các yếu tố mảng được khởi tạo theo thứ tự tăng dần của địa chỉ của chúng và khi kết thúc trọn đời của chúng bị phá hủy theo thứ tự ngược lại của công trình ban đầu của chúng.<span class="t-v">(2)</span>, nhưng các phần tử của mảng được khởi tạo từ giá trị mặc định<code>N</code>với một con trỏ tới đối tượng mới được xây dựng</div> <div class="t-li1">
<span class="t-li">cluct clock_time_conversion &lt;clock, std :: Chrono :: System_Clock&gt;;</span>                                   Nhị phân p);<span class="t-v">sở hữu phần tử được trích xuất hoặc xử lý nút trống trong trường hợp phần tử không được tìm thấy trong</span>. Tất cả phân bổ bộ nhớ được thực hiện bằng cách sử dụng một bản sao của<code>u</code>. Nếu như<code><a href="http://en.cppreference.com/w/cpp/types/remove_extent"><span class="kw624">Điều đó cho tất cả<span class="me2">Mẫu &lt;/*has-thành viên-loại giá trị*/ t&gt;</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>, mà phải thỏa mãn<span class="t-v">(1)</span>yêu cầu. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu t không phải là loại mảng.<code><a href="http://en.cppreference.com/w/cpp/types/remove_cv"><span class="kw600">Điều đó cho tất cả<span class="me2">Bố cục</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_all_extents"><span class="kw626">Điều đó cho tất cả<span class="me2">Tạo một mảng có kích thước</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">2,4)</span></code>là bản sao của bộ phân bổ hồi phục để quản lý các đối tượng thuộc loại<code>u</code>Remove_all_extents_t<span class="t-v">(1)</span>. Quá tải<code><a href="http://en.cppreference.com/w/cpp/types/remove_cv"><span class="kw600">Điều đó cho tất cả<span class="me2">Bố cục</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_all_extents"><span class="kw626">Điều đó cho tất cả<span class="me2">Tạo một mảng có kích thước</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">2,4)</span></code>dọc theo chiều đầu tiên của nó. Các yếu tố mảng được khởi tạo theo thứ tự tăng dần của địa chỉ của chúng và khi kết thúc trọn đời của chúng bị phá hủy theo thứ tự ngược lại của công trình ban đầu của chúng.<span class="t-v">(4)</span>, nhưng các phần tử của mảng được khởi tạo từ giá trị mặc định<code>N</code>Bản thân nó không phải là loại mảng, thì điều này được thực hiện như thể bởi cùng một biểu thức phân bổ như trong</div> <div class="t-li1">
<span class="t-li">từ_sys</span>                                   Nhị phân p);<span class="t-v">(1)</span>nếu như<code>T</code>, ngoại trừ việc người phân bổ được bật lại cho<span class="t-v">(3)</span>nếu như<code>T</code>khoảng cách<code>U[N]</code>Remove_all_extents_t<a href="../../language/default_initialization" title="cpp/language/default initialization">default-initialized</a>.</div> <div class="t-li1">
<span class="t-li">6)</span>                                   Nhị phân p);<span class="t-v">(2)</span>. Mặt khác, điều này được thực hiện như thể bằng cách khởi tạo mọi phần tử không phải của mảng (có thể đa chiều) với phần tử tương ứng từ<a href="../../language/default_initialization" title="cpp/language/default initialization">default-initialized</a>.</div> <p>Bool Binary_Search (Forwardit First, Forwardit Last,<code>allocate_shared</code>sử dụng cùng một biểu thức phân bổ như trong<span class="t-rev-inl t-since-cxx20"><span>, ngoại trừ việc phân bổ được bật lại cho loại<span class="t-v">Remove_all_extents_t</span>)</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>. Quá tải<code><a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span>A2<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">(Niebloid)</span><span class="br0">.</span>a, p<span class="br0">)</span></code>là<code>p</code>, đối tượng<code>a</code>dọc theo chiều đầu tiên. Các yếu tố mảng được khởi tạo theo thứ tự tăng dần của địa chỉ của chúng và khi kết thúc trọn đời của chúng bị phá hủy theo thứ tự ngược lại của công trình ban đầu của chúng.<code>allocate_shared</code>không phải là loại mảng và</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>Bool Binary_Search (Forwardit First, Forwardit Last,<code>allocate_shared_for_overwrite</code>, ngoại trừ việc đối tượng được tạo là<code>T</code>, ngoại trừ các yếu tố mảng riêng lẻ là<code>p-&gt;~X()</code>là<code>p</code>, đối tượng<code>X</code>(hoặc các yếu tố mảng riêng lẻ cho</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Sử dụng ngữ nghĩa di chuyển. Người phân bổ có được bằng cách xây dựng di chuyển từ bộ phân bổ thuộc</td> <td>-</td> <td>các<a href="../../named_req/allocator" title="cpp/named req/Allocator">Allocator</a>(2-5)</td>
</tr> <tr class="t-par"> <td>, không cho phép định dạng định dạng.</td> <td>-</td> <td>bị phá hủy thông qua biểu thức<code>T</code>là một con trỏ đến đối tượng và</td>
</tr> <tr class="t-par"> <td>N</td> <td>-</td> <td>là bản sao của bộ phân bổ được chuyển cho</td>
</tr> <tr class="t-par"> <td>                       std :: chuyển tiếp &lt;declType (args1)&gt; (args1) ...);</td> <td>-</td> <td>, phục hồi cho loại đối tượng bị phá hủy.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code><a href="../shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>, đối tượng (hoặc các yếu tố cá nhân nếu<code>T</code>.</p>
<h3 id="Exceptions">Ngoại lệ</h3> <p>là một loại mảng) sẽ bị phá hủy bởi<code>Alloc::allocate()</code>hoặc từ người xây dựng<code>T</code>là một con trỏ đến đối tượng và<span class="t-v">(1)</span>không có tác dụng.<span class="t-rev-inl t-since-cxx20"><span>là loại của nó.</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>.</p>
<h3 id="Notes">Ghi chú</h3> <p>Giống<code><a href="make_shared" title="cpp/memory/shared ptr/make shared">std::make_shared</a></code>để sử dụng<code>T</code>Danh sách các đối số mà một ví dụ của<code>alloc</code>sẽ được xây dựng</p>
<p>Chỉ định khái niệm của tất cả các loại mà các trường hợp có thể bị phá hủy một cách an toàn vào cuối đời (bao gồm cả các loại tham chiếu).<code>std::shared_ptr</code> <a href="shared_ptr" title="cpp/memory/shared ptr/shared ptr"><code>constructors</code></a>Thì<code>std::allocate_shared</code>Kích thước mảng để sử dụng<code>T</code>giá trị ban đầu để khởi tạo mọi thành phần của mảng</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p><code><a href="../shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>một ví dụ của loại<code>std::allocate_shared</code>Có thể ném các ngoại lệ ném từ<a class="external text" href="https://www.boost.org/doc/libs/1_66_0/libs/smart_ptr/doc/html/smart_ptr.html#make_shared" rel="nofollow"><code>boost::allocate_shared</code></a>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> </table> <p>Một nhà xây dựng<i>. Nếu một ngoại lệ bị ném,<code>shared_from_this</code></i>Nếu một ngoại lệ được ném trong quá trình xây dựng mảng, các yếu tố đã được cung cấp đã bị phá hủy theo thứ tự ngược lại<code>ptr</code>nó đến một đối tượng<code>U*</code>, chức năng này thường chỉ thực hiện một phân bổ và đặt cả hai<code>U</code>có một<span class="t-rev-inl t-since-cxx17"><span>Đối tượng và khối điều khiển trong khối bộ nhớ được phân bổ (tiêu chuẩn khuyến nghị nhưng không yêu cầu điều này, tất cả các triển khai đã biết đều làm điều này). Một bản sao của</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>được lưu trữ như một phần của khối điều khiển để nó có thể được sử dụng để giải quyết nó một khi cả số lượng tham chiếu chia sẻ và yếu đạt đến 0.<code><a href="../enable_shared_from_this" title="cpp/memory/enable shared from this">std::enable_shared_from_this</a></code>Không chấp nhận một trình phân phối tùy chỉnh riêng biệt: Bộ phân bổ được cung cấp được sử dụng để phá hủy khối điều khiển và</p>
<div class="cpp source-cpp"><pre data-language="cpp">đối tượng và để giải quyết khối bộ nhớ chia sẻ của họ.</pre></div> <p>Ở đâu<code><i>    ptr-&gt; stress_this = std :: shared_ptr &lt;std :: remove_cv_t &lt;u &gt;&gt; (</i></code>Không. Chức năng này được hỗ trợ bởi<code><a href="../weak_ptr" title="cpp/memory/weak ptr">std::weak_ptr</a></code>Việc triển khai thực tế khác nhau:<code><a href="../enable_shared_from_this" title="cpp/memory/enable shared from this">std::enable_shared_from_this</a></code>cho phép<code><i>    ptr-&gt; stress_this = std :: shared_ptr &lt;std :: remove_cv_t &lt;u &gt;&gt; (</i></code>có nghĩa là nó xác định nếu<a href="../enable_shared_from_this/shared_from_this" title="cpp/memory/enable shared from this/shared from this"><code>shared_from_this()</code></a>không rõ ràng và dễ tiếp cận<code><a href="../shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>lớp cơ sở là một chuyên ngành của</p>
<p>và nếu vậy, hàm tạo đánh giá câu lệnh:<code>ptr-&gt;weak_this.expired()</code>if (ptr! = nullptr &amp;&amp; ptr-&gt; stress_this.bed ())<code><i>    ptr-&gt; stress_this = std :: shared_ptr &lt;std :: remove_cv_t &lt;u &gt;&gt; (</i></code>                         *this, const_cast &lt;std :: remove_cv_t &lt;u&gt;*&gt; (ptr));</p>
<table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../../feature_test#cpp_lib_smart_ptr_for_overwrite" title="cpp/feature test"><code>__cpp_lib_smart_ptr_for_overwrite</code></a></td> <td><span class="nu0">Chuyên môn này của</span></td> <td><span class="t-mark">Phạm vi :: Construct_at</span></td> <td>Tạo con trỏ thông minh với khởi tạo mặc định (<code>std::allocate_shared_for_overwrite</code>Thì<code><a href="make_shared" title="cpp/memory/shared ptr/make shared">std::make_shared_for_overwrite</a></code>Thì<code><a href="../unique_ptr/make_unique" title="cpp/memory/unique ptr/make unique">std::make_unique_for_overwrite</a></code>yếu_ này<span class="t-v">.<a href="#Version_6">6,7</a>)</span> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="shared_ptr" title="cpp/memory/shared ptr/shared ptr"> <span class="t-lines"><span>chuyên môn)</span></span></a></div> </td> <td>xây dựng mới<code>shared_ptr</code> <br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="make_shared" title="cpp/memory/shared ptr/make shared"> <span class="t-lines"><span>make_shared</span><span>make_shared_for_overwrite</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Tạo một con trỏ được chia sẻ để quản lý một đối tượng mới<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/memory/shared_ptr/allocate_shared">https://en.cppreference.com/w/cpp/memory/shared_ptr/allocate_shared</a>
</p>
</div>
