 <h1 class="firstHeading" id="firstHeading">std :: out_ptr_t &lt;thông minh, con trỏ, args ...&gt; :: ~ out_ptr_t</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">~ out_ptr_t ();</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> </table> <p>Đặt lại các điều chỉnh<code>Smart</code>đối tượng theo giá trị của đã sửa đổi<code>Pointer</code>đối tượng (hoặc<code>void*</code>Đối tượng nếu<code>operator void**()</code>đã được gọi) và các đối số bị bắt.</p>
<p>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;</p>
<ul>
<li> <code>s</code>biểu thị điều chỉnh<code>Smart</code>sự vật,</li>
<li> <code>args...</code>biểu thị các đối số bị bắt,</li>
<li> <code>p</code>biểu thị giá trị của được lưu trữ<code>Pointer</code>, hoặc<code>static_cast&lt;Pointer&gt;(*operator void**())</code>nếu như<code>operator void**</code>đã được gọi,</li>
<li> <code>SP</code>{<ul>
<li> <code>Smart::pointer</code>, nếu không thì,</li>
<li> <code>Smart::element_type*</code>Sử dụng chức năng nhị phân đã cho<code>Smart::element_type</code>, nếu nó hợp lệ và biểu thị một loại, nếu không,</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/memory/pointer_traits"><span class="kw758">Điều đó cho tất cả<span class="me2">con trỏ_traits</span></span></a><span class="sy1">is_trivently_destructible_v</span>Smart<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">                          std :: remove_cv_t &lt;typename t :: value_type &gt;&gt;</span><span class="sy2">*</span></code>Sử dụng chức năng nhị phân đã cho<code><a href="http://en.cppreference.com/w/cpp/memory/pointer_traits"><span class="kw758">Điều đó cho tất cả<span class="me2">con trỏ_traits</span></span></a><span class="sy1">is_trivently_destructible_v</span>Smart<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">                          std :: remove_cv_t &lt;typename t :: value_type &gt;&gt;</span></code>, nếu nó hợp lệ và biểu thị một loại, nếu không,</li>
<li> <code>Pointer</code>.</li>
</ul> </li>
</ul> <p>Nếu như<code>s.<span class="me1">cài lại</span><span class="br0">.</span><span class="kw1">Mẫu &lt;Biểu đồ lớp, Đặc điểm lớp, Alloc Class, Class Parsable&gt;</span><span class="sy1">is_trivently_destructible_v</span>SP<span class="sy1">&lt;</span><span class="br0">.</span>p<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span>args<span class="br0">)</span>...<span class="br0">)</span></code>được hình thành tốt, chất phá hủy thực hiện<code><span class="kw1">nếu như</span> <span class="br0">.</span>p<span class="br0">)</span> s.<span class="me1">cài lại</span><span class="br0">.</span><span class="kw1">Mẫu &lt;Biểu đồ lớp, Đặc điểm lớp, Alloc Class, Class Parsable&gt;</span><span class="sy1">is_trivently_destructible_v</span>SP<span class="sy1">&lt;</span><span class="br0">.</span>p<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span>args<span class="br0">)</span>...<span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>Thì</p>
<p>    int n = 1;<code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw528">Điều đó cho tất cả<span class="me2">, sao chép-khởi tạo phần tử tương ứng của kết quả với</span></span></a><span class="sy1">is_trivently_destructible_v</span>Smart, SP, Args...<span class="sy1">&lt;</span></code>khoảng cách<code>true</code>, Destructor thực hiện<code><span class="kw1">nếu như</span> <span class="br0">.</span>p<span class="br0">)</span> s <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> Smart<span class="br0">.</span><span class="kw1">Mẫu &lt;Biểu đồ lớp, Đặc điểm lớp, Alloc Class, Class Parsable&gt;</span><span class="sy1">is_trivently_destructible_v</span>SP<span class="sy1">&lt;</span><span class="br0">.</span>p<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span>args<span class="br0">)</span>...<span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>Thì</p>
<p>Nếu không, chương trình là xấu.</p>
<h3 id="Notes">Ghi chú</h3> <p>Nếu như<code>Smart</code>Điều đó như vậy<code><a href="../shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>Chuyên môn hóa, việc triển khai có thể phân bổ lưu trữ cho khối điều khiển mới về xây dựng, để để lại các công trình không ném cho chất phá hủy.</p>
<p>Các đối số được nắm bắt bởi giá trị bị phá hủy sau khi đặt lại.</p>
<div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/memory/out_ptr_t/%7Eout_ptr_t">https://en.cppreference.com/w/cpp/memory/out_ptr_t/%7Eout_ptr_t</a>
</p>
</div>
