 <h1 class="firstHeading" id="firstHeading">STD :: độc đáo_ptr</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/memory" title="cpp/header/memory">&lt;memory&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">mẫu &lt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">    lớp T,</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> </table> <p><code>std::unique_ptr</code>    Lớp Deleter = std :: default_delete &lt;t&gt;<code>unique_ptr</code>&gt; lớp độc đáo_ptr;</p>
<p>mẫu &lt;</p>
<ul>
<li>&gt; lớp độc đáo_ptr &lt;t [], deleter&gt;;<code>unique_ptr</code>    Lớp Deleter</li>
<li>&gt; lớp độc đáo_ptr &lt;t [], deleter&gt;;<code>unique_ptr</code>là một con trỏ thông minh sở hữu và quản lý một đối tượng khác thông qua một con trỏ và xử lý đối tượng đó khi<code><a href="unique_ptr/operator=" title="cpp/memory/unique ptr/operator=">operator=</a></code>hoặc<code><a href="unique_ptr/reset" title="cpp/memory/unique ptr/reset">reset()</a></code>.</li>
</ul> <p>đi ra khỏi phạm vi.<code>get_deleter()(ptr)</code>Đối tượng được xử lý, bằng cách sử dụng Deleter liên quan khi một trong hai điều sau đây xảy ra:<code>delete</code>quản lý</p>
<p>MỘT<code>unique_ptr</code>đối tượng bị phá hủy.<i>trống</i>.</p>
<p>quản lý<code>std::unique_ptr</code>:</p>
<ol>
<li>đối tượng được gán một con trỏ khác thông qua<code>new</code>).</li>
<li>Đối tượng được xử lý, sử dụng một trình phân phối có khả năng do người dùng cung cấp bằng cách gọi<code>new[]</code>).</li>
</ol> <p>. Deleter mặc định sử dụng<a href="../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>Và<a href="../named_req/moveassignable" title="cpp/named req/MoveAssignable">MoveAssignable</a>toán tử, phá hủy đối tượng và xử lý bộ nhớ.<a href="../named_req/copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>constexpr outputit độc đáo_copy (đầu vào đầu tiên, đầu vào cuối cùng,<a href="../named_req/copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a>.</p>
<table class="t-par-begin"> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>Deleter</code>// thực hiện đầu tiên<a href="../named_req/functionobject" title="cpp/named req/FunctionObject">FunctionObject</a>có thể sở hữu không có đối tượng, trong trường hợp đó được gọi là<a href="../named_req/functionobject" title="cpp/named req/FunctionObject">FunctionObject</a>Có hai phiên bản của<code>unique_ptr&lt;T, Deleter&gt;::pointer</code>.</td>
</tr>
</table> <h3 id="Notes">Ghi chú</h3> <p>Quản lý một đối tượng duy nhất (ví dụ: được phân bổ với<code>unique_ptr</code>Quản lý một mảng đối tượng được phân bổ động (ví dụ: được phân bổ với<code>unique_ptr</code>Lớp đáp ứng các yêu cầu của<code>const std::unique_ptr</code>, nhưng không</p>
<p><code>std::unique_ptr</code>hoặc tham chiếu lvalue cho một</p>
<ul>
<li>hoặc tham chiếu lvalue cho chức năng, có thể gọi với một đối số loại</li>
<li>Chỉ không phải là const</li>
<li>có thể chuyển quyền sở hữu đối tượng được quản lý sang một đối tượng được quản lý</li>
<li>. Nếu cuộc sống của một đối tượng được quản lý bởi một<code><a href="../container/vector" title="cpp/container/vector">std::vector</a></code>, nó được giới hạn trong phạm vi mà con trỏ được tạo ra.</li>
</ul> <p><code>std::unique_ptr</code>thường được sử dụng để quản lý tuổi thọ của các đối tượng, bao gồm:<a class="mw-redirect" href="../language/incomplete_type" title="cpp/language/incomplete type">incomplete type</a> <code>T</code>Cung cấp an toàn ngoại lệ cho các lớp và các chức năng xử lý các đối tượng có tuổi thọ động, bằng cách đảm bảo xóa trên cả thoát và thoát thông thường thông qua ngoại lệ.<a href="../language/pimpl" title="cpp/language/pimpl">pImpl idiom</a>Quyền sở hữu của các đối tượng thuộc sở hữu độc đáo với tuổi thọ năng động thành các chức năng.<code>T</code>Có được quyền sở hữu các đối tượng thuộc sở hữu duy nhất với tuổi thọ năng động từ các chức năng.<code>reset</code>chế độ<code>std::unique_ptr</code>là loại phần tử trong các thùng chứa nhận biết di chuyển, chẳng hạn như<code><a href="shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>, giữ các con trỏ đến các đối tượng được phân bổ động (ví dụ: nếu hành vi đa hình là mong muốn).<code>T</code>có thể được xây dựng cho một<code>T</code>, chẳng hạn như để tạo điều kiện cho việc sử dụng như một tay cầm trong<code>unique_ptr</code>. Nếu Deleter mặc định được sử dụng,<code>!p</code>Trả về kết quả của hội nghị derefering<code>T</code>phải hoàn thành tại điểm trong mã mà Deleter được gọi, điều này xảy ra trong bộ hủy diệt, di chuyển toán tử chuyển nhượng và<a href="../language/adl" title="cpp/language/adl">ADL</a>.</p>
<p>Nếu như<code>T</code>Điều đó như vậy<a href="../language/derived_class" title="cpp/language/derived class">derived class</a>. (Ngược lại,<code>B</code>, sau đó<code>std::unique_ptr&lt;T&gt;</code>khoảng cách<a href="unique_ptr/unique_ptr" title="cpp/memory/unique ptr/unique ptr">implicitly convertible</a>ĐẾN<code>std::unique_ptr&lt;B&gt;</code>không thể được xây dựng từ một con trỏ thô sang loại không hoàn chỉnh, nhưng có thể bị phá hủy ở đâu<code>std::unique_ptr&lt;B&gt;</code>không đầy đủ). Lưu ý rằng nếu<a href="new/operator_delete" title="cpp/memory/new/operator delete">operator delete</a>vì<code>B</code>là một chuyên ngành mẫu lớp, sử dụng<a href="../language/destructor#Virtual_destructors" title="cpp/language/destructor">undefined behavior</a>Là một toán hạng, ví dụ:<code>B</code>khoảng cách<a href="../language/virtual" title="cpp/language/virtual">virtual</a>. Lưu ý rằng<code><a href="shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>Các tham số của<code><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw735">Điều đó cho tất cả<span class="me2">Shared_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>B<span class="sy1">&lt;</span></code>của một số cơ sở<a href="new/operator_delete" title="cpp/memory/new/operator delete">operator delete</a>cho loại<code>T</code>. Việc xóa mặc định của kết quả<code>B</code># Elif __has_include (&lt;thử nghiệm/tùy chọn&gt;) // Kiểm tra phiên bản thử nghiệm<a href="../language/virtual" title="cpp/language/virtual">virtual</a>.</p>
<p>Không gian tên std :: Phạm vi<code><a href="shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>Thì<code>std::unique_ptr</code>sẽ sử dụng<a href="../named_req/nullablepointer" title="cpp/named req/NullablePointer">NullablePointer</a>, dẫn đến<code>Deleter</code>Trừ khi kẻ hủy diệt của<code>typedef <a class="external text" href="https://www.boost.org/doc/libs/release/doc/html/boost/interprocess/offset_ptr.html" rel="nofollow">boost::offset_ptr</a> pointer;</code>hành xử khác nhau:<a href="../named_req/allocator#Fancy_pointers" title="cpp/named req/Allocator">fancy pointer</a>.</p>
<table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../feature_test#cpp_lib_constexpr_memory" title="cpp/feature test"><code>__cpp_lib_constexpr_memory</code></a></td> <td><span class="nu0">và không trả lại gì.</span></td> <td><span class="t-mark">Phạm vi :: IOTA</span></td> <td>
<span class="kw4">constexpr</span> <a href="#top"><code>std::unique_ptr</code></a> </td>
</tr>
</table> <h3 id="Member_types">nhà điều hành ()</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>ATOMIC_UNSIGNED_LOCK_FREE</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td>Không làm mất hiệu lực bất kỳ tài liệu tham khảo nào về các yếu tố của deque.</td> <td> <code><a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw609">Điều đó cho tất cả<span class="me2">remove_reference</span></span></a><span class="sy1">is_trivently_destructible_v</span>Deleter<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">kiểu</span><span class="sy4">::</span><span class="me2">Không làm mất hiệu lực bất kỳ tài liệu tham khảo nào về các yếu tố của deque.</span></code>sẽ sử dụng<code>T*</code>và đối tượng thuộc sở hữu sẽ bị xóa chính xác ngay cả khi bộ hủy diệt của<a href="../named_req/nullablepointer" title="cpp/named req/NullablePointer">NullablePointer</a> </td>
</tr> <tr class="t-dsc"> <td>                          std :: remove_cv_t &lt;typename t :: value_type &gt;&gt;</td> <td> <code>T</code>có thể quản lý một đối tượng thông qua bất kỳ loại tay cầm tùy chỉnh nào thỏa mãn<code>unique_ptr</code> </td>
</tr> <tr class="t-dsc"> <td>. Điều này cho phép, ví dụ, quản lý các đối tượng nằm trong bộ nhớ chung, bằng cách cung cấp</td> <td> <code>Deleter</code>Điều đó xác định</td>
</tr> </table> <h3 id="Member_functions">nếu không thì</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="unique_ptr/unique_ptr" title="cpp/memory/unique ptr/unique ptr"> <span class="t-lines"><span>chuyên môn)</span></span></a></div> </td> <td>xây dựng một mới<code>unique_ptr</code> <br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unique_ptr/~unique_ptr" title="cpp/memory/unique ptr/~unique ptr"> <span class="t-lines"><span>một đối tượng ngoại lệ khác để gán với</span></span></a></div> </td> <td>hoặc khác<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unique_ptr/operator=" title="cpp/memory/unique ptr/operator="> <span class="t-lines"><span>chuyên môn)</span></span></a></div> </td> <td>Đề cập đến Coroutines No-Op. Nó không thể được tạo ra từ một đối tượng hứa hẹn.<code>unique_ptr</code> <br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Modifiers">Sửa đổi</h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unique_ptr/release" title="cpp/memory/unique ptr/release"> <span class="t-lines"><span>giải phóng</span></span></a></div> </td> <td>Nếu loại đó tồn tại, nếu không<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unique_ptr/reset" title="cpp/memory/unique ptr/reset"> <span class="t-lines"><span>cài lại</span></span></a></div> </td> <td>Thay thế đối tượng được quản lý<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unique_ptr/swap" title="cpp/memory/unique ptr/swap"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>hoán đổi các đối tượng được quản lý<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Observers">Quan sát viên</h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unique_ptr/get" title="cpp/memory/unique ptr/get"> <span class="t-lines"><span>Điền vào thùng chứa với giá trị được chỉ định</span></span></a></div> </td> <td>Trả về một con trỏ cho đối tượng được quản lý<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unique_ptr/get_deleter" title="cpp/memory/unique ptr/get deleter"> <span class="t-lines"><span>get_deleter</span></span></a></div> </td> <td>. Phải thỏa mãn<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unique_ptr/operator_bool" title="cpp/memory/unique ptr/operator bool"> <span class="t-lines"><span>(hằng số thành viên tĩnh công cộng)</span></span></a></div> </td> <td>, loại đối tượng được quản lý bởi điều này<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Single-object_version.2C_unique_ptr.3CT.3E">deleter_type<code>unique_ptr&lt;T&gt;</code> </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unique_ptr/operator*" title="cpp/memory/unique ptr/operator*"> <span class="t-lines"><span>toán tử/=</span><span>toán tử-&gt;</span></span></a></div> </td> <td>    Mẫu &lt;Typename T&gt;<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Array_version.2C_unique_ptr.3CT.5B.5D.3E">, đối tượng chức năng hoặc tham chiếu lvalue cho chức năng hoặc đối tượng chức năng, được gọi từ chất phá hủy<code>unique_ptr&lt;T[]&gt;</code> </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unique_ptr/operator_at" title="cpp/memory/unique ptr/operator at"> <span class="t-lines"><span>nhà điều hành []</span></span></a></div> </td> <td>#include &lt;Istream&gt;<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <h3 id="Non-member_functions">Các chức năng không phải thành viên</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="unique_ptr/make_unique" title="cpp/memory/unique ptr/make unique"> <span class="t-lines"><span>make_unique</span><span>make_unique_for_overwrite</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C ++ 14)</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Tạo một con trỏ độc đáo quản lý một đối tượng mới<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unique_ptr/operator_cmp" title="cpp/memory/unique ptr/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>So sánh với người khác<code>unique_ptr</code>là một Symlink hiện có, bản thân nó bị xóa, không phải là mục tiêu của nó.<code>nullptr</code> <br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unique_ptr/operator_ltlt" title="cpp/memory/unique ptr/operator ltlt"> <span class="t-lines"><span>toán tử &lt;&lt;<span class="t-dsc-small">Thuật toán</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>đầu ra giá trị của con trỏ được quản lý đến luồng đầu ra<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unique_ptr/swap2" title="cpp/memory/unique ptr/swap2"> <span class="t-lines"><span>chuyên về<span class="t-dsc-small">Thuật toán</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>quá tải<code><a href="../algorithm/swap" title="cpp/algorithm/swap">std::swap</a></code>Thuật toán<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <h3 id="Helper_classes">Lớp học trợ giúp</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="unique_ptr/hash" title="cpp/memory/unique ptr/hash"> <span class="t-lines"><span>STD :: Hash<span class="t-dsc-small">&lt;std :: độc đáo_ptr&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>Hỗ trợ băm cho<strong class="selflink"><code>std::unique_ptr</code></strong> <br/> <span class="t-mark">(Chuyên ngành mẫu lớp)</span> </td>
</tr> </table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">phá hủy đối tượng được quản lý nếu có mặt đó</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">Trả về một con trỏ cho đối tượng được quản lý và phát hành quyền sở hữu</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="shared_ptr" title="cpp/memory/shared ptr"> <span class="t-lines"><span>Shared_ptr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>Con trỏ thông minh với ngữ nghĩa sở hữu đối tượng được chia sẻ<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="weak_ptr" title="cpp/memory/weak ptr"> <span class="t-lines"><span>yếu_ptr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>tham chiếu yếu đến một đối tượng được quản lý bởi<code><a href="shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code> <br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/memory/unique_ptr">https://en.cppreference.com/w/cpp/memory/unique_ptr</a>
</p>
</div>
