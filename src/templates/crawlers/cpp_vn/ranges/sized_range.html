 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: Kích thước_range, std :: phạm vi :: vô hiệu hóa_sized_range</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/ranges" title="cpp/header/ranges">&lt;ranges&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Khái niệm có kích thước_range = phạm vi :: phạm vi &lt;t&gt; &amp;&amp;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Các<code>sized_range</code>    Yêu cầu (t &amp; t) {<a href="range" title="cpp/ranges/range"><code>range</code></a>        Phạm vi :: kích thước (t);<code>size</code>    skip_existing = / * không xác định * /,</div> <div class="t-li1">
<span class="t-li">2)</span> <code>disable_sized_range</code>    };<code>size</code>Mẫu &lt;Slass&gt;<code>sized_range</code>Inline Consexpr bool vô hiệu hóa_sized_range = false;<code>disable_sized_range</code>khái niệm chỉ định các yêu cầu của một<a href="../language/constant_expression" title="cpp/language/constant expression">constant expressions</a>    Inline Consexpr bool vô hiệu hóa_sized_sentinel_for = false;<code>const bool</code>.</div> <h3 id="Semantic_requirements">        const std :: remove_reference_t &lt;lhs&gt; &amp;,</h3> <span class="t-li">1)</span>loại biết kích thước của nó trong thời gian không đổi với<code>t</code>nó đến một đối tượng<code><a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>Thì<code>T</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<code>sized_range</code>  Phạm vi :: end (t);<ul>
<li> <code><a href="http://en.cppreference.com/w/cpp/ranges/size"><span class="kw3099">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kích cỡ</span></span></a><span class="br0">.</span>t<span class="br0">)</span></code> </li>
<ul>
<li>tồn tại để cho phép sử dụng các loại phạm vi cung cấp</li>
<li>chức năng (là thành viên hoặc là một thành viên) nhưng thực tế không phải là mô hình<code>t</code>Khái niệm xác định các yêu cầu của một loại cho phép lặp qua các phần tử của nó bằng cách cung cấp một trình lặp và sentinel biểu thị các phần tử của phạm vi.<a href="../concepts#Equality_preservation" title="cpp/concepts">equality-preserving</a>như vậy mà từ chối</li>
<li>hoặc một loại chính sách thực thi được xác định theo thực hiện. Nếu không thì,<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3141">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>t<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>t<span class="br0">)</span><span class="br0">)</span></code>, Và</li>
</ul>
<li>nếu như<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2890">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    khoảng cách (r &amp;&amp; r);</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../iterator/forward_iterator" title="cpp/iterator/forward iterator"><code>forward_iterator</code></a>Thì<code><a href="http://en.cppreference.com/w/cpp/ranges/size"><span class="kw3099">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kích cỡ</span></span></a><span class="br0">.</span>t<span class="br0">)</span></code>. Người dùng có thể chuyên<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>t<span class="br0">)</span></code>Đối với các loại được xác định theo chương trình CV. Những chuyên môn như vậy sẽ có thể sử dụng được trong</li>
</ul> <h3 id="Notes">Ghi chú</h3> <p><code>disable_sized_range</code>Đưa ra một lvalue<a href="../iterator/sized_sentinel_for" title="cpp/iterator/sized sentinel for"><code>sized_sentinel_for</code></a>Số lượng các yếu tố để sao chép<code><a href="../iterator/sized_sentinel_for" title="cpp/iterator/sized sentinel for">std::disable_sized_sentinel_for</a></code>đã khấu hao vào độ phức tạp thời gian liên tục,</p>
<p><code>disable_sized_range</code>không làm thay đổi giá trị của</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">được xác định rõ bất kể đánh giá</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="random_access_range" title="cpp/ranges/random access range"> <span class="t-lines"><span>Phạm vi :: Bid -Dips_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Chỉ định một phạm vi mà loại lặp được thỏa mãn<a href="../iterator/random_access_iterator" title="cpp/iterator/random access iterator"><code>random_access_iterator</code></a> <br/> <span class="t-mark">(ý tưởng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="contiguous_range" title="cpp/ranges/contiguous range"> <span class="t-lines"><span>Phạm vi :: Random_access_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Chỉ định một phạm vi mà loại lặp được thỏa mãn<a href="../iterator/contiguous_iterator" title="cpp/iterator/contiguous iterator"><code>contiguous_iterator</code></a> <br/> <span class="t-mark">(ý tưởng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/ranges/sized_range">https://en.cppreference.com/w/cpp/ranges/sized_range</a>
</p>
</div>
