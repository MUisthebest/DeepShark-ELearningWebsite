 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: split_view &lt;v, mẫu&gt; ::<i>vòng lặp</i>
</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">lớp /*iterator* /;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> </table> <p>Loại trả lại của<a href="../split_view" title="cpp/ranges/split view"><code>split_view::begin</code></a>. Đây là một<a href="../../iterator/forward_iterator" title="cpp/iterator/forward iterator"><code>forward_iterator</code></a>, vì vậy người ta hy vọng rằng<code>V</code>mô hình ít nhất<a href="../forward_range" title="cpp/ranges/forward range"><code>forward_range</code></a>.</p>
<h3 id="Member_types">nhà điều hành ()</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>ATOMIC_UNSIGNED_LOCK_FREE</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code>iterator_concept</code> </td> <td> <code><a href="../../iterator/iterator_tags" title="cpp/iterator/iterator tags">std::forward_iterator_tag</a></code> </td>
</tr> <tr class="t-dsc"> <td> <code>iterator_category</code> </td> <td> <code><a href="../../iterator/iterator_tags" title="cpp/iterator/iterator tags">std::input_iterator_tag</a></code> </td>
</tr> <tr class="t-dsc"> <td> <code>value_type</code> </td> <td> <code><a href="http://en.cppreference.com/w/cpp/ranges/subrange"><span class="kw2910">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    find_end (r1 &amp;&amp; r1, r2 &amp;&amp; r2, pre pre = {},</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2890">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    khoảng cách (r &amp;&amp; r);</span></span></a><span class="sy1">is_trivently_destructible_v</span>V<span class="sy1">2,4)</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>difference_type</code> </td> <td> <code><a href="http://en.cppreference.com/w/cpp/ranges/iterator_t"><span class="kw2892">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Nếu chế độ xem cơ bản</span></span></a><span class="sy1">is_trivently_destructible_v</span>V<span class="sy1">&lt;</span></code> </td>
</tr> </table> <h3 id="Data_members">cửa hàng.</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>key_type</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code><i>/*LẶP LẠI*/</i></code> <span class="t-mark">Tên thành viên</span> </td> <td>Một con trỏ của loại<code><a href="http://en.cppreference.com/w/cpp/ranges/split_view"><span class="kw3110">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">                                    Phạm vi :: iterator_t &lt;Plats&gt;,</span></span></a><span class="sy1">is_trivently_destructible_v</span>V, Pattern<span class="sy1">&lt;</span><span class="sy2">*</span></code>cho cha mẹ<code><a href="../split_view" title="cpp/ranges/split view">split_view</a></code>Giống như các tài liệu tham khảo ngôn ngữ, sự ổn định là nông cạn đối với<br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">(riêng tư)</span>)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><i>cur_, ​​cur_</i></code> <span class="t-mark">Tên thành viên</span> </td> <td>là âm) của người lặp<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2890">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    khoảng cách (r &amp;&amp; r);</span></span></a><span class="sy1">is_trivently_destructible_v</span>V<span class="sy1">&lt;</span></code>vào cơ bản<a href="../view" title="cpp/ranges/view"><code>view</code></a>Điều đó chỉ ra sự khởi đầu của một subrange hiện tại.<br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">(riêng tư)</span>)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><i>Kế tiếp_</i></code> <span class="t-mark">Tên thành viên</span> </td> <td>Một mẫu phụ thuộc<code><a href="http://en.cppreference.com/w/cpp/ranges/subrange"><span class="kw2910">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    find_end (r1 &amp;&amp; r1, r2 &amp;&amp; r2, pre pre = {},</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2890">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    khoảng cách (r &amp;&amp; r);</span></span></a><span class="sy1">is_trivently_destructible_v</span>V<span class="sy1">2,4)</span></code>đến vị trí của mẫu bên cạnh subrange hiện tại.<br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">(riêng tư)</span>)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><i>    / *cur */() = phạm vi :: find (std :: di chuyển (/ *cur */()), end, *pbegin);</i></code> <span class="t-mark">Tên thành viên</span> </td> <td>Một lá cờ Boolean cho biết liệu một subbrange có dấu vết trống (nếu có).<br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">(riêng tư)</span>)</span> </td>
</tr> </table> <h3 id="Member_functions">nếu không thì</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>chuyên môn)</span></span></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Xây dựng một iterator<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>căn cứ</span></span></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>đến yếu tố hiện tại của chuỗi cơ bản.<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>toán tử/=</span></span></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Một lá cờ boolean cho biết liệu một subrange búp bê trống rỗng (nếu có) đã đạt được<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>fetch_or</span><span>fetch_or<span class="t-dsc-small">toán tử ++</span></span></span></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>tiến bộ của iterator<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <div class="t-member"> <h2 id="std::ranges::split_view::iterator::iterator">STD :: Phạm vi :: Split_view ::<i>vòng lặp</i>::<i>vòng lặp</i>
</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">/*iterator*/() = mặc định;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">constexpr /*iterator* /(split_view &amp; Parent, phạm vi :: iterator_t &lt;v&gt; hiện tại,</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <span class="t-li">1)</span>                        Phạm vi :: Subrange &lt;phạm vi :: iterator_t &lt;v &gt;&gt; tiếp theo);<ul>
<li> <code><a href="http://en.cppreference.com/w/cpp/ranges/split_view"><span class="kw3110">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">                                    Phạm vi :: iterator_t &lt;Plats&gt;,</span></span></a><span class="sy2">*</span> parent_ <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> nullptr<span class="sy4">Số lượng các yếu tố để sao chép</span></code>Thì</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2890">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    khoảng cách (r &amp;&amp; r);</span></span></a><span class="sy1">is_trivently_destructible_v</span>V<span class="sy1">&lt;</span> cur_ <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2890">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    khoảng cách (r &amp;&amp; r);</span></span></a><span class="sy1">is_trivently_destructible_v</span>V<span class="sy1">&lt;</span><span class="br0">.</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>Thì</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/ranges/subrange"><span class="kw2910">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    find_end (r1 &amp;&amp; r1, r2 &amp;&amp; r2, pre pre = {},</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2890">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    khoảng cách (r &amp;&amp; r);</span></span></a><span class="sy1">is_trivently_destructible_v</span>V<span class="sy1">2,4)</span> next_ <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <a href="http://en.cppreference.com/w/cpp/ranges/subrange"><span class="kw2910">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    find_end (r1 &amp;&amp; r1, r2 &amp;&amp; r2, pre pre = {},</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2890">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    khoảng cách (r &amp;&amp; r);</span></span></a><span class="sy1">is_trivently_destructible_v</span>V<span class="sy1">2,4)</span><span class="br0">.</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>, Và</li>
<li> <code>bool trailing_empty_ = false;</code>.</li>
</ul> <span class="t-li">2)</span>Giá trị-khởi xướng thành viên dữ liệu phi tĩnh với bộ khởi tạo thành viên mặc định của họ, nghĩa là<ul>
<li> <code><a href="http://en.cppreference.com/w/cpp/ranges/split_view"><span class="kw3110">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">                                    Phạm vi :: iterator_t &lt;Plats&gt;,</span></span></a><span class="sy2">*</span> parent_ <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw759">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span>parent<span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>Thì</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2890">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    khoảng cách (r &amp;&amp; r);</span></span></a><span class="sy1">is_trivently_destructible_v</span>V<span class="sy1">&lt;</span> cur_ <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> std<span class="sy4">::</span><span class="me2">(Niebloid)</span><span class="br0">.</span>current<span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>Thì</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/ranges/subrange"><span class="kw2910">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    find_end (r1 &amp;&amp; r1, r2 &amp;&amp; r2, pre pre = {},</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2890">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    khoảng cách (r &amp;&amp; r);</span></span></a><span class="sy1">is_trivently_destructible_v</span>V<span class="sy1">2,4)</span> next_ <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> std<span class="sy4">::</span><span class="me2">(Niebloid)</span><span class="br0">.</span>next<span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>, Và</li>
<li> <code>bool trailing_empty_ = false;</code>.</li>
</ul> </div> <div class="t-member"> <h2 id="std::ranges::split_view::iterator::base">STD :: Phạm vi :: Split_view ::<i>vòng lặp</i>::căn cứ</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">STD :: Phạm vi :: Split_view ::</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Mẫu &lt;class inputit1, class inputit2,<code>return cur_;</code>.</p>
</div> <div class="t-member"> <h2 id="std::ranges::split_view::iterator::operator.2A">STD :: Phạm vi :: Split_view ::<i>vòng lặp</i>:: Nhà điều hành*</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Phạm vi constexpr :: Range_Reference_T &lt;v&gt; Toán tử*() const;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Mẫu &lt;class inputit1, class inputit2,<code>return {cur_, next_.begin()};</code>.</p>
</div> <div class="t-member"> <h2 id="std::ranges::split_view::iterator::operator.2B.2B">STD :: Phạm vi :: Split_view ::<i>vòng lặp</i>STD :: Máy phát điện ::</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">:: Nhà điều hành ++</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">constexpr /*iterator* /&amp; toán tử ++ ();</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Mẫu &lt;class inputit1, class inputit2,<br/><code>cur_ <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> next_.<span class="me1">bắt đầu</span><span class="br0">.</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span><br/> <p><span class="kw1">nếu như</span> <span class="br0">.</span>cur_, ​​cur_<span class="sy3">Nếu tồn tại một</span><span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>/*LẶP LẠI*/<span class="sy2">-</span><span class="sy1">&lt;</span>Range constexpr :: Xem tự động liền kề &lt;n&gt; (r &amp;&amp; r);<span class="br0">)</span><span class="br0">)</span><br/> <span class="br0">danh tính</span><br/> <span class="kw1">nếu như</span> <span class="br0">.</span>cur_, ​​cur_<span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span>hay gây_<span class="me1">kết thúc</span><span class="br0">.</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span>cur_, ​​cur_<span class="sy1">==</span> <a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>/*LẶP LẠI*/<span class="sy2">-</span><span class="sy1">&lt;</span>Range constexpr :: Xem tự động liền kề &lt;n&gt; (r &amp;&amp; r);<span class="br0">)</span><span class="br0">)</span><br/> <span class="br0">danh tính</span><br/>    / *cur */() = phạm vi :: find (std :: di chuyển (/ *cur */()), end, *pbegin);<span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <span class="kw2">ĐÚNG VẬY</span><span class="sy4">Số lượng các yếu tố để sao chép</span><br/>Kế tiếp_<span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <span class="br0">danh tính</span>hay gây_<span class="br0">{</span><span class="sy4">Số lượng các yếu tố để sao chép</span><br/> <span class="br0">{</span><br/> <span class="kw1">&gt; =</span><br/>Kế tiếp_<span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span>/*LẶP LẠI*/<span class="sy2">-</span><span class="sy1">&lt;</span>Không bao giờ mô hình<span class="br0">.</span>cur_, ​​cur_<span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span><br/> <span class="br0">{</span><br/> <span class="kw1">&gt; =</span><br/>    / *cur */() = phạm vi :: find (std :: di chuyển (/ *cur */()), end, *pbegin);<span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <span class="kw2">SAI</span><span class="sy4">Số lượng các yếu tố để sao chép</span><br/> <br/></p>
<span class="kw1">Không chính thức,</span> <span class="sy2">*</span>this<span class="sy4">Số lượng các yếu tố để sao chép</span></code>
</div> <div class="t-li1">
<span class="t-li">2)</span>Mẫu &lt;class inputit1, class inputit2,<code>auto tmp = *this; ++*this; return tmp;</code>.</div>
</div> <h3 id="Non-member_functions">Các chức năng không phải thành viên</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>toán tử ==</span></span></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>so sánh các trình lặp cơ bản<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> </table> <div class="t-member"> <h2 id="operator.3D.3D.28std::ranges::split_view::iterator.2C_std::ranges::split_view::iterator.29">hay gây_<i>vòng lặp</i>toán tử == (std :: phạm vi :: split_view ::<i>vòng lặp</i>)</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Friend Consexpr Bool Toán tử == (const /*iterator* /&amp; x, const /*iterator* /&amp; y);</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Mẫu &lt;class inputit1, class inputit2,<code>return x.cur_ == y.cur_ and x.trailing_empty_ == y.trailing_empty_;</code>.</p>
<p>Các<code>!=</code>Mẫu &lt;Lớp thời lượng&gt;<a href="../../language/default_comparisons#Other_defaulted_comparison_operators" title="cpp/language/default comparisons">synthesized</a>từ<code>operator==</code>.</p>
<p>Thực thi hiệu quả<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">unqualified</a>hoặc<a href="../../language/qualified_lookup" title="cpp/language/qualified lookup">qualified lookup</a>Chức năng này không thể nhìn thấy thông thường<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>Chuyển đổi danh tính:<code>std::ranges::split_view::<i>vòng lặp</i></code>Hương hiệu nút</p>
</div> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/ranges/split_view/iterator">https://en.cppreference.com/w/cpp/ranges/split_view/iterator</a>
</p>
</div>
