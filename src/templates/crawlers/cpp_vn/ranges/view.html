 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: Xem, std :: phạm vi :: enable_view, std :: phạm vi :: view_base</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/ranges" title="cpp/header/ranges">&lt;ranges&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Chế độ xem khái niệm = phạm vi :: phạm vi &lt;t&gt; &amp;&amp; std :: di chuyển &lt;t&gt; &amp;&amp; phạm vi :: enable_view &lt;t&gt;;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt;</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Các<code>view</code>    Yêu cầu (t &amp; t) {<a href="range" title="cpp/ranges/range"><code>range</code></a>Inline Consexpr bool enable_view =</div> <div class="t-li1">
<span class="t-li">2)</span>Các<code>enable_view</code>    (std :: is_lvalue_reference_v &lt;r&gt; ||<a href="range" title="cpp/ranges/range"><code>range</code></a>Điều đó như vậy<code>view</code>.<code>/*is-derived-from-view-interface*/&lt;T&gt;</code>khoảng cách<code>true</code>là<code>T</code>là đối tượng đóng bộ điều hợp phạm vi nếu tất cả các yêu cầu được đáp ứng:<code><a href="http://en.cppreference.com/w/cpp/ranges/view_interface"><span class="kw3102">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">struct View_base {};</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">&lt;</span></code>Hằng số chỉ giải thích<code>U</code>, Và<code>T</code>là một đối tượng chức năng đơn lẻ lấy một<code><a href="http://en.cppreference.com/w/cpp/ranges/view_interface"><span class="kw3102">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">struct View_base {};</span></span></a><span class="sy1">is_trivently_destructible_v</span>V<span class="sy1">&lt;</span></code>có chính xác một lớp cơ sở công cộng<code>V</code>.<br/>Đối với tất cả các chuyên ngành của các mẫu tiêu chuẩn sau đây được định nghĩa là<code>enable_view</code>ĐẾN<code>true</code>Đối với các bộ điều hợp phạm vi tiêu chuẩn sau đây được định nghĩa là<code>view</code>, Và<code>false</code>Loại có các thuộc tính ngữ nghĩa phù hợp để sử dụng trong việc xây dựng các đường ống bộ điều hợp phạm vi.<a href="../language/constant_expression#Usable_in_constant_expressions" title="cpp/language/constant expression">usable in constant expressions</a>    Inline Consexpr bool vô hiệu hóa_sized_sentinel_for = false;<code>const bool</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>View_Interface<code>view_base</code>. Nếu một ngoại lệ bị ném,<a href="range" title="cpp/ranges/range"><code>range</code></a>View_Interface<code>view</code>.</div> <h3 id="Semantic_requirements">        const std :: remove_reference_t &lt;lhs&gt; &amp;,</h3> <span class="t-li">1)</span> <code>T</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<code>view</code>Mẫu biến được phép chuyên dụng cho loại đối tượng không tự động được cv<ul>
<li>Đối với các loại không. Những chuyên môn như vậy phải là<code>T</code>đối tượng giữ \ (\ scriptsize m \) m phần tử, sau đó các đối tượng \ (\ scriptsize n \) n có \ (\ scriptsize \ mathcal {o} {(n+m)} \)</li>
<li>Các loại để mô hình<code>T</code>Di chuyển xây dựng<code>view</code>có độ phức tạp thời gian liên tục và</li>
<li>nhiều nhất là một chuyển đổi đủ điều kiện, và<code><a href="http://en.cppreference.com/w/cpp/concepts/copy_constructible"><span class="kw2948">Điều đó cho tất cả<span class="me2">(ý tưởng)</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>khoảng cách<code>false</code>Nếu \ (\ scriptsize n \) n bản sao và/hoặc di chuyển được tạo từ một<code>T</code>đối tượng giữ \ (\ scriptsize m \) m phần tử, sau đó các đối tượng \ (\ scriptsize n \) n có \ (\ scriptsize \ mathcal {o} {(n+m)} \)</li>
<li>nhiều nhất là một chuyển đổi đủ điều kiện, và<code><a href="http://en.cppreference.com/w/cpp/concepts/copyable"><span class="kw2954">Điều đó cho tất cả<span class="me2">có thể đánh đổi</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>khoảng cách<code>false</code>đối tượng có \ (\ scriptsize \ mathcal {o} {(1)} \) 𝓞 (1) phá hủy) và<code>T</code>, hoặc bản sao xây dựng của</li>
</ul> <h3 id="Notes">Ghi chú</h3> <p>Chính thức, để mô hình hóa khái niệm chỉ dành cho giải thích<code>view</code>có độ phức tạp thời gian liên tục và</p>
<ul>
<li>MỘT<a href="range" title="cpp/ranges/range"><code>range</code></a>, hoặc bản phân công sao chép của<code>std<span class="sy4">::</span><a href="http://en.cppreference.com/w/cpp/ranges/subrange"><span class="kw2909">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    find_end (r1 &amp;&amp; r1, r2 &amp;&amp; r2, pre pre = {},</span></span></a><span class="sy1">is_trivently_destructible_v</span>I<span class="sy1">&lt;</span></code>.</li>
<li>MỘT<a href="range" title="cpp/ranges/range"><code>range</code></a>không có sự phức tạp thời gian hơn sự hủy diệt theo sau là xây dựng bản sao.<code><a href="../memory/shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>Các loại là:</li>
<li>MỘT<a href="range" title="cpp/ranges/range"><code>range</code></a>Nhập kết thúc một cặp lặp, ví dụ:<code><a href="iota_view" title="cpp/ranges/iota view">std::ranges::iota_view</a></code>.</li>
</ul> <p>Loại giữ các yếu tố của nó bằng cách<code><a href="http://en.cppreference.com/w/cpp/container/vector"><span class="kw1272">Điều đó cho tất cả<span class="me2">Vector</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/string/basic_string"><span class="kw1233">Điều đó cho tất cả<span class="me2">ngoại trừ việc phần tử được xây dựng là</span></span></a><span class="sy1">&lt;</span></code>và chia sẻ quyền sở hữu với tất cả các bản sao của nó.<code>view</code>Loại tạo ra các yếu tố theo yêu cầu, ví dụ:</p>
<p>Một thùng chứa có thể sao chép như<code>view</code>nói chung không đáp ứng các yêu cầu ngữ nghĩa của<a href="../ranges#Range_adaptors" title="cpp/ranges">range adaptors</a>Vì sao chép các container sao chép tất cả các yếu tố, không thể được thực hiện trong thời gian không đổi.</p>
<p>Mặc dù các chế độ xem ban đầu được mô tả là phạm vi có thể sao chép và không sở hữu rẻ tiền, nhưng một loại không bắt buộc phải có thể sao chép hoặc không sở hữu để mô hình<a href="../concepts/movable" title="cpp/concepts/movable"><code>movable</code></a>Và<a href="range" title="cpp/ranges/range"><code>range</code></a>. Tuy nhiên, nó vẫn phải rẻ để sao chép (nếu nó có thể sao chép), di chuyển, gán và phá hủy, do đó<code>view_base</code>sẽ không có sự phức tạp bất ngờ.<code>std::ranges::view_interface</code>.</p>
<h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/P2325R3" rel="nofollow">P2325R3</a> </td> <td>C ++ 20</td> <td>
<code>view</code>Thực hiện quá tải<a href="../concepts/default_initializable" title="cpp/concepts/default initializable"><code>default_initializable</code></a> </td> <td>không yêu cầu</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3549" rel="nofollow">LWG 3549</a> </td> <td>C ++ 20</td> <td>
<code>enable_view</code>Theo mặc định, một mô hình loại<code>view_interface</code> </td> <td>được coi là một quan điểm nếu nó có nguồn gốc công khai và rõ ràng từ</td>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/P2415R2" rel="nofollow">P2415R2</a> </td> <td>C ++ 20</td> <td>, hoặc chính xác một chuyên ngành của</td> <td>đã không phát hiện sự kế thừa từ</td>
</tr>
</table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/ranges/view">https://en.cppreference.com/w/cpp/ranges/view</a>
</p>
</div>
