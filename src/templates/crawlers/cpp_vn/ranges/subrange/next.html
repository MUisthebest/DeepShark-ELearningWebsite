 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: subrange &lt;i, s, k&gt; :: Tiếp theo</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">[[NODISCARD]] Consexpr Subrange Next (STD :: ITER_DIFFERTY_T &lt;i&gt; N = 1) Const &amp;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">    Yêu cầu std :: forward_iterator &lt;i&gt;;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>STD :: Chrono :: Leap_Second_info<code>subrange</code>tương ứng, và sau đó di chuyển cấu trúc kết quả từ<code>min(n, <a href="size" title="cpp/ranges/subrange/size">size()</a>)</code>người lặp được tăng lên bởi<code>-n</code>thời gian hoặc giảm dần bởi<code>*this</code>thời gian tôn trọng giá trị ban đầu của giá trị của<code>n &gt;= 0</code>hoặc<code>n &lt; 0</code>, khi<code>auto tmp = *this; tmp.advance(n); return tmp;</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>tương ứng. Tương đương với<code>min(n, <a href="size" title="cpp/ranges/subrange/size">size()</a>)</code>Tăng số lần lặp được lưu trữ bởi<code>-n</code>lần hoặc giảm nó bởi<code>n &gt;= 0</code>hoặc<code>n &lt; 0</code>thời gian, khi nào<code>*this</code>là các yếu tố của phạm vi.<code>advance(n); return std::move(*this);</code>.</div> <p>. Nếu không, viết không sửa đổi</p>
<ul>
<li> <code>I</code>không thực sự mô hình<a href="../../iterator/bidirectional_iterator" title="cpp/iterator/bidirectional iterator"><code>bidirectional_iterator</code></a>Và<code>n &lt; 0</code>, hoặc</li>
<li>Trình lặp được lưu trữ bị giảm sau khi trở thành một giá trị không thể xác định được.</li>
</ul> <h3 id="Parameter">/ * rvalue-tham chiếu */</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Trả về một kết quả, kết quả được bỏ qua. Nếu như</td> <td>-</td> <td>Số lượng gia số tối đa của trình lặp</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>MỘT<code>subrange</code>tương ứng, và sau đó di chuyển cấu trúc kết quả từ<code>min(n, <a href="size" title="cpp/ranges/subrange/size">size()</a>)</code>người lặp được tăng lên bởi<code>-n</code>thời gian hoặc giảm dần bởi<code>*this</code>thời gian tôn trọng giá trị ban đầu của giá trị của<code>n &gt;= 0</code>hoặc<code>n &lt; 0</code>tương ứng.</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Nói chung là<code>min(n, <a href="size" title="cpp/ranges/subrange/size">size()</a>)</code>gia tăng hoặc<code>-n</code>giảm trên người lặp, khi<code>n &gt;= 0</code>hoặc<code>n &lt; 0</code>tương ứng.</p>
<p>Toán tử bool &lt;(const std :: deque &lt;t, alloc&gt; &amp; lhs,<code>I</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../../iterator/random_access_iterator" title="cpp/iterator/random access iterator"><code>random_access_iterator</code></a>(phần còn lại). Nếu không, kích thước của mỗi<code>n &lt; 0</code>hoặc<code><a href="http://en.cppreference.com/w/cpp/iterator/sized_sentinel_for"><span class="kw2863">Điều đó cho tất cả<span class="me2">Kích thước_sentinel_for</span></span></a><span class="sy1">is_trivently_destructible_v</span>S, I<span class="sy1">&lt;</span></code>được mô hình hóa.</p>
<h3 id="Notes">Ghi chú</h3> <p>thuộc vật chất<span class="t-v">(2)</span>, khi<code>*this</code>có thể rời đi<code>I</code>Và<code>S</code>.</p>
<h3 id="Example">Ví dụ</h3> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="prev" title="cpp/ranges/subrange/prev"> <span class="t-lines"><span>trước</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>có được người lặp<code>subrange</code>Người vận hành giống như<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="advance" title="cpp/ranges/subrange/advance"> <span class="t-lines"><span>nâng cao</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(xảy ra khi<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../iterator/next" title="cpp/iterator/next"> <span class="t-lines"><span>Kế tiếp</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>tăng một lần lặp<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../iterator/ranges/next" title="cpp/iterator/ranges/next"> <span class="t-lines"><span>Phạm vi :: Tiếp theo</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>tăng một trình lặp bằng một khoảng cách nhất định hoặc đến một ràng buộc<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/ranges/subrange/next">https://en.cppreference.com/w/cpp/ranges/subrange/next</a>
</p>
</div>
