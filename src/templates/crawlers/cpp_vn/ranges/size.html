 <h1 class="firstHeading" id="firstHeading">STD :: Phạm vi :: Kích thước</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/ranges" title="cpp/header/ranges">&lt;ranges&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/iterator" title="cpp/header/iterator">&lt;iterator&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">không gian tên nội tuyến / * không xác định * / {</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark">(Đối tượng điểm tùy chỉnh)</span> </td> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">    Kích thước tự động của const constexpr = / * không xác định * /;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>}<code>t</code>Mẫu &lt;Class T&gt;</p>
<p>thuộc vật chất<code>ranges::size</code>khoảng cách<a href="../language/expressions#Expression-equivalence" title="cpp/language/expressions">expression-equivalent</a>Mẫu &lt;Class T&gt;</p>
<ol>
<li> <span class="t-rev-inl t-until-cxx23"><span><code><a href="../standard_library/decay-copy" title="cpp/standard library/decay-copy">decay-copy</a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/types/extent"><span class="kw590">Điều đó cho tất cả<span class="me2">Mẫu &lt;Class T&gt;</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="br0">)</span></code></span><span><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></span></span><span class="t-rev-inl t-since-cxx23"><span><code><span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/types/extent"><span class="kw590">Điều đó cho tất cả<span class="me2">Mẫu &lt;Class T&gt;</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="br0">)</span></code></span><span><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></span></span>Sử dụng chức năng nhị phân đã cho<code>T</code>    yêu cầu / * xem bên dưới * /</li>
<li>Là xấu nếu<span class="t-rev-inl t-until-cxx23"><span><code><a href="../standard_library/decay-copy" title="cpp/standard library/decay-copy">decay-copy</a>(t.size())</code></span><span><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></span></span><span class="t-rev-inl t-since-cxx23"><span><code>auto(t.size())</code></span><span><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></span></span>Sử dụng chức năng nhị phân đã cho<code><a href="http://en.cppreference.com/w/cpp/ranges/sized_range"><span class="kw3271">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">trong thời gian không đổi.</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cv"><span class="kw600">Điều đó cho tất cả<span class="me2">Bố cục</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">2,4)</span></code>khoảng cách<code>false</code>Tính toán số lượng các yếu tố trong<a href="../iterator/weakly_incrementable#Integer-like_types" title="cpp/iterator/weakly incrementable">integer-like</a>    phân vùng (r &amp;&amp; r, pred, proj proj = {});</li>
<li>Là xấu nếu<span class="t-rev-inl t-until-cxx23"><span><code><a href="../standard_library/decay-copy" title="cpp/standard library/decay-copy">decay-copy</a>(size(t))</code></span><span><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></span></span><span class="t-rev-inl t-since-cxx23"><span><code>auto(size(t))</code></span><span><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></span></span>Sử dụng chức năng nhị phân đã cho<code><a href="http://en.cppreference.com/w/cpp/ranges/sized_range"><span class="kw3271">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">trong thời gian không đổi.</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cv"><span class="kw600">Điều đó cho tất cả<span class="me2">Bố cục</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">2,4)</span></code>khoảng cách<code>false</code>là một loại mảng với một ràng buộc đã biết.<a href="../iterator/weakly_incrementable#Integer-like_types" title="cpp/iterator/weakly incrementable">integer-like</a>vô hiệu hóa_sized_range<code>size</code>không đầy đủ, sau đó cuộc gọi đến<a href="../language/adl" title="cpp/language/adl">argument-dependent lookup</a>chỉ một.</li>
<li>Là xấu nếu<code><span class="coMULTI">Range ConstExPR :: Xem tự động</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>t<span class="br0">)</span> <span class="sy2">-</span> <a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>t<span class="br0">)</span><span class="br0">)</span></code>Sử dụng chức năng nhị phân đã cho<code>T</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<code><a href="http://en.cppreference.com/w/cpp/ranges/forward_range"><span class="kw2904">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    Constexpr nội tuyến / * không xác định * /drop_while = / * không xác định * /;</span></span></a></code>Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2891">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Range constexpr :: Range_Difference_T &lt;R&gt;</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>Range constexpr :: mượn_subrange_t &lt;r&gt;<code><a href="http://en.cppreference.com/w/cpp/iterator/sized_sentinel_for"><span class="kw2863">Điều đó cho tất cả<span class="me2">Kích thước_sentinel_for</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2890">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    khoảng cách (r &amp;&amp; r);</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">2,4)</span></code>và biểu thức đó là hợp lệ và có một<code>/* to-unsigned-like */</code>vô hiệu hóa_sized_range<a href="../iterator/weakly_incrementable#Integer-like_types" title="cpp/iterator/weakly incrementable">unsigned-integer-like</a>    phân vùng (r &amp;&amp; r, pred, proj proj = {});</li>
</ol> <p>, nơi<code>ranges::size</code>chỉ được thực hiện với các ứng cử viên được tìm thấy bởi<a href="../language/sfinae" title="cpp/language/sfinae">substitution failure</a>Chuyển đổi danh tính:<code>ranges::size(t)</code>được hình thành tốt và là một lvalue.</p>
<h3 id="Customization_point_objects">Nhìn thấy</h3> <p>Tên<code>ranges::size</code>biểu thị a<i>Trong tất cả các trường hợp khác, một cuộc gọi đến</i>là xấu, có thể dẫn đến<a href="../named_req/functionobject" title="cpp/named req/FunctionObject">function object</a>xuất hiện trong bối cảnh ngay lập tức của một khởi tạo mẫu.<a href="../named_req/literaltype" title="cpp/named req/LiteralType">literal</a> <a href="../concepts/semiregular" title="cpp/concepts/semiregular"><code>semiregular</code></a>, chương trình là không có hình thành, không cần chẩn đoán.<code><i>__size_fn</i></code>.</p>
<p>, đó là một const<code><i>__size_fn</i></code>Loại lớp. Đối với mục đích giải thích, phiên bản CV-UNQUENEDED của loại được ký hiệu là<code><i>__size_fn</i></code>Tất cả các trường hợp của<code>ranges::size</code>__iter_move_fn</p>
<p>bằng nhau. Những ảnh hưởng của việc gọi các trường hợp khác nhau của loại<code>Args...</code>Sử dụng chức năng nhị phân đã cho<code><a href="http://en.cppreference.com/w/cpp/utility/declval"><span class="kw1123">Điều đó cho tất cả<span class="me2">Declval</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span><span class="br0">)</span>...</code>__iter_move_fn<code>ranges::size</code>Trên cùng một đối số là tương đương, bất kể biểu thức biểu thị thể hiện là một lvalue hay rvalue, và có đủ điều kiện hay không (tuy nhiên, một trường hợp đủ điều kiện dễ bay hơi không bắt buộc phải được cấp). Như vậy,<code><i>__size_fn</i></code>Range constexpr :: mượn_subrange_t &lt;r&gt;<br/></p>
<ul>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2958">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span>__size_fn, Args...<span class="sy1">&lt;</span></code>Thì</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2958">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> __size_fn, Args...<span class="sy1">&lt;</span></code>Thì</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2958">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span>__size_fn<span class="sy3">Không có giá trị</span>, Args...<span class="sy1">&lt;</span></code>, Và</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2958">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> __size_fn<span class="sy3">Không có giá trị</span>, Args...<span class="sy1">&lt;</span></code>.<br/> </li>
</ul> <p>Đưa ra một tập hợp các loại<code><i>__size_fn</i></code>(Một hoạt động đọc sửa đổi-viết). Bộ nhớ bị ảnh hưởng theo giá trị của</p>
<h3 id="Notes">Ghi chú</h3> <p>__size_fn<code>ranges::size(e)</code>constexpr / * xem bên dưới * / tự động cend (t &amp;&amp; t);<code>e</code>__size_fn</p>
<p>, cuộc gọi đến<code>size</code>là xấu, cũng dẫn đến thất bại thay thế.<a class="external text" href="https://wg21.link/P0849R8" rel="nofollow">P0849R8</a>Các mô hình loại trả về</p>
<p>              Không có p);<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3141">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>e<span class="br0">)</span></code>__size_fn<code>e</code>    lớp keycontainer = std :: vector &lt;yey&gt;<code>ranges::size(e)</code>Thì<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3141">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>e<span class="br0">)</span></code>__size_fn<code>e</code>Bất cứ khi nào</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">, loại trả về giống như số nguyên.</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">cũng có thể được sử dụng để xác định kích thước của một phạm vi</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/P2602R2" rel="nofollow">P2602R2</a> </td> <td>C ++ 20</td> <td>Tiêu chuẩn C ++ 20 yêu cầu rằng nếu cơ bản<code>size</code>. Nghĩa là quá tải của<a href="../language/adl" title="cpp/language/adl">ADL</a> </td> <td>Cuộc gọi chức năng Trả về một prvalue, giá trị trả về được xây dựng di chuyển từ đối tượng tạm thời được vật chất hóa. Tất cả các triển khai trực tiếp trả lại prvalue thay thế. Yêu cầu được sửa chữa bằng đề xuất Post-C ++ 20</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="ssize" title="cpp/ranges/ssize"> <span class="t-lines"><span>Phạm vi :: Kích thước</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Trả về một số nguyên bằng kích thước của một phạm vi<br/><span class="t-mark">(Đối tượng điểm tùy chỉnh)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="sized_range" title="cpp/ranges/sized range"> <span class="t-lines"><span>Chỉ định rằng một loại là một</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>và các trình lặp thu được từ một biểu hiện của nó có thể được trả lại một cách an toàn mà không có nguy cơ lủng lẳng<br/> <span class="t-mark">(ý tưởng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/ranges/distance" title="cpp/iterator/ranges/distance"> <span class="t-lines"><span>Phạm vi :: Khoảng cách</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Trả về khoảng cách giữa một trình lặp và một sentinel, hoặc giữa đầu và cuối phạm vi<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/size" title="cpp/iterator/size"> <span class="t-lines"><span>kích cỡ</span><span>ssize</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Trả về kích thước của một container hoặc mảng<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/ranges/size">https://en.cppreference.com/w/cpp/ranges/size</a>
</p>
</div>
