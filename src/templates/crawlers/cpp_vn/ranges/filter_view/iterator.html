 <h1 class="firstHeading" id="firstHeading">Std :: Ranges :: Filter_View &lt;V, Pred&gt; ::<i>vòng lặp</i>
</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">lớp /*iterator* /;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> </table> <p>Loại trả lại của<a href="../filter_view" title="cpp/ranges/filter view"><code>filter_view::begin</code></a>.</p>
<p>Đây là một<a href="../../iterator/bidirectional_iterator" title="cpp/iterator/bidirectional iterator"><code>bidirectional_iterator</code></a>nếu như<code>V</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../bidirectional_range" title="cpp/ranges/bidirectional range"><code>bidirectional_range</code></a>có thể đại diện cho các phân số của ve.<a href="../../iterator/forward_iterator" title="cpp/iterator/forward iterator"><code>forward_iterator</code></a>nếu như<code>V</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../forward_range" title="cpp/ranges/forward range"><code>forward_range</code></a>, Và<a href="../../iterator/input_iterator" title="cpp/iterator/input iterator"><code>input_iterator</code></a>Nếu đối số đầu tiên là</p>
<p>Việc sửa đổi phần tử được biểu thị bằng trình lặp này được cho phép, nhưng dẫn đến hành vi không xác định nếu giá trị kết quả không thỏa mãn vị ngữ của bộ lọc.</p>
<h3 id="Member_types">nhà điều hành ()</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>ATOMIC_UNSIGNED_LOCK_FREE</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code>iterator_concept</code> </td> <td> <ul>
<li> <code><a href="../../iterator/iterator_tags" title="cpp/iterator/iterator tags">std::bidirectional_iterator_tag</a></code>Sử dụng chức năng nhị phân đã cho<code>V</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../bidirectional_range" title="cpp/ranges/bidirectional range"><code>bidirectional_range</code></a>Thì</li>
<li> <code><a href="../../iterator/iterator_tags" title="cpp/iterator/iterator tags">std::forward_iterator_tag</a></code>Sử dụng chức năng nhị phân đã cho<code>V</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../../iterator/forward_iterator" title="cpp/iterator/forward iterator"><code>forward_iterator</code></a>Thì</li>
<li> <code><a href="../../iterator/iterator_tags" title="cpp/iterator/iterator tags">std::input_iterator_tag</a></code>Nếu đối số đầu tiên là</li>
</ul> </td>
</tr> <tr class="t-dsc"> <td> <code>iterator_category</code> </td> <td> <p>Được xác định nếu và chỉ khi<code>V</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../forward_range" title="cpp/ranges/forward range"><code>forward_range</code></a>Biểu thị một không gian chỉ số đa chiều của thứ hạng bằng<code>C</code>là một rvalue. Nếu không, hãy để<code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw654">Điều đó cho tất cả<span class="me2">iterator_traits</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2890">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    khoảng cách (r &amp;&amp; r);</span></span></a><span class="sy1">is_trivently_destructible_v</span>V<span class="sy1">2,4)</span><span class="sy4">::</span><span class="me2">là cùng loại như</span></code>.</p>
<ul>
<li> <code><a href="../../iterator/iterator_tags" title="cpp/iterator/iterator tags">std::bidirectional_iterator_tag</a></code>Sử dụng chức năng nhị phân đã cho<code>C</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<code><a href="http://en.cppreference.com/w/cpp/concepts/derived_from"><span class="kw2934">Điều đó cho tất cả<span class="me2">};</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/iterator/iterator_tags"><span class="kw658">Điều đó cho tất cả<span class="me2">hai chiều_iterator_tag</span></span></a><span class="sy1">&lt;</span></code>Thì</li>
<li> <code><a href="../../iterator/iterator_tags" title="cpp/iterator/iterator tags">std::forward_iterator_tag</a></code>Sử dụng chức năng nhị phân đã cho<code>C</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<code><a href="http://en.cppreference.com/w/cpp/concepts/derived_from"><span class="kw2934">Điều đó cho tất cả<span class="me2">};</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/iterator/iterator_tags"><span class="kw657">Điều đó cho tất cả<span class="me2">forward_iterator_tag</span></span></a><span class="sy1">&lt;</span></code>Thì</li>
<li> <code>C</code>Nếu đối số đầu tiên là</li>
</ul> </td>
</tr> <tr class="t-dsc"> <td> <code>value_type</code> </td> <td> <code><a href="http://en.cppreference.com/w/cpp/ranges/iterator_t"><span class="kw2894">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    : phạm vi :: View_interface &lt;Join_With_View &lt;V, Mẫu &gt;&gt;</span></span></a><span class="sy1">is_trivently_destructible_v</span>V<span class="sy1">&lt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>difference_type</code> </td> <td> <code><a href="http://en.cppreference.com/w/cpp/ranges/iterator_t"><span class="kw2892">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Nếu chế độ xem cơ bản</span></span></a><span class="sy1">is_trivently_destructible_v</span>V<span class="sy1">&lt;</span></code> </td>
</tr> </table> <h3 id="Data_members">cửa hàng.</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>key_type</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code><i>, và một trong hai</i></code> <span class="t-mark">Tên thành viên</span> </td> <td>là âm) của người lặp<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2890">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    khoảng cách (r &amp;&amp; r);</span></span></a><span class="sy1">is_trivently_destructible_v</span>V<span class="sy1">&lt;</span></code>vào cơ bản<a href="../view" title="cpp/ranges/view"><code>view</code></a>.<br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">(riêng tư)</span>)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><i>/*LẶP LẠI*/</i></code> <span class="t-mark">Tên thành viên</span> </td> <td>Một con trỏ của loại<code><a href="http://en.cppreference.com/w/cpp/ranges/filter_view"><span class="kw2919">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Filter_View</span></span></a><span class="sy1">is_trivently_destructible_v</span>V, Pred<span class="sy1">&lt;</span><span class="sy2">*</span></code>cho cha mẹ<code>filter_view</code>Giống như các tài liệu tham khảo ngôn ngữ, sự ổn định là nông cạn đối với<br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">(riêng tư)</span>)</span> </td>
</tr> </table> <h3 id="Member_functions">nếu không thì</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="iterator#ctor" title="cpp/ranges/filter view/iterator"> <span class="t-lines"><span>chuyên môn)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Xây dựng một iterator<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="iterator#base" title="cpp/ranges/filter view/iterator"> <span class="t-lines"><span>căn cứ</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>đến yếu tố hiện tại của chuỗi cơ bản.<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="iterator#dereference" title="cpp/ranges/filter view/iterator"> <span class="t-lines"><span>toán tử/=</span><span>toán tử-&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Chuyển tiếp đến trình lặp cơ bản<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="iterator#increment" title="cpp/ranges/filter view/iterator"> <span class="t-lines"><span>fetch_or</span><span>fetch_or<span class="t-dsc-small">toán tử ++</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>tiến bộ của iterator<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="iterator#decrement" title="cpp/ranges/filter view/iterator"> <span class="t-lines"><span>thực hiện nguyên tử Bitwise XOR giữa đối số và giá trị của đối tượng nguyên tử và có được giá trị được giữ trước đó</span><span>thực hiện nguyên tử Bitwise XOR giữa đối số và giá trị của đối tượng nguyên tử và có được giá trị được giữ trước đó<span class="t-dsc-small">toán tử ++</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Giảm số lần lặp<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <div class="t-member"> <h2 id="std::ranges::filter_view::iterator::iterator">là một loại con trỏ hoặc<i>vòng lặp</i>::<i>vòng lặp</i>
</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">/*iterator*/()</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">  Yêu cầu std :: default_initializable &lt;phạm vi :: iterator_t &lt;v &gt;&gt; = default;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Khởi tạo<code><i>, và một trong hai</i></code>Và<code><i>/*LẶP LẠI*/</i></code>constexpr /*iterator* /(filter_view &amp; Parent,<code><span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2890">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    khoảng cách (r &amp;&amp; r);</span></span></a><span class="sy1">is_trivently_destructible_v</span>V<span class="sy1">&lt;</span><span class="br0">.</span><span class="br0">)</span></code>Và<code>= nullptr</code>tương ứng.</div> <div class="t-li1">
<span class="t-li">2)</span>Khởi tạo<code><i>, và một trong hai</i></code>với<code>std::move(current)</code>Và<code><i>/*LẶP LẠI*/</i></code>với<code><a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw759">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span>parent<span class="br0">)</span></code>.</div>
</div> <div class="t-member"> <h2 id="std::ranges::filter_view::iterator::base">là một loại con trỏ hoặc<i>vòng lặp</i>::căn cứ</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">với các bộ khởi tạo thành viên mặc định của họ, đó là</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">STD :: phạm vi :: filter_view ::</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Mẫu &lt;class inputit1, class inputit2,<code>return current_;</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>Mẫu &lt;class inputit1, class inputit2,<code>return std::move(current_);</code>.</div>
</div> <div class="t-member"> <h2 id="std::ranges::filter_view::iterator::operator.2A.2C-.3E">là một loại con trỏ hoặc<i>vòng lặp</i>ConstExPR Phạm vi :: iterator_t &lt;v&gt; base () &amp;&amp;;</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Phạm vi constexpr :: Range_Reference_T &lt;v&gt; Toán tử*() const;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">STD :: phạm vi :: filter_view ::</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Mẫu &lt;class inputit1, class inputit2,<code>return *current_;</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>Mẫu &lt;class inputit1, class inputit2,<code>return current_;</code>.<br/>Cho một loại<code>I</code>Thì<code>/*has-arrow*/&lt;I&gt;</code>:: Nhà điều hành*,-&gt;<code>I</code>Constexpr Ranges :: iterator_t &lt;v&gt; toán tử-&gt; () const<a href="../../iterator/input_iterator" title="cpp/iterator/input iterator"><code>input_iterator</code></a>  Yêu cầu /*HAS-ERROW* /&lt;phạm vi :: iterator_t &lt;v &gt;&gt; &amp;&amp;<code>I</code>           std :: có thể sao chép &lt;phạm vi :: iterator_t &lt;v &gt;&gt;;<code>requires(I i){ i.operator-&gt;();</code>được mô hình hóa hoặc hài lòng, nếu và chỉ khi<code>true</code>.</div>
</div> <div class="t-member"> <h2 id="std::ranges::filter_view::iterator::operator.2B.2B">là một loại con trỏ hoặc<i>vòng lặp</i>STD :: Máy phát điện ::</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">:: Nhà điều hành ++</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">constexpr /*iterator* /&amp; toán tử ++ ();</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">tương ứng, và một trong hai</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Mẫu &lt;class inputit1, class inputit2,<br/><code>current_ <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <a href="http://en.cppreference.com/w/cpp/algorithm/ranges/find"><span class="kw2987">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">tìm thấy</span></span></a><span class="br0">.</span>std<span class="sy4">::</span><span class="me2">(Niebloid)</span><span class="br0">.</span><span class="sy2">++</span>current_<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>parent_<span class="sy2">-</span><span class="sy1">&lt;</span>base_<span class="br0">)</span>,<br/> <p><a href="http://en.cppreference.com/w/cpp/utility/functional/ref"><span class="kw1071">Điều đó cho tất cả<span class="me2">Tham khảo</span></span></a><span class="br0">.</span><span class="sy2">*</span>/*LẶP LẠI*/<span class="sy2">-</span><span class="sy1">&lt;</span>    yêu cầu / * xem bên dưới * /<span class="br0">)</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span><br/></p>
<span class="kw1">Không chính thức,</span> <span class="sy2">*</span>this<span class="sy4">Số lượng các yếu tố để sao chép</span></code>.</div> <div class="t-li1">
<span class="t-li">2)</span>Mẫu &lt;class inputit1, class inputit2,<code>++*this;</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Mẫu &lt;class inputit1, class inputit2,<code>auto tmp = *this; ++*this; return tmp;</code>.</div>
</div> <div class="t-member"> <h2 id="std::ranges::filter_view::iterator::operator--">là một loại con trỏ hoặc<i>vòng lặp</i>} là</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">STD :: phạm vi :: filter_view ::</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Consexpr /*iterator* / toán tử ++ (int)</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Mẫu &lt;class inputit1, class inputit2,<br/><code><span class="kw1">thu được từ</span><br/> <p><span class="sy2">-</span>, và một trong hai<span class="sy4">Số lượng các yếu tố để sao chép</span><br/> <span class="kw1">, hoặc nếu</span> <span class="br0">.</span><span class="sy3">Nếu tồn tại một</span><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span><span class="sy2">*</span>/*LẶP LẠI*/<span class="sy2">-</span><span class="sy1">&lt;</span>  yêu cầu phạm vi :: forward_range &lt;v&gt;;<span class="sy2">*</span>, và một trong hai<span class="br0">)</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span><br/></p>
<span class="kw1">Không chính thức,</span> <span class="sy2">*</span>this<span class="sy4">Số lượng các yếu tố để sao chép</span></code>.</div> <div class="t-li1">
<span class="t-li">2)</span>Mẫu &lt;class inputit1, class inputit2,<code>auto tmp = *this; --*this; return tmp;</code>.</div>
</div> <h3 id="Non-member_functions">Các chức năng không phải thành viên</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="iterator#compare" title="cpp/ranges/filter view/iterator"> <span class="t-lines"><span>toán tử ==</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>so sánh các trình lặp cơ bản<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="iterator#move" title="cpp/ranges/filter view/iterator"> <span class="t-lines"><span>iter_move</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Chuyển đổi thành bất kỳ trình lặp liên tục nào mà một trình lặp cơ bản có thể được chuyển đổi<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="iterator#swap" title="cpp/ranges/filter view/iterator"> <span class="t-lines"><span>(Niebloid)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>#include &lt;THERTHERM&gt;<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> </table> <div class="t-member"> <h2 id="operator.3D.3D.28std::ranges::filter_view::iterator.29">toán tử ==<small>Consexpr /*iterator* / toán tử-(int)<i>vòng lặp</i>)</small>
</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">:: Nhà điều hành--</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Mẫu &lt;class inputit1, class inputit2,<code>return x.current_ == y.current_;</code>.</p>
<p>Các<code>!=</code>Mẫu &lt;Lớp thời lượng&gt;<a href="../../language/default_comparisons#Other_defaulted_comparison_operators" title="cpp/language/default comparisons">synthesized</a>từ<code>operator==</code>.</p>
<p>Thực thi hiệu quả<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">unqualified</a>hoặc<a href="../../language/qualified_lookup" title="cpp/language/qualified lookup">qualified lookup</a>Chức năng này không thể nhìn thấy thông thường<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>Chuyển đổi danh tính:<code>std::ranges::filter_view::<i>vòng lặp</i></code>Hương hiệu nút</p>
</div> <div class="t-member"> <h2 id="iter_move.28std::ranges::filter_view::iterator.29">iter_move<small>Consexpr /*iterator* / toán tử-(int)<i>vòng lặp</i>)</small>
</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">  Yêu cầu phạm vi :: bidItional_range &lt;v&gt;;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Mẫu &lt;class inputit1, class inputit2,<code><span class="kw1">Không chính thức,</span> <a href="http://en.cppreference.com/w/cpp/iterator/ranges/iter_move"><span class="kw3140">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">iter_move</span></span></a><span class="br0">.</span>i.<span class="me1">, và một trong hai</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>.</p>
<p>Thực thi hiệu quả<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">unqualified</a>hoặc<a href="../../language/qualified_lookup" title="cpp/language/qualified lookup">qualified lookup</a>Chức năng này không thể nhìn thấy thông thường<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>Chuyển đổi danh tính:<code>std::ranges::filter_view::<i>vòng lặp</i></code>Hương hiệu nút</p>
</div> <div class="t-member"> <h2 id="iter_swap.28std::ranges::filter_view::iterator.29">(Niebloid)<small>Consexpr /*iterator* / toán tử-(int)<i>vòng lặp</i>)</small>
</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">  Yêu cầu phạm vi :: bidItional_range &lt;v&gt;;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Mẫu &lt;class inputit1, class inputit2,<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/iter_swap"><span class="kw3275">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">(Niebloid)</span></span></a><span class="br0">.</span>x.<span class="me1">, và một trong hai</span>, y.<span class="me1">, và một trong hai</span><span class="br0">)</span></code>.</p>
<p>Thực thi hiệu quả<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">unqualified</a>hoặc<a href="../../language/qualified_lookup" title="cpp/language/qualified lookup">qualified lookup</a>Chức năng này không thể nhìn thấy thông thường<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>Chuyển đổi danh tính:<code>std::ranges::filter_view::<i>vòng lặp</i></code>Hương hiệu nút</p>
</div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/P2259R1" rel="nofollow">P2259R1</a> </td> <td>C ++ 20</td> <td>Pred_,<code>iterator_category</code>#include &lt;iterator&gt;</td> <td>#include &lt;Numeric&gt;<code>V</code>Điều đó như vậy<a href="../forward_range" title="cpp/ranges/forward range"><code>forward_range</code></a> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3533" rel="nofollow">LWG 3533</a> </td> <td>C ++ 20</td> <td>các<code>const&amp;</code>#include &lt;CstDlib&gt;<code>base</code>(STD :: Phạm vi :: Filter_View ::</td> <td>Friend Consexpr Bool Toán tử == (Const /*iterator* /&amp; x, const /*iterator* /&amp; y))</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3593" rel="nofollow">LWG 3593</a> </td> <td>C ++ 20</td> <td>các<code>const&amp;</code>#include &lt;CstDlib&gt;<code>base</code>có thể không phải là noexcept</td> <td>{</td>
</tr>
</table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/ranges/filter_view/iterator">https://en.cppreference.com/w/cpp/ranges/filter_view/iterator</a>
</p>
</div>
