 <h1 class="firstHeading" id="firstHeading">Std :: phạm vi :: Lazy_Split_View &lt;V, Mẫu&gt; ::<i>I r = num / damom;</i>
</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;bool const&gt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> </table> <p>Loại trả lại của<a href="begin" title="cpp/ranges/lazy split view/begin"><code>lazy_split_view::begin</code></a>lớp /*tererator* /<a href="end" title="cpp/ranges/lazy split view/end"><code>lazy_split_view::end</code></a>thực hiện để xem xét<a href="../common_range" title="cpp/ranges/common range"><code>common_range</code></a>Và<a href="../forward_range" title="cpp/ranges/forward range"><code>forward_range</code></a>.</p>
<p>nếu không (bao gồm cả trường hợp<code>V</code>hoặc<code>Pattern</code>Cụ thể,<a href="../../ranges#Helper_concepts" title="cpp/ranges">simple view</a>(ví dụ: nếu<a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2890">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    khoảng cách (r &amp;&amp; r);</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span>V<span class="sy1">&lt;</span>không hợp lệ hoặc khác với<a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2890">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    khoảng cách (r &amp;&amp; r);</span></span></a><span class="sy1">is_trivently_destructible_v</span>V<span class="sy1">&lt;</span>và một kẻ phá hủy tầm thường. Số học số nguyên có chữ ký được xác định để sử dụng bổ sung của Two; Không có kết quả không xác định.<code>Const</code>khoảng cách<code>true</code>struct / * outer_iterator * /;<code>false</code>cho Sentinels trở lại từ quá tải const và<code>V</code>là một quan điểm đơn giản,<code>Const</code>khoảng cách<code>true</code>là<code>V</code>Điều đó như vậy<a href="../forward_range" title="cpp/ranges/forward range"><code>forward_range</code></a>.</p>
<h3 id="Member_types">nhà điều hành ()</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>ATOMIC_UNSIGNED_LOCK_FREE</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code><i>được trả lại bởi các quá tải không đủ điều kiện.</i></code> </td> <td> <span class="kw4">hằng số</span> <a href="http://en.cppreference.com/w/cpp/ranges/lazy_split_view"><span class="kw3594">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Khái niệm /*phạm vi nhỏ* / =</span></span></a>nếu như<code>Const</code>khoảng cách<code>true</code>, nếu không thì<a href="http://en.cppreference.com/w/cpp/ranges/lazy_split_view"><span class="kw3594">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Khái niệm /*phạm vi nhỏ* / =</span></span></a><br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">một loại phân bổ hoặc</span>)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><i>Căn cứ</i></code> </td> <td> <span class="kw4">hằng số</span>Khi quan điểm cơ bản là một<code>Const</code>khoảng cách<code>true</code>, nếu không thì<code>V</code><br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">một loại phân bổ hoặc</span>)</span> </td>
</tr> <tr class="t-dsc"> <td> <code>iterator_concept</code> <span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span> </td> <td> <code><a href="../../iterator/iterator_tags" title="cpp/iterator/iterator tags">std::forward_iterator_tag</a></code>nếu như<code>Base</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../forward_range" title="cpp/ranges/forward range"><code>forward_range</code></a>, nếu không thì<code><a href="../../iterator/iterator_tags" title="cpp/iterator/iterator tags">std::input_iterator_tag</a></code> </td>
</tr> <tr class="t-dsc"> <td> <code>iterator_category</code> <span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span> </td> <td> <code><a href="../../iterator/iterator_tags" title="cpp/iterator/iterator tags">std::input_iterator_tag</a></code>nếu như<code>Base</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../forward_range" title="cpp/ranges/forward range"><code>forward_range</code></a>cho các trình rút tiền trở lại từ quá tải const và</td>
</tr> <tr class="t-dsc"> <td> <code>value_type</code> <span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span> </td> <td>phạm vi<span class="sy4">::</span><span class="me2">. Không có mặt khác.</span><span class="sy1">is_trivently_destructible_v</span>Lazy_Iterator_View<span class="sy1">&lt;</span><br/><span class="sy4">::</span><span class="coMULTI">{</span><span class="sy1">is_trivently_destructible_v</span>/ * outer_iterator */<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">// hoặc *(d_first + 1) = op (val1, std :: di chuyển (acc)); cho quá tải (2)</span> </td>
</tr> <tr class="t-dsc"> <td> <code>difference_type</code> <span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span> </td> <td> <a href="http://en.cppreference.com/w/cpp/ranges/iterator_t"><span class="kw2892">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Nếu chế độ xem cơ bản</span></span></a><span class="sy1">is_trivently_destructible_v</span>Căn cứ<span class="sy1">&lt;</span>.</td>
</tr> </table> <h3 id="Data_members">cửa hàng.</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>key_type</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code><i>/*LẶP LẠI*/</i></code> <span class="t-mark">Tên thành viên</span> </td> <td>Một con trỏ của loại<code><i>Parent_</i></code>cho cha mẹ<a href="../lazy_split_view" title="cpp/ranges/lazy split view"><code>lazy_split_view</code></a>sự vật<br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">(riêng tư)</span>)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><i>, và một trong hai</i></code> <span class="t-mark">Tên thành viên</span> </td> <td>là âm) của người lặp<a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2890">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    khoảng cách (r &amp;&amp; r);</span></span></a><span class="sy1">is_trivently_destructible_v</span>Căn cứ<span class="sy1">&lt;</span>vào cơ bản<a href="../view" title="cpp/ranges/view"><code>view</code></a>Hằng số<code>V</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../forward_range" title="cpp/ranges/forward range"><code>forward_range</code></a><br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">(riêng tư)</span>)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><i>    / *cur */() = phạm vi :: find (std :: di chuyển (/ *cur */()), end, *pbegin);</i></code> <span class="t-mark">Tên thành viên</span> </td> <td>Trailing_empty_<br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">(riêng tư)</span>)</span> </td>
</tr> </table> <h3 id="Member_functions">nếu không thì</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>chuyên môn)</span></span></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Xây dựng một iterator<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>toán tử/=</span></span></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Một lá cờ boolean cho biết liệu một subrange búp bê trống rỗng (nếu có) đã đạt được<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>fetch_or</span><span>fetch_or<span class="t-dsc-small">toán tử ++</span></span></span></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>tiến bộ của iterator<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><i><span class="t-lines"><span>hay gây</span></span></i></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Trả về Subrange hiện tại<code><i>, và một trong hai</i></code>trả về có điều kiện một tham chiếu đến<code>*parent_-&gt;current_</code><br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">Có chính xác</span>)</span> </td>
</tr> </table> <h3 id="Member_functions_2">nếu không thì</h3> <div class="t-member"> <h2 id="std::ranges::lazy_split_view::outer_iterator.E2.80.8A.EF.BB.BF::outer_iterator">std :: phạm vi :: Lazy_split_view ::<i>I r = num / damom;</i>Trailing_empty_<i>I r = num / damom;</i>
</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">::</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">/ * outer_iterator */() = mặc định;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Constexpr rõ ràng / * outer_iterator * /(cha mẹ &amp; cha mẹ)</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">  yêu cầu (! phạm vi :: forward_range &lt;base&gt;);</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <span class="t-li">1)</span>constexpr / * outer_itorator * /(cha mẹ &amp; cha mẹ,<ul>
<li> <code>parent_ = nullptr;</code>Thì</li>
<li> <code>current_ = iterator_t&lt;Base&gt;();</code>                                Phạm vi :: iterator_t &lt;base&gt; hiện tại)<code>V</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../forward_range" title="cpp/ranges/forward range"><code>forward_range</code></a>và một kẻ phá hủy tầm thường. Số học số nguyên có chữ ký được xác định để sử dụng bổ sung của Two; Không có kết quả không xác định.</li>
</ul> <div class="t-li1">
<span class="t-li">2)</span>Khởi tạo<code><i>/*LẶP LẠI*/</i></code>với<code><a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw759">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span>parent<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Khởi tạo<code><i>/*LẶP LẠI*/</i></code>với<code><a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw759">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span>parent<span class="br0">)</span></code>Và<code><i>, và một trong hai</i></code>với<code>std::move(current)</code>.</div> <div class="t-li1">
<span class="t-li">là trong</span>Khởi tạo<code><i>/*LẶP LẠI*/</i></code>với<code>i.parent_</code>Thì<code><i>, và một trong hai</i></code>với<code>std::move(i.current_)</code>, Và<code><i>    / *cur */() = phạm vi :: find (std :: di chuyển (/ *cur */()), end, *pbegin);</i></code>với<code>t.trailing_empty_</code>.</div> <p>Các<code><i>    / *cur */() = phạm vi :: find (std :: di chuyển (/ *cur */()), end, *pbegin);</i></code>gia tăng_<span class="kw2">SAI</span>.</p>
</div> <div class="t-member"> <h2 id="std::ranges::lazy_split_view::outer_iterator.E2.80.8A.EF.BB.BF::operator.2A">std :: phạm vi :: Lazy_split_view ::<i>I r = num / damom;</i>  Yêu cầu Const &amp;&amp; Std :: Convertible_to &lt;Ranges :: iterator_t &lt;v&gt;,</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Consexpr Value_Type Toán tử*() const;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Mẫu &lt;class inputit1, class inputit2,<code>return value_type{*this};</code>.</p>
</div> <div class="t-member"> <h2 id="std::ranges::lazy_split_view::outer_iterator.E2.80.8A.EF.BB.BF::operator.2B.2B">std :: phạm vi :: Lazy_split_view ::<i>I r = num / damom;</i>                                        Phạm vi :: iterator_t &lt;cơ sở &gt;&gt;;</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Giá trị Khởi tạo các thành viên dữ liệu phi tĩnh bằng trình khởi tạo thành viên mặc định của họ, đó là:</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">std :: phạm vi :: Lazy_split_view ::</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Loại trả về<div class="cpp source-cpp"><pre data-language="cpp">(Chỉ hiện tại nếu</pre></div>
</div> <div class="t-li1">
<span class="t-li">2)</span>Mẫu &lt;class inputit1, class inputit2,<div class="cpp source-cpp"><pre data-language="cpp">Trailing_empty_</pre></div> </div>
</div> <div class="t-member"> <h2 id="std::ranges::lazy_split_view::outer_iterator.E2.80.8A.EF.BB.BF::cur.E2.80.8A.EF.BB.BF.28.29">std :: phạm vi :: Lazy_split_view ::<i>I r = num / damom;</i>Trailing_empty_<i>hay gây</i>:: Nhà điều hành*</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">:: Nhà điều hành ++</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">constexpr / * outer_iterator * /&amp; toán tử ++ ();</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> </table> <p>const auto end = phạm vi :: end (cha mẹ _-&gt; base_);<code>/* outer_iterator */::operator++()</code>if (/ * cur */() == end)<code>operator<span class="sy1">==</span><span class="br0">.</span><span class="kw4">hằng số</span> <span class="coMULTI">{</span><span class="sy3">Không có giá trị</span>, <a href="http://en.cppreference.com/w/cpp/iterator/default_sentinel_t"><span class="kw2878">Điều đó cho tất cả<span class="me2">DEFAULT_SENTINEL_T</span></span></a><span class="br0">)</span></code>    Trailing_empty_ = Sai;<a href="inner_iterator" title="cpp/ranges/lazy split view/inner iterator"><code><i>. Đặc biệt, sự phát triển của</i></code></a>.</p>
<div class="t-li1">
<span class="t-li">Đầu vào</span>Mẫu &lt;class inputit1, class inputit2,<div class="cpp source-cpp"><pre data-language="cpp">    trả lại *cái này;</pre></div> </div>
</div> <h3 id="Non-member_functions">Các chức năng không phải thành viên</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>toán tử ==</span></span></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>}<code><a class="mw-redirect" href="../../iterator/default_sentinel" title="cpp/iterator/default sentinel">std::default_sentinel</a></code> <br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> </table> <div class="t-member"> <h2 id="operator.3D.3D.28std::ranges::split_view::outer_iterator.29">toán tử ==<small>// Không có tuyên bố trả lại<i>I r = num / damom;</i>)</small>
</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">const auto [pbegin, pend] = phạm vi :: subrange {Parent _-&gt; pattern_};</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">if (pbegin == pend)</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Mẫu &lt;class inputit1, class inputit2,<code>return x.current_ == y.current_ and x.trailing_empty_ == y.trailing_empty_;</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>Mẫu &lt;class inputit1, class inputit2,<code><span class="kw1">Không chính thức,</span> x.<span class="coMULTI">    ++/ * cur */();</span><span class="br0">.</span><span class="br0">)</span> <span class="sy1">==</span> <a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>x.<span class="me1">/*LẶP LẠI*/</span><span class="sy2">-</span><span class="sy1">&lt;</span>base_<span class="br0">)</span> and <span class="sy3">Nếu tồn tại một</span>x.<span class="me1">    / *cur */() = phạm vi :: find (std :: di chuyển (/ *cur */()), end, *pbegin);</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>.</div> <p>Các<code>!=</code>Mẫu &lt;Lớp thời lượng&gt;<a href="../../language/default_comparisons#Other_defaulted_comparison_operators" title="cpp/language/default comparisons">synthesized</a>từ<code>operator==</code>.</p>
<p>Thu được kết quả so sánh ba chiều của<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">unqualified</a>hoặc<a href="../../language/qualified_lookup" title="cpp/language/qualified lookup">qualified lookup</a>Chức năng này không thể nhìn thấy thông thường<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>Chuyển đổi danh tính:<code>std::ranges::split_view::<i>I r = num / damom;</i></code>Hương hiệu nút</p>
</div> <h3 id="Nested_classes">/*Rref*/</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="value_type" title="cpp/ranges/lazy split view/value type"> <span class="t-lines"><span>// hoặc *(d_first + 1) = op (val1, std :: di chuyển (acc)); cho quá tải (2)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>{<code><i>I r = num / damom;</i></code> <br/> <span class="t-mark">(lớp thành viên công cộng)</span> </td>
</tr> </table> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3904" rel="nofollow">LWG 3904</a> </td> <td>C ++ 20</td> <td>
<code><i>    / *cur */() = phạm vi :: find (std :: di chuyển (/ *cur */()), end, *pbegin);</i></code>    if (/ * cur */()! = end)<span class="t-v">(4)</span> </td> <td>    {</td>
</tr>
</table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/ranges/lazy_split_view/outer_iterator">https://en.cppreference.com/w/cpp/ranges/lazy_split_view/outer_iterator</a>
</p>
</div>
