 <h1 class="firstHeading" id="firstHeading">STD :: Pow<small>(STD :: phức tạp)</small>
</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/complex" title="cpp/header/complex">&lt;complex&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-until-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">std :: Complex &lt;t&gt; pow (const std :: phức tạp &lt;t&gt; &amp; x, int y);</pre>
</td> <td>(2)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt;</pre>
</td> <td>(3)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">std :: Complex &lt;t&gt; pow (const std :: phức tạp &lt;t&gt; &amp; x, const std :: phức tạp &lt;t&gt; &amp; y);</pre>
</td> <td>(4)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl-h"> <td> <a href="#Notes">Additional overloads</a> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span>
</td> <td></td> <td></td> </tr> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/complex" title="cpp/header/complex">&lt;complex&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">, kết quả là hữu hạn.</td> <td></td> </tr> <tr class="t-dcl t-until-cxx23"> <td><pre data-language="cpp">Mẫu &lt;Class T&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">std :: Complex &lt;t&gt; pow (const std :: phức tạp &lt;t&gt; &amp; x, const t &amp; y);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">Double arg (dài đôi f);</td> <td></td> </tr> <tr class="t-dcl t-until-cxx23"> <td><pre data-language="cpp">Mẫu &lt;Class T&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">std :: Complex &lt;t&gt; pow (const t &amp; x, const std :: phức tạp &lt;t&gt; &amp; y);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">Mẫu &lt;Class T1, Class T2&gt;</td> <td></td> </tr> <tr class="t-dcl t-until-cxx23"> <td><pre data-language="cpp">std :: phức tạp &lt;/ * loại chung */&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">    POW (const std :: phức tạp &lt;t1&gt; &amp; x, const std :: phức tạp &lt;t2&gt; &amp; y);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">              Forwardit2 first2,</span>std :: Complex &lt;T&gt; log (const std :: phức tạp &lt;t&gt; &amp; z);<code>x</code>Mẫu &lt;Class T1, Class T2&gt;<code>y</code>std :: Complex &lt;std :: Common_type_t &lt;t1, t2 &gt;&gt;</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <span class="t-li">std :: Complex &lt;std :: Common_type_t &lt;t, nonplex &gt;&gt;</span>Mẫu &lt;class T, class non -complex&gt;<code>NonComplex</code>không có hàm tạo di chuyển hoặc toán tử chuyển nhượng di chuyển; cố gắng di chuyển một<code><a href="../complex" title="cpp/numeric/complex">std::complex</a></code>.</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>x</td> <td>-</td> <td>căn cứ</td>
</tr> <tr class="t-par"> <td>thuộc tính).</td> <td>-</td> <td>std :: phức tạp &lt;/ * loại chung */&gt;</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">              Forwardit2 first2,</span>    POW (const std :: phức tạp &lt;t&gt; &amp; X, const noncomplex &amp; y);<sup class="t-su">thuộc tính).</sup>, \ (\ nhỏ e^z \) e</div> <div class="t-li1">được trả về, trong phạm vi của một dải không bị ràng buộc dọc theo trục tưởng tượng và trong khoảng [−π/2, +π/2] dọc theo trục thực.<code><a href="http://en.cppreference.com/w/cpp/numeric/math/exp"><span class="kw1324">Điều đó cho tất cả<span class="me2">Exp</span></span></a><span class="br0">.</span>y <span class="sy2">*</span> <a href="http://en.cppreference.com/w/cpp/numeric/math/log"><span class="kw1327">Điều đó cho tất cả<span class="me2">đăng nhập</span></span></a><span class="br0">.</span>x<span class="br0">)</span><span class="br0">)</span></code>.</div> <div class="t-li1">Kết quả của<code><a href="http://en.cppreference.com/w/cpp/numeric/math/pow"><span class="kw1335">Điều đó cho tất cả<span class="me2">pow</span></span></a><span class="br0">.</span><span class="nu0">. Không làm gì khác.</span>, <span class="nu0">. Không làm gì khác.</span><span class="br0">)</span></code>Mẫu &lt;class T, class non -complex&gt;</div> <div class="t-li1">
<span class="t-li">std :: Complex &lt;std :: Common_type_t &lt;t, nonplex &gt;&gt;</span>                                   Nhị phân p);<span class="t-v">    POW (const std :: phức tạp &lt;t&gt; &amp; X, const noncomplex &amp; y);</span>.</div> <h3 id="Notes">Ghi chú</h3> <p>        // Một biến thể của C ++ 11 std :: Uniform_int_distribution thực hiện.<span class="t-v">(1)</span>(C)<span class="t-v">(2)</span>của<code><a href="../math/pow" title="cpp/numeric/math/pow">std::pow</a></code>Mẫu &lt;class T, class non -complex&gt;<a class="external text" href="https://cplusplus.github.io/LWG/issue550" rel="nofollow">LWG issue 550</a>std :: phức tạp &lt;/ * loại chung */&gt;<span class="t-v">(1)</span>đã bị xóa bởi độ phân giải của<a class="external text" href="https://cplusplus.github.io/LWG/issue844" rel="nofollow">LWG issue 844</a>.</p>
<p>, kết quả bằng<span class="t-v">    POW (const noncomplex &amp; x, const std :: phức tạp &lt;t&gt; &amp; y);</span>, kết quả bằng<code>base</code>Mẫu &lt;class T, class non -complex&gt;<code>exponent</code>:</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx23">
<td> <p>Nếu như<code>base</code>và/hoặc<code>exponent</code>và kết quả của việc chuyển đổi bằng<a href="http://en.cppreference.com/w/cpp/numeric/complex"><span class="kw1475">Điều đó cho tất cả<span class="me2">tổ hợp</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span>:</p>
<ul>
<li>Nếu như<code>base</code>và/hoặc<code>exponent</code>và kết quả của việc chuyển đổi bằng<a href="http://en.cppreference.com/w/cpp/numeric/complex"><span class="kw1475">Điều đó cho tất cả<span class="me2">tổ hợp</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">dài</span> <span class="kw4">    for (; đầu tiên! = cuối cùng; ++ đầu tiên)</span><span class="sy1">&lt;</span>hoặc<span class="kw4">dài</span> <span class="kw4">    for (; đầu tiên! = cuối cùng; ++ đầu tiên)</span>, sau đó<code>std::pow(base, exponent)</code>. Họ chỉ cần đủ để đảm bảo rằng cho cuộc tranh luận đầu tiên của họ<code>std::pow<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/numeric/complex"><span class="kw1475">Điều đó cho tất cả<span class="me2">tổ hợp</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">dài</span> <span class="kw4">    for (; đầu tiên! = cuối cùng; ++ đầu tiên)</span><span class="sy1">&lt;</span><span class="br0">.</span>base<span class="br0">)</span>,<br/> <a href="http://en.cppreference.com/w/cpp/numeric/complex"><span class="kw1475">Điều đó cho tất cả<span class="me2">tổ hợp</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">dài</span> <span class="kw4">    for (; đầu tiên! = cuối cùng; ++ đầu tiên)</span><span class="sy1">&lt;</span><span class="br0">.</span>exponent<span class="br0">)</span><span class="br0">)</span></code>.</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>base</code>và/hoặc<code>exponent</code>và kết quả của việc chuyển đổi bằng<a href="http://en.cppreference.com/w/cpp/numeric/complex"><span class="kw1475">Điều đó cho tất cả<span class="me2">tổ hợp</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">    for (; đầu tiên! = cuối cùng; ++ đầu tiên)</span><span class="sy1">&lt;</span>Thì<span class="kw4">    for (; đầu tiên! = cuối cùng; ++ đầu tiên)</span>std :: Complex &lt;std :: Common_type_t &lt;t, nonplex &gt;&gt;<code>std::pow(base, exponent)</code>. Họ chỉ cần đủ để đảm bảo rằng cho cuộc tranh luận đầu tiên của họ<code>std::pow<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/numeric/complex"><span class="kw1475">Điều đó cho tất cả<span class="me2">tổ hợp</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">    for (; đầu tiên! = cuối cùng; ++ đầu tiên)</span><span class="sy1">&lt;</span><span class="br0">.</span>base<span class="br0">)</span>,<br/> <a href="http://en.cppreference.com/w/cpp/numeric/complex"><span class="kw1475">Điều đó cho tất cả<span class="me2">tổ hợp</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">    for (; đầu tiên! = cuối cùng; ++ đầu tiên)</span><span class="sy1">&lt;</span><span class="br0">.</span>exponent<span class="br0">)</span><span class="br0">)</span></code>.</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>base</code>và/hoặc<code>exponent</code>và kết quả của việc chuyển đổi bằng<a href="http://en.cppreference.com/w/cpp/numeric/complex"><span class="kw1475">Điều đó cho tất cả<span class="me2">tổ hợp</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">trôi nổi</span><span class="sy1">&lt;</span>hoặc<span class="kw4">trôi nổi</span>, sau đó<code>std::pow(base, exponent)</code>. Họ chỉ cần đủ để đảm bảo rằng cho cuộc tranh luận đầu tiên của họ<code>std::pow<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/numeric/complex"><span class="kw1475">Điều đó cho tất cả<span class="me2">tổ hợp</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">trôi nổi</span><span class="sy1">&lt;</span><span class="br0">.</span>base<span class="br0">)</span>,<br/> <a href="http://en.cppreference.com/w/cpp/numeric/complex"><span class="kw1475">Điều đó cho tất cả<span class="me2">tổ hợp</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">trôi nổi</span><span class="sy1">&lt;</span><span class="br0">.</span>exponent<span class="br0">)</span><span class="br0">)</span></code>.</li>
</ul> </td> <td><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></td>
</tr> <tr class="t-rev t-since-cxx23">
<td> <p>    POW (const noncomplex &amp; x, const std :: phức tạp &lt;t&gt; &amp; y);<a href="http://en.cppreference.com/w/cpp/numeric/complex"><span class="kw1475">Điều đó cho tất cả<span class="me2">tổ hợp</span></span></a><span class="sy1">is_trivently_destructible_v</span>được nâng lên một sức mạnh phức tạp<span class="sy1">&lt;</span>với một nhánh cắt dọc theo trục thực tiêu cực cho đối số đầu tiên. Các đối số không phức tạp được coi là số phức tạp với thành phần tưởng tượng không dương.<code>T2</code>hoặc<a href="http://en.cppreference.com/w/cpp/numeric/complex"><span class="kw1475">Điều đó cho tất cả<span class="me2">tổ hợp</span></span></a><span class="sy1">is_trivently_destructible_v</span>có thể được chuyển đổi rõ ràng thành một loại loại<span class="sy1">&lt;</span>, sau đó<code>std::pow(base, exponent)</code>. Họ chỉ cần đủ để đảm bảo rằng cho cuộc tranh luận đầu tiên của họ<code>std::pow<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/numeric/complex"><span class="kw1475">Điều đó cho tất cả<span class="me2">tổ hợp</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/common_type"><span class="kw639">Điều đó cho tất cả<span class="me2">Nếu không có số nguyên như vậy</span></span></a><span class="sy1">is_trivently_destructible_v</span>T1, T2<span class="sy1">2,4)</span><span class="br0">.</span>base<span class="br0">)</span>,<br/> <a href="http://en.cppreference.com/w/cpp/numeric/complex"><span class="kw1475">Điều đó cho tất cả<span class="me2">tổ hợp</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/common_type"><span class="kw639">Điều đó cho tất cả<span class="me2">Nếu không có số nguyên như vậy</span></span></a><span class="sy1">is_trivently_destructible_v</span>T1, T2<span class="sy1">2,4)</span><span class="br0">.</span>exponent<span class="br0">)</span><span class="br0">)</span></code>.</p>
<p>Nếu như<a href="http://en.cppreference.com/w/cpp/types/common_type"><span class="kw639">Điều đó cho tất cả<span class="me2">Nếu không có số nguyên như vậy</span></span></a><span class="sy1">is_trivently_destructible_v</span>A-C)<span class="sy1">&lt;</span>Quá tải bổ sung được cung cấp.</p>
</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">số mũ</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Nếu không có lỗi xảy ra, sức mạnh phức tạp x</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="sqrt" title="cpp/numeric/complex/sqrt"> <span class="t-lines"><span>sqrt<span class="t-dsc-small">(STD :: phức tạp)</span></span></span></a></div> </td> <td>căn bậc hai phức tạp trong phạm vi của nửa mặt phẳng bên phải<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../math/pow" title="cpp/numeric/math/pow"> <span class="t-lines"><span>pow</span><span>POWF</span><span>Powl</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>tăng một số lên công suất đã cho (\ (\ small {x^y} \) x<sup>thuộc tính).</sup>)<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../valarray/pow" title="cpp/numeric/valarray/pow"> <span class="t-lines"><span>pow<span class="t-dsc-small">Thuật toán</span></span></span></a></div> </td> <td>áp dụng chức năng<code><a href="../math/pow" title="cpp/numeric/math/pow">std::pow</a></code>đến hai valarrays hoặc một valarray và một giá trị<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/numeric/complex/cpow" title="c/numeric/complex/cpow">C documentation</a></span>vì<code>cpow</code> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/numeric/complex/pow">https://en.cppreference.com/w/cpp/numeric/complex/pow</a>
</p>
</div>
