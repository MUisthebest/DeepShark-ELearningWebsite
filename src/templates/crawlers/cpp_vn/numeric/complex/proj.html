 <h1 class="firstHeading" id="firstHeading">std :: proj (std :: phức tạp)</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/complex" title="cpp/header/complex">&lt;complex&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt; </pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl-h"> <td> <a href="#Notes">Additional overloads</a> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span>
</td> <td></td> <td></td> </tr> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/complex" title="cpp/header/complex">&lt;complex&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">, kết quả là hữu hạn.</td> <td></td> </tr> <tr class="t-dcl t-until-cxx23"> <td><pre data-language="cpp">std :: Complex &lt;T&gt; proj (const std :: phức tạp &lt;t&gt; &amp; z);</pre></td> <td><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">std :: phức tạp &lt;float&gt; proj (float f);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">STD :: phức tạp &lt;Uuble&gt; proj (double f);</pre>
</td> <td>Double arg (dài đôi f);</td> <td class="t-dcl-nopad"> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>std :: phức tạp &lt;dài đôi&gt; proj (dài đôi f);<code>z</code>Mẫu &lt;Class FloatingPoint&gt;<a class="extiw" href="https://en.wikipedia.org/wiki/Riemann_sphere" title="enwiki:Riemann sphere">Riemann sphere</a>.</div> <div class="t-li1">STD :: Complex &lt;LeoatingPoint&gt; Proj (FloatingPoint F);<code>z</code>Thì<code>std::proj(z) == z</code>Mẫu &lt;Class Integer&gt;<code><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/numeric/math/INFINITY"><span class="kw1380">Vô cùng</span></a>, <span class="nu16">0,0</span><span class="br0">)</span></code>hoặc<code><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/numeric/math/INFINITY"><span class="kw1380">Vô cùng</span></a>, <span class="sy2">-</span><span class="nu16">0,0</span><span class="br0">)</span></code>STD :: Complex &lt;Uuble&gt; Proj (Integer I);<code><a href="http://en.cppreference.com/w/cpp/numeric/complex/imag2"><span class="kw2691">Điều đó cho tất cả<span class="me2">hình ảnh</span></span></a><span class="br0">.</span>z<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">FloatingPoint</span>Trả về hình chiếu của số phức</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Trả về độ lớn của số phức</td> <td>-</td> <td>z</td>
</tr> <tr class="t-par"> <td>có thể sửa đổi các phần tử của phạm vi thông qua trình lặp được thu hút. Nếu như</td> <td>-</td> <td>Mẫu &lt;Class Integer&gt; </td>
</tr> <tr class="t-par"> <td>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</td> <td>-</td> <td>Có các bit đệm.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">1)</span>Quá tải bổ sung được cung cấp cho tất cả các loại số nguyên và dấu phẩy động, được coi là số phức tạp với thành phần tưởng tượng không dương.<code>z</code>Hình chiếu của</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;arithmetic1, orithmetic2, số học lớp3&gt; lớp</span>Quá tải bổ sung được cung cấp cho tất cả các loại số nguyên và dấu phẩy động, được coi là số phức tạp với thành phần tưởng tượng không dương.<code><a href="http://en.cppreference.com/w/cpp/numeric/complex"><span class="kw1475">Điều đó cho tất cả<span class="me2">tổ hợp</span></span></a><span class="br0">.</span>f<span class="br0">)</span></code>Hình chiếu của</div> <div class="t-li1">
<span class="t-li">Quá tải bổ sung được cung cấp cho tất cả các loại số nguyên và dấu nổi, được coi là số phức tạp với thành phần tưởng tượng bằng không.</span>Quá tải bổ sung được cung cấp cho tất cả các loại số nguyên và dấu phẩy động, được coi là số phức tạp với thành phần tưởng tượng không dương.<code><a href="http://en.cppreference.com/w/cpp/numeric/complex"><span class="kw1475">Điều đó cho tất cả<span class="me2">tổ hợp</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">    for (; đầu tiên! = cuối cùng; ++ đầu tiên)</span><span class="sy1">&lt;</span><span class="br0">.</span>i<span class="br0">)</span></code>Hình chiếu của</div> <h3 id="Notes">Ghi chú</h3> <p>Các<code>proj</code>lên quả cầu riemann.</p>
<p>, kết quả bằng<span class="t-v">. Nếu không có lỗi xảy ra, đây là góc pha của</span>trong khoảng [−π; π].<code>num</code>:</p>
<ul>
<li>Nếu như<code>num</code>Toán tử gán bản sao được xác định ngầm cho một lớp<span class="t-rev-inl t-until-cxx23"><span>không phải là một CV-Unquilify</span><span><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></span></span>là tích cực hoặc +0, π nếu<code>T</code>, sau đó<code>std::proj(num)</code>. Họ chỉ cần đủ để đảm bảo rằng cho cuộc tranh luận đầu tiên của họ<code>std<span class="sy4">::</span><span class="me2">niebloids</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/numeric/complex"><span class="kw1475">Điều đó cho tất cả<span class="me2">tổ hợp</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="br0">.</span>num<span class="br0">)</span><span class="br0">)</span></code>.</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>num</code>là tiêu cực hoặc -0, nan khác.<code>std::proj(num)</code>. Họ chỉ cần đủ để đảm bảo rằng cho cuộc tranh luận đầu tiên của họ<code>std<span class="sy4">::</span><span class="me2">niebloids</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/numeric/complex"><span class="kw1475">Điều đó cho tất cả<span class="me2">tổ hợp</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">    for (; đầu tiên! = cuối cùng; ++ đầu tiên)</span><span class="sy1">&lt;</span><span class="br0">.</span>num<span class="br0">)</span><span class="br0">)</span></code>.</li>
</ul> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Hình chiếu của</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">lên quả cầu riemann.</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="abs" title="cpp/numeric/complex/abs"> <span class="t-lines"><span>tròn<span class="t-dsc-small">(STD :: phức tạp)</span></span></span></a></div> </td> <td>Trả về độ lớn của một số phức<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="norm" title="cpp/numeric/complex/norm"> <span class="t-lines"><span>định mức</span></span></a></div> </td> <td>trả về cường độ bình phương<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="polar" title="cpp/numeric/complex/polar"> <span class="t-lines"><span>cực</span></span></a></div> </td> <td>xây dựng một số phức từ độ lớn và góc pha<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/numeric/complex/cproj" title="c/numeric/complex/cproj">C documentation</a></span>vì<code>cproj</code> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/numeric/complex/proj">https://en.cppreference.com/w/cpp/numeric/complex/proj</a>
</p>
</div>
