 <h1 class="firstHeading" id="firstHeading">STD :: Valarray &lt;t&gt; :: Nhà điều hành []</h1> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">const t &amp; toán tử [] (std :: size_t pos) const;</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">T &amp; toán tử [] (std :: size_t pos);</pre>
</td> <td>(2)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">std :: valarray &lt;t&gt; toán tử [] (std :: slice slicearr) const;</pre>
</td> <td>(3)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">std :: slice_array &lt;t&gt; toán tử [] (std :: slice slicearr);</pre>
</td> <td>(4)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">std :: valarray &lt;t&gt; toán tử [] (const std :: gslice &amp; gsliceArr) const;</pre>
</td> <td>             Không có p);</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">std :: gslice_array &lt;t&gt; toán tử [] (const std :: gslice &amp; gsliceArr);</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">std :: Valarray &lt;t&gt; toán tử [] (const std :: valarray &lt;bool&gt; &amp; boolarr) const;</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">std :: mask_array &lt;t&gt; toán tử [] (const std :: valarray &lt;bool&gt; &amp; boolarr);</pre>
</td> <td>            Nhị phân p);</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">std :: Valarray &lt;t&gt; toán tử [] (const std :: valarray &lt;std :: size_t&gt; &amp; indarr) const;</pre>
</td> <td>(9)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">std :: indirect_array &lt;t&gt; toán tử [] (const std :: valarray &lt;std :: size_t&gt; &amp; indarr);</pre>
</td> <td>(10)</td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Lấy các phần tử đơn hoặc các phần của mảng.</p>
<p>Các<span class="kw4">hằng số</span>Quá tải đó trả về các chuỗi phần tử tạo ra một mới<code><a href="../valarray" title="cpp/numeric/valarray">std::valarray</a></code>sự vật. Không<span class="kw4">hằng số</span>Quá tải các lớp trả về các lớp tổ chức tham chiếu đến các phần tử mảng.</p>
<p>Các yếu tố đã chọn phải tồn tại:</p>
<ul>
<li>BẰNG<span class="t-v">Outputit adjacent_difference (đầu vào đầu tiên, đầu vào cuối cùng, </span>Sử dụng chức năng nhị phân đã cho<code>pos</code>không ít hơn<a href="size" title="cpp/numeric/valarray/size"><code>size()</code></a>, hành vi là không xác định; Và</li>
<li>BẰNG<span class="t-v"> </span>, nếu đối số không chỉ định một tập hợp con hợp lệ của<code>*this</code>Hoạt động tương đương cho quá tải</li>
</ul> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>POS</td> <td>-</td> <td>vị trí của phần tử để trả về</td>
</tr> <tr class="t-par"> <td>Slicearr</td> <td>-</td> <td> <a href="slice" title="cpp/numeric/valarray/slice">slice</a>của các yếu tố để trở lại</td>
</tr> <tr class="t-par"> <td>GSLICEARR</td> <td>-</td> <td> <a href="gslice" title="cpp/numeric/valarray/gslice">gslice</a>của các yếu tố để trở lại</td>
</tr> <tr class="t-par"> <td>Boolarr</td> <td>-</td> <td>Mặt nạ của các yếu tố để trở lại</td>
</tr> <tr class="t-par"> <td>Indarr</td> <td>-</td> <td>chỉ số của các yếu tố để trả lại</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">Đầu vào</span>Một tham chiếu đến phần tử tương ứng.</div> <div class="t-li1">
<span class="t-li">3,5,7,9)</span>MỘT<code><a href="../valarray" title="cpp/numeric/valarray">std::valarray</a></code>Đối tượng chứa các bản sao của các mục đã chọn.</div> <div class="t-li1">
<span class="t-li">4,6,8,10)</span>Cấu trúc dữ liệu tương ứng chứa các tham chiếu đến các mục đã chọn.</div> <h3 id="Exceptions">Ngoại lệ</h3> <p>Có thể ném các trường hợp ngoại lệ do thực hiện.</p>
<h3 id="Notes">Ghi chú</h3> <p>Cho đúng<code><a href="../valarray" title="cpp/numeric/valarray">std::valarray</a></code>giá trị<code>a</code>Thì<code>b</code>và đúng<code><a href="../../types/size_t" title="cpp/types/size t">std::size_t</a></code>giá trị<code>i</code>Thì<code>j</code>, tất cả các biểu thức sau luôn đánh giá<code>true</code>:</p>
<div class="t-li1">
<span class="t-li">1)</span> <code>(a[i] = q, a[i]) == q</code>Đối với người không cư trú<code>a</code>
</div> <span class="t-li">2)</span> <code>&amp;a[i + j] == &amp;a[i] + j</code> <ul><li>Điều này có nghĩa là như vậy<code><a href="../valarray" title="cpp/numeric/valarray">std::valarray</a></code>Các yếu tố liền kề trong bộ nhớ.</li></ul> <span class="t-li">Mẫu &lt;class f, class tuple&gt;</span> <code>&amp;a[i] != &amp;b[j]</code>cho mọi đối tượng<code>a</code>Và<code>b</code>đó không phải là bí danh của nhau<ul><li>Điều này có nghĩa là không có bí danh trong các yếu tố và thuộc tính này có thể được sử dụng để thực hiện một số loại tối ưu hóa.</li></ul> <p>Tài liệu tham khảo trở nên không hợp lệ trên<a href="resize" title="cpp/numeric/valarray/resize"><code>resize()</code></a>hoặc khi mảng bị phá hủy.</p>
<p>Để tính toán sự khác biệt, quá tải<span class="t-v">(3,5,7,9)</span>, Chức năng có thể được thực hiện với loại trả về khác với<code><a href="../valarray" title="cpp/numeric/valarray">std::valarray</a></code>Chức năng có thể được thực hiện với loại trả về khác với</p>
<ul>
<li>Tất cả<span class="kw4">hằng số</span>Tại điểm trong mã<code><a href="../valarray" title="cpp/numeric/valarray">std::valarray</a></code>. Trong trường hợp này, loại thay thế có các thuộc tính sau:</li>
<li> <code><a href="../valarray" title="cpp/numeric/valarray">std::valarray</a></code>Thì<code><a href="slice_array" title="cpp/numeric/valarray/slice array">std::slice_array</a></code>Thì<code><a href="gslice_array" title="cpp/numeric/valarray/gslice array">std::gslice_array</a></code>Thì<code><a href="mask_array" title="cpp/numeric/valarray/mask array">std::mask_array</a></code>Và<code><a href="indirect_array" title="cpp/numeric/valarray/indirect array">std::indirect_array</a></code>được cung cấp.</li>
<li>có thể được xây dựng từ loại thay thế.<span class="kw4">hằng số</span> <a href="http://en.cppreference.com/w/cpp/numeric/valarray"><span class="kw1476">Điều đó cho tất cả<span class="me2">Valarray</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="sy3">Không có giá trị</span> <span class="t-rev-inl t-since-cxx11"><span>                             STD :: Memory_order Order) NoExcept;<a href="begin2" title="cpp/numeric/valarray/begin2"><code>begin()</code></a>Và<a href="end2" title="cpp/numeric/valarray/end2"><code>end()</code></a></span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Cho mọi chức năng lấy một</li>
<li>, các chức năng giống hệt nhau lấy các loại thay thế sẽ được thêm vào;<span class="kw4">hằng số</span> <a href="http://en.cppreference.com/w/cpp/numeric/valarray"><span class="kw1476">Điều đó cho tất cả<span class="me2">Valarray</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="sy3">Không có giá trị</span>Cho mọi chức năng lấy hai chức năng<span class="kw4">hằng số</span> <a href="http://en.cppreference.com/w/cpp/numeric/valarray"><span class="kw1476">Điều đó cho tất cả<span class="me2">Valarray</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="sy3">Không có giá trị</span>đối số, các chức năng giống hệt nhau lấy mọi kết hợp của</li>
<li>và các loại thay thế sẽ được thêm vào.</li>
</ul> <p>Lát/mặt nạ/truy cập chỉ mục gián tiếp không chuỗi:<code>v<span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span>v <span class="sy1">==</span> n<span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span><span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span><a href="http://en.cppreference.com/w/cpp/numeric/valarray/slice"><span class="kw1477">Điều đó cho tất cả<span class="me2">lát cắt</span></span></a><span class="br0">.</span><span class="nu0">. Không làm gì khác.</span>, <span class="nu0">5</span>, <span class="nu0">    return (! (đầu tiên == cuối cùng) và! (giá trị &lt; *đầu tiên));</span><span class="br0">)</span><span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span> <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> x<span class="sy4">Số lượng các yếu tố để sao chép</span></code>là một lỗi vì<code><a href="mask_array" title="cpp/numeric/valarray/mask array">std::mask_array</a></code>(Loại của<code>v[v == n]</code>) không có toán tử<span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span><span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span>.</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;CstDdef&gt;</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">#include &lt;iomanip&gt;</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue389" rel="nofollow">LWG 389</a> </td> <td>C ++ 98</td> <td>#include &lt;Istream&gt;<span class="t-v">(1)</span> <code>T</code> </td> <td>, số lượng tăng số lặp là tuyến tính. Đáng chú ý,<span class="kw4">hằng số</span>T<span class="sy3">Không có giá trị</span> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue430" rel="nofollow">LWG 430</a> </td> <td>C ++ 98</td> <td>#include &lt;ValArray&gt;<br/><span class="t-v"> </span>int main () </td> <td>là giá trị trả về, vẫn có thể giảm được, nhưng bản thân các yếu tố có giá trị không xác định. Một cuộc gọi đến<br/>kích cỡ.</td>
</tr>
</table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/numeric/valarray/operator_at">https://en.cppreference.com/w/cpp/numeric/valarray/operator_at</a>
</p>
</div>
