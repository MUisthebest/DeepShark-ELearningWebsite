 <h1 class="firstHeading" id="firstHeading">std :: Discret_distribution &lt;inttype&gt; :: Discret_distribution</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Discret_distribution ();</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;Class Inputit&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Discret_distribution (đầu vào đầu tiên, đầu vào cuối cùng);</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Discret_distribution (std :: initizer_list &lt;double&gt; trọng số);</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;Class Undyoperation&gt;</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> </table> <p>Xây dựng một đối tượng phân phối mới.</p>
<div class="t-li1">
<span class="t-li">1)</span>Discret_distribution (STD :: size_t Count, Double Xmin, Double Xmax,<code>​0​</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>                       Unanyeration unary_op);<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>. Nếu như<code>first == last</code>Rõ ràng rời rạc_distribution (const param_type &amp; params);</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Hàm tạo mặc định. Xây dựng phân phối với một trọng số p = {1}. Phân phối này sẽ luôn tạo ra<code>weights</code>. Gọi một cách hiệu quả<code>discrete_distribution(weights.begin(), weights.end())</code>.</div> <div class="t-li1">
<span class="t-li">là trong</span>và i ∈ {0, ..., đếm - 1}.<code>count</code>, các hiệu ứng giống như của hàm tạo mặc định.<code>unary_op</code>Xây dựng sự phân phối với các trọng số trong<sub class="t-su t-su-b">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</sub>Xây dựng phân phối với<span><span>Các trọng số được tạo ra bằng chức năng</span><span>/</span><span>(Niebloid)</span></span>. Mỗi trọng số bằng W<code>xmin</code>Và<code>xmax</code>= unary_op (xmin + (i + 0,5)), trong đó = =<code>count == 0</code>(xmax - xmin)</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>và i ∈ {0, ..., đếm - 1}.<code>params</code>như các tham số phân phối.</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>phải sao cho Δ&gt; 0. Nếu<code>InputIterator</code>(6)<code>double</code> </td>
</tr> <tr class="t-par"> <td>Các hiệu ứng giống như của hàm tạo mặc định.</td> <td>-</td> <td>Xây dựng phân phối với</td>
</tr> <tr class="t-par"> <td>          Lớp đầu ra, lớp BinaryOperation&gt;</td> <td>-</td> <td>Biến đổi đầu ra Constexpr (đầu vào đầu tiên1, đầu vào<br/> <p>Đầu tiên, cuối cùng</p>
<p><span class="t-cc"><code> Ret fun(const Type &amp;a);</code></span></p>
<p>phạm vi của các phần tử để tổng<code>const &amp;</code>.<br/>Phạm vi của các yếu tố xác định các số sẽ sử dụng làm trọng số. Loại yếu tố được đề cập bởi<span class="kw4">    for (; đầu tiên! = cuối cùng; ++ đầu tiên)</span>trọng lượng<code>Ret</code>Giá trị ban đầu của tổng<code>double</code> <code>Ret</code>Đối tượng chức năng hoạt động nhị phân sẽ được áp dụng.</p>
</td>
</tr> <tr class="t-par"> <td>Kiểm tra khoảng trống ()</td> <td>-</td> <td>Tập hợp phân phối tập hợp</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>InputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</td>
</tr>
</table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/numeric/random/discrete_distribution/discrete_distribution">https://en.cppreference.com/w/cpp/numeric/random/discrete_distribution/discrete_distribution</a>
</p>
</div>
