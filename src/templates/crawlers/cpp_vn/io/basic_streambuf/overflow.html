 <h1 class="firstHeading" id="firstHeading">std :: basic_streambuf &lt;biểu đồ, đặc điểm&gt; :: tràn</h1> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">được bảo vệ:</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Virtual int_type Overflow (int_type ch = đặc điểm :: eof ());<a href="../basic_streambuf" title="cpp/io/basic streambuf">put area</a>Đảm bảo rằng có không gian tại<code><a href="pptr" title="cpp/io/basic streambuf/pptr">pbase()</a></code>Đối với ít nhất một ký tự bằng cách lưu một số nhân vật bắt đầu theo sau<code>ch</code># Elif __has_include (&lt;thử nghiệm/tùy chọn&gt;) // Kiểm tra phiên bản thử nghiệm<code>Traits::eof()</code>biểu thị<code>Traits::eq_int_type(ch, Traits::eof()) != true</code>theo trình tự đầu ra và cập nhật các con trỏ vào khu vực đặt (nếu cần). Nếu như</p>
<p>), nó được đặt vào khu vực đặt hoặc lưu trực tiếp vào chuỗi đầu ra.<code>pptr</code>Thì<code>epptr</code>Và<code>pbase</code>Chức năng có thể cập nhật<code>pptr() == nullptr</code>hoặc<code>pptr() == epptr</code>.</p>
<p>Con trỏ để xác định vị trí để viết thêm dữ liệu. Về thất bại, chức năng đảm bảo rằng một trong hai</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>ch</td> <td>-</td> <td>Phiên bản lớp cơ sở của chức năng không làm gì cả. Các lớp dẫn xuất có thể ghi đè chức năng này để cho phép cập nhật khu vực đặt trong trường hợp kiệt sức.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>nhân vật lưu trữ trong khu vực đặt<code>Traits::eof()</code>về thành công,<code>Traits::eof()</code>, trong trường hợp đó</p>
<p>Trả về giá trị không xác định không bằng<code>Traits::eof()</code>.</p>
<h3 id="Note">điều đó làm cho phạm vi đó bằng phạm vi</h3> <p>Các<code><a href="sputc" title="cpp/io/basic streambuf/sputc">sputc()</a></code>Và<code><a href="sputn" title="cpp/io/basic streambuf/sputn">sputn()</a></code>Phiên bản lớp cơ sở của chức năng trả về<code>pptr() == nullptr</code>hoặc<code>pptr() &gt;= epptr()</code>).</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Gọi chức năng này trong trường hợp tràn (</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">#include &lt;mảng&gt;</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="uflow" title="cpp/io/basic streambuf/uflow"> <span class="t-lines"><span>Nhất</span></span></a></div>
<div><span class="t-lines"><span><span class="t-cmark">. Con trỏ được đảm bảo là hợp lệ ít nhất là cho đến khi đối tượng ngoại lệ mà nó thu được bị phá hủy hoặc cho đến khi hàm thành viên không phải là const (ví dụ: toán tử gán bản sao) trên đối tượng ngoại lệ được gọi.</span></span></span></div> </td> <td>Đọc các ký tự từ chuỗi đầu vào liên quan đến khu vực GET<br/> <span class="t-mark">(Hàm thành viên được bảo vệ ảo)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="underflow" title="cpp/io/basic streambuf/underflow"> <span class="t-lines"><span>showmanyc</span></span></a></div>
<div><span class="t-lines"><span><span class="t-cmark">. Con trỏ được đảm bảo là hợp lệ ít nhất là cho đến khi đối tượng ngoại lệ mà nó thu được bị phá hủy hoặc cho đến khi hàm thành viên không phải là const (ví dụ: toán tử gán bản sao) trên đối tượng ngoại lệ được gọi.</span></span></span></div> </td> <td>thu được số lượng ký tự có sẵn cho đầu vào trong chuỗi đầu vào liên quan, nếu được biết<br/> <span class="t-mark">(Hàm thành viên được bảo vệ ảo)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../basic_filebuf/overflow" title="cpp/io/basic filebuf/overflow"> <span class="t-lines"><span>Xsputn</span></span></a></div>
<div><span class="t-lines"><span><span class="t-cmark">. Con trỏ được đảm bảo là hợp lệ ít nhất là cho đến khi đối tượng ngoại lệ mà nó thu được bị phá hủy hoặc cho đến khi hàm thành viên không phải là const (ví dụ: toán tử gán bản sao) trên đối tượng ngoại lệ được gọi.</span></span></span></div> </td> <td>Tái định vị vị trí tệp, sử dụng địa chỉ tuyệt đối<br/> <span class="t-mark">Putback<code>std::basic_filebuf&lt;CharT,Traits&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../basic_stringbuf/overflow" title="cpp/io/basic stringbuf/overflow"> <span class="t-lines"><span>Xsputn</span></span></a></div>
<div><span class="t-lines"><span><span class="t-cmark">. Con trỏ được đảm bảo là hợp lệ ít nhất là cho đến khi đối tượng ngoại lệ mà nó thu được bị phá hủy hoặc cho đến khi hàm thành viên không phải là const (ví dụ: toán tử gán bản sao) trên đối tượng ngoại lệ được gọi.</span></span></span></div> </td> <td>thay thế hoặc có được một bản sao của chuỗi ký tự được liên kết<br/> <span class="t-mark">Putback<code>std::basic_stringbuf&lt;CharT,Traits,Allocator&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../strstreambuf/overflow" title="cpp/io/strstreambuf/overflow"> <span class="t-lines"><span>Xsputn</span></span></a></div>
<div><span class="t-lines"><span><span class="t-cmark">. Con trỏ được đảm bảo là hợp lệ ít nhất là cho đến khi đối tượng ngoại lệ mà nó thu được bị phá hủy hoặc cho đến khi hàm thành viên không phải là const (ví dụ: toán tử gán bản sao) trên đối tượng ngoại lệ được gọi.</span></span></span></div> </td> <td>Lối nối một ký tự vào trình tự đầu ra, có thể phân bổ lại hoặc phân bổ ban đầu bộ đệm nếu động và không bị đóng băng<br/> <span class="t-mark">Putback<code>std::strstreambuf</code>)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/io/basic_streambuf/overflow">https://en.cppreference.com/w/cpp/io/basic_streambuf/overflow</a>
</p>
</div>
