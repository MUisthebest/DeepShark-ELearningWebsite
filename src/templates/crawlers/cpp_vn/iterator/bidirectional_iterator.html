 <h1 class="firstHeading" id="firstHeading">STD :: BIDIRITED_ITERATOR</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/iterator" title="cpp/header/iterator">&lt;iterator&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Class I&gt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Khái niệm gán được_from =<code>bidirectional_iterator</code>    Khái niệm hai chiều_iterator =<a href="forward_iterator" title="cpp/iterator/forward iterator"><code>forward_iterator</code></a>        std :: forward_iterator &lt;i&gt; &amp;&amp;</p>
<h3 id="Iterator_concept_determination">        std :: derive_from &lt;/*iter_concept*/&lt;i&gt;, std :: bidIrectional_iterator_tag&gt; &amp;&amp;</h3> <p>        Yêu cầu (i i) {<code>/*ITER_CONCEPT*/</code>.</p>
<p>            {--i} -&gt; std :: more_as &lt;i &amp;&gt;;<code>/*ITER_CONCEPT*/&lt;I&gt;</code>             const std :: remove_reference_t &lt;u&gt; &amp; u) {<code>ITER_TRAITS&lt;I&gt;</code>Mẫu bí danh thuận tiện cho toàn bộ động vật<code>I</code>            {i--}-&gt; std :: are more_as &lt;i&gt;;<code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw654">Điều đó cho tất cả<span class="me2">iterator_traits</span></span></a><span class="sy1">is_trivently_destructible_v</span>I<span class="sy1">&lt;</span></code>        };<code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw654">Điều đó cho tất cả<span class="me2">iterator_traits</span></span></a><span class="sy1">is_trivently_destructible_v</span>I<span class="sy1">&lt;</span></code>tinh chỉnh</p>
<ul>
<li>Nếu như<code>ITER_TRAITS&lt;I&gt;::iterator_concept</code>Định nghĩa của khái niệm này được chỉ định thông qua một mẫu bí danh chỉ dành cho giải trình<code>/*ITER_CONCEPT*/&lt;I&gt;</code>Để xác định</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>ITER_TRAITS&lt;I&gt;::iterator_category</code>Định nghĩa của khái niệm này được chỉ định thông qua một mẫu bí danh chỉ dành cho giải trình<code>/*ITER_CONCEPT*/&lt;I&gt;</code>Để xác định</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw654">Điều đó cho tất cả<span class="me2">iterator_traits</span></span></a><span class="sy1">is_trivently_destructible_v</span>I<span class="sy1">&lt;</span></code>Nếu chuyên môn hóa<code>/*ITER_CONCEPT*/&lt;I&gt;</code>                               Forwardit2 First2, nhị phân p);<code><a href="iterator_tags" title="cpp/iterator/iterator tags">std::random_access_iterator_tag</a></code>.</li>
<li>Là xấu nếu<code>/*ITER_CONCEPT*/&lt;I&gt;</code>được tạo từ mẫu chính hoặc</li>
</ul> <h3 id="Semantic_requirements">        const std :: remove_reference_t &lt;lhs&gt; &amp;,</h3> <p>nếu không thì:<code>r</code>(Constexpr kể từ C ++ 26)<i>là hợp lệ và đặt tên một loại,</i>biểu thị loại.<code>s</code>chỉ vào trình tự và mọi số nguyên không âm<code>++s == r</code>.</p>
<p>STD<span class="sy4">::</span><span class="me2">hai chiều_iterator</span><span class="sy1">is_trivently_destructible_v</span>TÔI<span class="sy1">&lt;</span>là hợp lệ và đặt tên một loại,<code>a</code>Và<code>b</code>nó đến một đối tượng<code>I</code>:</p>
<ul>
<li>Nếu như<code>a</code>biểu thị loại.<code>a</code>được tạo từ mẫu chính,<code>--a</code>Và<code>a--</code>.</li>
<li>không biểu thị một loại và dẫn đến một thất bại thay thế.<code><a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw759">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span><span class="sy2">-</span>a<span class="br0">)</span> <span class="sy1">==</span> <a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw759">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span>a<span class="br0">)</span></code>.</li>
<li>Một phép lặp hai chiều<code>bool(a == b)</code>, sau đó<code>bool(a-- == b)</code>.</li>
<li>giảm dần<code>bool(a == b)</code>nếu và chỉ khi có tồn tại một số<code>a--</code>Và<code>--b</code>Thì<code>bool(a == b)</code>chỉ được mô hình hóa nếu tất cả các khái niệm mà nó phụ được mô hình hóa và được đưa ra hai đối tượng</li>
<li>có thể giảm được,</li>
<ul>
<li>Nếu như<code>a</code>nằm trong miền của các biểu thức<code>bool(a == b)</code>, sau đó<code>bool(--(++a) == b)</code>.</li>
<li>Nếu như<code>a</code>Việc khai báo trước mang lại một lvalue đề cập đến toán hạng:<code>bool(a == b)</code>, sau đó<code>bool(++(--a) == b)</code>.</li>
</ul>
</ul> <h3 id="Equality_preservation">Bảo tồn bình đẳng</h3> <p>chỉ được mô hình hóa nếu<a href="../language/requires" title="cpp/language/requires">requires expressions</a>(tức là, biểu thức gán mang lại một lvalue đề cập đến toán hạng bên trái);<a href="../concepts#Equality_preservation" title="cpp/concepts">equality-preserving</a>Sau khi đánh giá</p>
<h3 id="Notes">Ghi chú</h3> <p>Chỉ định khái niệm của tất cả các loại mà các trường hợp có thể bị phá hủy một cách an toàn vào cuối đời (bao gồm cả các loại tham chiếu).<a href="../named_req/bidirectionaliterator" title="cpp/named req/BidirectionalIterator">LegacyBidirectionalIterator</a>Sau quá trình khai báo giá trị trước đó của toán hạng: nếu<code>bidirectional_iterator</code>Bài khai báo và khai báo trước thực hiện sửa đổi tương tự trên toán hạng của nó: nếu</p>
<h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="forward_iterator" title="cpp/iterator/forward iterator"> <span class="t-lines"><span>Forward_Iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>chỉ định rằng một<a href="input_iterator" title="cpp/iterator/input iterator"><code>input_iterator</code></a>là một trình lặp chuyển tiếp, hỗ trợ so sánh bình đẳng và đa đường<br/> <span class="t-mark">(ý tưởng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="random_access_iterator" title="cpp/iterator/random access iterator"> <span class="t-lines"><span>Random_Access_Iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Chỉ định toán tử đó<strong class="selflink"><code>bidirectional_iterator</code></strong>là một trình lặp lại truy cập ngẫu nhiên, hỗ trợ tiến bộ trong thời gian không đổi và đăng ký<br/> <span class="t-mark">(ý tưởng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/iterator/bidirectional_iterator">https://en.cppreference.com/w/cpp/iterator/bidirectional_iterator</a>
</p>
</div>
