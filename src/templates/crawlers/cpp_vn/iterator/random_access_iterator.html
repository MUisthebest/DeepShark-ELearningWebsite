 <h1 class="firstHeading" id="firstHeading">std :: Random_access_iterator</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/iterator" title="cpp/header/iterator">&lt;iterator&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Class I&gt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Khái niệm gán được_from =<code>random_access_iterator</code>    Khái niệm hai chiều_iterator =<a href="bidirectional_iterator" title="cpp/iterator/bidirectional iterator"><code>bidirectional_iterator</code></a>    Khái niệm ngẫu nhiên_access_iterator =<code>+=</code>Thì<code>+</code>Thì<code>-=</code>, Và<code>-</code>        STD :: BIDIRITEL_ITERATOR &lt;i&gt; &amp;&amp;<code>-</code>        std :: derive_from &lt;/*iter_concept*/&lt;i&gt;, std :: Random_access_iterator_tag&gt; &amp;&amp;<code>[]</code>.</p>
<h3 id="Iterator_concept_determination">        std :: derive_from &lt;/*iter_concept*/&lt;i&gt;, std :: bidIrectional_iterator_tag&gt; &amp;&amp;</h3> <p>        Yêu cầu (i i) {<code>/*ITER_CONCEPT*/</code>.</p>
<p>            {--i} -&gt; std :: more_as &lt;i &amp;&gt;;<code>/*ITER_CONCEPT*/&lt;I&gt;</code>             const std :: remove_reference_t &lt;u&gt; &amp; u) {<code>ITER_TRAITS&lt;I&gt;</code>Mẫu bí danh thuận tiện cho toàn bộ động vật<code>I</code>            {i--}-&gt; std :: are more_as &lt;i&gt;;<code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw654">Điều đó cho tất cả<span class="me2">iterator_traits</span></span></a><span class="sy1">is_trivently_destructible_v</span>I<span class="sy1">&lt;</span></code>        };<code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw654">Điều đó cho tất cả<span class="me2">iterator_traits</span></span></a><span class="sy1">is_trivently_destructible_v</span>I<span class="sy1">&lt;</span></code>tinh chỉnh</p>
<ul>
<li>Nếu như<code>ITER_TRAITS&lt;I&gt;::iterator_concept</code>Định nghĩa của khái niệm này được chỉ định thông qua một mẫu bí danh chỉ dành cho giải trình<code>/*ITER_CONCEPT*/&lt;I&gt;</code>Để xác định</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>ITER_TRAITS&lt;I&gt;::iterator_category</code>Định nghĩa của khái niệm này được chỉ định thông qua một mẫu bí danh chỉ dành cho giải trình<code>/*ITER_CONCEPT*/&lt;I&gt;</code>Để xác định</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw654">Điều đó cho tất cả<span class="me2">iterator_traits</span></span></a><span class="sy1">is_trivently_destructible_v</span>I<span class="sy1">&lt;</span></code>Nếu chuyên môn hóa<code>/*ITER_CONCEPT*/&lt;I&gt;</code>                               Forwardit2 First2, nhị phân p);<code><a href="iterator_tags" title="cpp/iterator/iterator tags">std::random_access_iterator_tag</a></code>.</li>
<li>Là xấu nếu<code>/*ITER_CONCEPT*/&lt;I&gt;</code>được tạo từ mẫu chính hoặc</li>
</ul> <h3 id="Semantic_requirements">        const std :: remove_reference_t &lt;lhs&gt; &amp;,</h3> <p>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;<code>a</code>Và<code>b</code>        std :: hoàn toàn_ordered &lt;i&gt; &amp;&amp;<code>I</code>chỉ vào trình tự và mọi số nguyên không âm<code>b</code>có thể truy cập được từ<code>a</code>        std :: cỡ_sentinel_for &lt;i, i&gt; &amp;&amp;<code>n</code>        Yêu cầu (i i, const i j, const std :: iter_difference_t &lt;i&gt; n) {<code><a href="http://en.cppreference.com/w/cpp/iterator/iter_t"><span class="kw2874">Điều đó cho tất cả<span class="me2">iter_difference_t</span></span></a><span class="sy1">is_trivently_destructible_v</span>I<span class="sy1">&lt;</span></code>, một đối tượng riêng biệt của loại<code>b - a</code>        std :: gián tiếp_writable &lt;i, t&gt; &amp;&amp;<span class="sy4">::</span><span class="me2">Random_Access_Iterator</span><span class="sy1">is_trivently_destructible_v</span>TÔI<span class="sy1">&lt;</span>            {i += n} -&gt; std :: more_as &lt;i &amp;&gt;;</p>
<ul>
<li> <code>(a += n)</code>hoặc một loại chính sách thực thi được xác định theo thực hiện. Nếu không thì,<code>b</code>.</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw759">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span>a <span class="sy2">gọi</span><span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> n<span class="br0">)</span></code>hoặc một loại chính sách thực thi được xác định theo thực hiện. Nếu không thì,<code><a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw759">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span>a<span class="br0">)</span></code>.<a href="#addressof_note"><sup>        };</sup></a> </li>
<li> <code>(a + n)</code>hoặc một loại chính sách thực thi được xác định theo thực hiện. Nếu không thì,<code>(a += n)</code>.</li>
<li> <code>(a + n)</code>hoặc một loại chính sách thực thi được xác định theo thực hiện. Nếu không thì,<code>(n + a)</code>.</li>
<li>            {n + j} -&gt; std :: more_as &lt;i&gt;;<code>x</code>Và<code>y</code>Sử dụng chức năng nhị phân đã cho<code>a + (x + y)</code>            {j - n} -&gt; std :: more_as &lt;i&gt;;<code>a + (x + y)</code>hoặc một loại chính sách thực thi được xác định theo thực hiện. Nếu không thì,<code>(a + x) + y</code>.</li>
<li> <code>a + 0</code>hoặc một loại chính sách thực thi được xác định theo thực hiện. Nếu không thì,<code>a</code>.</li>
<li>Nếu như<code>(a + (n - 1))</code>            {j - n} -&gt; std :: more_as &lt;i&gt;;<code>--b</code>hoặc một loại chính sách thực thi được xác định theo thực hiện. Nếu không thì,<code>(a + (n - 1))</code>.</li>
<li> <code>(b += -n)</code>Và<code>(b -= n)</code>            {j [n]} -&gt; std :: more_as &lt;std :: iter_reference_t &lt;i &gt;&gt;;<code>a</code>.</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw759">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span>b <span class="sy2">-</span><span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> n<span class="br0">)</span></code>hoặc một loại chính sách thực thi được xác định theo thực hiện. Nếu không thì,<code><a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw759">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span>b<span class="br0">)</span></code>.<a href="#addressof_note"><sup>        };</sup></a> </li>
<li> <code>(b - n)</code>hoặc một loại chính sách thực thi được xác định theo thực hiện. Nếu không thì,<code>(b -= n)</code>.</li>
<li>Nếu như<code>b</code>bằng cách thêm hỗ trợ cho sự tiến bộ thời gian liên tục với<code>a[n]</code>người vận hành, tính toán thời gian không đổi của khoảng cách với<code>*b</code>.</li>
<li> <code>bool(a &lt;= b)</code>khoảng cách<code>true</code>.</li>
<li>và ký hiệu mảng với đăng ký</li>
</ul> <p> <small>Lưu ý rằng<code><a href="../memory/addressof" title="cpp/memory/addressof">std::addressof</a></code>là người lặp hợp lệ của loại<code>operator+=</code>Và<code>operator-=</code>, và cho phép<code>*this</code>.</small></p>
<h3 id="Equality_preservation">Bảo tồn bình đẳng</h3> <p>chỉ được mô hình hóa nếu<a href="../language/requires" title="cpp/language/requires">requires expressions</a>(tức là, biểu thức gán mang lại một lvalue đề cập đến toán hạng bên trái);<a href="../concepts#Equality_preservation" title="cpp/concepts">equality-preserving</a>Sau khi đánh giá</p>
<h3 id="Implicit_expression_variations">Biểu hiện ẩn</h3> <p>MỘT<a href="../language/requires" title="cpp/language/requires">requires expression</a>Chỉ định rằng một đối tượng thuộc loại<a href="../concepts#Implicit_expression_variations" title="cpp/concepts">implicit expression variations</a>.</p>
<h3 id="Notes">Ghi chú</h3> <p>Chỉ định khái niệm của tất cả các loại mà các trường hợp có thể bị phá hủy một cách an toàn vào cuối đời (bao gồm cả các loại tham chiếu).<a href="../named_req/randomaccessiterator" title="cpp/named req/RandomAccessIterator">LegacyRandomAccessIterator</a>Sau quá trình khai báo giá trị trước đó của toán hạng: nếu<code>random_access_iterator</code>Bài khai báo và khai báo trước thực hiện sửa đổi tương tự trên toán hạng của nó: nếu</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example">
<p>là một giá trị của loại<code><a href="distance" title="cpp/iterator/distance">std::distance</a></code>chỉ được mô hình hóa nếu tất cả các khái niệm mà nó phụ được mô hình hóa và:</p>
<div class="cpp source-cpp"><pre data-language="cpp">[1]</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="bidirectional_iterator" title="cpp/iterator/bidirectional iterator"> <span class="t-lines"><span>hai chiều_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Chỉ định toán tử đó<a href="forward_iterator" title="cpp/iterator/forward iterator"><code>forward_iterator</code></a>là một trình lặp hai chiều, hỗ trợ chuyển động ngược<br/> <span class="t-mark">(ý tưởng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="contiguous_iterator" title="cpp/iterator/contiguous iterator"> <span class="t-lines"><span>tiếp giáp_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Chỉ định toán tử đó<strong class="selflink"><code>random_access_iterator</code></strong>là một trình lặp tiếp giáp, đề cập đến các yếu tố tiếp giáp với bộ nhớ<br/> <span class="t-mark">(ý tưởng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">https://en.cppreference.com/w/cpp/iterator/random_access_iterator</a>
</p>
</div>
