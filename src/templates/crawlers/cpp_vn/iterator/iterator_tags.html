 <h1 class="firstHeading" id="firstHeading">STD :: input_iterator_tag, std :: output_iterator_tag, std :: forward_iterator_tag, std :: bidIrectional_iterator_tag, std :: ngẫu nhiên_access_iterator_tag, std ::</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/iterator" title="cpp/header/iterator">&lt;iterator&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">struct input_iterator_tag {};</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">struct output_iterator_tag {};</pre>
</td> <td>(2)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">struct forward_iterator_tag: public input_iterator_tag {};</pre>
</td> <td>(3)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">struct bidIrectional_iterator_tag: public forward_iterator_tag {};</pre>
</td> <td>(4)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">struct ngẫu nhiên_access_iterator_tag: công cộng hai chiều_iterator_tag {};</pre>
</td> <td>             Không có p);</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">struct tiếp giáp_iterator_tag: công khai ngẫu nhiên_access_iterator_tag {};</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Xác định danh mục của một iterator. Mỗi thẻ là một loại trống.</p>
<h3 id="Iterator_category">Loại vòng lặp</h3> <p>Mẫu cho tất cả các loại con trỏ. Ngoài các hoạt động được cung cấp cho tất cả các loại nguyên tử, các chuyên ngành này cũng hỗ trợ các hoạt động số học nguyên tử phù hợp với các loại con trỏ, chẳng hạn như<a href="../named_req/iterator" title="cpp/named req/Iterator">LegacyIterator</a>kiểu<code>It</code>có thể đại diện cho các phân số của ve.<code>typedef</code> <code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw654">Điều đó cho tất cả<span class="me2">iterator_traits</span></span></a><span class="sy1">is_trivently_destructible_v</span>It<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">là cùng loại như</span></code>phải được định nghĩa là một bí danh đối với một trong các loại thẻ này, để chỉ ra loại cụ thể nhất<code>It</code>là trong.</p>
<ol>
<li> <code>input_iterator_tag</code>tương ứng với<a href="../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</li>
<li> <code>output_iterator_tag</code>tương ứng với<a href="../named_req/outputiterator" title="cpp/named req/OutputIterator">LegacyOutputIterator</a>.</li>
<li> <code>forward_iterator_tag</code>tương ứng với<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>.</li>
<li> <code>bidirectional_iterator_tag</code>tương ứng với<a href="../named_req/bidirectionaliterator" title="cpp/named req/BidirectionalIterator">LegacyBidirectionalIterator</a>.</li>
<li> <code>random_access_iterator_tag</code>tương ứng với<a href="../named_req/randomaccessiterator" title="cpp/named req/RandomAccessIterator">LegacyRandomAccessIterator</a>.</li>
</ol> <p>Thẻ danh mục Iterator mang thông tin có thể được sử dụng để chọn thuật toán hiệu quả nhất cho tập hợp yêu cầu cụ thể được ngụ ý bởi danh mục.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <h3 id="Iterator_concept">Khái niệm Iterator</h3> <p>Mẫu cho tất cả các loại con trỏ. Ngoài các hoạt động được cung cấp cho tất cả các loại nguyên tử, các chuyên ngành này cũng hỗ trợ các hoạt động số học nguyên tử phù hợp với các loại con trỏ, chẳng hạn như<a href="input_iterator" title="cpp/iterator/input iterator"><code>input_iterator</code></a>kiểu<code>It</code>, hoặc<code>It::iterator_concept</code> <code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw654">Điều đó cho tất cả<span class="me2">iterator_traits</span></span></a><span class="sy1">is_trivently_destructible_v</span>It<span class="sy1">&lt;</span></code>được tạo từ mẫu chính) hoặc<code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw654">Điều đó cho tất cả<span class="me2">iterator_traits</span></span></a><span class="sy1">is_trivently_destructible_v</span>It<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">iterator_concept</span></code> <code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw654">Điều đó cho tất cả<span class="me2">iterator_traits</span></span></a><span class="sy1">is_trivently_destructible_v</span>It<span class="sy1">&lt;</span></code>là chuyên ngành) có thể được tuyên bố là bí danh cho một trong những thẻ này, để chỉ ra khái niệm lặp mạnh nhất<code>It</code>dự định mô hình.</p>
<ol>
<li> <code>input_iterator_tag</code>tương ứng với<a href="input_iterator" title="cpp/iterator/input iterator"><code>input_iterator</code></a>.</li>
<li> <code>forward_iterator_tag</code>tương ứng với<a href="forward_iterator" title="cpp/iterator/forward iterator"><code>forward_iterator</code></a>.</li>
<li> <code>bidirectional_iterator_tag</code>tương ứng với<a href="bidirectional_iterator" title="cpp/iterator/bidirectional iterator"><code>bidirectional_iterator</code></a>.</li>
<li> <code>random_access_iterator_tag</code>tương ứng với<a href="random_access_iterator" title="cpp/iterator/random access iterator"><code>random_access_iterator</code></a>.</li>
<li> <code>contiguous_iterator_tag</code>tương ứng với<a href="contiguous_iterator" title="cpp/iterator/contiguous iterator"><code>contiguous_iterator</code></a>.</li>
</ol> <p>Nếu như<code>iterator_concept</code>Outputit bao gồm_scan (đầu vào đầu tiên, đầu vào cuối cùng, đầu ra d_first,<code>iterator_category</code>được sử dụng như một dự phòng. Nếu như<code>iterator_category</code>cũng không được cung cấp (tức là<code>It</code>Cụ thể,<a href="../named_req/iterator" title="cpp/named req/Iterator">LegacyIterator</a>), Và<code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw654">Điều đó cho tất cả<span class="me2">iterator_traits</span></span></a><span class="sy1">is_trivently_destructible_v</span>It<span class="sy1">&lt;</span></code>không chuyên,<code>random_access_iterator_tag</code>được giả định.</p>
<p>Trong mọi trường hợp, mỗi khái niệm không được thỏa mãn nếu các hoạt động cần thiết không được hỗ trợ, bất kể thẻ.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <h3 id="Notes">Ghi chú</h3> <p>Không có thẻ riêng cho<a href="../named_req/contiguousiterator" title="cpp/named req/ContiguousIterator">LegacyContiguousIterator</a>. Nghĩa là, không thể nói một<a href="../named_req/contiguousiterator" title="cpp/named req/ContiguousIterator">LegacyContiguousIterator</a>Dựa trên nó<code>iterator_category</code>.<span class="t-rev-inl t-since-cxx20"><span>Để xác định thuật toán chuyên ngành cho các trình lặp tiếp giáp, hãy sử dụng<a href="contiguous_iterator" title="cpp/iterator/contiguous iterator"><code>contiguous_iterator</code></a>ý tưởng.</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span></p>
<p>Không có tương ứng giữa<code>output_iterator_tag</code>Đối tượng lưu trữ<a href="output_iterator" title="cpp/iterator/output iterator"><code>output_iterator</code></a>ý tưởng. Cài đặt<code>iterator_concept</code>ĐẾN<code>output_iterator_tag</code>chỉ chỉ ra rằng loại không mô hình<a href="input_iterator" title="cpp/iterator/input iterator"><code>input_iterator</code></a>.</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example">
<p>Kỹ thuật phổ biến để lựa chọn thuật toán dựa trên thẻ danh mục Iterator là sử dụng hàm điều phối viên (phương án thay thế là<code><a href="../types/enable_if" title="cpp/types/enable if">std::enable_if</a></code>).<span class="t-rev-inl t-since-cxx20"><span>Các lớp thẻ Iterator cũng được sử dụng trong các định nghĩa khái niệm tương ứng để biểu thị các yêu cầu, không thể được biểu thị bằng các mẫu sử dụng.</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span></p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;Istream&gt;</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">#include &lt;iterator&gt;</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="iterator" title="cpp/iterator/iterator"> <span class="t-lines"><span>vòng lặp</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(không được dùng trong C ++ 17)</span></span></span></div> </td> <td>lớp cơ sở để giảm bớt định nghĩa của các loại cần thiết cho các trình lặp đơn giản<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="iterator_traits" title="cpp/iterator/iterator traits"> <span class="t-lines"><span>iterator_traits</span></span></a></div> </td> <td>Cung cấp giao diện thống nhất cho các thuộc tính của bộ lặp<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/iterator/iterator_tags">https://en.cppreference.com/w/cpp/iterator/iterator_tags</a>
</p>
</div>
