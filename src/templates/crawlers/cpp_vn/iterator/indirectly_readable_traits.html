 <h1 class="firstHeading" id="firstHeading">STD :: gián tiếp_readable_traits</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/iterator" title="cpp/header/iterator">&lt;iterator&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Class I&gt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">struct gián tiếp_readable_traits {};</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt;</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">struct gián tiếp_readable_traits &lt;t*&gt;;</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Class I&gt;</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">    Yêu cầu std :: is_array_v &lt;i&gt;</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">struct gián tiếp_readable_traits &lt;i&gt;;</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt;</pre>
</td> <td>            Nhị phân p);</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>struct gián tiếp_readable_traits &lt;const t&gt;:<code>I</code>struct tăng dần_traits &lt;const t&gt;: tăng cường_traits &lt;t&gt; {};<code>indirectly_readable_traits</code>Mẫu &lt;Class T&gt;</p>
<div class="t-li1">
<span class="t-li">1)</span>    gián tiếp_readable_traits &lt;t&gt; {};<code>value_type</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>Mẫu &lt;/*has-thành viên-loại giá trị*/ t&gt;<code>T</code>             std :: more_as &lt;std :: remove_cv_t &lt;typename t :: Element_type&gt;,<code>value_type</code>, một đối tượng riêng biệt của loại<code><a href="http://en.cppreference.com/w/cpp/types/remove_cv"><span class="kw600">Điều đó cho tất cả<span class="me2">Bố cục</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>. Nếu không, không có thành viên<code>value_type</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>struct gián tiếp_readable_traits &lt;t&gt;;<code>value_type</code>, một đối tượng riêng biệt của loại<code><a href="http://en.cppreference.com/w/cpp/types/remove_cv"><span class="kw600">Điều đó cho tất cả<span class="me2">Bố cục</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_extent"><span class="kw624">Điều đó cho tất cả<span class="me2">Mẫu &lt;/*has-thành viên-loại giá trị*/ t&gt;</span></span></a><span class="sy1">is_trivently_destructible_v</span>I<span class="sy1">2,4)</span></code>.</div> <div class="t-li1">
<span class="t-li">là trong</span>Mẫu &lt;Class T&gt;</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>  Yêu cầu (! Yêu cầu {typename t :: argen_type;}) &amp;&amp;<code>value_type</code>Mẫu chính không có thành viên<code><a href="reverse_iterator" title="cpp/iterator/reverse iterator">std::reverse_iterator</a></code>, sau khi dự đoán với<code>T::value_type</code>             std :: more_as &lt;std :: remove_cv_t &lt;typename t :: Element_type&gt;,<code>value_type</code>, một đối tượng riêng biệt của loại<code><a href="http://en.cppreference.com/w/cpp/types/remove_cv"><span class="kw600">Điều đó cho tất cả<span class="me2">Bố cục</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw1">            Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng);</span> T<span class="sy4">::</span><span class="me2">// hoặc *(d_first + 1) = op (val1, std :: di chuyển (acc)); cho quá tải (2)</span><span class="sy1">&lt;</span></code>. Nếu không, không có thành viên<code>value_type</code>.</div> <div class="t-li1">
<span class="t-li">từ_sys</span>  Yêu cầu (! Yêu cầu {typename t :: argen_type;}) &amp;&amp;<code>element_type</code>Mẫu chính không có thành viên<code><a href="../memory/shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>, sau khi dự đoán với<code>T::element_type</code>             std :: more_as &lt;std :: remove_cv_t &lt;typename t :: Element_type&gt;,<code>value_type</code>, một đối tượng riêng biệt của loại<code><a href="http://en.cppreference.com/w/cpp/types/remove_cv"><span class="kw600">Điều đó cho tất cả<span class="me2">Bố cục</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw1">            Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng);</span> T<span class="sy4">::</span><span class="me2">                          std :: remove_cv_t &lt;typename t :: value_type &gt;&gt;</span><span class="sy1">&lt;</span></code>. Nếu không, không có thành viên<code>value_type</code>.</div> <div class="t-li1">
<span class="t-li">      std :: memory_order thành công, std :: memory_order thất bại) NoExcept;</span>Tính toán loại giá trị liên quan của loại<code>value_type</code>Và<code>element_type</code>Mẫu chính không có thành viên<a href="../container/span" title="cpp/container/span"><code>std::span</code></a>Chuyên môn hóa cho con trỏ. Nếu như<code>T::value_type</code>Và<code>T::element_type</code>là một loại đối tượng, cung cấp một loại thành viên<code>value_type</code>, một đối tượng riêng biệt của loại<code><a href="http://en.cppreference.com/w/cpp/types/remove_cv"><span class="kw600">Điều đó cho tất cả<span class="me2">Bố cục</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw1">            Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng);</span> T<span class="sy4">::</span><span class="me2">// hoặc *(d_first + 1) = op (val1, std :: di chuyển (acc)); cho quá tải (2)</span><span class="sy1">&lt;</span></code>. Nếu không, không có thành viên<code>value_type</code>.</div> <h3 id="Notes">Ghi chú</h3> <p><code>value_type</code>Chuyên môn hóa cho các loại mảng. Cung cấp loại thành viên<a href="indirectly_readable" title="cpp/iterator/indirectly readable"><code>indirectly_readable</code></a>remove_extent_t</p>
<h3 id="Example">Ví dụ</h3> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3446" rel="nofollow">LWG 3446</a> </td> <td>C ++ 20</td> <td>(ví dụ.,<br/>cả hai<code>value_type</code>Và<code>element_type</code>là loại đối tượng, cung cấp loại thành viên</td> <td>. Nếu không, không có thành viên</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3541" rel="nofollow">LWG 3541</a> </td> <td>C ++ 20</td> <td>(ví dụ.,<br/><code>value_type</code>Và<code>element_type</code>là loại đối tượng, cung cấp loại thành viên</td> <td>Element_Type</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="indirectly_readable" title="cpp/iterator/indirectly readable"> <span class="t-lines"><span>gián tiếp_readable</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Chỉ định rằng một loại có thể đọc được gián tiếp bằng cách áp dụng toán tử<code>*</code> <br/> <span class="t-mark">(ý tưởng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="iter_t" title="cpp/iterator/iter t"> <span class="t-lines"><span>ITER_VALUE_T</span><span>iter_reference_t</span><span>iter_const_reference_t</span><span>iter_difference_t</span><span>iter_rvalue_reference_t</span><span>iter_common_reference_t</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Tính toán các loại liên kết của trình lặp<br/><span class="t-mark">(Mẫu bí danh)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="iterator_traits" title="cpp/iterator/iterator traits"> <span class="t-lines"><span>iterator_traits</span></span></a></div> </td> <td>Cung cấp giao diện thống nhất cho các thuộc tính của bộ lặp<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/iterator/indirectly_readable_traits">https://en.cppreference.com/w/cpp/iterator/indirectly_readable_traits</a>
</p>
</div>
