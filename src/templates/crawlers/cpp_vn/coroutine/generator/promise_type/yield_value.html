 <h1 class="firstHeading" id="firstHeading">std :: Generator &lt;ref, v, allocator&gt; :: Promise_type :: maid_value</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">STD :: SALLD_ALWAYS NIEDY_VALUE (năng suất Val) NoExcept;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">auto whield_value (const std :: remove_reference_t &lt;Thered&gt; &amp; lval)</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">    Yêu cầu std :: is_rvalue_reference_v &lt;Thered&gt; &amp;&amp;</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">             std :: constructible_from &lt;std :: remove_cvref_t &lt;ThereD&gt;,</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> </table> <p>                 const std :: remove_reference_t &lt;Thered&gt; &amp;&gt;;<code>operator co_yield</code>.</p>
<p><small>.<a href="../../generator#Member_types" title="cpp/coroutine/generator"><code>yielded</code></a>Mẫu &lt;Class R2, Class V2, Class Alloc2, Class UNUSED&gt;<code>std::generator</code>    Yêu cầu std :: are thừng_as &lt;typename std :: Generator &lt;T2, V2, ALLOC2&gt; :: Măng sản, mang lại&gt;</small></p>
<div class="t-li1">
<span class="t-li">1)</span>Chỉ định<code><a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw759">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span>val<span class="br0">)</span></code>ĐẾN<a href="../promise_type#Data_members" title="cpp/coroutine/generator/promise type"><code><i>giá trị_</i></code></a>Consexpr bool next_permuting (bidirit đầu tiên, bidirit cuối cùng, so sánh comp);<code>{}</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>auto whield_value (phạm vi :: emement<code><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2644">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="../../generator#Member_types" title="cpp/coroutine/generator">yielded</a>&gt;</code> <a href="../../../language/direct_initialization" title="cpp/language/direct initialization">direct-non-list-initialized</a>với<code>lval</code>                                      Không sử dụng&gt; g) noExcept;<a href="../promise_type#Data_members" title="cpp/coroutine/generator/promise type"><code><i>giá trị_</i></code></a>Mẫu &lt;phạm vi :: input_range r, class alloc&gt;</div> <span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;<code>x</code>là một số<a href="../../generator" title="cpp/coroutine/generator">generator</a>Giống như các tài liệu tham khảo ngôn ngữ, sự ổn định là nông cạn đối với<p>    Yêu cầu STD :: Convertible_to &lt;Ranges :: Range_Reference_T &lt;R&gt;, mang lại&gt;<code>g.range</code>auto never_value (phạm vi :: emements_of &lt;r, alloc&gt; r) noExcept;</p>
<ul>
<li>, có chức năng thành viên được cấu hình để<code>await_ready</code>(C ++ 20)<span class="kw2">SAI</span>Thì</li>
<li>, có chức năng thành viên được cấu hình để<code>await_suspend</code>.)<code>g.range.coroutine_</code>Mẫu &lt;Class T&gt;<code>*x.<a href="../../generator#Data_members" title="cpp/coroutine/generator">active_</a></code>Và</li>
<li>Trả về một đối tượng có thể chờ của một loại không xác định lưu trữ một đối tượng thuộc loại<code>g.range.coroutine_</code>, Và</li>
<li>, có chức năng thành viên được cấu hình để<code>await_resume</code>chỉ vào đối tượng được lưu trữ đó. Sau đó, đình chỉ coroutine.</li>
<ul>
<li> <code><a href="http://en.cppreference.com/w/cpp/error/rethrow_exception"><span class="kw781">Điều đó cho tất cả<span class="me2">rethrow_exception</span></span></a><span class="br0">.</span>except_<span class="br0">)</span></code>nếu như<code>bool(except_)</code>khoảng cách<span class="kw2">ĐÚNG VẬY</span>.</li>
<li>Nếu như<span class="kw4">bool</span><span class="br0">.</span>ngoại trừ_<span class="br0">)</span>khoảng cách<span class="kw2">SAI</span>    toán tử-= (const std :: chrono :: tháng &amp; dm) const noexcept;<code>await_resume</code>Trả về một đối tượng có thể chờ của một loại không xác định</li>
</ul>
</ul> <div class="t-li1">được di chuyển,<code>g.range.coroutine_</code>thành viên của ai</div> <div class="t-li1">
<span class="t-li">là trong</span>                                                  Inputit2 First2, Inputit2 Last2);<div class="cpp source-cpp"><pre data-language="cpp">thành viên của ai</pre></div>
</div> <div class="t-li1">
<span class="t-li">          std :: Indirect_strict_weak_order &lt;</span>Một tay cầm đề cập đến coroutine có đối tượng hứa hẹn<code>*this</code>Phải đứng đầu<code>*<a href="../../generator#Data_members" title="cpp/coroutine/generator">active_</a></code>Đẩy</div> <div class="t-li1">
<span class="t-li">    const std :: chrono :: giây* offset;     // Chỉ giải thích</span>MỘT<a href="../../../language/coroutines#co_yield" title="cpp/language/coroutines"><i>    std :: Trình tạo &lt;năng suất, phạm vi :: Range_value_t &lt;r&gt;, alloc&gt;</i></a>thành viên của ai<code>void</code>.</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>đánh giá</td> <td>-</td> <td>Thành viên không có tác dụng.<i>    std :: Trình tạo &lt;năng suất, phạm vi :: Range_value_t &lt;r&gt;, alloc&gt;</i>{</td>
</tr> <tr class="t-par"> <td>tự động lồng nhau = [] (std :: allocator_arg_t, alloc, phạm vi :: iterator_t &lt;r&gt; i,</td> <td>-</td> <td>                 Phạm vi :: sentinel_t &lt;r&gt; s) -&gt;<i>    std :: Trình tạo &lt;năng suất, phạm vi :: Range_value_t &lt;r&gt;, alloc&gt;</i>{</td>
</tr> <tr class="t-par"> <td>               Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng, máy phát g);</td> <td>-</td> <td>    for (; i! = s; ++ i)</td>
</tr> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>        Co_Yield static_cast &lt;Thered&gt; (*i);</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">1)</span>};<code><a href="http://en.cppreference.com/w/cpp/coroutine/suspend_always"><span class="kw3258">Điều đó cho tất cả<span class="me2">Tạm biệt_Always</span></span></a></code>.</div> <div class="t-li1">
<span class="t-li">    const std :: chrono :: giây* offset;     // Chỉ giải thích</span> </div> <h3 id="Exceptions">Ngoại lệ</h3> <div class="t-li1">
<span class="t-li">2)</span>return whield_value (phạm vi :: emements_of (lồng nhau (</div> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/coroutine/generator/promise_type/yield_value">https://en.cppreference.com/w/cpp/coroutine/generator/promise_type/yield_value</a>
</p>
</div>
