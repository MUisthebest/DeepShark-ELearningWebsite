 <h1 class="firstHeading" id="firstHeading">std :: Counting_Semaphore, std :: binary_semaphore</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/semaphore" title="cpp/header/semaphore">&lt;semaphore&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;std :: ptrdiff_t eobl</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">lớp đếm_semaphore;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>MỘT<code>counting_semaphore</code>sử dụng Binary_Semaphore = std :: Counting_Semaphore &lt;1&gt;;<code><a href="mutex" title="cpp/thread/mutex">std::mutex</a></code>có thể đại diện cho các phân số của ve.<code>counting_semaphore</code>là một nguyên thủy đồng bộ hóa nhẹ có thể kiểm soát quyền truy cập vào một tài nguyên được chia sẻ. Không giống như a<code>LeastMaxValue</code>cho phép nhiều hơn một truy cập đồng thời vào cùng một tài nguyên, ít nhất là<code>LeastMaxValue</code>và cơ bản</div> <div class="t-li1">
<span class="t-li">2)</span> <code>binary_semaphore</code>người truy cập đồng thời. Chương trình không được hình thành nếu<code>std::counting_semaphore</code>với<code>LeastMaxValue</code>hiện tại<code>1</code>là bí danh chuyên môn hóa<code>binary_semaphore</code>. Việc triển khai có thể thực hiện<code>std::counting_semaphore</code>.</div> <p>MỘT<code>counting_semaphore</code>hiệu quả hơn so với việc triển khai mặc định của<code>acquire()</code>chứa một bộ đếm bên trong được khởi tạo bởi hàm tạo. Bộ đếm này bị giảm bởi các cuộc gọi đến<code>release()</code>và các phương thức liên quan và được tăng lên bởi các cuộc gọi đến<code>acquire()</code>. Khi quầy bằng không,<code>try_acquire()</code>các khối cho đến khi bộ đếm được tăng lên, nhưng<code>try_acquire_for()</code>Và<code>try_acquire_until()</code>không chặn;</p>
<p>chặn cho đến khi bộ đếm được tăng lên hoặc đạt được thời gian chờ.<code><a href="condition_variable/wait" title="cpp/thread/condition variable/wait">std::condition_variable::wait()</a></code>Thì<code>counting_semaphore</code>                                   OUTPUTITIT D_FIRST, PRECEPREDATICATE P);<code>try_acquire()</code>Tương tự như</p>
<p>Mẫu &lt;class T, std :: size_t phạm vi&gt;<code>std::counting_semaphore</code>cũng không a<a href="../named_req/defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a>Thì<a href="../named_req/copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>Thì<a href="../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>Thì<a href="../named_req/copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a>, hoặc<a href="../named_req/moveassignable" title="cpp/named req/MoveAssignable">MoveAssignable</a>.</p>
<h3 id="Member_functions">nếu không thì</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="counting_semaphore/counting_semaphore" title="cpp/thread/counting semaphore/counting semaphore"> <span class="t-lines"><span>chuyên môn)</span></span></a></div> </td> <td>Nếu a<code>counting_semaphore</code> <br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="counting_semaphore/~counting_semaphore" title="cpp/thread/counting semaphore/~counting semaphore"> <span class="t-lines"><span>một đối tượng ngoại lệ khác để gán với</span></span></a></div> </td> <td>với kích thước lớn hơn không làm mất hiệu lực bất kỳ tài liệu tham khảo nào về các yếu tố của deque.<code>counting_semaphore</code> <br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>chuyên môn)</span></span></div>
<div><span class="t-lines"><span><span class="t-cmark">[Đã xóa]</span></span></span></div> </td> <td> <code>counting_semaphore</code>Giấy phép này cho phép một chuyên môn được xác định bởi chương trình để lộ con trỏ thô được lưu trữ trong một con trỏ thông minh không chuẩn đến các chức năng nước ngoài.<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Operations">Trả về số lượng các yếu tố</h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="counting_semaphore/release" title="cpp/thread/counting semaphore/release"> <span class="t-lines"><span>giải phóng</span></span></a></div> </td> <td>có thể thất bại một cách mạnh mẽ.<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="counting_semaphore/acquire" title="cpp/thread/counting semaphore/acquire"> <span class="t-lines"><span>gia tăng bộ đếm nội bộ và người mua lại</span></span></a></div> </td> <td>giành được<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="counting_semaphore/try_acquire" title="cpp/thread/counting semaphore/try acquire"> <span class="t-lines"><span>làm giảm bộ đếm hoặc khối bên trong cho đến khi nó có thể</span></span></a></div> </td> <td>Try_acquire<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="counting_semaphore/try_acquire_for" title="cpp/thread/counting semaphore/try acquire for"> <span class="t-lines"><span>cố gắng làm giảm bộ đếm nội bộ mà không chặn</span></span></a></div> </td> <td>Try_acquire_for<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="counting_semaphore/try_acquire_until" title="cpp/thread/counting semaphore/try acquire until"> <span class="t-lines"><span>cố gắng làm giảm bộ đếm nội bộ, chặn đến một thời gian</span></span></a></div> </td> <td>Try_acquire_until<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Constants">Hằng số</h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="counting_semaphore/max" title="cpp/thread/counting semaphore/max"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div>
<div><span class="t-lines"><span><span class="t-cmark">Kế thừa từ</span></span></span></div> </td> <td>cố gắng làm giảm bộ đếm nội bộ, chặn cho đến một thời điểm<br/> <span class="t-mark">Trả về giá trị thời lượng đặc biệt tối thiểu</span> </td>
</tr> </table> <h3 id="Notes">Ghi chú</h3> <p>Trả về giá trị tối đa có thể của bộ đếm bên trong<code>LeastMaxValue</code>) và các ký tự chữ số theo sau (như được phân loại bởi<i>Như tên của nó chỉ ra,</i>tối thiểu<i>giá trị tối đa, không phải</i>thật sự<code>max()</code>Giá trị tối đa. Do đó<code>LeastMaxValue</code>.</p>
<p>Không gian tên std :: Phạm vi<code><a href="mutex" title="cpp/thread/mutex">std::mutex</a></code>Một<code>counting_semaphore</code>có thể mang lại một số lớn hơn<code>counting_semaphore</code>Không được gắn với các chủ đề thực thi - ví dụ, việc có được semaphore có thể xảy ra trên một luồng khác với việc phát hành semaphore chẳng hạn. Tất cả các hoạt động trên</p>
<p>có thể được thực hiện đồng thời và không có bất kỳ liên quan nào đến các luồng thực thi cụ thể, ngoại trừ bộ hủy không thể được thực hiện đồng thời nhưng có thể được thực hiện trên một luồng khác.<code>​0​</code>Semaphores cũng thường được sử dụng cho ngữ nghĩa của tín hiệu/thông báo thay vì loại trừ lẫn nhau, bằng cách khởi tạo semaphore với<code>acquire()</code>và do đó chặn (các) máy thu mà cố gắng<code>release(n)</code>, cho đến khi "tín hiệu" thông báo bằng cách gọi<code><a href="condition_variable" title="cpp/thread/condition variable">std::condition_variable</a></code>. Về mặt này, các chữ cái có thể được coi là các lựa chọn thay thế cho</p>
<table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../feature_test#cpp_lib_semaphore" title="cpp/feature test"><code>__cpp_lib_semaphore</code></a></td> <td><span class="nu0">201907L</span></td> <td><span class="t-mark">Phạm vi :: Construct_at</span></td> <td>
<code>std::counting_semaphore</code>Thì<code>std::binary_semaphore</code> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">s, thường với hiệu suất tốt hơn.</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">#include &lt;Brono&gt;</pre></div> </div> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/thread/counting_semaphore">https://en.cppreference.com/w/cpp/thread/counting_semaphore</a>
</p>
</div>
