 <h1 class="firstHeading" id="firstHeading">STD :: Chấm dứt</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/exception" title="cpp/header/exception">&lt;exception&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-until-cxx11"> <td><pre data-language="cpp">khoảng trống chấm dứt ();</pre></td> <td class="t-dcl-nopad"> </td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">[[noreturn]] void chấm dứt () NoExcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> </table> <p><code>std::terminate()</code>được gọi bởi thời gian chạy C ++ khi chương trình không thể tiếp tục vì bất kỳ lý do nào sau đây:</p>
<div class="t-li1">
<span class="t-li">1)</span>chồng chéo với container.<a href="../language/throw" title="cpp/language/throw">exception is thrown</a>và không bị bắt (đó là việc thực hiện xác định xem có bất kỳ ngăn xếp nào được thực hiện trong trường hợp này)</div> <div class="t-li1">
<span class="t-li">2)</span>Một chức năng được gọi trực tiếp bởi cơ chế xử lý ngoại lệ trong khi xử lý một ngoại lệ chưa bị bắt thoát thông qua một ngoại lệ (ví dụ: một chất phá hủy của một số đối tượng cục bộ hoặc một hàm tạo bản sao xây dựng một tham số bắt giữ)</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>người xây dựng hoặc chất phá hủy của một tĩnh<span class="t-rev-inl t-since-cxx11"><span>hoặc chủ đề địa phương</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Đối tượng ném một ngoại lệ</div> <div class="t-li1">
<span class="t-li">là trong</span>một chức năng được đăng ký với<code><a href="../utility/program/atexit" title="cpp/utility/program/atexit">std::atexit</a></code> <span class="t-rev-inl t-since-cxx11"><span>hoặc<code><a href="../utility/program/at_quick_exit" title="cpp/utility/program/at quick exit">std::at_quick_exit</a></code></span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>ném một ngoại lệ</div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Một<a href="../language/except_spec" title="cpp/language/except spec">dynamic exception specification</a>bị vi phạm và người xử lý mặc định cho<code><a href="unexpected" title="cpp/error/unexpected">std::unexpected</a></code>được thực hiện<span class="t-li">từ_sys</span>một người xử lý không mặc định cho<code><a href="unexpected" title="cpp/error/unexpected">std::unexpected</a></code>ném một ngoại lệ vi phạm đặc điểm kỹ thuật ngoại lệ động vi phạm trước đó, nếu đặc điểm kỹ thuật không bao gồm<code><a href="bad_exception" title="cpp/error/bad exception">std::bad_exception</a></code> </td> <td><span class="t-mark-rev t-until-cxx17">xáo trộn</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <span class="t-li">6)</span>Một<a href="../language/noexcept_spec" title="cpp/language/noexcept spec">noexcept specification</a>bị vi phạm (nó được xác định bằng cách thực hiện cho dù có bất kỳ ngăn xếp nào được thực hiện trong trường hợp này)<span class="t-li">. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu biểu thức</span> <code><a href="nested_exception/rethrow_nested" title="cpp/error/nested exception/rethrow nested">std::nested_exception::rethrow_nested</a></code>được gọi cho một đối tượng không giữ một ngoại lệ bị bắt<span class="t-li">được hình thành tốt. Chương trình không được hình thành nếu</span>Một ngoại lệ được ném từ chức năng ban đầu của<code><a href="../thread/thread" title="cpp/thread/thread">std::thread</a></code> <span class="t-li">Toán tử bool constexpr&gt; (const std :: Chrono :: sys_time &lt;fending&gt; &amp; x,</span>có thể tham gia<code><a href="../thread/thread" title="cpp/thread/thread">std::thread</a></code>bị phá hủy hoặc được gán cho<span class="t-li">                           const std :: Chrono :: Leap_Second &amp; y) noExcept;</span> <code><a href="../thread/condition_variable/wait" title="cpp/thread/condition variable/wait">std::condition_variable::wait</a></code>Thì<code><a href="../thread/condition_variable/wait_until" title="cpp/thread/condition variable/wait until">std::condition_variable::wait_until</a></code>, hoặc<code><a href="../thread/condition_variable/wait_for" title="cpp/thread/condition variable/wait for">std::condition_variable::wait_for</a></code>Không đạt được điều kiện hậu kỳ của nó (ví dụ: nếu tái tạo các lần ném mutex)</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <span class="t-li">Mẫu &lt;Lớp thời lượng&gt;</span>một chức năng được gọi bởi một<a href="../algorithm" title="cpp/algorithm">parallel algorithm</a>thoát qua một ngoại lệ chưa được tính toán và<a href="../algorithm/execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">execution policy</a>Chỉ định chấm dứt.</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <p><code>std::terminate()</code>Cũng có thể được gọi trực tiếp từ chương trình.</p>
<p><br/>      std :: memory_order order = std :: memory_order_seq_cst) noexcept dễ bay hơi;<code>std::terminate</code>được gọi là do một ngoại lệ ném, một người xử lý thử/bắt ngầm được coi là hoạt động. Vì vậy, gọi<code><a href="current_exception" title="cpp/error/current exception">std::current_exception</a></code>Sẽ trả lại ngoại lệ ném.</p>
<p>Trong mọi trường hợp,<code>std::terminate</code>Các cuộc gọi hiện đã được cài đặt<code><a href="terminate_handler" title="cpp/error/terminate handler">std::terminate_handler</a></code>. Mặc định<code><a href="terminate_handler" title="cpp/error/terminate handler">std::terminate_handler</a></code>cuộc gọi<code><a href="../utility/program/abort" title="cpp/utility/program/abort">std::abort</a></code>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <p>Nếu một chất hủy diệt thiết lập lại trình xử lý chấm dứt trong quá trình tháo ra và việc tháo gỡ sau đó đã dẫn đến<code>terminate</code>Được gọi, trình xử lý đã được cài đặt ở cuối biểu thức ném là cái sẽ được gọi là. .</p>
</td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> <p>Nếu một bộ hủy đặt thiết lập lại trình xử lý chấm dứt trong quá trình tháo gỡ ngăn xếp, thì nó không xác định được trình xử lý nào được gọi nếu việc tháo gỡ sau đó dẫn đến<code>terminate</code>được gọi.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <h3 id="Parameters">) với giá trị ban đầu</h3> <p>Gán cho đã cho</p>
<h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Gán cho đã cho</p>
<h3 id="Notes">Ghi chú</h3> <p>Nếu cơ chế xử lý không muốn, ví dụ: bởi vì nó yêu cầu các hoạt động nguyên tử có thể làm mờ kích thước nhị phân, một cuộc gọi trực tiếp đến<code><a href="../utility/program/abort" title="cpp/utility/program/abort">std::abort</a></code>được ưa thích khi chấm dứt chương trình bất thường.</p>
<p>Một số nội tại trình biên dịch, ví dụ:<a class="external text" href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html" rel="nofollow"><code>__builtin_trap</code></a>(GCC, Clang và ICC) hoặc<a class="external text" href="https://docs.microsoft.com/en-us/cpp/intrinsics/debugbreak?view=msvc-160" rel="nofollow"><code>__debugbreak</code></a>(MSVC), có thể được sử dụng để chấm dứt chương trình càng nhanh càng tốt.</p>
<h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2111" rel="nofollow">LWG 2111</a> </td> <td>C ++ 11</td> <td>ảnh hưởng của cuộc gọi<code>set_terminate</code>Trong quá trình tháo gỡ khác với C ++ 98 và phá vỡ một số ABI</td> <td>làm cho không xác định</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="terminate_handler" title="cpp/error/terminate handler"> <span class="t-lines"><span>chấm dứt_handler</span></span></a></div> </td> <td>loại chức năng được gọi bởi<code>std::terminate</code> <br/> <span class="t-mark">(typedef)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/program/abort" title="cpp/utility/program/abort"> <span class="t-lines"><span>khẳng định ((2 + 2 == 5) &amp;&amp; "Có năm đèn");</span></span></a></div> </td> <td>Việc thực hiện<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/error/terminate">https://en.cppreference.com/w/cpp/error/terminate</a>
</p>
</div>
