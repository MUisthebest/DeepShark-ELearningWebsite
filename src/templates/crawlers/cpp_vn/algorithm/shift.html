 <h1 class="firstHeading" id="firstHeading">STD :: Shift_left, std :: shift_right</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Class ForwardIT&gt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Consexpr chuyển tiếp</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">    Shift_left (ForwardIT đầu tiên, Forwardit Last,</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">                TYPENAME STD :: iterator_traits &lt;forwardIt&gt; :: argen_type n);</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Mẫu &lt;class execPolicy, class forwardit&gt;<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Chuyển tiếp<code>n</code>    Shift_left (Chính sách thực thi</p>
<div class="t-li1">
<span class="t-li">1)</span>                TYPENAME STD :: iterator_traits &lt;forwardIt&gt; :: argen_type n);<code>n == 0 || n &gt;= last - first</code>    shift_right (execPolicy &amp;&amp; chính sách, forwardit trước, chuyển tiếp cuối cùng,<code>n &lt; 0</code>                 TYPENAME STD :: iterator_traits &lt;forwardIt&gt; :: argen_type n);<code>i</code>TRONG<code>[</code><code>​0​</code><code>, </code><code>last - first - n</code><code>)</code>Dịch chuyển các yếu tố trong phạm vi<code>first + n + i</code>qua<code>first + i</code>Mẫu &lt;class execPolicy, class forwardit&gt;<code>i</code>Mẫu &lt;Class execPolicy,<code>​0​</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Chuyển tiếp<code>n == 0 || n &gt;= last - first</code>    shift_right (execPolicy &amp;&amp; chính sách, forwardit trước, chuyển tiếp cuối cùng,<code>n &lt; 0</code>                 TYPENAME STD :: iterator_traits &lt;forwardIt&gt; :: argen_type n);<code>i</code>TRONG<code>[</code><code>​0​</code><code>, </code><code>last - first - n</code><code>)</code>Dịch chuyển các yếu tố trong phạm vi<code>first + i</code>qua<code>first + n + i</code>. Nếu như<code>ForwardIt</code>vị trí.<a href="../named_req/bidirectionaliterator" title="cpp/named req/BidirectionalIterator">LegacyBidirectionalIterator</a>Dịch chuyển các yếu tố đến đầu phạm vi. Nếu như<code>i</code>Mẫu &lt;Class execPolicy,<code>last - first - n - 1</code>.</div> <div class="t-li1">
<span class="t-li">Một động thái tương đương với một bản sao</span>                                   Nhị phân p);<span class="t-v">(1)</span>Và<span class="t-v">(3)</span>, không có hiệu ứng. Nếu như<code>policy</code>, hành vi là không xác định. Nếu không, đối với mọi số nguyên<code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2644">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</div> <p>, di chuyển phần tử ban đầu ở vị trí</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>đến phạm vi bắt đầu tại</td> <td>-</td> <td>hoán đổi các yếu tố trong phạm vi</td>
</tr> <tr class="t-par"> <td>cuối cùng</td> <td>-</td> <td>được đặt sau các yếu tố trong</td>
</tr> <tr class="t-par"> <td>Trả về một kết quả, kết quả được bỏ qua. Nếu như</td> <td>-</td> <td>để định vị</td>
</tr> <tr class="t-par"> <td>std :: iterator_traits &lt;buputit&gt; :: value_type acc = *first;</td> <td>-</td> <td>*d_first = acc;<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">execution policy</a> </td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>ForwardIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>ForwardIt</code>. Các động tác được thực hiện theo thứ tự ngày càng tăng của<a href="../named_req/bidirectionaliterator" title="cpp/named req/BidirectionalIterator">LegacyBidirectionalIterator</a>Dịch chuyển các yếu tố đến cuối phạm vi. Nếu như<a href="../named_req/valueswappable" title="cpp/named req/ValueSwappable">ValueSwappable</a>BẰNG<span class="t-v">ConstExpr Outputit Adjacent_Difference (Inputit First, Inputit Last, </span>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">và các phạm vi phải được sắp xếp theo cùng một.<code>ForwardIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/moveassignable" title="cpp/named req/MoveAssignable">MoveAssignable</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">Đầu vào</span>, không có hiệu ứng. Nếu như<code>n</code>là ít hơn<code>last - first</code>; Nếu không nếu<code>first + (last - first - n)</code>để định vị<code>first</code>.</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>, di chuyển phần tử ban đầu ở vị trí<code>n</code>là ít hơn<code>last - first</code>; Nếu không nếu<code>first + n</code>để định vị<code>last</code>.</div> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <div class="t-li1">
<span class="t-li">Đầu vào</span>Nếu phạm vi trống.<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span> <span class="sy2">-</span> n</code>Phần cuối của phạm vi đích</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>Nếu phạm vi trống.<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span> <span class="sy2">-</span> n</code>đáp ứng</div> <h3 id="Exceptions">Ngoại lệ</h3> <p>Sự khởi đầu của phạm vi đích<code>ExecutionPolicy</code>chính sách</p>
<ul>
<li>Chính sách thực thi để sử dụng. Nhìn thấy<code>ExecutionPolicy</code>Để biết chi tiết.<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">standard policies</a>Thì<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>Loại loại 1 và type2 phải sao cho một đối tượng của loại iterator_traits<code>ExecutionPolicy</code>Đầu vào</li>
<li>value_type<code><a href="../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>có thể được chuyển đổi hoàn toàn thành cả hai. Loại</li>
</ul> <h3 id="Notes">Ghi chú</h3> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../feature_test#cpp_lib_shift" title="cpp/feature test"><code>__cpp_lib_shift</code></a></td> <td><span class="nu0">201806L</span></td> <td><span class="t-mark">Phạm vi :: Construct_at</span></td> <td>
<a href="#top"><code>std::shift_left</code></a>Và<a href="#top"><code>std::shift_right</code></a> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">các yêu cầu, sau đó các di chuyển được thực hiện theo thứ tự giảm</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">, tương ứng, nhưng được thực hiện theo</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="move" title="cpp/algorithm/move"> <span class="t-lines"><span>(Niebloid)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="move_backward" title="cpp/algorithm/move backward"> <span class="t-lines"><span>(Niebloid)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="rotate" title="cpp/algorithm/rotate"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="ranges/shift" title="cpp/algorithm/ranges/shift"> <span class="t-lines"><span>(Niebloid)</span><span>Phạm vi :: Shift_left</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td>(C ++ 23)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/shift">https://en.cppreference.com/w/cpp/algorithm/shift</a>
</p>
</div>
