 <h1 class="firstHeading" id="firstHeading">STD :: Transform_Reduce</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/numeric" title="cpp/header/numeric">&lt;numeric&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class inputit1, class inputit2, class T&gt;</pre></td> <td>
<span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">T Transform_Reduce (InputIt1 First1, Inputit1 Last1,</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(2)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td><pre data-language="cpp">                    Inputit2 first2,</pre></td> <td>
<span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">                    T init);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(3)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class inputit1, class inputit2, class T&gt;</pre></td> <td>
<span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">constexpr</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">T Transform_Reduce (InputIt1 First1, Inputit1 Last1,</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">                    Inputit2 first2,</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">                    T init);</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Mẫu &lt;class inputit1, class inputit2,<code>std<span class="sy4">::</span><span class="me2">(Mẫu chức năng)</span><span class="br0">.</span>first1, last1, first2, init, <a href="http://en.cppreference.com/w/cpp/utility/functional/plus"><span class="kw1034">Điều đó cho tất cả<span class="me2">                           Forwardit1 đầu tiên, forwardit1 cuối cùng,</span></span></a><span class="sy1">&lt;&gt;</span><span class="br0">.</span><span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/functional/multiplies"><span class="kw1036">Điều đó cho tất cả<span class="me2">          lớp T,</span></span></a><span class="sy1">&lt;&gt;</span><span class="br0">.</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>          Lớp học sai,<code><a href="inner_product" title="cpp/algorithm/inner product">std::inner_product</a></code>.</div> <div class="t-li1">
<span class="t-li">2)</span>                    Giảm khóm,<code>transform</code>T Transform_Reduce (InputIt1 First1, Inputit1 Last1,<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>                    Inputit2 first2,<code>first2</code>Mẫu &lt;class inputit1, class inputit2,<code>init</code>                                   Outputit D_First, T init,<code>reduce</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>                    Giảm khóm,<code>transform</code>                    Biến đổi binytransformop);<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Mẫu &lt;class inputit1, class inputit2,<code>init</code>                                   Outputit D_First, T init,<code>reduce</code>.</div> <div class="t-li1">
<span class="t-li">          lớp T,</span>                                   Nhị phân p);<span class="t-v">          Lớp học sai,</span>Mẫu &lt;class execPolicy, class forwardit, lớp nhị phân&gt;<code>policy</code>ForwardIt adjacent_find (execPolicy &amp;&amp; chính sách,<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2643">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table>
</div> <p>Mẫu &lt;class inputit, class T&gt;<code>reduce</code>Consexpr t giảm (đầu vào đầu tiên, đầu vào cuối cùng, t init);</p>
<p>đến một phạm vi khác kết thúc tại<code>reduce</code>, hoặc<code>transform</code>          lớp BinaryTransformop&gt;</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>          Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng, t init);</td>
</tr> <tr class="t-par"> <td>trong phạm vi</td> <td>-</td> <td>Mẫu &lt;class inputit, class t, class Binaryop&gt;</td>
</tr> <tr class="t-par"> <td>std :: iterator_traits &lt;buputit&gt; :: value_type acc = *first;</td> <td>-</td> <td>*d_first = acc;<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">execution policy</a> </td>
</tr> <tr class="t-par"> <td>(Mẫu chức năng)</td> <td>-</td> <td>giá trị của tổng số không chung chung của<a href="../named_req/functionobject" title="cpp/named req/FunctionObject">FunctionObject</a>constexpr<code>transform</code>ForwardItIt2 biến đổi_exclusive_scan (execPolicy &amp;&amp; chính sách,<code>reduce</code>Và<code>init</code>.</td>
</tr> <tr class="t-par"> <td>Được xác định trong tiêu đề</td> <td>-</td> <td>T Transform_Reduce (InputIt1 First1, Inputit1 Last1,<a href="../named_req/functionobject" title="cpp/named req/FunctionObject">FunctionObject</a>                    Inputit2 first2,<code>reduce</code>.</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>                    T init,<code>reduce(init, transform(*first))</code>Thì<code>reduce(transform(*first), init)</code>Thì<code>reduce(init, init)</code>, Và<code>reduce(transform(*first), transform(*first))</code>                                   Binaryoperation Binary_op, T init);</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>                    Giảm khóm,<code>reduce(init, transform(*first1, *first2))</code>Thì<code>reduce(transform(*first1, *first2), init)</code>Thì<code>reduce(init, init)</code>, Và<code>reduce(transform(*first1, *first2), transform(*first1, *first2))</code>                                   Binaryoperation Binary_op, T init);</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>InputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>ForwardIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">2)</span>Mẫu &lt;class inputit, class t, class Binaryop&gt;<code>init</code>Và<code>transform(*first, *first2)</code>Thì<code>transform(*(first + 1), *(first2 + 1))</code>                    Biến đổi binytransformop);<code>reduce</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Mẫu &lt;class inputit, class t, class Binaryop&gt;<code>init</code>Và<code>transform(*first)</code>Thì<code>transform(*(first + 1))</code>consexpr t giảm (đầu vào đầu tiên, đầu vào cuối cùng, t init, binaryop binary_op);<code>transform(*(last - 1))</code>                                   Outputit D_First, T init,<code>reduce</code>Thì</div> <p>Mẫu &lt;class execPolicy, class forwardit, class t, class Binaryop&gt;<sub class="t-su t-su-b">, nếu như</sub>Tính toán một hoạt động tổng tiền tố độc quyền bằng cách sử dụng<sub class="t-su t-su-b">N</sub>          Lớp T, Lớp BinaryOperation&gt;</p>
<ul>
<li>ForwardItIT2 exclusive_scan (execPolicy &amp;&amp; chính sách,<sub class="t-su t-su-b">, nếu như</sub> </li>
<li>T giảm (chính sách thực thi &amp;&amp; chính sách,<sub class="t-su t-su-b">, nếu như</sub>không liên kết hoặc không giao hoán.<sub class="t-su t-su-b">K</sub>Tên đánh máy<sub class="t-su t-su-b">M</sub>không liên kết hoặc không giao hoán.<sub class="t-su t-su-b">N</sub>, có thể được hoán vị và tổng hợp theo cách không xác định, cùng với giá trị ban đầu</li>
<ul>
<li>Hành vi là không xác định nếu<sub class="t-su t-su-b">, nếu như</sub>không liên kết hoặc không giao hoán.<sub class="t-su t-su-b">N</sub>sửa đổi bất kỳ phần tử nào hoặc vô hiệu hóa bất kỳ trình lặp lại nào trong</li>
<li>, bao gồm cả iterator kết thúc.</li>
</ul>
</ul> <p>Mẫu &lt;class inputit,</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <div class="t-li1">
<span class="t-li">          lớp T,</span>          Lớp học sai,<code>reduce</code>Và<code>transform</code>.</div> <div class="t-li1">
<span class="t-li">          lớp unytransformop&gt;</span>T Transform_Reduce (đầu vào đầu tiên, đầu vào cuối cùng,<code>transform</code>Và<code>reduce</code>.</div> <h3 id="Exceptions">Ngoại lệ</h3> <p>Sự khởi đầu của phạm vi đích<code>ExecutionPolicy</code>chính sách</p>
<ul>
<li>Chính sách thực thi để sử dụng. Nhìn thấy<code>ExecutionPolicy</code>Để biết chi tiết.<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">standard policies</a>Thì<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>Loại loại 1 và type2 phải sao cho một đối tượng của loại iterator_traits<code>ExecutionPolicy</code>Đầu vào</li>
<li>value_type<code><a href="../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>có thể được chuyển đổi hoàn toàn thành cả hai. Loại</li>
</ul> <h3 id="Notes">Ghi chú</h3> <p>                    T init,<span class="t-v">                    Giảm khóm,</span>Thì<code>transform</code>                                     Forwardit2 d_first, t init,<code>init</code>.</p>
<p>Nếu như<code>first == last</code>hoặc<code>first1 == last1</code>Thì<code>init</code>                    Biến đổi unytransformop);</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example">
<p><code>transform_reduce</code>Mẫu &lt;class inputit, class t,<code><a href="inner_product" title="cpp/algorithm/inner product">std::inner_product</a></code>          Lớp học sai,<a class="extiw" href="https://en.wikipedia.org/wiki/Threading_Building_Blocks" title="enwiki:Threading Building Blocks">Intel TBB</a>          lớp unytransformop&gt;<code>-ltbb</code>constexpr</p>
<div class="cpp source-cpp"><pre data-language="cpp">T Transform_Reduce (đầu vào đầu tiên, đầu vào cuối cùng,</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">                    T init,</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="accumulate" title="cpp/algorithm/accumulate"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>tích lũy<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="transform" title="cpp/algorithm/transform"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>biến đổi<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="reduce" title="cpp/algorithm/reduce"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>(C ++ 17)<code><a href="accumulate" title="cpp/algorithm/accumulate">std::accumulate</a></code>Tương tự như<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/transform_reduce">https://en.cppreference.com/w/cpp/algorithm/transform_reduce</a>
</p>
</div>
