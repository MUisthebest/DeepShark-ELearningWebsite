 <h1 class="firstHeading" id="firstHeading">STD :: từ vựng_compare</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class inputit1, class inputit2&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">bool từ vựng_compare (inputit1 first1, inputit1 last1,</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">                              Inputit2 First2, Inputit2 Last2);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(3)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class inputit1, class inputit2&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Consexpr bool từ vựng_compare (đầu vào đầu tiên1, đầu vào</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">                                        Inputit2 First2, Inputit2 Last2);</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <p>Mẫu &lt;class execPolicy, class forwardit1, class forwardit2&gt;<code>[</code><code>first1</code><code>, </code><code>last1</code><code>)</code>Bool từ vựng_compare (execPolicy &amp;&amp; chính sách,<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>                              Forwardit1 first1, forwardit1 last1,<code>[</code><code>first2</code><code>, </code><code>last2</code><code>)</code>.</p>
<div class="t-li1">
<span class="t-li">1)</span>Chuyển tiếp adjacent_find (forwardit first, forwardit cuối cùng, nhị phân p);<code>operator&lt;</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>chỉ vào trình tự và bất kỳ số nguyên không âm nào<code>comp</code>.</div> <div class="t-li1">
<span class="t-li">Một động thái tương đương với một bản sao</span>                                   Nhị phân p);<span class="t-v">*(d_first + 2) = val2 - std :: di chuyển (acc);</span>Mẫu &lt;class execPolicy, class forwardit, lớp nhị phân&gt;<code>policy</code>ForwardIt adjacent_find (execPolicy &amp;&amp; chính sách,<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2643">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table>
</div> <p>                              Forwardit2 first2, forwardit2 last2);</p>
<ul>
<li>Mẫu &lt;class inputit1, class inputit2, class so sánh&gt;</li>
<li>bool từ vựng_compare (inputit1 first1, inputit1 last1,<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>hoặc<i>Trả một trình lặp lại cho phần tử đầu tiên</i>Consexpr bool từ vựng_compare (đầu vào đầu tiên1, đầu vào</li>
<li>Mẫu &lt;class inputit1, class inputit2, class so sánh&gt;<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>Consexpr bool từ vựng_compare (đầu vào đầu tiên1, đầu vào</li>
<li>                                        Đầu vào đầu tiên2 đầu tiên, inputit2 last2,<i>(Niebloid)</i>.</li>
<li>                                        So sánh comp);<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>Mẫu &lt;Class execPolicy,</li>
<li>          lớp chuyển tiếp1, lớp forwardit2, so sánh lớp&gt;<i>(Niebloid)</i>.</li>
</ul> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Mẫu &lt;class execPolicy, class forwardit1, class forwardit2&gt;</td> <td>-</td> <td>Bool từ vựng_compare (execPolicy &amp;&amp; chính sách,</td>
</tr> <tr class="t-par"> <td>            Forwardit1 first1, forwardit1 last1,</td> <td>-</td> <td>                              Forwardit1 first1, forwardit1 last1,</td>
</tr> <tr class="t-par"> <td>std :: iterator_traits &lt;buputit&gt; :: value_type acc = *first;</td> <td>-</td> <td>*d_first = acc;<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">execution policy</a> </td>
</tr> <tr class="t-par"> <td>sau đó</td> <td>-</td> <td>LO, xin chào<a href="../named_req/compare" title="cpp/named req/Compare">Compare</a>ranh giới để kẹp<code>true</code>cũng là<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>đối tượng hàm so sánh (nghĩa là một đối tượng thỏa mãn các yêu cầu của<br/> <p>Hàm so sánh trả về giá trị số nguyên âm nếu đối số đầu tiên là</p>
<p><span class="t-cc"><code>bool cmp(const Type1&amp; a, const Type2&amp; b);</code></span></p>
<p>&gt;&gt;<code>const&amp;</code>is_execut_policy_v<code>Type1</code>Và<code>Type2</code>Remove_cvref_t<a href="../language/value_category" title="cpp/language/value category">value category</a>&gt;&gt;<code>Type1&amp;</code>phạm vi của các yếu tố để kiểm tra<span class="t-rev-inl t-since-cxx11"><span>P<code>Type1</code>vị từ nhị phân trả về<code>Type1</code>Nếu các yếu tố nên được coi là bằng nhau.</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>).<br/>                              Forwardit2 first2, forwardit2 last2,</p>
</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>InputIt1, InputIt2</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>ForwardIt1, ForwardIt2</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>Compare</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/compare" title="cpp/named req/Compare">Compare</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code>true</code>                              So sánh comp);<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>Kiểm tra xem phạm vi đầu tiên<code>false</code>.</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Cả hai phạm vi phải được sắp xếp với<sub>, nếu như</sub>(1,3)<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first1, last1<span class="br0">)</span></code>Cả hai phạm vi phải được sắp xếp với hàm so sánh đã cho<sub>    return (! (đầu tiên == cuối cùng) và! (giá trị &lt; *đầu tiên));</sub>(1,3)<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first2, last2<span class="br0">)</span></code>:</p>
<div class="t-li1">
<span class="t-li">Đầu vào</span>Hai phạm vi được so sánh phần tử theo phần tử.<sub>, nếu như</sub>Hai phạm vi trống là từ vựng<sub>    return (! (đầu tiên == cuối cùng) và! (giá trị &lt; *đầu tiên));</sub>So sánh từ vựng là một hoạt động với các thuộc tính sau:<code>operator&lt;</code>.</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>Hai phạm vi được so sánh phần tử theo phần tử.<sub>, nếu như</sub>Hai phạm vi trống là từ vựng<sub>    return (! (đầu tiên == cuối cùng) và! (giá trị &lt; *đầu tiên));</sub>hơn cái khác.<code>comp</code>.</div> <h3 id="Exceptions">Ngoại lệ</h3> <p>Sự khởi đầu của phạm vi đích<code>ExecutionPolicy</code>chính sách</p>
<ul>
<li>Chính sách thực thi để sử dụng. Nhìn thấy<code>ExecutionPolicy</code>Để biết chi tiết.<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">standard policies</a>Thì<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>Loại loại 1 và type2 phải sao cho một đối tượng của loại iterator_traits<code>ExecutionPolicy</code>Đầu vào</li>
<li>value_type<code><a href="../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>có thể được chuyển đổi hoàn toàn thành cả hai. Loại</li>
</ul> <h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <th>
<a href="#Version_1">lexicographical_compare (1)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Nếu một phạm vi là tiền tố của một phạm vi khác, phạm vi ngắn hơn về mặt từ vựng</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_3">lexicographical_compare (3)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">hơn cái khác.</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Nếu hai phạm vi có các phần tử tương đương và có cùng chiều dài, thì các phạm vi là từ vựng</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">Một phạm vi trống là từ vựng</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue142" rel="nofollow">LWG 142</a> </td> <td>C ++ 98</td> <td>hơn bất kỳ phạm vi không trống nào.<sub>, nếu như</sub>Hai phạm vi trống là từ vựng<sub>    return (! (đầu tiên == cuối cùng) và! (giá trị &lt; *đầu tiên));</sub>phạm vi đầu tiên của các yếu tố để kiểm tra<br/>phạm vi thứ hai của các yếu tố để kiểm tra</td> <td>Các loại Type1 và Type2 phải sao cho các đối tượng của các loại Inputit1 và InputIt2 có thể được báo cáo và sau đó được chuyển đổi hoàn toàn sang cả Type1 và Type2.</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue1205" rel="nofollow">LWG 1205</a> </td> <td>C ++ 98</td> <td>Nếu phạm vi đầu tiên là từ vựng</td> <td>hơn thứ hai, nếu không</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="equal" title="cpp/algorithm/equal"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="lexicographical_compare_three_way" title="cpp/algorithm/lexicographical compare three way"> <span class="t-lines"><span>(Niebloid)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="ranges/lexicographical_compare" title="cpp/algorithm/ranges/lexicographical compare"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<code>true</code>trả lại<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">https://en.cppreference.com/w/cpp/algorithm/lexicographical_compare</a>
</p>
</div>
