 <h1 class="firstHeading" id="firstHeading">std :: Sao chép, std :: copy_if</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl"> <td><pre data-language="cpp">Mẫu &lt;class inputit, class outputit&gt;</pre></td> <td>(1)</td> <td><span class="t-mark-rev t-since-cxx20">ForwardItIT2 Sao chép (Chính sách thực thi &amp;&amp; chính sách,</span></td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">(Constexpr kể từ C ++ 20)</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td><pre data-language="cpp">Mẫu &lt;class execPolicy, class forwardit1, class forwardit2&gt;</pre></td> <td>(3)</td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-since-cxx20">ForwardItIT2 Sao chép (Chính sách thực thi &amp;&amp; chính sách,</span>
</td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">                 ForwardIt1 đầu tiên, forwardit1 cuối cùng, forwardit2 d_first);</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <p>Mẫu &lt;class inputit, class outputit, lớp unyredicate&gt;<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Outputit copy_if (đầu vào đầu tiên, đầu vào cuối cùng, đầu ra d_first,<code>d_first</code>                  Không có dự đoán);</p>
<div class="t-li1">
<span class="t-li">1)</span>(Constexpr kể từ C ++ 20)<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Mẫu &lt;Class execPolicy,<code>first</code>          lớp chuyển tiếp1, class forwardit2, lớp unyredicate&gt;<code>last</code>.</div> <div class="t-li1">Nếu như<code>d_first</code>ForwardItIt2 copy_if (execPolicy &amp;&amp; chính sách,<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>                    Forwardit1 đầu tiên, forwardit1 cuối cùng, forwardit2 d_first,<code><a href="copy_backward" title="cpp/algorithm/copy backward">std::copy_backward</a></code>                    Không có dự đoán);</div> <div class="t-li1">
<span class="t-li">2)</span>Sao chép các yếu tố trong phạm vi, được xác định bởi<code>policy</code>, hành vi là không xác định. Trong trường hợp này,<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2642">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table>
</div> <div class="t-li1">Nếu như<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>và tiến hành</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Bản sao tất cả các yếu tố trong phạm vi<code>pred</code>(C ++ 20)<code>true</code>bắt đầu từ</div> <div class="t-li1">Nếu như<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>và tiến hành</div> <div class="t-li1">
<span class="t-li">là trong</span>                                   Nhị phân p);<span class="t-v">(3)</span>Mẫu &lt;class execPolicy, class forwardit, lớp nhị phân&gt;<code>policy</code>, hành vi là không xác định. Trong trường hợp này,<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2642">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table>
</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>có thể được sử dụng thay thế.</td>
</tr> <tr class="t-par"> <td>không trống, sử dụng bộ tích lũy</td> <td>-</td> <td>Để lưu trữ giá trị bị trừ:</td>
</tr> <tr class="t-par"> <td>std :: iterator_traits &lt;buputit&gt; :: value_type acc = *first;</td> <td>-</td> <td>*d_first = acc;<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">execution policy</a> </td>
</tr> <tr class="t-par"> <td>Sao chép các yếu tố, nhưng được thực thi theo</td> <td>-</td> <td>. Quá tải này không tham gia vào độ phân giải quá tải trừ khi<code>true</code>và sự chồng chéo phạm vi đích, hành vi không được xác định.<br/> <p>              Không có p);<code>pred(v)</code>(6)<code>bool</code>Kiểm tra xem vị ngữ không<code>v</code>Đối với tất cả các yếu tố trong phạm vi<code>VT</code>là<code>VT</code>Kiểm tra xem vị ngữ không<code>InputIt</code>Đối với ít nhất một yếu tố trong phạm vi<a href="../language/value_category" title="cpp/language/value category">value category</a>5)<code>v</code>Kiểm tra xem vị ngữ không<code>VT&amp;</code>phạm vi của các yếu tố để kiểm tra<span class="t-rev-inl t-since-cxx11"><span>P<code>VT</code>vị từ nhị phân trả về<code>VT</code>Nếu các yếu tố nên được coi là bằng nhau.</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Đối tượng chức năng hoạt động nhị phân sẽ được áp dụng.</p>
</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>InputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>OutputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/outputiterator" title="cpp/named req/OutputIterator">LegacyOutputIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>ForwardIt1, ForwardIt2</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>UnaryPredicate</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/predicate" title="cpp/named req/Predicate">Predicate</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Chỉ sao chép các yếu tố mà vị ngữ</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>. Thuật toán bản sao này ổn định: Thứ tự tương đối của các yếu tố được sao chép được bảo tồn.<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>:</p>
<div class="t-li1">
<span class="t-li">Đầu vào</span>và sự chồng chéo phạm vi đích, hành vi không được xác định.</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>4)<code>pred</code>. Quá tải này không tham gia vào độ phân giải quá tải trừ khi</div> <p>Phạm vi của các yếu tố để sao chép<code>ExecutionPolicy</code>PRED<code>ForwardIt1</code>một vị từ không được trả lại<a href="../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>.</p>
<h3 id="Exceptions">Ngoại lệ</h3> <p>Sự khởi đầu của phạm vi đích<code>ExecutionPolicy</code>chính sách</p>
<ul>
<li>Chính sách thực thi để sử dụng. Nhìn thấy<code>ExecutionPolicy</code>Để biết chi tiết.<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">standard policies</a>Thì<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>Loại loại 1 và type2 phải sao cho một đối tượng của loại iterator_traits<code>ExecutionPolicy</code>Đầu vào</li>
<li>value_type<code><a href="../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>có thể được chuyển đổi hoàn toàn thành cả hai. Loại</li>
</ul> <h3 id="Notes">Ghi chú</h3> <p>cho các yếu tố cần thiết.<code>std::copy</code>Đầu ra tererator vào phần tử trong phạm vi đích, một qua phần tử cuối cùng được sao chép.<code><a href="../string/byte/memmove" title="cpp/string/byte/memmove">std::memmove</a></code>Cho \ (\ scriptsize n \) n như<a href="../named_req/triviallycopyable" title="cpp/named req/TriviallyCopyable">TriviallyCopyable</a>Chính xác là \ (\ scriptsize n \) n.<a href="../named_req/contiguousiterator" title="cpp/named req/ContiguousIterator">LegacyContiguousIterator</a>.</p>
<p>Chính xác \ (\ scriptsize n \) n ứng dụng của vị ngữ<code>std::copy</code>, và nhiều nhất là các bài tập NN.<code>std::copy_backward</code>Cho quá tải với một</p>
<h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <th>
<a href="#Version_1">copy (1)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">, có thể có một chi phí hiệu suất nếu</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_3">copy_if (3)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Loại giá trị không</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example">
<p>Trong thực tế, việc triển khai<code>std::copy</code>Tránh nhiều bài tập và sử dụng các chức năng bản sao hàng loạt như<code><a href="../container/vector" title="cpp/container/vector">std::vector</a></code>Nếu loại giá trị là<code><a href="../container/vector" title="cpp/container/vector">std::vector</a></code>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">Và các loại lặp lại thỏa mãn</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">Khi sao chép phạm vi chồng chéo,</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2039" rel="nofollow">LWG 2039</a> </td> <td>C ++ 11</td> <td>phù hợp khi sao chép bên trái (đầu của phạm vi đích nằm ngoài phạm vi nguồn) trong khi<code>std::copy_if</code>phù hợp khi sao chép bên phải (cuối phạm vi đích nằm ngoài phạm vi nguồn).</td> <td>Mẫu &lt;class inputit, class outputit&gt;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2044" rel="nofollow">LWG 2044</a> </td> <td>C ++ 11</td> <td>Bản sao đầu ra (đầu vào đầu tiên, đầu vào cuối cùng,<code>std::copy_if</code>              Outputit D_First)</td> <td>{</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="copy_backward" title="cpp/algorithm/copy backward"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="reverse_copy" title="cpp/algorithm/reverse copy"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="copy_n" title="cpp/algorithm/copy n"> <span class="t-lines"><span>(Niebloid)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="fill" title="cpp/algorithm/fill"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>đổ đầy<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="remove_copy" title="cpp/algorithm/remove copy"> <span class="t-lines"><span>(Niebloid)</span><span>remove_copy</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="ranges/copy" title="cpp/algorithm/ranges/copy"> <span class="t-lines"><span>(Mẫu chức năng)</span><span>Phạm vi :: Sao chép</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/copy">https://en.cppreference.com/w/cpp/algorithm/copy</a>
</p>
</div>
