 <h1 class="firstHeading" id="firstHeading">STD :: Xóa, STD :: Remove_if</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class forwardit, class t&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Chuyển tiếp loại bỏ (forwardit đầu tiên, forwardit cuối cùng, const t &amp; value);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;class forwardit, class t&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(3)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Consexpr chuyển tiếp loại bỏ (Forwardit First, ForwardIt Last, Const T &amp; Value);</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;class execPolicy, class forwardit, class t&gt;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Chuyển tiếp loại bỏ (execPolicy &amp;&amp; chính sách,</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <p>                  Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng, const t &amp; value);<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Mẫu &lt;class forwardit, lớp unyrepreicate&gt;</p>
<div class="t-li1">
<span class="t-li">1)</span>Chuyển tiếp emove_if (forwardIt đầu tiên, forwardit cuối cùng, p không có tính p);<code>value</code>           Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng, const t &amp; value);<code>operator==</code>).</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Mẫu &lt;class forwardit, lớp unyrepreicate&gt;<code>p</code>(C ++ 20)<code>true</code>.</div> <div class="t-li1">
<span class="t-li">Một động thái tương đương với một bản sao</span>                                   Nhị phân p);<span class="t-v">*(d_first + 2) = val2 - std :: di chuyển (acc);</span>Mẫu &lt;class execPolicy, class forwardit, lớp nhị phân&gt;<code>policy</code>ForwardIt adjacent_find (execPolicy &amp;&amp; chính sách,<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2643">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table>
</div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <p>Consexpr ForwardIT Remove_if (ForwardIt First, ForwardIt Last,<a href="../iterator#Types_and_writability" title="cpp/iterator">value type</a>của<code>ForwardIt</code># Elif __has_include (&lt;thử nghiệm/tùy chọn&gt;) // Kiểm tra phiên bản thử nghiệm<a href="../named_req/copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a>Hoạt động tương đương cho quá tải</p>
</td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> <p>                               Không có p);<code>*first</code># Elif __has_include (&lt;thử nghiệm/tùy chọn&gt;) // Kiểm tra phiên bản thử nghiệm<a href="../named_req/moveassignable" title="cpp/named req/MoveAssignable">MoveAssignable</a>Hoạt động tương đương cho quá tải</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <p>Mẫu &lt;class execPolicy, class forwardit, lớp unyredicate&gt;<span class="t-rev-inl t-until-cxx11"><span><a href="../language/copy_assignment" title="cpp/language/copy assignment">copy assignment</a></span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span><a href="../language/move_assignment" title="cpp/language/move assignment">move assignment</a></span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>ForwardIt Remove_if (ExecUtPolicy &amp;&amp; chính sách,<i>điều hòa sau)</i>Xóa tất cả các yếu tố thỏa mãn các tiêu chí cụ thể khỏi phạm vi<i>giá trị của các yếu tố để loại bỏ</i>Loại bỏ tất cả các yếu tố bằng<i>điều hòa sau)</i>Nếu<a href="../iterator#Dereferenceability_and_validity" title="cpp/iterator">dereferenceable</a><span class="t-rev-inl t-since-cxx11"><span>Nếu loại<a href="../named_req/moveassignable" title="cpp/named req/MoveAssignable">MoveAssignable</a>Việc loại bỏ được thực hiện bằng cách thay đổi (bằng cách</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>.</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>) Các phần tử trong phạm vi theo cách mà các yếu tố không được loại bỏ xuất hiện ở đầu phạm vi. Thứ tự tương đối của các yếu tố còn lại được bảo tồn và</td>
</tr> <tr class="t-par"> <td>được phân vùng liên quan đến</td> <td>-</td> <td>thuộc vật chất</td>
</tr> <tr class="t-par"> <td>std :: iterator_traits &lt;buputit&gt; :: value_type acc = *first;</td> <td>-</td> <td>*d_first = acc;<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">execution policy</a> </td>
</tr> <tr class="t-par"> <td>, nhưng được thực hiện theo</td> <td>-</td> <td>. Quá tải này không tham gia vào độ phân giải quá tải trừ khi<code>true</code>Kích thước của container không thay đổi. Trình lặp chỉ vào một yếu tố giữa cái mới<br/> <p>              Không có p);<code>p(v)</code>(6)<code>bool</code>Kiểm tra xem vị ngữ không<code>v</code>Đối với tất cả các yếu tố trong phạm vi<code>VT</code>là<code>VT</code>Kiểm tra xem vị ngữ không<code>ForwardIt</code>Đối với ít nhất một yếu tố trong phạm vi<a href="../language/value_category" title="cpp/language/value category">value category</a>5)<code>v</code>Kiểm tra xem vị ngữ không<code>VT&amp;</code>phạm vi của các yếu tố để kiểm tra<span class="t-rev-inl t-since-cxx11"><span>P<code>VT</code>vị từ nhị phân trả về<code>VT</code>Nếu các yếu tố nên được coi là bằng nhau.</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Đối tượng chức năng hoạt động nhị phân sẽ được áp dụng.</p>
</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>ForwardIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>UnaryPredicate</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/predicate" title="cpp/named req/Predicate">Predicate</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>hợp lý<code>end</code>kết thúc và<code>end</code>).</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Cho quá tải<code>N</code>(1,3)<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>:</p>
<div class="t-li1">
<span class="t-li">Đầu vào</span>Phạm vi của các yếu tố<code>N</code>ConstExpr typename iterator_traits &lt;buputit&gt; :: arget_type<code>value</code>    Count_if (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);<code>operator==</code>.</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>Phạm vi của các yếu tố<code>N</code>Mẫu &lt;class execPolicy, class forwardit, lớp unyredicate&gt;<code>p</code>.</div> <h3 id="Exceptions">Ngoại lệ</h3> <p>Sự khởi đầu của phạm vi đích<code>ExecutionPolicy</code>chính sách</p>
<ul>
<li>Chính sách thực thi để sử dụng. Nhìn thấy<code>ExecutionPolicy</code>Để biết chi tiết.<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">standard policies</a>Thì<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>Loại loại 1 và type2 phải sao cho một đối tượng của loại iterator_traits<code>ExecutionPolicy</code>Đầu vào</li>
<li>value_type<code><a href="../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>có thể được chuyển đổi hoàn toàn thành cả hai. Loại</li>
</ul> <h3 id="Notes">Ghi chú</h3> <p>thuộc vật chất<code>remove</code>Kết thúc phạm vi vẫn còn<code>erase</code>, nhưng bản thân các yếu tố có các giá trị không xác định (theo<i>điều hòa sau)</i>phạm vi của các yếu tố để xử lý<i>giá trị của các yếu tố để loại bỏ</i>Nếu phần tử nên được loại bỏ.<a class="extiw" href="https://en.wikipedia.org/wiki/Erase-remove_idiom" title="enwiki:Erase-remove idiom"><i>Trình lặp quá khứ cho phạm vi giá trị mới (nếu điều này không</i> idiom</a><span class="t-rev-inl t-since-cxx20"><span>, sau đó nó chỉ ra một giá trị không xác định, và các trình lặp lại cho bất kỳ giá trị nào giữa trình lặp này và<code><a href="../container/vector/erase2" title="cpp/container/vector/erase2">std::erase</a></code>Kích thước của container để phù hợp với nó mới<a href="../container#Non-member_function_table" title="cpp/container">overloads</a>thường được theo sau bởi một cuộc gọi đến một container<i>hàm thành viên, xóa các giá trị không xác định và giảm</i>thuộc vật chất<code><a href="../container/vector/erase2" title="cpp/container/vector/erase2">std::erase_if</a></code>Kích thước của container để phù hợp với nó mới<a href="../container#Non-member_function_table" title="cpp/container">overloads</a>vì<i>Xem thêm việc triển khai</i>hợp lý</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>.</p>
<p>kích cỡ. Hai lời mời này cùng nhau tạo thành một cái gọi là<a href="../container#Member_function_table" title="cpp/container">member functions</a> <a href="../container/list/remove" title="cpp/container/list/remove"><code>list::remove</code></a>Thì<a href="../container/list/remove" title="cpp/container/list/remove"><code>list::remove_if</code></a>Thì<a href="../container/forward_list/remove" title="cpp/container/forward list/remove"><code>forward_list::remove</code></a>, Và<a href="../container/forward_list/remove" title="cpp/container/forward list/remove"><code>forward_list::remove_if</code></a>Xóa bỏ</p>
<p>, có thể đạt được bằng hàm tự do<code><a href="../container/set" title="cpp/container/set">std::set</a></code>Và<code><a href="../container/map" title="cpp/container/map">std::map</a></code>Điều đó có<a href="../named_req/moveassignable" title="cpp/named req/MoveAssignable">MoveAssignable</a>Đối với tất cả các tiêu chuẩn</p>
<p>sự liên tiếp<a href="../io/c/remove" title="cpp/io/c/remove"><code>std::remove</code></a>TRONG<a href="../header/cstdio" title="cpp/header/cstdio"><code>&lt;cstdio&gt;</code></a>container, hoặc<code>const char*</code>Điều đó có</p>
<p>container tiêu chuẩn<code>std::remove</code>Các thùng chứa có tên tương tự<code>value</code>Xóa các yếu tố bị loại bỏ.<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>.</p>
<h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <th>
<a href="#Version_1">remove</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Các thuật toán này không thể được sử dụng với các thùng chứa kết hợp như</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_3">remove_if</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">bởi vì các loại vòng lặp của chúng không gây khó chịu cho</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example">
<p>Các loại (các khóa trong các thùng chứa này không thể sửa đổi).<a class="extiw" href="https://en.wikipedia.org/wiki/Erase-remove_idiom" title="enwiki:Erase-remove idiom">Erase-remove idiom</a>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">Thư viện tiêu chuẩn cũng xác định quá tải</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">, trong đó có một</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue283" rel="nofollow">LWG 283</a> </td> <td>C ++ 98</td> <td>
<code>T</code>(Sử dụng<a href="../named_req/equalitycomparable" title="cpp/named req/EqualityComparable">EqualityComparable</a>Đếm các yếu tố mà vị ngữ<br/>(xác định ở trên) và kết quả của<code>ForwardIt</code>giá trị để tìm kiếm<code>T</code> </td> <td>và được sử dụng để xóa các tập tin.<code>ForwardIt</code><br/>được<a href="../named_req/copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a>Bởi vì</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="remove_copy" title="cpp/algorithm/remove copy"> <span class="t-lines"><span>(Niebloid)</span><span>remove_copy</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unique" title="cpp/algorithm/unique"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="ranges/remove" title="cpp/algorithm/ranges/remove"> <span class="t-lines"><span>(Mẫu chức năng)</span><span>Phạm vi :: Xóa</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/remove">https://en.cppreference.com/w/cpp/algorithm/remove</a>
</p>
</div>
