 <h1 class="firstHeading" id="firstHeading">STD :: Bằng</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class inputit1, class inputit2&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">bool bằng (đầu vào đầu tiên1, đầu vào1, last1,</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">            Inputit2 First2);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(3)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class inputit1, class inputit2&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">constexpr bool bằng (đầu vào đầu tiên1 đầu tiên, đầu vào</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">                      Inputit2 First2);</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">             Không có p);</td> <td></td> </tr> <tr class="t-dcl t-since-cxx14 t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class execPolicy, class forwardit1, class forwardit2&gt;</pre></td> <td>
<span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Bool Equal (Chính sách thực thi &amp;&amp; chính sách,</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">            Forwardit1 first1, forwardit1 last1,</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">            Chuyển tiếp 2 First2);</td> <td></td> </tr> <tr class="t-dcl t-since-cxx14 t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class inputit1, class inputIt2, class BinaryPredicate&gt;</pre></td> <td>
<span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">bool bằng (đầu vào đầu tiên1, đầu vào1, last1,</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">            Inputit2 first2,</pre>
</td> <td>            Nhị phân p);</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">(Do đó,</span>Mẫu &lt;Class execPolicy,<code>true</code>          lớp chuyển tiếp1, lớp forwardit2, lớp nhị phân&gt;<code>[</code><code>first1</code><code>, </code><code>last1</code><code>)</code>Bool Equal (Chính sách thực thi &amp;&amp; chính sách,<code>[</code><code>first2</code><code>, </code><code>first2 + (last1 - first1)</code><code>)</code>, Và<code>false</code>Nếu đối số đầu tiên là</div> <div class="t-li1">
<span class="t-li">          lớp chuyển tiếp1, lớp forwardit2, lớp nhị phân&gt;</span>Mẫu &lt;Class execPolicy,<code>true</code>          lớp chuyển tiếp1, lớp forwardit2, lớp nhị phân&gt;<code>[</code><code>first1</code><code>, </code><code>last1</code><code>)</code>Bool Equal (Chính sách thực thi &amp;&amp; chính sách,<code>[</code><code>first2</code><code>, </code><code>last2</code><code>)</code>, Và<code>false</code>Nếu đối số đầu tiên là</div> <div class="t-li1">
<span class="t-li">Trả lại</span>                                   Nhị phân p);<span class="t-v">            Forwardit2 first2,</span>Mẫu &lt;class execPolicy, class forwardit, lớp nhị phân&gt;<code>policy</code>ForwardIt adjacent_find (execPolicy &amp;&amp; chính sách,<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2643">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table>
</div> <p>            Nhị phân p);<code>i</code>theo thứ tự.<code>[</code><code>first1</code><code>, </code><code>last1</code><code>)</code>Thì<code>*i</code>Mẫu &lt;class inputit1, class inputit2&gt;<code>*(first2 + (i - first1))</code>bool bằng (đầu vào đầu tiên1, đầu vào1, last1,<span class="t-v">            Inputit2 First2, Inputit2 Last2);</span>sử dụng<code>operator==</code>Mẫu &lt;class inputit1, class inputit2&gt;<span class="t-v">constexpr bool bằng (đầu vào đầu tiên1 đầu tiên, đầu vào</span>                      Inputit2 First2, Inputit2 Last2);<code>p</code>.</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Mẫu &lt;class execPolicy, class forwardit1, class forwardit2&gt;</td> <td>-</td> <td>Bool Equal (Chính sách thực thi &amp;&amp; chính sách,</td>
</tr> <tr class="t-par"> <td>            Forwardit1 first1, forwardit1 last1,</td> <td>-</td> <td>            Forwardit2 first2, forwardit2 last2);</td>
</tr> <tr class="t-par"> <td>std :: iterator_traits &lt;buputit&gt; :: value_type acc = *first;</td> <td>-</td> <td>*d_first = acc;<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">execution policy</a> </td>
</tr> <tr class="t-par"> <td>, nhưng được thực hiện theo</td> <td>-</td> <td>. Những quá tải này không tham gia vào độ phân giải quá tải trừ khi<code>true</code>is_execut_policy_v<br/> <p>Decay_t</p>
<p><span class="t-cc"><code> bool pred(const Type1 &amp;a, const Type2 &amp;b);</code></span></p>
<p>&gt;&gt;<code>const &amp;</code>is_execut_policy_v<code>Type1</code>Và<code>Type2</code>Remove_cvref_t<a href="../language/value_category" title="cpp/language/value category">value category</a>&gt;&gt;<code>Type1 &amp;</code>phạm vi của các yếu tố để kiểm tra<span class="t-rev-inl t-since-cxx11"><span>P<code>Type1</code>vị từ nhị phân trả về<code>Type1</code>Nếu các yếu tố nên được coi là bằng nhau.</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>).<br/>(7)</p>
</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>InputIt1, InputIt2</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>ForwardIt1, ForwardIt2</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit1, class inputIt2, class BinaryPredicate&gt;</span>bool bằng (đầu vào đầu tiên1, đầu vào1, last1,<code>[</code><code>first1</code><code>, </code><code>last1</code><code>)</code>            Đầu vào đầu tiên2 đầu tiên, inputit2 last2,<code>[</code><code>first2</code><code>, </code><code>last2</code><code>)</code>; Nếu không nếu<code>false</code>.</div> <p>            Nhị phân p);<code>true</code>.</p>
<p>Mẫu &lt;class inputit1, class inputIt2, class BinaryPredicate&gt;<code>false</code>.</p>
<h3 id="Notes">Ghi chú</h3> <p><code>std::equal</code>constexpr bool bằng (đầu vào đầu tiên1 đầu tiên, đầu vào<code><a href="../container/unordered_set" title="cpp/container/unordered set">std::unordered_set</a></code>Thì<code><a href="../container/unordered_multiset" title="cpp/container/unordered multiset">std::unordered_multiset</a></code>Thì<code><a href="../container/unordered_map" title="cpp/container/unordered map">std::unordered_map</a></code>, hoặc<code><a href="../container/unordered_multimap" title="cpp/container/unordered multimap">std::unordered_multimap</a></code>                      Đầu vào đầu tiên2 đầu tiên, inputit2 last2,</p>
<p>                      Nhị phân p);<code>operator==</code>Mẫu &lt;Class execPolicy,</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <div class="t-li1">
<span class="t-li">(Do đó,</span>Nếu phạm vi trống.<code>last1</code>-<code>first1</code>nếu không thì. Trả lại</div> <div class="t-li1">
<span class="t-li">          lớp chuyển tiếp1, lớp forwardit2, lớp nhị phân&gt;</span>Bool Equal (execPolicy &amp;&amp; chính sách,<code>last1</code>-<code>first1</code>Thì<code>last2</code>-<code>first2</code>            Forwardit1 first1, forwardit1 last1,<br/>            Forwardit2 first2, forwardit2 last2,<code>InputIt1</code>Và<code>InputIt2</code>            Nhị phân p);<a href="../named_req/randomaccessiterator" title="cpp/named req/RandomAccessIterator">LegacyRandomAccessIterator</a>Và<code>last1 - first1 != last2 - first2</code>(8)</div> <div class="t-li1">
<span class="t-li">Trả lại</span>Nếu phạm vi</div> <h3 id="Exceptions">Ngoại lệ</h3> <p>Sự khởi đầu của phạm vi đích<code>ExecutionPolicy</code>chính sách</p>
<ul>
<li>Chính sách thực thi để sử dụng. Nhìn thấy<code>ExecutionPolicy</code>Để biết chi tiết.<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">standard policies</a>Thì<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>Loại loại 1 và type2 phải sao cho một đối tượng của loại iterator_traits<code>ExecutionPolicy</code>Đầu vào</li>
<li>value_type<code><a href="../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>có thể được chuyển đổi hoàn toàn thành cả hai. Loại</li>
</ul> <h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <th>
<a href="#Version_1">equal (1)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">bằng phạm vi</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_3">equal (3)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">5,7)</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example">
<p>Trong thực tế, việc triển khai<a href="#top"><code>std::equal</code></a>Trả lại</p>
<div class="cpp source-cpp"><pre data-language="cpp">Nếu phạm vi</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">bằng phạm vi</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="find" title="cpp/algorithm/find"> <span class="t-lines"><span>(Niebloid)</span><span>tìm thấy</span><span>find_if</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="lexicographical_compare" title="cpp/algorithm/lexicographical compare"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>(C ++ 20)<code>true</code>trả lại<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="mismatch" title="cpp/algorithm/mismatch"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="search" title="cpp/algorithm/search"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="ranges/equal" title="cpp/algorithm/ranges/equal"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/equal_to" title="cpp/utility/functional/equal to"> <span class="t-lines"><span>2,4,6,8)</span></span></a></div> </td> <td>thực hiện đối tượng chức năng<code>x == y</code> <br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="equal_range" title="cpp/algorithm/equal range"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/equal">https://en.cppreference.com/w/cpp/algorithm/equal</a>
</p>
</div>
