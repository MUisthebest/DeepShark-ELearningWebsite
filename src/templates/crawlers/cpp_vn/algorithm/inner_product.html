 <h1 class="firstHeading" id="firstHeading">STD :: Inside_Product</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/numeric" title="cpp/header/numeric">&lt;numeric&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class inputit1, class inputit2, class T&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">T bên trong_product (inputIt1 First1, inputIt1 last1, inputit2 first2, t init init);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(2)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class inputit1, class inputit2, class T&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Constexpr t bên trong_product (Inputit1 First1, Inputit1 Last1,</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>                           Đầu vào đầu tiên2, t init);<code>[</code><code>first1</code><code>, </code><code>last1</code><code>)</code>Mẫu &lt;class inputit1, class inputit2, class T,<code>first2</code>.</p>
<div class="t-li1">
<span class="t-li">1)</span>(loại<code>acc</code>) với giá trị ban đầu<code>T</code>và sau đó sửa đổi nó với<code>init</code>          Lớp BinaryOperation1, Lớp BinaryOperation2&gt;<span class="t-rev-inl t-until-cxx11"><span><code>acc = acc + (*i1) * (*i2)</code></span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span><code>acc = std::move(acc) + (*i1) * (*i2)</code></span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>trong phạm vi<code>i1</code>theo thứ tự.<code>[</code><code>first1</code><code>, </code><code>last1</code><code>)</code>Constexpr t bên trong_product (Inputit1 First1, Inputit1 Last1,<code>i2</code>                           Đầu vào đầu tiên2, t init,<code>first2</code>Mẫu &lt;class inputit1, class inputit2, class T,</div> <div class="t-li1">
<span class="t-li">2)</span>(loại<code>acc</code>) với giá trị ban đầu<code>T</code>và sau đó sửa đổi nó với<code>init</code>          Lớp BinaryOperation1, Lớp BinaryOperation2&gt;<span class="t-rev-inl t-until-cxx11"><span><code>acc = op1(acc, op2(*i1, *i2))</code></span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span><code>acc = op1(std::move(acc), op2(*i1, *i2))</code></span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>trong phạm vi<code>i1</code>theo thứ tự.<code>[</code><code>first1</code><code>, </code><code>last1</code><code>)</code>Constexpr t bên trong_product (Inputit1 First1, Inputit1 Last1,<code>i2</code>                           Đầu vào đầu tiên2, t init,<code>first2</code>.</div> <p>Nếu như<code>op1</code>hoặc<code>op2</code>                           BinaryOperation1 Op1, BinaryOperation2 Op2);</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Mẫu &lt;class execPolicy, class forwardit1, class forwardit2&gt;</td> <td>-</td> <td>Tính toán sản phẩm bên trong (nghĩa là tổng sản phẩm) hoặc thực hiện bản đồ đã đặt hàng/giảm hoạt động trên phạm vi</td>
</tr> <tr class="t-par"> <td>và phạm vi bắt đầu tại</td> <td>-</td> <td>và sau đó sửa đổi nó với biểu thức</td>
</tr> <tr class="t-par"> <td>trong phạm vi</td> <td>-</td> <td>Theo thứ tự và trình lặp tương ứng của nó</td>
</tr> <tr class="t-par"> <td>Trong phạm vi bắt đầu tại</td> <td>-</td> <td>. Đối với ý nghĩa tích hợp của + và *, điều này tính toán sản phẩm bên trong của hai phạm vi.<code>op2</code>và sau đó sửa đổi nó với biểu thức<br/> <p>Đầu tiên, cuối cùng</p>
<p><span class="t-cc"><code> Ret fun(const Type1 &amp;a, const Type2 &amp;b);</code></span></p>
<p>phạm vi của các phần tử để tổng<code>const &amp;</code>.<br/>Theo thứ tự và trình lặp tương ứng của nó<code>Ret</code>Giá trị ban đầu của tổng<code>T</code>Op<code>Ret</code>Đối tượng chức năng hoạt động nhị phân sẽ được áp dụng.</p>
</td>
</tr> <tr class="t-par"> <td>Trong phạm vi bắt đầu tại</td> <td>-</td> <td>Vô hiệu hóa bất kỳ trình lặp nào (bao gồm cả trình lặp cuối) hoặc sửa đổi bất kỳ yếu tố nào của phạm vi liên quan, hành vi không được xác định.<br/> <p>Đầu tiên, cuối cùng</p>
<p><span class="t-cc"><code> Ret fun(const Type1 &amp;a, const Type2 &amp;b);</code></span></p>
<p>phạm vi của các phần tử để tổng<code>const &amp;</code>.<br/>Phạm vi đầu tiên của các yếu tố<code>Ret</code>Giá trị ban đầu của tổng<code>Type3</code>Op<code>Ret</code>Đối tượng chức năng hoạt động nhị phân sẽ được áp dụng.</p>
</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>InputIt1, InputIt2</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>ForwardIt1, ForwardIt2</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a>Và<a href="../named_req/copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code>acc</code>có thể được gán một giá trị của loại</p>
<h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <th>
<a href="#Version_1">inner_product (1)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Đầu tiên2</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_2">inner_product (2)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Sự khởi đầu của phạm vi thứ hai của các yếu tố</pre></div> </td>
</tr>
</table> <h3 id="Notes">Ghi chú</h3> <p>Giá trị ban đầu của tổng sản phẩm<code><a href="transform_reduce" title="cpp/algorithm/transform reduce">std::transform_reduce</a></code>OP1<code>op1</code>Và<code>op2</code>Đối tượng chức năng hoạt động nhị phân sẽ được áp dụng. Hàm "tổng" này có giá trị được trả về bởi<code>std::inner_product</code>và giá trị hiện tại của bộ tích lũy và tạo ra một giá trị mới được lưu trữ trong bộ tích lũy.</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Các loại Type1 và Type2 phải sao cho các đối tượng thuộc loại T và Type3 có thể được chuyển đổi hoàn toàn thành Type1 và Type2 tương ứng. Loại</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">OP2</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue242" rel="nofollow">LWG 242</a> </td> <td>C ++ 98</td> <td>
<code>op1</code>Và<code>op2</code>    trả lại init;</td> <td>Đối tượng chức năng hoạt động nhị phân sẽ được áp dụng. Hàm "sản phẩm" này lấy một giá trị từ mỗi phạm vi và tạo ra một giá trị mới.</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2055" rel="nofollow">LWG 2055</a><br/>.<a class="external text" href="https://wg21.link/P0616R0" rel="nofollow">P0616R0</a>)</td> <td>C ++ 11</td> <td>
<code>acc</code>Mẫu &lt;class inputit, lớp T, lớp BinaryOperation&gt;</td> <td>constexpr // kể từ C ++ 20</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="transform_reduce" title="cpp/algorithm/transform reduce"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>(C ++ 17)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="accumulate" title="cpp/algorithm/accumulate"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>tích lũy<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="partial_sum" title="cpp/algorithm/partial sum"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div> </td> <td>Partial_sum<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/inner_product">https://en.cppreference.com/w/cpp/algorithm/inner_product</a>
</p>
</div>
