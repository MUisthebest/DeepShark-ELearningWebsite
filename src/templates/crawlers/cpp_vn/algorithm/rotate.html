 <h1 class="firstHeading" id="firstHeading">STD :: Xoay</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;Class ForwardIT&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Chuyển tiếp vòng quay (Forwardit đầu tiên, chuyển tiếp giữa, chuyển tiếp cuối cùng);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;Class ForwardIT&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Constexpr ForwardIt Rotate (ForwardIT đầu tiên,</div> <div class="t-li1">                            Chuyển tiếp giữa, chuyển tiếp cuối cùng);<code>std::rotate</code>Mẫu &lt;class execPolicy, class forwardit&gt;<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Chuyển tiếp ROTATE (execPolicy &amp;&amp; chính sách,<code>[</code><code>first</code><code>, </code><code>middle</code><code>)</code>                  Chuyển tiếp đầu tiên, chuyển tiếp giữa, chuyển tiếp cuối cùng);<code>[</code><code>middle</code><code>, </code><code>last</code><code>)</code>Thực hiện một vòng quay bên trái trên một loạt các yếu tố.</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>Mẫu &lt;class execPolicy, class forwardit, lớp nhị phân&gt;<code>policy</code>, hành vi là không xác định. Trong trường hợp này,<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2643">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table>
</div> <p>Nếu như<code>[</code><code>first</code><code>, </code><code>middle</code><code>)</code>hoặc<code>[</code><code>middle</code><code>, </code><code>last</code><code>)</code>Cụ thể,<a href="../iterator#Ranges" title="cpp/iterator">valid range</a>Hoạt động tương đương cho quá tải</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>đến phạm vi bắt đầu tại</td> <td>-</td> <td>hoán đổi các yếu tố trong phạm vi</td>
</tr> <tr class="t-par"> <td>ổn định</td> <td>-</td> <td>theo cách mà các yếu tố trong</td>
</tr> <tr class="t-par"> <td>cuối cùng</td> <td>-</td> <td>được đặt sau các yếu tố trong</td>
</tr> <tr class="t-par"> <td>std :: iterator_traits &lt;buputit&gt; :: value_type acc = *first;</td> <td>-</td> <td>*d_first = acc;<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">execution policy</a> </td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>ForwardIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/valueswappable" title="cpp/named req/ValueSwappable">ValueSwappable</a>Và<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">và các phạm vi phải được sắp xếp theo cùng một.<code>ForwardIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/moveassignable" title="cpp/named req/MoveAssignable">MoveAssignable</a>Và<a href="../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>trong khi các đơn đặt hàng của các yếu tố trong cả hai phạm vi được bảo tồn.</p>
<ul>
<li> <code>last</code>Sử dụng chức năng nhị phân đã cho<code>first == middle</code>khoảng cách<code>true</code>Thì</li>
<li> <code>first</code>Sử dụng chức năng nhị phân đã cho<code>middle == last</code>khoảng cách<code>true</code>Thì</li>
<li> <code>first + (last - middle)</code><sup class="reference" id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup>không phải là a<code>first</code>.</li>
</ul> <ol class="references"> <li id="cite_note-1"> <span class="reference-text">Các<code>+</code>Và<code>-</code>Sự khởi đầu của phạm vi ban đầu</span> </li> </ol> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Mẫu &lt;class execPolicy, class forwardit, class so sánh&gt;<code>first</code>Và<code>last</code>.</p>
<h3 id="Exceptions">Ngoại lệ</h3> <p>Trình lặp trong phạm vi đích, chỉ qua phần tử cuối cùng được sao chép nếu<code>ExecutionPolicy</code>Bài tập bằng không nếu</p>
<ul>
<li>Chính sách thực thi để sử dụng. Nhìn thấy<code>ExecutionPolicy</code>Để biết chi tiết.<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">standard policies</a>Thì<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>Loại loại 1 và type2 phải sao cho một đối tượng của loại iterator_traits<code>ExecutionPolicy</code>Đầu vào</li>
<li>value_type<code><a href="../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>có thể được chuyển đổi hoàn toàn thành cả hai. Loại</li>
</ul> <h3 id="Notes">Ghi chú</h3> <p><code>std::rotate</code>phần tử sẽ xuất hiện ở đầu phạm vi xoay<code>ForwardIt</code>Phần cuối của phạm vi ban đầu<a href="../named_req/bidirectionaliterator" title="cpp/named req/BidirectionalIterator">LegacyBidirectionalIterator</a>Một người lặp bằng với:<a href="../named_req/randomaccessiterator" title="cpp/named req/RandomAccessIterator">LegacyRandomAccessIterator</a>.</p>
<p>Nếu lần thực hiện hoán vị cuối cùng và phạm vi được đặt lại về hoán vị đầu tiên.<a class="external text" href="https://github.com/microsoft/STL/blob/main/stl/src/vector_algorithms.cpp" rel="nofollow">MSVC STL</a>Bất kỳ trường hợp ngoại lệ nào được ném từ các hoạt động lặp lại hoặc hoán đổi phần tử.<a href="../named_req/contiguousiterator" title="cpp/named req/ContiguousIterator">LegacyContiguousIterator</a>Nhiều nhất là hoán đổi n/2, trong đó<a href="../language/adl" title="cpp/language/adl">ADL</a>. Tính trung bình trên toàn bộ chuỗi hoán vị, các triển khai điển hình sử dụng khoảng 3 so sánh và 1,5 giao dịch hoán đổi mỗi cuộc gọi.<code>swap</code>.</p>
<h3 id="Possible_implementation">. ​</h3> <p>được tìm thấy,<a class="external text" href="https://github.com/gcc-mirror/gcc/blob/14d8a5ae472ca5743016f37da2dd4770d83dea21/libstdc%2B%2B-v3/include/bits/stl_algo.h#L1213-L1416" rel="nofollow">libstdc++</a>Thì<a class="external text" href="https://github.com/llvm/llvm-project/tree/6adbc83ee9e46b476e0f75d5671c3a21f675a936/libcxx/include/__algorithm/rotate.h" rel="nofollow">libc++</a>, Và<a class="external text" href="https://github.com/microsoft/STL/blob/472161105d596192194d4715ccad307c6c163b4a/stl/inc/xutility#L5392-L5446" rel="nofollow">MSVC STL</a>.</p>
<table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">nếu không, tức là vị trí mới của phần tử được trỏ bởi</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example t-example-std-c++14">
<p><code>std::rotate</code>Các hoạt động không bắt buộc phải được hỗ trợ, chúng chỉ được sử dụng để đại diện cho vị trí của trình lặp được trả về.<a class="extiw" href="https://en.wikipedia.org/wiki/insertion_sort" title="enwiki:insertion sort">insertion sort</a>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">có hiệu quả tốt hơn đối với các triển khai chung nếu</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">thỏa mãn</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue488" rel="nofollow">LWG 488</a> </td> <td>C ++ 98</td> <td>hoặc (tốt hơn)<code>first</code>Mẫu &lt;class forwardit&gt;</td> <td>đến nửa đầu của một vectơ số nguyên:</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="rotate_copy" title="cpp/algorithm/rotate copy"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="ranges/rotate" title="cpp/algorithm/ranges/rotate"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/rotate">https://en.cppreference.com/w/cpp/algorithm/rotate</a>
</p>
</div>
