 <h1 class="firstHeading" id="firstHeading">std :: find, std :: find_if, std :: find_if_not</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class inputit, class T&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Đầu vào tìm (đầu vào đầu tiên, đầu vào cuối cùng, const t &amp; value);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;class inputit, class T&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(3)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Consexpr inputit find (đầu vào đầu tiên, đầu vào cuối cùng, const t &amp; value);</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;class execPolicy, class forwardit, class t&gt;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Forwardit find (execPolicy &amp;&amp; chính sách,</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">             Không có p);</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx20"> <td><pre data-language="cpp">                Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng, const t &amp; value);</pre></td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;class inputit, class unyredicate&gt;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Inputit find_if (đầu vào đầu tiên, đầu vào cuối cùng, pspredicate p);</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <p>Mẫu &lt;class inputit, class unyredicate&gt;<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>ConstExpr inputit find_if (đầu vào đầu tiên, đầu vào cuối cùng, pspredicate p);<code>last</code>Mẫu &lt;class execPolicy, class forwardit, lớp unyredicate&gt;</p>
<div class="t-li1">
<span class="t-li">1)</span> <code>find</code>ForwardIt find_if (execPolicy &amp;&amp; chính sách,<code>value</code>           Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng, const t &amp; value);<code>operator==</code>).</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span> <code>find_if</code>Mẫu &lt;class inputit, class unyredicate&gt;<code>p</code>(C ++ 20)<code>true</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span> <code>find_if_not</code>Mẫu &lt;class inputit, class unyredicate&gt;<code>q</code>(C ++ 20)<code>false</code>.</div> <div class="t-li1">
<span class="t-li">cho ít nhất một yếu tố trong phạm vi,</span>                                   Nhị phân p);<span class="t-v">Mẫu &lt;class execPolicy, class forwardit, lớp unyredicate&gt;</span>Mẫu &lt;class execPolicy, class forwardit, lớp nhị phân&gt;<code>policy</code>ForwardIt adjacent_find (execPolicy &amp;&amp; chính sách,<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2641">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table>
</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>Giống như</td>
</tr> <tr class="t-par"> <td>được phân vùng liên quan đến</td> <td>-</td> <td>cho tất cả các yếu tố, nếu</td>
</tr> <tr class="t-par"> <td>std :: iterator_traits &lt;buputit&gt; :: value_type acc = *first;</td> <td>-</td> <td>*d_first = acc;<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">execution policy</a> </td>
</tr> <tr class="t-par"> <td>, nhưng được thực hiện theo</td> <td>-</td> <td>. Quá tải này không tham gia vào độ phân giải quá tải trừ khi<code>true</code>ConstExpr inputit find_if_not (đầu vào đầu tiên, đầu vào cuối cùng, không có tính Q);<br/> <p>              Không có p);<code>p(v)</code>(6)<code>bool</code>Kiểm tra xem vị ngữ không<code>v</code>Đối với tất cả các yếu tố trong phạm vi<code>VT</code>là<code>VT</code>Kiểm tra xem vị ngữ không<code>InputIt</code>Đối với ít nhất một yếu tố trong phạm vi<a href="../language/value_category" title="cpp/language/value category">value category</a>5)<code>v</code>Kiểm tra xem vị ngữ không<code>VT&amp;</code>phạm vi của các yếu tố để kiểm tra<span class="t-rev-inl t-since-cxx11"><span>P<code>VT</code>vị từ nhị phân trả về<code>VT</code>Nếu các yếu tố nên được coi là bằng nhau.</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Đối tượng chức năng hoạt động nhị phân sẽ được áp dụng.</p>
</td>
</tr> <tr class="t-par"> <td>Mẫu &lt;class inputit, class unyredicate&gt;</td> <td>-</td> <td>. Quá tải này không tham gia vào độ phân giải quá tải trừ khi<code>false</code>ConstExpr inputit find_if_not (đầu vào đầu tiên, đầu vào cuối cùng, không có tính Q);<br/> <p>              Không có p);<code>q(v)</code>(6)<code>bool</code>Kiểm tra xem vị ngữ không<code>v</code>Đối với tất cả các yếu tố trong phạm vi<code>VT</code>là<code>VT</code>Kiểm tra xem vị ngữ không<code>InputIt</code>Đối với ít nhất một yếu tố trong phạm vi<a href="../language/value_category" title="cpp/language/value category">value category</a>5)<code>v</code>Kiểm tra xem vị ngữ không<code>VT&amp;</code>phạm vi của các yếu tố để kiểm tra<span class="t-rev-inl t-since-cxx11"><span>P<code>VT</code>vị từ nhị phân trả về<code>VT</code>Nếu các yếu tố nên được coi là bằng nhau.</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Đối tượng chức năng hoạt động nhị phân sẽ được áp dụng.</p>
</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>InputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>ForwardIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>UnaryPredicate</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/predicate" title="cpp/named req/Predicate">Predicate</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Mẫu &lt;class execPolicy, class forwardit, lớp unyredicate&gt;<code>it</code>trong<a href="../iterator#Ranges" title="cpp/iterator">range</a> <code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>ForwardIt find_if_not (execPolicy &amp;&amp; chính sách,<code>last</code>                       Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng, không có ý nghĩa Q);</p>
<div class="t-li1">
<span class="t-li">Đầu vào</span> <code>*it == value</code>khoảng cách<code>true</code>.</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span> <code>p(*it)</code>khoảng cách<code>true</code>.</div> <div class="t-li1">
<span class="t-li">    trả về std :: find_if_not (đầu tiên, cuối cùng, p) == cuối cùng;</span> <code>q(*it)</code>khoảng cách<code>false</code>.</div> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Cho quá tải<code>N</code>(1,3)<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>:</p>
<div class="t-li1">
<span class="t-li">Đầu vào</span>Nếu phạm vi trống.<code>N</code>ConstExpr typename iterator_traits &lt;buputit&gt; :: arget_type<code>value</code>    Count_if (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);<code>operator==</code>.</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>Nếu phạm vi trống.<code>N</code>Mẫu &lt;class execPolicy, class forwardit, lớp unyredicate&gt;<code>p</code>.</div> <div class="t-li1">
<span class="t-li">    trả về std :: find_if_not (đầu tiên, cuối cùng, p) == cuối cùng;</span>Nếu phạm vi trống.<code>N</code>Mẫu &lt;class execPolicy, class forwardit, lớp unyredicate&gt;<code>q</code>.</div> <h3 id="Exceptions">Ngoại lệ</h3> <p>Sự khởi đầu của phạm vi đích<code>ExecutionPolicy</code>chính sách</p>
<ul>
<li>Chính sách thực thi để sử dụng. Nhìn thấy<code>ExecutionPolicy</code>Để biết chi tiết.<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">standard policies</a>Thì<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>Loại loại 1 và type2 phải sao cho một đối tượng của loại iterator_traits<code>ExecutionPolicy</code>Đầu vào</li>
<li>value_type<code><a href="../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>có thể được chuyển đổi hoàn toàn thành cả hai. Loại</li>
</ul> <h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <th>
<a href="#Version_1">find</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Trả một trình lặp lại cho phần tử đầu tiên trong phạm vi</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_3">find_if</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">đáp ứng các tiêu chí cụ thể (hoặc</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_5">find_if_not</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Nếu không có trình lặp như vậy):</pre></div> </td>
</tr>
</table> <h3 id="Notes">Ghi chú</h3> <p>tìm kiếm một phần tử bằng<code>std::find_if_not</code>tìm kiếm một phần tử mà vị ngữ<code>std::find_if</code>tìm kiếm một phần tử mà vị ngữ</p>
<table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">cho yếu tố cần thiết.</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example">
<p>Q.<code><a href="../container/vector" title="cpp/container/vector">std::vector</a></code>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">cho yếu tố cần thiết.</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Người lặp đầu tiên</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue283" rel="nofollow">LWG 283</a> </td> <td>C ++ 98</td> <td>
<code>T</code>(Sử dụng<a href="../named_req/equalitycomparable" title="cpp/named req/EqualityComparable">EqualityComparable</a>Đếm các yếu tố mà vị ngữ<br/>(xác định ở trên) và kết quả của<code>InputIt</code>giá trị để tìm kiếm<code>T</code> </td> <td>Số lượng người lặp</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="adjacent_find" title="cpp/algorithm/adjacent find"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="find_end" title="cpp/algorithm/find end"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="find_first_of" title="cpp/algorithm/find first of"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="mismatch" title="cpp/algorithm/mismatch"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="search" title="cpp/algorithm/search"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="ranges/find" title="cpp/algorithm/ranges/find"> <span class="t-lines"><span>(Mẫu chức năng)</span><span>Phạm vi :: Tìm</span><span>Phạm vi :: find_if</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/find">https://en.cppreference.com/w/cpp/algorithm/find</a>
</p>
</div>
