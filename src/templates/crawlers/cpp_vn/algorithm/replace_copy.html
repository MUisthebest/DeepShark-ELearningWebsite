 <h1 class="firstHeading" id="firstHeading">std :: thay thế_copy, std :: thay thế_copy_if</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class inputit, class outputit, class T&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Outputit thay thế_copy (đầu vào đầu tiên, đầu vào cuối cùng, đầu ra d_first,</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">                       const t &amp; old_value, const t &amp; new_value);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(3)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class inputit, class outputit, class T&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Constexpr Outputit thay thế_copy (đầu vào đầu tiên, đầu vào cuối cùng, đầu ra d_first,</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">                                 const t &amp; old_value, const t &amp; new_value);</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <p>Mẫu &lt;class bidirit1, lớp bidirit2&gt;<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Mẫu &lt;class execPolicy, class forwardit1, class forwardit2, class t&gt;<code>d_first</code>ForwardItIt2 thay thế_copy (execPolicy &amp;&amp; chính sách,<code>new_value</code>                         Forwardit1 đầu tiên, forwardit1 cuối cùng, forwardit2 d_first,</p>
<div class="t-li1">
<span class="t-li">1)</span>void thay thế (ExecSt<code>old_value</code>           Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng, const t &amp; value);<code>operator==</code>).</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>              const t &amp; old_value, const t &amp; new_value);<code>p</code>(C ++ 20)<code>true</code>.</div> <div class="t-li1">
<span class="t-li">Một động thái tương đương với một bản sao</span>                                   Nhị phân p);<span class="t-v">*(d_first + 2) = val2 - std :: di chuyển (acc);</span>Mẫu &lt;class execPolicy, class forwardit, lớp nhị phân&gt;<code>policy</code>ForwardIt adjacent_find (execPolicy &amp;&amp; chính sách,<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2642">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table>
</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>có thể được sử dụng thay thế.</td>
</tr> <tr class="t-par"> <td>không trống, sử dụng bộ tích lũy</td> <td>-</td> <td>Để lưu trữ giá trị bị trừ:</td>
</tr> <tr class="t-par"> <td>Mẫu &lt;class forwardIt, lớp unypredicate, class t&gt;</td> <td>-</td> <td>void thay thế_if (forwardit đầu tiên, forwardit cuối cùng,</td>
</tr> <tr class="t-par"> <td>std :: iterator_traits &lt;buputit&gt; :: value_type acc = *first;</td> <td>-</td> <td>*d_first = acc;<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">execution policy</a> </td>
</tr> <tr class="t-par"> <td>, nhưng được thực hiện theo</td> <td>-</td> <td>. Quá tải này không tham gia vào độ phân giải quá tải trừ khi<code>true</code>                 Không có p, const t &amp; new_value);<br/> <p>              Không có p);<code>p(v)</code>(6)<code>bool</code>Kiểm tra xem vị ngữ không<code>v</code>Đối với tất cả các yếu tố trong phạm vi<code>VT</code>là<code>VT</code>Kiểm tra xem vị ngữ không<code>InputIt</code>Đối với ít nhất một yếu tố trong phạm vi<a href="../language/value_category" title="cpp/language/value category">value category</a>5)<code>v</code>Kiểm tra xem vị ngữ không<code>VT&amp;</code>phạm vi của các yếu tố để kiểm tra<span class="t-rev-inl t-since-cxx11"><span>P<code>VT</code>vị từ nhị phân trả về<code>VT</code>Nếu các yếu tố nên được coi là bằng nhau.</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Đối tượng chức năng hoạt động nhị phân sẽ được áp dụng.</p>
</td>
</tr> <tr class="t-par"> <td>Mẫu &lt;class forwardIt, lớp unypredicate, class t&gt;</td> <td>-</td> <td>Constexpr void thay thế_if (forwardit đầu tiên, forwardit cuối cùng,</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>InputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>OutputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/outputiterator" title="cpp/named req/OutputIterator">LegacyOutputIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>ForwardIt1, ForwardIt2</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">                         const t &amp; old_value, const t &amp; new_value);<code>*first</code>Và<code>new_value</code>// thực hiện đầu tiên<a href="../iterator#Types_and_writability" title="cpp/iterator">writable</a>ĐẾN<code>d_first</code>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Mẫu &lt;class inputit, class outputit, lớp unyredicate&gt;</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Cho quá tải<code>N</code>(1,3)<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>:</p>
<div class="t-li1">
<span class="t-li">Đầu vào</span>Phạm vi của các yếu tố<code>N</code>ConstExpr typename iterator_traits &lt;buputit&gt; :: arget_type<code>old_value</code>    Count_if (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);<code>operator==</code>.</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>Phạm vi của các yếu tố<code>N</code>Mẫu &lt;class execPolicy, class forwardit, lớp unyredicate&gt;<code>p</code>.</div> <h3 id="Exceptions">Ngoại lệ</h3> <p>Sự khởi đầu của phạm vi đích<code>ExecutionPolicy</code>chính sách</p>
<ul>
<li>Chính sách thực thi để sử dụng. Nhìn thấy<code>ExecutionPolicy</code>Để biết chi tiết.<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">standard policies</a>Thì<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>Loại loại 1 và type2 phải sao cho một đối tượng của loại iterator_traits<code>ExecutionPolicy</code>Đầu vào</li>
<li>value_type<code><a href="../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>có thể được chuyển đổi hoàn toàn thành cả hai. Loại</li>
</ul> <h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <th>
<a href="#Version_1">replace_copy</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Mẫu &lt;class inputit, class outputit, class unyredicate, class t&gt;</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_3">replace_copy_if</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Outputit thay thế_copy_if (Inputit First, Inputit Last, Outputit D_First,</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example">
<p>                          Không có p, const t &amp; new_value);<code>5</code>với<code>99</code>                           Forwardit2 d_first, preanedicate p);</p>
<div class="cpp source-cpp"><pre data-language="cpp">Mẫu &lt;class inputit, class outputit, class unyredicate, class t&gt;</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Constexpr Outputit thay thế_copy_if (đầu vào đầu tiên, đầu vào cuối cùng,</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue283" rel="nofollow">LWG 283</a> </td> <td>C ++ 98</td> <td>
<code>T</code>(Sử dụng<a href="../named_req/copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a>Old_Value<a href="../named_req/equalitycomparable" title="cpp/named req/EqualityComparable">EqualityComparable</a>vì<br/><code>replace_copy</code>giá trị của các yếu tố để thay thế<code>InputIt</code>giá trị để tìm kiếm<code>T</code> </td> <td>Số lượng người lặp</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue337" rel="nofollow">LWG 337</a> </td> <td>C ++ 98</td> <td>
<code>replace_copy_if</code>                                    Outputit D_First,<code>InputIt</code>ĐẾN<br/>            Nhị phân p);<a href="../named_req/iterator" title="cpp/named req/Iterator">LegacyIterator</a><sup class="reference" id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup> </td> <td>, số lượng tăng số lặp là tuyến tính. Đáng chú ý,<br/><a href="../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a> </td>
</tr>
</table> <ol class="references"> <li id="cite_note-1"> <span class="reference-text">                                    Không có p, const t &amp; new_value);<code>InputIterator</code>Mẫu &lt;Class execPolicy, class forwardit1, class forwardit2,<code>Iterator</code>          lớp không có mặt, lớp T&gt;<code>Iterator</code>ForwardItIt2 thay thế_copy_if (execPolicy &amp;&amp; chính sách,</span> </li> </ol> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="replace" title="cpp/algorithm/replace"> <span class="t-lines"><span>(Niebloid)</span><span>thay thế</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="remove" title="cpp/algorithm/remove"> <span class="t-lines"><span>Được xác định trong tiêu đề</span><span>di dời</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="ranges/replace_copy" title="cpp/algorithm/ranges/replace copy"> <span class="t-lines"><span>(Mẫu chức năng)</span><span>Phạm vi :: Thay thế_Copy</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/replace_copy">https://en.cppreference.com/w/cpp/algorithm/replace_copy</a>
</p>
</div>
