 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: Xóa, std :: phạm vi :: remove_if</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td><pre data-language="cpp">Mẫu &lt;std :: có thể thấm được i, std :: sentinel_for &lt;i&gt; s, class T,</pre></td> <td>(1)</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          lớp proj = std :: danh tính&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td><pre data-language="cpp">Yêu cầu STD :: Indirect_Binary_Predicate &lt;Ranges :: Equ_to,</pre></td> <td>(3)</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">             std :: dự kiến ​​&lt;i, proj&gt;, const t*&gt;</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>                  Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng, const t &amp; value);<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Constexpr Phạm vi :: Subrange &lt;i&gt;<code>[</code><code>ret</code><code>, </code><code>last</code><code>)</code>là<code>ret</code>    loại bỏ (tôi đầu tiên, s cuối cùng, const t &amp; value, proj proj = {});</p>
<div class="t-li1">
<span class="t-li">1)</span>Chuyển tiếp emove_if (forwardIt đầu tiên, forwardit cuối cùng, p không có tính p);<code>value</code>Mẫu &lt;class inputit, lớp đầu ra,<code><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>proj, <span class="sy2">*</span>i<span class="br0">)</span> <span class="sy1">==</span> value</code>Mẫu &lt;phạm vi :: forward_range r, class t, class proj = std :: identity&gt;</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Yêu cầu STD :: Thấy &lt;Ranges :: iterator_t &lt;r &gt;&gt; &amp;&amp;<code><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>pred, <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>proj, <span class="sy2">*</span>i<span class="br0">)</span><span class="br0">)</span></code>(C ++ 20)<code>true</code>.</div> <div class="t-li1">
<span class="t-li">Một động thái tương đương với một bản sao</span>                                   Nhị phân p);<span class="t-v">*(d_first + 2) = val2 - std :: di chuyển (acc);</span>Sử dụng<code>r</code>Mẫu &lt;class R, std :: copy_constructable f&gt;<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>first</code>Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>last</code>.</div> <p>         std :: indirect_binary_predicate &lt;ranges :: quare_to,<i>điều hòa sau)</i>Xóa tất cả các yếu tố thỏa mãn các tiêu chí cụ thể khỏi phạm vi<i>giá trị của các yếu tố để loại bỏ</i>Loại bỏ tất cả các yếu tố bằng<i>điều hòa sau)</i>             STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;, const t*&gt;<a href="../../named_req/moveassignable" title="cpp/named req/MoveAssignable">MoveAssignable</a>Range constexpr :: mượn_subrange_t &lt;r&gt;</p>
<p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>) Các phần tử trong phạm vi theo cách mà các yếu tố không được loại bỏ xuất hiện ở đầu phạm vi. Thứ tự tương đối của các yếu tố còn lại được bảo tồn và</td>
</tr> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>) Các phần tử trong phạm vi theo cách mà các yếu tố không được loại bỏ xuất hiện ở đầu phạm vi. Thứ tự tương đối của các yếu tố còn lại được bảo tồn và</td>
</tr> <tr class="t-par"> <td>được phân vùng liên quan đến</td> <td>-</td> <td>thuộc vật chất</td>
</tr> <tr class="t-par"> <td>Sao chép các yếu tố, nhưng được thực thi theo</td> <td>-</td> <td>Các thực thể giống như chức năng được mô tả trên trang này là</td>
</tr> <tr class="t-par"> <td>niebloids</td> <td>-</td> <td>, đó là:</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code>{ret, last}</code>là<code>[</code><code>first</code><code>, </code><code>ret</code><code>)</code>    loại bỏ (r &amp;&amp; r, const t &amp; value, proj proj = {});<code>[</code><code>ret</code><code>, </code><code>last</code><code>)</code>Mẫu &lt;std :: có thể thấm I, std :: sentinel_for &lt;i&gt; s, class proj = std :: identity,</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>không được phép<code>N</code>          std :: indirect_unary_predicate &lt;std :: dự kiến ​​&lt;i, proj &gt;&gt; pred&gt;<code>N <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3140">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>, Và<code>N - 1</code>Constexpr Phạm vi :: Subrange &lt;i&gt;</p>
<h3 id="Notes">Ghi chú</h3> <p>thuộc vật chất<code>ranges::remove</code>Kết thúc phạm vi vẫn còn<code>erase</code>, nhưng bản thân các yếu tố có các giá trị không xác định (theo<i>điều hòa sau)</i>phạm vi của các yếu tố để xử lý<i>giá trị của các yếu tố để loại bỏ</i>Nếu phần tử nên được loại bỏ.<a class="extiw" href="https://en.wikipedia.org/wiki/Erase-remove_idiom" title="enwiki:Erase-remove idiom">Erase-remove idiom</a>, sau đó nó chỉ ra một giá trị không xác định, và các trình lặp lại cho bất kỳ giá trị nào giữa trình lặp này và<code><a href="../../container/vector/erase2" title="cpp/container/vector/erase2">std::erase</a></code>Kích thước của container để phù hợp với nó mới<a href="../../container#Non-member_function_table" title="cpp/container">overloads</a>thường được theo sau bởi một cuộc gọi đến một container<i>hàm thành viên, xóa các giá trị không xác định và giảm</i>thuộc vật chất<code><a href="../../container/vector/erase2" title="cpp/container/vector/erase2">std::erase_if</a></code>Kích thước của container để phù hợp với nó mới<a href="../../container#Non-member_function_table" title="cpp/container">overloads</a>vì<i>Xem thêm việc triển khai</i>    remove_if (tôi đầu tiên, s cuối cùng, pred, proj proj = {});</p>
<p>kích cỡ. Hai lời mời này cùng nhau tạo thành một cái gọi là<a href="../../container#Member_function_table" title="cpp/container">member functions</a> <a href="../../container/list/remove" title="cpp/container/list/remove"><code>list::remove</code></a>Thì<a href="../../container/list/remove" title="cpp/container/list/remove"><code>list::remove_if</code></a>Thì<a href="../../container/forward_list/remove" title="cpp/container/forward list/remove"><code>forward_list::remove</code></a>, Và<a href="../../container/forward_list/remove" title="cpp/container/forward list/remove"><code>forward_list::remove_if</code></a>Xóa bỏ</p>
<p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<code><a href="../../container/set" title="cpp/container/set">std::set</a></code>Và<code><a href="../../container/map" title="cpp/container/map">std::map</a></code>Điều đó có<a href="../../named_req/moveassignable" title="cpp/named req/MoveAssignable">MoveAssignable</a>Đối với tất cả các tiêu chuẩn</p>
<p>container tiêu chuẩn<code>ranges::remove</code>Các thùng chứa có tên tương tự<code>value</code>Xóa các yếu tố bị loại bỏ.<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>.</p>
<h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <th>
<a href="#Version_1">remove</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">          std :: Indirect_unary_predicate &lt;</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_3">remove_if</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Yêu cầu std :: Thấy &lt;phạm vi :: iterator_t &lt;r &gt;&gt;</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">Range constexpr :: mượn_subrange_t &lt;r&gt;</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="remove_copy" title="cpp/algorithm/ranges/remove copy"> <span class="t-lines"><span>(Mẫu chức năng)</span><span>Phạm vi :: remove_copy</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unique" title="cpp/algorithm/ranges/unique"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../remove" title="cpp/algorithm/remove"> <span class="t-lines"><span>Được xác định trong tiêu đề</span><span>di dời</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/remove">https://en.cppreference.com/w/cpp/algorithm/ranges/remove</a>
</p>
</div>
