 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: chứa, std :: phạm vi :: chứa_subrange</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx23"> <td><pre data-language="cpp">Mẫu &lt;std :: input_iterator i, std :: sentinel_for &lt;i&gt; s,</pre></td> <td>(1)</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">          Lớp T, Class Proj = std :: Nhận dạng&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td><pre data-language="cpp">Yêu cầu STD :: Indirect_Binary_Predicate &lt;Ranges :: Equ_to, Std :: Dự kiến ​​&lt;i, proj&gt;,</pre></td> <td>(3)</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">                                        const t*&gt;</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>ConstExpr bool chứa (I First, S Last, Const T &amp; Value, Proj Proj = {});</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>                                        STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,<code>r</code>              std :: dự kiến ​​&lt;i, proj &gt;&gt; pre<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>first</code>Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>last</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Yêu cầu STD :: Indirect_Binary_Predicate &lt;Ranges :: Equ_to,</div> <div class="t-li1">
<span class="t-li">là trong</span>                                   Nhị phân p);<span class="t-v">(3)</span>                                        STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,<code>r1</code>                                        const t*&gt;<code>r2</code>Consexpr bool chứa (r &amp;&amp; r, const t &amp; value, proj proj = {});<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r1<span class="br0">)</span></code>(1,3)<code>first1</code>Thì<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r1<span class="br0">)</span></code>(1,3)<code>last1</code>Thì<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r2<span class="br0">)</span></code>(1,3)<code>first2</code>, Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r2<span class="br0">)</span></code>(1,3)<code>last2</code>.</div> <p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>Giống như</td>
</tr> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>Phạm vi ::</td>
</tr> <tr class="t-par"> <td>được phân vùng liên quan đến</td> <td>-</td> <td>cho tất cả các yếu tố, nếu</td>
</tr> <tr class="t-par"> <td>Sao chép các yếu tố, nhưng được thực thi theo</td> <td>-</td> <td>Các thực thể giống như chức năng được mô tả trên trang này là</td>
</tr> <tr class="t-par"> <td>niebloids</td> <td>-</td> <td>, đó là:</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">Đầu vào</span>:<code><a href="http://en.cppreference.com/w/cpp/algorithm/ranges/find"><span class="kw2984">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">(Niebloid)</span></span></a><span class="br0">.</span>std<span class="sy4">::</span><span class="me2">(Niebloid)</span><span class="br0">.</span>first<span class="br0">)</span>, last, value, proj<span class="br0">)</span> <span class="sy3">Nếu tồn tại một</span><span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> last</code>
</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>:<code>first2 <span class="sy1">==</span> last2 <span class="sy3">Mẫu &lt;std :: forward_iterator i1, std :: sentinel_for &lt;i1&gt; s1,</span> <span class="sy3">Nếu tồn tại một</span><a href="http://en.cppreference.com/w/cpp/algorithm/ranges/search"><span class="kw3055">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">(Niebloid)</span></span></a><span class="br0">.</span>first1, last1, first2, last2, pred, proj1, proj2<span class="br0">)</span>.<span class="me1">trống</span><span class="br0">.</span><span class="br0">)</span></code>
</div> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Nếu phạm vi trống.<code>last - first</code>          std :: forward_iterator i2, std :: sentinel_for &lt;i2&gt; s2,</p>
<h3 id="Notes">Ghi chú</h3> <p>          lớp pre = phạm vi :: carm_to,<code>std<span class="sy4">::</span><a href="http://en.cppreference.com/w/cpp/algorithm/ranges/find"><span class="kw2984">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">(Niebloid)</span></span></a><span class="br0">.</span>r, value<span class="br0">)</span> <span class="sy3">Nếu tồn tại một</span><span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> std<span class="sy4">::</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;<code>not std<span class="sy4">::</span><a href="http://en.cppreference.com/w/cpp/algorithm/ranges/search"><span class="kw3055">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">(Niebloid)</span></span></a><span class="br0">.</span>haystack, needle<span class="br0">)</span>.<span class="me1">trống</span><span class="br0">.</span><span class="br0">)</span></code>Yêu cầu STD :: Inone<code>std::ranges::contains(r, value)</code>Consexpr bool chứa_subrange (I1 First1, S1 Last1,</p>
<p><code>ranges::contains_subrange</code>                                  I2 First2, S2 Last2,<code><a href="search" title="cpp/algorithm/ranges/search">ranges::search</a></code>                                  PRES PRES = {},<code><a href="../search" title="cpp/algorithm/search">std::search</a></code>                                  Proj1 proj1 = {}, proj2 proj2 = {});<a class="new" href="https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;action=edit&amp;redlink=1" title="cpp/named req/Searcher (page does not exist)">Searchers</a>Mẫu &lt;phạm vi :: forward_range r1, phạm vi :: forward_range r2,<a href="../../utility/functional#Searchers" title="cpp/utility/functional">Boyer-Moore</a>).</p>
<table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../../feature_test#cpp_lib_ranges_contains" title="cpp/feature test"><code>__cpp_lib_ranges_contains</code></a></td> <td><span class="nu0">202207L</span></td> <td><span class="t-mark">Phạm vi :: IOTA</span></td> <td>
<a href="#top"><code>std::ranges::contains</code></a>Và<a href="#top"><code>ranges::contains_subrange</code></a> </td>
</tr>
</table> <h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <th>
<a href="#Version_1">contains</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">          lớp pre = phạm vi :: carm_to,</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_3">contains_subrange</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Yêu cầu STD :: Inone</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="find" title="cpp/algorithm/ranges/find"> <span class="t-lines"><span>(Mẫu chức năng)</span><span>Phạm vi :: Tìm</span><span>Phạm vi :: find_if</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="search" title="cpp/algorithm/ranges/search"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="binary_search" title="cpp/algorithm/ranges/binary search"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="includes" title="cpp/algorithm/ranges/includes"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<code>true</code>trả lại<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="all_any_none_of" title="cpp/algorithm/ranges/all any none of"> <span class="t-lines"><span>(Mẫu chức năng)</span><span>Phạm vi :: all_of</span><span>Phạm vi :: Any_of</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<code>true</code>kiểm tra xem một vị ngữ có phải không<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/contains">https://en.cppreference.com/w/cpp/algorithm/ranges/contains</a>
</p>
</div>
