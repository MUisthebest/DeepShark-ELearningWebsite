 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: end_with</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">Mẫu &lt;std :: input_iterator i1, std :: sentinel_for &lt;i1&gt; s1,</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">          std :: input_iterator i2, std :: sentinel_for &lt;i2&gt; s2,</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> </table> <p>          lớp pre = phạm vi :: carm_to,</p>
<div class="t-li1">
<span class="t-li">1)</span>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;<code>N1</code>Và<code>N2</code>{<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3142">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first1, last1<span class="br0">)</span></code>Và<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3142">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first2, last2<span class="br0">)</span></code>Yêu cầu (STD :: Forward_Iterator &lt;I1&gt; |<code>N1 &lt; N2</code>; Nếu không nếu<code>false</code>để định vị<code>true</code>         (std :: forward_iterator &lt;I2&gt; |<code>[</code><code>first2</code><code>, </code><code>last2</code><code>)</code>         std :: gián tiếp_comparable &lt;i1, i2, prej1, proj2&gt;<code>[</code><code>first1 + N1 - N2</code><code>, </code><code>last1</code><code>)</code>Consexpr bool ends_with (I1 First1, S1 Last1, I2 First2, S2 Last2, Pred = {},<code>pred</code>                          Proj1 proj1 = {}, proj2 proj2 = {});<code>proj1</code>Và<code>proj2</code>tương ứng.</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>Sử dụng<code>r1</code>Và<code>r2</code>Mẫu &lt;phạm vi :: input_range r1, phạm vi :: input_range r2,<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r1<span class="br0">)</span></code>(1,3)<code>first1</code>Thì<code>ranges:begin(r2)</code>(1,3)<code>first2</code>Thì<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r1<span class="br0">)</span></code>(1,3)<code>last1</code>, Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r2<span class="br0">)</span></code>(1,3)<code>last2</code>.</div> <p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Mẫu &lt;class execPolicy, class forwardit1, class forwardit2&gt;</td> <td>-</td> <td>Giống như</td>
</tr> <tr class="t-par"> <td>          lớp pre = phạm vi :: carm_to,</td> <td>-</td> <td>Giống như</td>
</tr> <tr class="t-par"> <td>            Forwardit1 first1, forwardit1 last1,</td> <td>-</td> <td>         (phạm vi :: forward_range &lt;r2&gt; |</td>
</tr> <tr class="t-par"> <td>Yêu cầu (phạm vi :: forward_range &lt;r1&gt; |</td> <td>-</td> <td>         (phạm vi :: forward_range &lt;r2&gt; |</td>
</tr> <tr class="t-par"> <td>Sao chép các yếu tố, nhưng được thực thi theo</td> <td>-</td> <td>         std :: gián tiếp_comparable &lt;phạm vi :: iterator_t &lt;r1&gt;,</td>
</tr> <tr class="t-par"> <td>                                    Phạm vi :: iterator_t &lt;r2&gt;,</td> <td>-</td> <td>                                    Pred, Proj1, Proj2&gt;</td>
</tr> <tr class="t-par"> <td>constexpr bool ends_with (r1 &amp;&amp; r1, r2 &amp;&amp; r2, pred = {},</td> <td>-</td> <td>                          Proj1 proj1 = {}, proj2 proj2 = {});</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code>true</code>Kiểm tra xem phạm vi thứ hai có khớp với hậu tố của phạm vi thứ nhất hay không.<code>false</code>Nếu đối số đầu tiên là</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Cho phép<code>min(N1, N2)</code>tương ứng. Nếu như<code>N1 &lt; N2</code>.</p>
<p>Nếu chỉ khi mọi yếu tố trong phạm vi<code>N1</code>Và<code>N2</code>bằng với phần tử tương ứng trong<a href="../../iterator/sized_sentinel_for" title="cpp/iterator/sized sentinel for"><code>sized_sentinel_for</code></a>. So sánh được thực hiện bằng cách áp dụng vị ngữ nhị phân<a href="../../ranges/sized_range" title="cpp/ranges/sized range"><code>sized_range</code></a>) Và<code>N1 &lt; N2</code>đến các yếu tố trong hai phạm vi được dự kiến ​​bởi</p>
<h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Như nguồn gốc, như thể đang sử dụng</pre></div> </td>
</tr>
</table> <h3 id="Notes">Ghi chú</h3> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../../feature_test#cpp_lib_ranges_starts_ends_with" title="cpp/feature test"><code>__cpp_lib_ranges_starts_ends_with</code></a></td> <td><span class="nu0">Chỉ giải thích*</span></td> <td><span class="t-mark">Phạm vi :: IOTA</span></td> <td>
<code>std::ranges::starts_with</code>Thì<code>std::ranges::ends_with</code> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">R1</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">phạm vi của các yếu tố được sử dụng làm hậu tố</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="starts_with" title="cpp/algorithm/ranges/starts with"> <span class="t-lines"><span>(Niebloid)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td>(C ++ 23)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../string/basic_string/ends_with" title="cpp/string/basic string/ends with"> <span class="t-lines"><span>vị từ nhị phân so sánh các yếu tố dự kiến</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>phạm vi của các yếu tố được sử dụng làm hậu tố<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::basic_string&lt;CharT,Traits,Allocator&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../string/basic_string_view/ends_with" title="cpp/string/basic string view/ends with"> <span class="t-lines"><span>vị từ nhị phân so sánh các yếu tố dự kiến</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>proj1<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::basic_string_view&lt;CharT,Traits&gt;</code>)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/ends_with">https://en.cppreference.com/w/cpp/algorithm/ranges/ends_with</a>
</p>
</div>
