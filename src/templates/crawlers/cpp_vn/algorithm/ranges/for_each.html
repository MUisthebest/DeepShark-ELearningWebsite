 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: for_each, std :: phạm vi :: for_each_result</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;std :: input_iterator I, std :: sentinel_for &lt;i&gt; s, class proj = std :: nhận dạng,</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          STD :: Inone</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-h"> <td>Mẫu &lt;phạm vi :: input_range r, std :: meally_incrementable o&gt;</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">ConstExpr for_each_result &lt;i, Fun&gt;</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>void for_each (execPolicy &amp;&amp; chính sách,<code>f</code>    for_each (tôi đầu tiên, s cuối cùng, vui vẻ f, proj proj = {});<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Mẫu &lt;class execPolicy, class forwardit, lớp unanyfunction2&gt;</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>Sử dụng<code>r</code>              std :: dự kiến ​​&lt;i, proj &gt;&gt; pre<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>first</code>Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>last</code>.</div> <p>ConstExpr inputit for_each_n (đầu vào đầu tiên, kích thước n, không có chức năng f);<code>f</code>Áp dụng đối tượng chức năng đã cho<code>f</code>kết quả của việc phá hủy mọi trình lặp trong phạm vi</p>
<p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>Mẫu &lt;phạm vi :: input_range r, class proj = std :: nhận dạng,</td>
</tr> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>          std :: gián tiếp_unary_invocable &lt;</td>
</tr> <tr class="t-par"> <td>có thể sửa đổi các phần tử của phạm vi thông qua trình lặp được thu hút. Nếu như</td> <td>-</td> <td>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; vui vẻ&gt;</td>
</tr> <tr class="t-par"> <td>niebloids</td> <td>-</td> <td>, đó là:</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code><span class="br0">danh tính</span>std<span class="sy4">::</span><a href="http://en.cppreference.com/w/cpp/iterator/ranges/next"><span class="kw3141">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Kế tiếp</span></span></a><span class="br0">.</span>std<span class="sy4">::</span><span class="me2">(Niebloid)</span><span class="br0">.</span>first<span class="br0">)</span>, last<span class="br0">)</span>, std<span class="sy4">::</span><span class="me2">(Niebloid)</span><span class="br0">.</span>f<span class="br0">)</span><span class="br0">{</span></code></p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>không được phép<code>last - first</code>Ứng dụng của<code>f</code>Và<code>proj</code>.</p>
<h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Consexpr for_each_result &lt;phạm vi :: mượn_iterator_t &lt;r&gt;, fun&gt;</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example">
<p>f<a href="../../language/lambda" title="cpp/language/lambda">lambda expression</a>đối tượng chức năng, được áp dụng cho kết quả của việc phá hủy mọi trình lặp trong phạm vi<code>operator()</code>    for_each (r &amp;&amp; r, fun f, proj proj = {});<code><a href="../accumulate" title="cpp/algorithm/accumulate">std::accumulate</a></code>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">Mẫu &lt;Class I, Class F&gt;</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">sử dụng for_each_result = phạm vi :: in_fun_result &lt;i, f&gt;;</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <a href="../../language/range-for" title="cpp/language/range-for"> range-<code>for</code> loop</a><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span> </td> <td>}</td>
</tr> <tr class="t-dsc"> <td> <div><a href="transform" title="cpp/algorithm/ranges/transform"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="for_each_n" title="cpp/algorithm/ranges/for each n"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../for_each" title="cpp/algorithm/for each"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/for_each">https://en.cppreference.com/w/cpp/algorithm/ranges/for_each</a>
</p>
</div>
