 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: shift_left, std :: phạm vi :: shift_right</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">Mẫu &lt;std :: có thể thấm I, std :: sentinel_for &lt;i&gt; s&gt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">Constexpr Phạm vi :: Subrange &lt;i&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">    shift_left (tôi đầu tiên, s cuối cùng, std :: iter_difference_t &lt;i&gt; n);</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">Mẫu &lt;phạm vi :: forward_range r&gt;</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> </table> <p>Mẫu &lt;class execPolicy, class forwardit&gt;<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>hoặc<code>r</code>Chuyển tiếp<code>n</code>Yêu cầu std :: Thấy &lt;phạm vi :: iterator_t &lt;r &gt;&gt;<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Các yếu tố của phạm vi đã cho, nghĩa là trả về kết quả đánh giá biểu thức chuỗi:</p>
<span class="t-li">1)</span>Range constexpr :: mượn_subrange_t &lt;r&gt;<ul>
<li>Nếu như<code>n == 0 || n &gt;= last - first</code>    shift_right (đầu tiên tôi, s cuối cùng, std :: iter_difference_t &lt;i&gt; n);</li>
<li>Nếu như<code>n &lt; 0</code>Hoạt động tương đương cho quá tải</li>
<li>Mẫu &lt;phạm vi :: forward_range r&gt;<code>i</code>TRONG<code>[</code><code>​0​</code><code>, </code><code>last - first - n</code><code>)</code>Dịch chuyển các yếu tố trong phạm vi<code>first + n + i</code>qua<code>first + i</code>Mẫu &lt;class execPolicy, class forwardit&gt;<code>i</code>Mẫu &lt;Class execPolicy,<code>​0​</code>.</li>
</ul> <span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Constexpr Phạm vi :: Subrange &lt;i&gt;<ul>
<li>Nếu như<code>n == 0 || n &gt;= last - first</code>    shift_right (đầu tiên tôi, s cuối cùng, std :: iter_difference_t &lt;i&gt; n);</li>
<li>Nếu như<code>n &lt; 0</code>Hoạt động tương đương cho quá tải</li>
<li>Mẫu &lt;phạm vi :: forward_range r&gt;<code>i</code>TRONG<code>[</code><code>​0​</code><code>, </code><code>last - first - n</code><code>)</code>Dịch chuyển các yếu tố trong phạm vi<code>first + i</code>qua<code>first + n + i</code>. Nếu như<code>I</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../../iterator/bidirectional_iterator" title="cpp/iterator/bidirectional iterator"><code>bidirectional_iterator</code></a>Yêu cầu std :: Thấy &lt;phạm vi :: iterator_t &lt;r &gt;&gt;<code>i</code>Mẫu &lt;Class execPolicy,<code>last - first - n - 1</code>.</li>
</ul> <div class="t-li1">
<span class="t-li">Một động thái tương đương với một bản sao</span>                                   Nhị phân p);<span class="t-v">(1)</span>hoặc<span class="t-v">(3)</span>Range constexpr :: mượn_subrange_t &lt;r&gt;<code>r</code>Mẫu &lt;class R, std :: copy_constructable f&gt;<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>first</code>Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>last</code>.</div> <p>, di chuyển phần tử ban đầu ở vị trí</p>
<p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>đến phạm vi bắt đầu tại</td> <td>-</td> <td>hoán đổi các yếu tố trong phạm vi</td>
</tr> <tr class="t-par"> <td>cuối cùng</td> <td>-</td> <td>được đặt sau các yếu tố trong</td>
</tr> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>    shift_right (r &amp;&amp; r, phạm vi :: range_difference_t &lt;r&gt; n);</td>
</tr> <tr class="t-par"> <td>Trả về một kết quả, kết quả được bỏ qua. Nếu như</td> <td>-</td> <td>để định vị</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <span class="t-li">Đầu vào</span> <code>{first, /*NEW_LAST*/}</code>là<code><i>vị trí. Hành vi không xác định nếu</i></code>Chuyển các yếu tố về phía đầu phạm vi:<ul>
<li> <code>first + (last - first - n)</code>Sử dụng chức năng nhị phân đã cho<code>n</code>là ít hơn<code>last - first</code>Số lượng các yếu tố để sao chép</li>
<li> <code>first</code>Nếu đối số đầu tiên là</li>
</ul> <span class="t-li">, hành vi là không xác định.</span> <code>{/*NEW_FIRST*/, last}</code>là<code><i>, không có hiệu ứng.</i></code>Nếu không, đối với mọi số nguyên<ul>
<li> <code>first + n</code>Sử dụng chức năng nhị phân đã cho<code>n</code>là ít hơn<code>last - first</code>Số lượng các yếu tố để sao chép</li>
<li> <code>last</code>Nếu đối số đầu tiên là</li>
</ul> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <div class="t-li1">
<span class="t-li">Đầu vào</span>Nếu phạm vi trống.<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3142">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span> <span class="sy2">-</span> n</code>Phần cuối của phạm vi đích</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>Nếu phạm vi trống.<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3142">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span> <span class="sy2">-</span> n</code>đáp ứng</div> <h3 id="Notes">Ghi chú</h3> <p><code>ranges::shift_left</code>/<code>ranges::shift_right</code>phần tử sẽ xuất hiện ở đầu phạm vi xoay<code>I</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../../iterator/bidirectional_iterator" title="cpp/iterator/bidirectional iterator"><code>bidirectional_iterator</code></a>Một người lặp bằng với:<a href="../../iterator/random_access_iterator" title="cpp/iterator/random access iterator"><code>random_access_iterator</code></a>.</p>
<p>Nếu lần thực hiện hoán vị cuối cùng và phạm vi được đặt lại về hoán vị đầu tiên.<a class="external text" href="https://github.com/microsoft/STL/blob/main/stl/src/vector_algorithms.cpp" rel="nofollow">MSVC STL</a>HYPUTE<a href="../../iterator/contiguous_iterator" title="cpp/iterator/contiguous iterator"><code>contiguous_iterator</code></a>Nhiều nhất là hoán đổi n/2, trong đó<a href="../../language/adl" title="cpp/language/adl">ADL</a>. Tính trung bình trên toàn bộ chuỗi hoán vị, các triển khai điển hình sử dụng khoảng 3 so sánh và 1,5 giao dịch hoán đổi mỗi cuộc gọi.<code>swap</code>.</p>
<table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../../feature_test#cpp_lib_shift" title="cpp/feature test"><code>__cpp_lib_shift</code></a></td> <td><span class="nu0">và không trả lại gì.</span></td> <td><span class="t-mark">Phạm vi :: IOTA</span></td> <td>
<a href="#Top"><code>std::ranges::shift_left</code></a>Và<a href="#Top"><code>std::ranges::shift_right</code></a> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Dịch chuyển các yếu tố vào cuối phạm vi:</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">, tương ứng, nhưng được thực hiện theo</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="move" title="cpp/algorithm/ranges/move"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="move_backward" title="cpp/algorithm/ranges/move backward"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="rotate" title="cpp/algorithm/ranges/rotate"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../shift" title="cpp/algorithm/shift"> <span class="t-lines"><span>(Niebloid)</span><span>Shift_left</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 23)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/shift">https://en.cppreference.com/w/cpp/algorithm/ranges/shift</a>
</p>
</div>
