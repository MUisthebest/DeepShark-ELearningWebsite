 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: độc đáo_copy, std :: phạm vi :: độc đáo_copy_result</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;std :: input_iterator I, std :: sentinel_for &lt;i&gt; s, std :: meally_incrementable o,</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          lớp proj = std :: danh tính,</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-h"> <td>Mẫu &lt;phạm vi :: input_range r, std :: meally_incrementable o&gt;</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          STD :: Indirect_equilationence_relation &lt;std :: dự kiến ​​&lt;i, proj &gt;&gt; c = ranges :: arem_to&gt;</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>    thay thế_copy (đầu tiên tôi, s cuối cùng, o kết quả, const t1 &amp; old_value, const t2 &amp; new_value,<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Mẫu &lt;phạm vi :: input_range r, std :: meally_incrementable o, class T,<code>result</code>                        Forwardit1 cuối cùng, forwardit2 d_first);</div> <div class="t-li1">Mẫu &lt;phạm vi :: input_range r1, phạm vi :: input_range r2&gt;<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Và<code>[</code><code>result</code><code>, </code><code>result + N</code><code>)</code>Yêu cầu std :: Inonectly_swappable &lt;Ranges :: iterator_t &lt;r1&gt;, phạm vi :: iterator_t &lt;r2 &gt;&gt;<code>N <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3140">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>.</div> <div class="t-li1">              C = phạm vi :: Equ_to&gt;<code>*(i - 1)</code>Và<code>*i</code>Constexpr Phạm vi :: Subrange &lt;i&gt;<code><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>comp, <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>proj, <span class="sy2">*</span><span class="br0">.</span>i <span class="sy2">-</span> <span class="nu0">, nếu như</span><span class="br0">)</span><span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>proj, <span class="sy2">*</span>i<span class="br0">)</span><span class="br0">)</span> <span class="sy1">==</span> <span class="kw2">ĐÚNG VẬY</span></code>là<code>i</code>    duy nhất (đầu tiên tôi, s cuối cùng, c comp = {}, proj proj = {});<code>[</code><code>first + 1</code><code>, </code><code>last</code><code>)</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>Sử dụng<code>r</code>Mẫu &lt;class R, std :: copy_constructable f&gt;<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>first</code>, Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>last</code>.</div> <p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>             STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;, const t*&gt;</td>
</tr> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>             STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;, const t*&gt;</td>
</tr> <tr class="t-par"> <td>. Sự chồng chéo của phạm vi được chính thức được phép, nhưng dẫn đến thứ tự không thể đoán trước của kết quả.</td> <td>-</td> <td>Yêu cầu std :: Inonectly_copyable &lt;i, o&gt; &amp;&amp; (std :: forward_iterator &lt;i&gt; ||</td>
</tr> <tr class="t-par"> <td>sau đó</td> <td>-</td> <td>Mẫu &lt;std :: input_iterator i, std :: sentinel_for &lt;i&gt; s,</td>
</tr> <tr class="t-par"> <td>niebloids</td> <td>-</td> <td>          STD :: yếu_incrementable o, class proj = std :: nhận dạng,</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code>{last, result + N}</code></p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>không được phép<code>N - 1</code>          std :: indirect_unary_predicate &lt;std :: dự kiến ​​&lt;iterator_t &lt;r&gt;, proj &gt;&gt; pred&gt; pre<code>comp</code>             .<code>proj</code>.</p>
<h3 id="Possible_implementation">. ​</h3> <p>được tìm thấy,<a class="external text" href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/ranges_algo.h#L1198-L1276" rel="nofollow">libstdc++</a>Và<a class="external text" href="https://github.com/microsoft/STL/blob/472161105d596192194d4715ccad307c6c163b4a/stl/inc/algorithm#L4022-L4113" rel="nofollow">MSVC STL</a>                 std :: iter_value_t &lt;o &gt;&gt;) || STD :: gián tiếp_copyable_stable &lt;i, o&gt;)<a class="external text" href="https://github.com/CaseyCarter/cmcstl2/blob/master/include/stl2/detail/algorithm/unique_copy.hpp" rel="nofollow">cmcstl2</a>Thì<a class="external text" href="https://github.com/tcbrindle/NanoRange/blob/master/include/nanorange/algorithm/unique_copy.hpp" rel="nofollow">NanoRange</a>, Và<a class="external text" href="https://github.com/ericniebler/range-v3/blob/master/include/range/v3/algorithm/unique_copy.hpp" rel="nofollow">range-v3</a>).</p>
<table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Constexpr độc đáo_copy_result &lt;i, o&gt;</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">    độc đáo_copy (đầu tiên tôi, s cuối cùng, o kết quả, c comp = {}, proj proj = {});</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Mẫu &lt;phạm vi :: input_range r, std :: meally_incrementable o, class proj = std :: nhận dạng,</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="unique" title="cpp/algorithm/ranges/unique"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="copy" title="cpp/algorithm/ranges/copy"> <span class="t-lines"><span>(Mẫu chức năng)</span><span>Phạm vi :: Sao chép</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="adjacent_find" title="cpp/algorithm/ranges/adjacent find"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../unique_copy" title="cpp/algorithm/unique copy"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/unique_copy">https://en.cppreference.com/w/cpp/algorithm/ranges/unique_copy</a>
</p>
</div>
