 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: next_permuting, std :: phạm vi :: next_permuting_result</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;std :: bidIrectional_iterator i, std :: sentinel_for &lt;i&gt; s,</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          Lớp comp = phạm vi :: Ít hơn, lớp proj = std :: nhận dạng&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-h"> <td>Yêu cầu std :: gián tiếp_copyable &lt;i, o&gt;</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Yêu cầu STD :: Sắp xếp &lt;i, comp, proj&gt;</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Mẫu &lt;lớp bidirit, so sánh lớp&gt;<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>          bool next_permuting (bidirit đầu tiên, bidirit cuối cùng, so sánh comp);<a class="extiw" href="https://en.wikipedia.org/wiki/permutation" title="enwiki:permutation">permutation</a>ConstExPR next_permuting_result &lt;i&gt;<i>    next_permuting (đầu tiên tôi, s cuối cùng, comp comp = {}, proj proj = {});</i>Mẫu &lt;phạm vi :: bid -<code>comp</code>          lớp proj = std :: danh tính&gt;<code>proj</code>Consexpr bool next_permuting (bidirit đầu tiên, bidirit cuối cùng, so sánh comp);<code>{last, true}</code>Yêu cầu STD :: Sắp xếp &lt;Ranges :: iterator_t &lt;r&gt;, comp, proj&gt;<i>Consexpr next_permuting_result &lt;phạm vi :: mượn_iterator_t &lt;r&gt;&gt;</i>    next_permuting (r &amp;&amp; r, comp comp = {}, proj proj = {});<code><a href="http://en.cppreference.com/w/cpp/ranges-algorithm-placeholder/sort"><span class="kw2852">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Được xác định trong tiêu đề</span></span></a><span class="br0">.</span>first, last, comp, proj<span class="br0">)</span></code>Mẫu &lt;Class I&gt;<code>{last, false}</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>Sử dụng<code>r</code>              std :: dự kiến ​​&lt;i, proj &gt;&gt; pre<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>first</code>, Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>last</code>.</div> <p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>từ vựng<i>liên quan đến đối tượng chức năng so sánh nhị phân</i> </td>
</tr> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>từ vựng<i>liên quan đến đối tượng chức năng so sánh nhị phân</i> </td>
</tr> <tr class="t-par"> <td>sau đó</td> <td>-</td> <td>và đối tượng chức năng chiếu<code>true</code>cũng là<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>Nếu như vậy</td>
</tr> <tr class="t-par"> <td>niebloids</td> <td>-</td> <td>, đó là:</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">1)</span> <code>ranges::next_permutation_result&lt;I&gt;{last, true}</code>"Next Permtution"<i>Trả một trình lặp lại cho phần tử đầu tiên</i>tồn tại; nếu không thì biến phạm vi thành hoán vị đầu tiên về mặt từ vựng như thể bằng cách<code>ranges::next_permutation_result&lt;I&gt;{last, false}</code>) và trả lại</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>Mẫu lớp trợ giúp<code>ranges<span class="sy4">::</span><span class="me2">, và trở lại</span><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/ranges/borrowed_iterator_t"><span class="kw2855">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">        sử dụng u = std :: decay_t &lt;std :: indoke_result_t &lt;f &amp;, t, std :: iter_reference_t &lt;i &gt;&gt;&gt;;</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">2,4)</span></code>.</div> <h3 id="Exceptions">Ngoại lệ</h3> <p>phạm vi của các yếu tố để hoán vị</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>phạm vi của các yếu tố để<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3140">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>phạm vi của các yếu tố để<span class="t-v">(1)</span>hoặc<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3140">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>phạm vi của các yếu tố để<span class="t-v">(2)</span>Nếu hoán vị mới là từ vựng lớn hơn so với cũ.</p>
<h3 id="Notes">Ghi chú</h3> <p>Nếu lần thực hiện hoán vị cuối cùng và phạm vi được đặt lại về hoán vị đầu tiên.<a class="external text" href="https://github.com/microsoft/STL/blob/main/stl/src/vector_algorithms.cpp" rel="nofollow">MSVC STL</a>HYPUTE<a href="../../iterator/contiguous_iterator" title="cpp/iterator/contiguous iterator"><code>contiguous_iterator</code></a>Nhiều nhất là hoán đổi n/2, trong đó<a href="../../language/adl" title="cpp/language/adl">ADL</a>. Tính trung bình trên toàn bộ chuỗi hoán vị, các triển khai điển hình sử dụng khoảng 3 so sánh và 1,5 giao dịch hoán đổi mỗi cuộc gọi.<code>swap</code>.</p>
<h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">đối tượng chức năng so sánh trả về</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">hơn thứ hai</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Nếu hoán vị mới là từ vựng</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="prev_permutation" title="cpp/algorithm/ranges/prev permutation"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="is_permutation" title="cpp/algorithm/ranges/is permutation"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../next_permutation" title="cpp/algorithm/next permutation"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../prev_permutation" title="cpp/algorithm/prev permutation"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../is_permutation" title="cpp/algorithm/is permutation"> <span class="t-lines"><span>(Niebloid)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/next_permutation">https://en.cppreference.com/w/cpp/algorithm/ranges/next_permutation</a>
</p>
</div>
