 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: bằng</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;std :: input_iterator i1, std :: sentinel_for &lt;i1&gt; s1,</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          std :: input_iterator i2, std :: sentinel_for &lt;i2&gt; s2,</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Mẫu &lt;Class execPolicy,<code>true</code>          lớp pre = phạm vi :: carm_to,<code>[</code><code>first1</code><code>, </code><code>last1</code><code>)</code>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;<code>[</code><code>first2</code><code>, </code><code>last2</code><code>)</code>, Và<code>false</code>Nếu đối số đầu tiên là</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>Sử dụng<code>r</code>              std :: dự kiến ​​&lt;i, proj &gt;&gt; pre<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>first</code>Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>last</code>.</div> <p>Yêu cầu STD :: Inone<code>pred</code>consexpr bool bằng (I1 First1, S1 Last1, I2 First2, S2 Last2,<code><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>pred, <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>proj1, <span class="sy2">*</span>first1<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>proj2, <span class="sy2">*</span>first2<span class="br0">)</span><span class="br0">)</span></code>(C ++ 20)<code>true</code>                      PROD PRED = {}, proj1 proj1 = {}, proj2 proj2 = {});</p>
<p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Mẫu &lt;class execPolicy, class forwardit1, class forwardit2&gt;</td> <td>-</td> <td>Mẫu &lt;phạm vi :: input_range r1, phạm vi :: input_range r2,</td>
</tr> <tr class="t-par"> <td>          lớp pre = phạm vi :: carm_to,</td> <td>-</td> <td>Bool Equal (Chính sách thực thi &amp;&amp; chính sách,</td>
</tr> <tr class="t-par"> <td>            Forwardit1 first1, forwardit1 last1,</td> <td>-</td> <td>          lớp pre = phạm vi :: carm_to,</td>
</tr> <tr class="t-par"> <td>Yêu cầu (phạm vi :: forward_range &lt;r1&gt; |</td> <td>-</td> <td>            Forwardit2 first2, forwardit2 last2);</td>
</tr> <tr class="t-par"> <td>Sao chép các yếu tố, nhưng được thực thi theo</td> <td>-</td> <td>Các thực thể giống như chức năng được mô tả trên trang này là</td>
</tr> <tr class="t-par"> <td>                                    Phạm vi :: iterator_t &lt;r2&gt;,</td> <td>-</td> <td>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;</td>
</tr> <tr class="t-par"> <td>constexpr bool ends_with (r1 &amp;&amp; r1, r2 &amp;&amp; r2, pred = {},</td> <td>-</td> <td>Yêu cầu STD :: Inone</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>bool bằng (đầu vào đầu tiên1, đầu vào1, last1,<code>[</code><code>first1</code><code>, </code><code>last1</code><code>)</code>            Đầu vào đầu tiên2 đầu tiên, inputit2 last2,<code>[</code><code>first2</code><code>, </code><code>last2</code><code>)</code>; Nếu không nếu<code>false</code>.</p>
<p>                                    Pred, Proj1, Proj2&gt;<code>true</code>.</p>
<p>Mẫu &lt;class inputit1, class inputIt2, class BinaryPredicate&gt;<code>false</code>.</p>
<h3 id="Notes">Ghi chú</h3> <p><code>ranges::equal</code>constexpr bool bằng (đầu vào đầu tiên1 đầu tiên, đầu vào<code><a href="../../container/unordered_set" title="cpp/container/unordered set">std::unordered_set</a></code>Thì<code><a href="../../container/unordered_multiset" title="cpp/container/unordered multiset">std::unordered_multiset</a></code>Thì<code><a href="../../container/unordered_map" title="cpp/container/unordered map">std::unordered_map</a></code>, hoặc<code><a href="../../container/unordered_multimap" title="cpp/container/unordered multimap">std::unordered_multimap</a></code>                      Đầu vào đầu tiên2 đầu tiên, inputit2 last2,</p>
<p>                      Nhị phân p);<code>operator==</code>Mẫu &lt;Class execPolicy,</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Nếu phạm vi trống.<code>min(last1 - first1, last2 - first2)</code>constexpr bool bằng (r1 &amp;&amp; r1, r2 &amp;&amp; r2, pred = {},</p>
<p>            Forwardit2 first2, forwardit2 last2,<code>S1</code>Và<code>S2</code>                      Proj1 proj1 = {}, proj2 proj2 = {});<code><a href="../../iterator/sized_sentinel_for" title="cpp/iterator/sized sentinel for">std::sized_sentinel_for</a></code>Nếu các giá trị dự kiến ​​của phạm vi<code>last1 - first1 != last2 - first2</code>(8)</p>
<h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">bằng với các giá trị dự kiến ​​của phạm vi</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example">
<p>Trong thực tế, việc triển khai<code>ranges::equal</code>Trả lại</p>
<div class="cpp source-cpp"><pre data-language="cpp">Hai phạm vi được coi là bằng nhau nếu chúng có cùng một số phần tử và mỗi cặp các yếu tố dự kiến ​​tương ứng thỏa mãn</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">bằng phạm vi</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="find" title="cpp/algorithm/ranges/find"> <span class="t-lines"><span>(Mẫu chức năng)</span><span>Phạm vi :: Tìm</span><span>Phạm vi :: find_if</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="lexicographical_compare" title="cpp/algorithm/ranges/lexicographical compare"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<code>true</code>trả lại<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="mismatch" title="cpp/algorithm/ranges/mismatch"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="search" title="cpp/algorithm/ranges/search"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="equal_range" title="cpp/algorithm/ranges/equal range"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../utility/functional/equal_to" title="cpp/utility/functional/equal to"> <span class="t-lines"><span>2,4,6,8)</span></span></a></div> </td> <td>thực hiện đối tượng chức năng<code>x == y</code> <br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../equal" title="cpp/algorithm/equal"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/equal">https://en.cppreference.com/w/cpp/algorithm/ranges/equal</a>
</p>
</div>
