 <h1 class="firstHeading" id="firstHeading">STD :: Phạm vi :: từ vựng_compare</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;std :: input_iterator i1, std :: sentinel_for &lt;i1&gt; s1,</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          std :: input_iterator i2, std :: sentinel_for &lt;i2&gt; s2,</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Mẫu &lt;class execPolicy, class forwardit1, class forwardit2&gt;<code>[</code><code>first1</code><code>, </code><code>last1</code><code>)</code>Bool từ vựng_compare (execPolicy &amp;&amp; chính sách,<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>                              Forwardit1 first1, forwardit1 last1,<code>[</code><code>first2</code><code>, </code><code>last2</code><code>)</code>.</p>
<div class="t-li1">
<span class="t-li">1)</span>chỉ vào trình tự và bất kỳ số nguyên không âm nào<code>comp</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>Sử dụng<code>r</code>              std :: dự kiến ​​&lt;i, proj &gt;&gt; pre<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>first</code>Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>last</code>.</div> <p>                              Forwardit2 first2, forwardit2 last2);</p>
<ul>
<li>Mẫu &lt;class inputit1, class inputit2, class so sánh&gt;</li>
<li>bool từ vựng_compare (inputit1 first1, inputit1 last1,<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>hoặc<i>Trả một trình lặp lại cho phần tử đầu tiên</i>Consexpr bool từ vựng_compare (đầu vào đầu tiên1, đầu vào</li>
<li>Mẫu &lt;class inputit1, class inputit2, class so sánh&gt;<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>Consexpr bool từ vựng_compare (đầu vào đầu tiên1, đầu vào</li>
<li>                                        Đầu vào đầu tiên2 đầu tiên, inputit2 last2,<i>(Niebloid)</i>.</li>
<li>                                        So sánh comp);<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>Mẫu &lt;Class execPolicy,</li>
<li>          lớp chuyển tiếp1, lớp forwardit2, so sánh lớp&gt;<i>(Niebloid)</i>.</li>
</ul> <p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Mẫu &lt;class execPolicy, class forwardit1, class forwardit2&gt;</td> <td>-</td> <td>Bool từ vựng_compare (execPolicy &amp;&amp; chính sách,</td>
</tr> <tr class="t-par"> <td>          lớp pre = phạm vi :: carm_to,</td> <td>-</td> <td>Bool từ vựng_compare (execPolicy &amp;&amp; chính sách,</td>
</tr> <tr class="t-par"> <td>            Forwardit1 first1, forwardit1 last1,</td> <td>-</td> <td>                              Forwardit1 first1, forwardit1 last1,</td>
</tr> <tr class="t-par"> <td>Yêu cầu (phạm vi :: forward_range &lt;r1&gt; |</td> <td>-</td> <td>                              Forwardit1 first1, forwardit1 last1,</td>
</tr> <tr class="t-par"> <td>sau đó</td> <td>-</td> <td>              STD :: Dự kiến ​​&lt;i, proj &gt;&gt; comp = phạm vi :: Ít hơn&gt;</td>
</tr> <tr class="t-par"> <td>                                    Phạm vi :: iterator_t &lt;r2&gt;,</td> <td>-</td> <td>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;</td>
</tr> <tr class="t-par"> <td>constexpr bool ends_with (r1 &amp;&amp; r1, r2 &amp;&amp; r2, pred = {},</td> <td>-</td> <td>Yêu cầu STD :: Inone</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code>true</code>                              So sánh comp);<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>đối tượng hàm so sánh (nghĩa là một đối tượng thỏa mãn các yêu cầu của</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>          Lớp Proj1 = std :: Nhận dạng, lớp proj2 = std :: Nhận dạng,<code>N1 <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3141">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first1, last1<span class="br0">)</span></code>Và<code>N2 <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3141">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first2, last2<span class="br0">)</span></code>.</p>
<h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">          std :: Indirect_strict_weak_order &lt;</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">              std :: dự kiến ​​&lt;i1, proj1&gt;,</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">              STD :: Dự kiến ​​&lt;i2, proj2 &gt;&gt; comp = phạm vi :: Ít hơn&gt;</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="equal" title="cpp/algorithm/ranges/equal"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../lexicographical_compare" title="cpp/algorithm/lexicographical compare"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>(C ++ 20)<code>true</code>trả lại<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/lexicographical_compare">https://en.cppreference.com/w/cpp/algorithm/ranges/lexicographical_compare</a>
</p>
</div>
