 <h1 class="firstHeading" id="firstHeading">STD :: Partial_Sort</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;Lass Randomit&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">void partial_sort (ngẫu nhiên đầu tiên, ngẫu nhiên giữa, ngẫu nhiên cuối cùng);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;Lass Randomit&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(3)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Consexpr void partial_sort (ngẫu nhiên đầu tiên, ngẫu nhiên giữa, ngẫu nhiên cuối cùng);</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;class execPolicy, class Randomit&gt;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void partial_sort (execPolicy &amp;&amp; chính sách,</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <p>                   Ngẫu nhiên đầu tiên, ngẫu nhiên giữa, ngẫu nhiên cuối cùng);<code>[</code><code>first</code><code>, </code><code>middle</code><code>)</code>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>middle − first</code>void partial_sort (ngẫu nhiên đầu tiên, ngẫu nhiên giữa, ngẫu nhiên cuối cùng,<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>.</p>
<p>                   So sánh comp);<code>[</code><code>middle</code><code>, </code><code>last</code><code>)</code>Mẫu &lt;Class Randomit, Class So sánh&gt;</p>
<div class="t-li1">
<span class="t-li">1)</span>Chuyển tiếp adjacent_find (forwardit first, forwardit cuối cùng, nhị phân p);<code>operator&lt;</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>chỉ vào trình tự và bất kỳ số nguyên không âm nào<code>comp</code>.</div> <div class="t-li1">
<span class="t-li">Một động thái tương đương với một bản sao</span>                                   Nhị phân p);<span class="t-v">*(d_first + 2) = val2 - std :: di chuyển (acc);</span>Mẫu &lt;class execPolicy, class forwardit, lớp nhị phân&gt;<code>policy</code>ForwardIt adjacent_find (execPolicy &amp;&amp; chính sách,<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2643">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table>
</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>Consexpr void partial_sort (ngẫu nhiên đầu tiên, ngẫu nhiên giữa, ngẫu nhiên cuối cùng,</td>
</tr> <tr class="t-par"> <td>ổn định</td> <td>-</td> <td>                             So sánh comp);</td>
</tr> <tr class="t-par"> <td>std :: iterator_traits &lt;buputit&gt; :: value_type acc = *first;</td> <td>-</td> <td>*d_first = acc;<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">execution policy</a> </td>
</tr> <tr class="t-par"> <td>sau đó</td> <td>-</td> <td>LO, xin chào<a href="../named_req/compare" title="cpp/named req/Compare">Compare</a>Constexpr bool bao gồm (đầu vào đầu tiên1, đầu vào1, last1,<code>true</code>cũng là<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>                         Inputit2 First2, Inputit2 Last2, so sánh comp);<i>Mẫu &lt;Class execPolicy, class forwardit1, class forwardit2,</i>          Lớp so sánh&gt;<br/> <p>Hàm so sánh trả về giá trị số nguyên âm nếu đối số đầu tiên là</p>
<p><span class="t-cc"><code>bool cmp(const Type1&amp; a, const Type2&amp; b);</code></span></p>
<p>&gt;&gt;<span class="kw4">hằng số</span><span class="sy3">Không có giá trị</span>is_execut_policy_v<code>Type1</code>Và<code>Type2</code>Remove_cvref_t<a href="../language/value_category" title="cpp/language/value category">value category</a>&gt;&gt;<code>Type1&amp;</code>phạm vi của các yếu tố để kiểm tra<span class="t-rev-inl t-since-cxx11"><span>P<code>Type1</code>vị từ nhị phân trả về<code>Type1</code>Nếu các yếu tố nên được coi là bằng nhau.</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>).<br/>và cho bất kỳ</p>
</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>RandomIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/valueswappable" title="cpp/named req/ValueSwappable">ValueSwappable</a>Và<a href="../named_req/randomaccessiterator" title="cpp/named req/RandomAccessIterator">LegacyRandomAccessIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">và các phạm vi phải được sắp xếp theo cùng một.<code>RandomIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/moveassignable" title="cpp/named req/MoveAssignable">MoveAssignable</a>Và<a href="../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Gán cho đã cho</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Mẫu &lt;class execPolicy, lớp ngẫu nhiên, so sánh lớp&gt;<code>cmp</code>.</p>
<h3 id="Exceptions">Ngoại lệ</h3> <p>Sự khởi đầu của phạm vi đích<code>ExecutionPolicy</code>chính sách</p>
<ul>
<li>Chính sách thực thi để sử dụng. Nhìn thấy<code>ExecutionPolicy</code>Để biết chi tiết.<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">standard policies</a>Thì<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>Loại loại 1 và type2 phải sao cho một đối tượng của loại iterator_traits<code>ExecutionPolicy</code>Đầu vào</li>
<li>value_type<code><a href="../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>có thể được chuyển đổi hoàn toàn thành cả hai. Loại</li>
</ul> <h3 id="Notes">Ghi chú</h3> <h4 id="Algorithm">void partial_sort (execPolicy &amp;&amp; chính sách,</h4> <p>Vị trí chính xác là phần tử sẽ xảy ra ở vị trí này nếu phạm vi được sắp xếp đầy đủ.<i>                   Ngẫu nhiên đầu tiên, ngẫu nhiên giữa, ngẫu nhiên cuối cùng,</i>                   So sánh comp);<i>Sắp xếp lại các yếu tố sao cho phạm vi</i>Chứa các loại được sắp xếp</p>
<p>các yếu tố nhỏ nhất trong phạm vi<a class="extiw" href="https://en.wikipedia.org/wiki/Heap_(data_structure)#Applications" title="enwiki:Heap (data structure)">heap</a>Thứ tự của các yếu tố bằng nhau không được đảm bảo để được bảo tồn. Thứ tự của các yếu tố còn lại trong phạm vi<code>operator&lt;</code>không xác định.<i>Trình lặp truy cập ngẫu nhiên xác định phạm vi</i>Trình lặp truy cập ngẫu nhiên xác định trình lặp một lần cuối của phạm vi sẽ được sắp xếp<code>middle − first</code>Xấp xỉ (các ứng dụng nhật ký đầu tiên (đầu tiên) của</p>
<p><a class="extiw" href="https://en.wikipedia.org/wiki/Heapsort" title="enwiki:Heapsort">Heap sort</a>Thuật toán<code>[</code><code>first</code><code>, </code><code>middle</code><code>)</code>Hơi chọn<code><a href="sort_heap" title="cpp/algorithm/sort heap">std::sort_heap</a></code>).</p>
<h4 id="Intended_use">để chọn các yếu tố nhỏ nhất và</h4> <p><code>std::partial_sort</code>Sắp xếp đống<i>Để sắp xếp các phần tử đã chọn trong đống theo thứ tự tăng dần.</i>của<code>[</code><code>first</code><code>, </code><code>middle</code><code>)</code>Để chọn các phần tử, một đống được sử dụng (xem</p>
<h3 id="Possible_implementation">. ​</h3> <p>được tìm thấy,<a class="external text" href="https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%2B%2B-v3/include/bits/stl_algo.h#L1915" rel="nofollow">libstdc++</a>Và<a class="external text" href="https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L5025" rel="nofollow">libc++</a>.</p>
<table class="eq-fun-cpp-table"> <tr> <th>
<a href="#Version_1">partial_sort (1)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">). Ví dụ, cho</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_3">partial_sort (3)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">như là chức năng so sánh,</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">tối đa</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">được sử dụng để chọn</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="nth_element" title="cpp/algorithm/nth element"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="partial_sort_copy" title="cpp/algorithm/partial sort copy"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="stable_sort" title="cpp/algorithm/stable sort"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="sort" title="cpp/algorithm/sort"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="ranges/partial_sort" title="cpp/algorithm/ranges/partial sort"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/partial_sort">https://en.cppreference.com/w/cpp/algorithm/partial_sort</a>
</p>
</div>
