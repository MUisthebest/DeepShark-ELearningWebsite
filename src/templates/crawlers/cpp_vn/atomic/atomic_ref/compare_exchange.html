 <h1 class="firstHeading" id="firstHeading">STD :: ATOMIC_REF &lt;T&gt; :: Compare_exchange_weak, std :: Atomic_Ref &lt;t&gt; :: Compare_Exchange_strong</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">bool compare_exchange_weak (T &amp; mong đợi, T mong muốn,</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">                            std :: memory_order thành công, </pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">                            std :: memory_order fail) const noexcept;</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">bool compare_exchange_weak (T &amp; mong đợi, T mong muốn,</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>      Tên std :: Atomic &lt;T&gt; :: value_type mong muốn) NOEXCEPT;<a href="../../language/object" title="cpp/language/object">value representation</a>                            STD :: Memory_order Order =<code>expected</code>    .<code>desired</code>                                std :: memory_order_seq_cst) const noexcept;<code>expected</code>bool compare_exchange_strong (T &amp; mong đợi, T mong muốn,</p>
<p>                              std :: memory_order thành công, <code>success</code>Và<code>failure</code>                              std :: memory_order fail) const noexcept;<code>order</code>bool compare_exchange_strong (T &amp; mong đợi, T mong muốn,<code><a href="../memory_order" title="cpp/atomic/memory order">std::memory_order_acquire</a></code>Và<code><a href="../memory_order" title="cpp/atomic/memory order">std::memory_order_relaxed</a></code>                              STD :: Memory_order Order = <code>order <span class="sy1">==</span> <a href="http://en.cppreference.com/w/cpp/atomic/memory_order"><span class="kw2101">Điều đó cho tất cả<span class="me2">      Typename std :: Atomic &lt;T&gt; :: value_type* mong đợi, </span></span></a></code>, hoặc<code>order <span class="sy1">==</span> <a href="http://en.cppreference.com/w/cpp/atomic/memory_order"><span class="kw2100">Điều đó cho tất cả<span class="me2">    (STD dễ bay hơi :: Atomic &lt;T&gt;* obj,</span></span></a></code>tương ứng.</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>hy vọng</td> <td>-</td> <td>                                  std :: memory_order_seq_cst) const noexcept;<code>atomic_ref</code>sự vật</td>
</tr> <tr class="t-par"> <td>bool Atomic_compare_exchange_strong_explict</td> <td>-</td> <td>của đối tượng được tham chiếu với</td>
</tr> <tr class="t-par"> <td>      Typename std :: Atomic &lt;T&gt; :: value_type mong muốn,</td> <td>-</td> <td>(Thực hiện hoạt động đọc sửa đổi-viết). Nếu không, tải giá trị thực được lưu trữ trong đối tượng được tham chiếu vào</td>
</tr> <tr class="t-par"> <td>Mẫu &lt;Class T&gt;</td> <td>-</td> <td>(Thực hiện hoạt động tải).<code><a href="../memory_order" title="cpp/atomic/memory order">std::memory_order_release</a></code>hoặc<code><a href="../memory_order" title="cpp/atomic/memory order">std::memory_order_acq_rel</a></code> </td>
</tr> <tr class="t-par"> <td>Thay thế nguyên tử giá trị được trỏ đến bởi</td> <td>-</td> <td>                              std :: memory_order thành công, </td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code>true</code>Các mô hình bộ nhớ cho các hoạt động đọc biến đổi-viết và tải là<code>false</code>Nếu đối số đầu tiên là</p>
<h3 id="Notes">Ghi chú</h3> <p>bool compare_exchange_strong (T &amp; mong đợi, T mong muốn,<code><a href="../../string/byte/memcmp" title="cpp/string/byte/memcmp">std::memcmp</a></code>Và<code><a href="../../string/byte/memcpy" title="cpp/string/byte/memcpy">std::memcpy</a></code>                              STD :: Memory_order Order = </p>
<p>tương ứng. Trong các phiên bản (2) và (4)<span class="t-v">Outputit adjacent_difference (đầu vào đầu tiên, đầu vào cuối cùng, </span>được sử dụng cho cả hoạt động đọc biến đổi-viết và tải, ngoại trừ<code>*this != expected</code>được sử dụng cho hoạt động tải nếu</p>
<p>So sánh nguyên tử<code>T</code>tham chiếu đến giá trị dự kiến ​​sẽ được tìm thấy trong đối tượng được tham chiếu bởi</p>
<p>(Thực hiện hoạt động đọc biến đổi-viết). Nếu không, tải giá trị thực tế được trỏ đến bởi</p>
<p>vào trong</p>
<h3 id="Example">Ví dụ</h3> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/atomic/atomic_ref/compare_exchange">https://en.cppreference.com/w/cpp/atomic/atomic_ref/compare_exchange</a>
</p>
</div>
