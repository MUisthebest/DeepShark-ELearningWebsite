 <h1 class="firstHeading" id="firstHeading">std :: Atomic &lt;t&gt; :: Toán tử+=,-=, &amp; =, | =,^=</h1> <table class="t-dcl-begin"> <tr class="t-dcl-h"> <td>T fetch_add (t arg, std :: memory_order order =<code>atomic&lt;<i>được xác định, tương ứng.</i></code>﻿<code>&gt;</code>chuyên môn<br/><span class="t-rev-inl t-since-cxx20"><span>Và<code>atomic&lt;<i>là tùy chọn trong việc thực hiện độc lập.</i></code>﻿<code>&gt;</code>chuyên môn</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>
</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Toán tử t+= (t arg) noExcept;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Toán tử t+= (t arg) noexcept dễ bay hơi;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Toán tử t-= (t arg) noExcept;</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Toán tử t-= (t arg) noexcept dễ bay hơi;</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl-h"> <td>T fetch_add (t arg, std :: memory_order order =<code>atomic&lt;T*&gt;</code>                        std :: memory_order_seq_cst) NoExcept biến động;</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Toán tử t*+= (std :: ptrdiff_t arg) noExcept;</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Toán tử t*+= (std :: ptrdiff_t arg) noexcept dễ bay hơi;</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Toán tử t*-= (std :: ptrdiff_t arg) noExcept;</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Toán tử t*-= (std :: ptrdiff_t arg) NoExcept dễ bay hơi;</pre>
</td> <td>            Nhị phân p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl-h"> <td>T fetch_add (t arg, std :: memory_order order =<code>atomic&lt;<i>được xác định, tương ứng.</i></code>﻿<code>&gt;</code>chuyên môn</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Toán tử t &amp; = (t arg) noExcept;</pre>
</td> <td>(9)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Toán tử t &amp; = (t arg) noexcept dễ bay hơi;</pre>
</td> <td>(10)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Toán tử t | = (t arg) noExcept;</pre>
</td> <td>(11)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Toán tử t | = (t arg) NoExcept dễ bay hơi;</pre>
</td> <td>(12)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Toán tử t^= (t arg) noExcept;</pre>
</td> <td>(13)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Toán tử t^= (t arg) noexcept dễ bay hơi;</pre>
</td> <td>(14)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> </table> <p>Thay thế nguyên tử giá trị hiện tại bằng kết quả của tính toán liên quan đến giá trị trước đó và<code>arg</code>. Hoạt động là hoạt động đọc biến đổi-viết.</p>
<ul>
<li>nhà điều hành<span class="sy2">gọi</span><span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span>Thực hiện bổ sung nguyên tử. Tương đương với<code>return fetch_add(arg) + arg;</code>.</li>
<li>nhà điều hành<span class="sy2">-</span><span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span>Thực hiện phép trừ nguyên tử. Tương đương với<code>return fetch_sub(arg) - arg;</code>.</li>
<li>nhà điều hành<span class="sy3">Không có giá trị</span><span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span>thực hiện nguyên tử bitwise và. Tương đương với<code>return fetch_and(arg) &amp; arg;</code>.</li>
<li>nhà điều hành<span class="sy3">|</span><span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span>thực hiện nguyên tử bitwise hoặc. Tương đương với<code>return fetch_or(arg) | arg;</code>.</li>
<li>nhà điều hành<span class="sy3">^</span><span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span>thực hiện độc quyền nguyên tử bitwise hoặc. Tương đương với<code>return fetch_xor(arg) ^ arg;</code>.</li>
</ul> <div class="t-li1">
<span class="t-li">              Forwardit2 first2,</span>                  std :: memory_order_seq_cst) noExcept;<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>T* fetch_add (std :: ptrdiff_t arg, <a href="../../numeric/fenv" title="cpp/numeric/fenv">floating-point environment</a>                  std :: memory_order_seq_cst) noExcept;<code><a href="../../types/numeric_limits" title="cpp/types/numeric limits">std::numeric_limits</a></code>                  std :: memory_order_seq_cst) NoExcept biến động;</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table>
</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit1, class inputIt2, class BinaryPredicate&gt;</span>Kết quả có thể là một địa chỉ không xác định, nhưng các hoạt động khác không có hành vi không xác định.</div> <div class="t-li1">Nếu như<code>T</code>. Đó là, nó thực hiện sau khi tăng cường nguyên tử. Hoạt động là một hoạt động đọc biến đổi. Bộ nhớ bị ảnh hưởng theo giá trị của</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>bool compare_exchange_strong (T &amp; mong đợi, T mong muốn,<code><a href="http://en.cppreference.com/w/cpp/atomic/atomic"><span class="kw2070">Điều đó cho tất cả<span class="me2">nguyên tử</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">Chờ đợi</span></code>khoảng cách<code>false</code>                              std :: memory_order thành công, <span class="kw4">bay hơi</span>                              std :: memory_order thất bại) NoExcept;</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>T ATOMIC_FETCH_ADD_EXPLICIT (STD :: ATOMIC &lt;T&gt;* OBJ,</td> <td>-</td> <td>đối số cho hoạt động số học</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Giá trị kết quả (nghĩa là kết quả của việc áp dụng toán tử nhị phân tương ứng vào giá trị ngay trước các hiệu ứng của hàm thành viên tương ứng trong<a href="../memory_order#Modification_order" title="cpp/atomic/memory order">modification order</a>của<code>*this</code>).</p>
<h3 id="Notes">Ghi chú</h3> <p>Không giống như hầu hết các toán tử gán hợp chất, các toán tử gán hợp chất cho các loại nguyên tử không trả về một tham chiếu đến các đối số bên trái của chúng. Họ trả lại một bản sao của giá trị được lưu trữ thay thế.</p>
<h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/P0558R1" rel="nofollow">P0558R1</a> </td> <td>C ++ 11</td> <td>Đặc điểm nhưng được khuyến khích làm như vậy. Nếu kết quả không phải là giá trị thể hiện cho loại của nó, kết quả không được xác định nhưng hoạt động khác không có hành vi không xác định.<span class="kw4">Vô hiệu</span>Kết quả có thể là một địa chỉ không xác định, nhưng hoạt động khác không có hành vi không xác định.</td> <td>Không phải là một loại đối tượng hoàn chỉnh, chương trình không được hình thành.</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="operator_arith" title="cpp/atomic/atomic/operator arith"> <span class="t-lines"><span>fetch_or</span><span>fetch_or<span class="t-dsc-small">toán tử ++</span></span><span>thực hiện nguyên tử Bitwise XOR giữa đối số và giá trị của đối tượng nguyên tử và có được giá trị được giữ trước đó</span><span>thực hiện nguyên tử Bitwise XOR giữa đối số và giá trị của đối tượng nguyên tử và có được giá trị được giữ trước đó<span class="t-dsc-small">toán tử ++</span></span></span></a></div> </td> <td>toán tử ++<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/atomic/atomic/operator_arith2">https://en.cppreference.com/w/cpp/atomic/atomic/operator_arith2</a>
</p>
</div>
