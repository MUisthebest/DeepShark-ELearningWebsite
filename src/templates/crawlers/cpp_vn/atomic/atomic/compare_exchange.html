 <h1 class="firstHeading" id="firstHeading">STD :: ATOMIC &lt;T&gt; :: Compare_exchange_weak, std :: Atomic &lt;T&gt; :: Compare_exchange_strong</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">bool compare_exchange_weak (T &amp; mong đợi, T mong muốn,</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">                            std :: memory_order thành công, </pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">                            std :: memory_order thất bại) NoExcept;</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">bool compare_exchange_weak (T &amp; mong đợi, T mong muốn,</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">                            std :: memory_order thành công, </pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">                            STD :: Memory_order Fails) NoExcept biến động;</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">bool compare_exchange_weak (T &amp; mong đợi, T mong muốn,</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">                            STD :: Memory_order Order =</pre>
</td> <td>            Nhị phân p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> </table> <p>      Tên std :: Atomic &lt;T&gt; :: value_type mong muốn) NOEXCEPT;<span class="t-rev-inl t-until-cxx20"><span><a href="../../language/object" title="cpp/language/object">object representation</a></span><span><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></span></span><span class="t-rev-inl t-since-cxx20"><span><a href="../../language/object" title="cpp/language/object">value representation</a></span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>của<code>*this</code>                                std :: memory_order_seq_cst) noExcept;<code>expected</code>bool compare_exchange_weak (T &amp; mong đợi, T mong muốn,<code>desired</code>                            STD :: Memory_order Order =<code>*this</code>Mẫu &lt;Class T&gt;<code>expected</code>bool Atomic_compare_exchange_strong</p>
<table class="wikitable"> <tr> <th rowspan="2">(Constexpr kể từ C ++ 14)</th> <th colspan="2">    (STD dễ bay hơi :: Atomic &lt;T&gt;* obj,</th>
</tr> <tr> <th>      Typename std :: Atomic &lt;T&gt; :: value_type* mong đợi, </th> <th>      Tên std :: Atomic &lt;T&gt; :: value_type mong muốn) NOEXCEPT;</th>
</tr> <tr> <td>
<span class="t-v">            Inputit2 First2, Inputit2 Last2);</span> </td> <td>
<code>success</code> </td> <td>
<code>failure</code> </td>
</tr> <tr> <td>
<span class="t-v">constexpr bool bằng (đầu vào đầu tiên1 đầu tiên, đầu vào</span> </td> <td>
<code>order</code> </td> <td> <ul>
<li> <code><a href="http://en.cppreference.com/w/cpp/atomic/memory_order"><span class="kw2099">Điều đó cho tất cả<span class="me2">Thứ tự đồng bộ hóa bộ nhớ là</span></span></a></code>nếu như<br/><code>order</code>khoảng cách<code><a href="http://en.cppreference.com/w/cpp/atomic/memory_order"><span class="kw2101">Điều đó cho tất cả<span class="me2">      Typename std :: Atomic &lt;T&gt; :: value_type* mong đợi, </span></span></a></code> </li>
<li> <code><a href="http://en.cppreference.com/w/cpp/atomic/memory_order"><span class="kw2097">Điều đó cho tất cả<span class="me2">                                std :: memory_order_seq_cst) NoExcept biến động;</span></span></a></code>nếu như<br/><code>order</code>khoảng cách<code><a href="http://en.cppreference.com/w/cpp/atomic/memory_order"><span class="kw2100">Điều đó cho tất cả<span class="me2">    (STD dễ bay hơi :: Atomic &lt;T&gt;* obj,</span></span></a></code> </li>
<li>[tĩnh]<code>order</code> </li>
</ul> </td>
</tr>
</table> <p>Nếu như<code>failure</code><span class="t-rev-inl t-until-cxx17"><span>Mẫu &lt;Class T&gt;<code>success</code>hoặc</span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span>bool Atomic_compare_exchange_weak_explict<code><a href="http://en.cppreference.com/w/cpp/atomic/memory_order"><span class="kw2100">Điều đó cho tất cả<span class="me2">    (STD dễ bay hơi :: Atomic &lt;T&gt;* obj,</span></span></a></code>Và<code><a href="http://en.cppreference.com/w/cpp/atomic/memory_order"><span class="kw2101">Điều đó cho tất cả<span class="me2">      Typename std :: Atomic &lt;T&gt; :: value_type* mong đợi, </span></span></a></code>Hoạt động tương đương cho quá tải</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>bool compare_exchange_strong (T &amp; mong đợi, T mong muốn,<code><a href="http://en.cppreference.com/w/cpp/atomic/atomic"><span class="kw2070">Điều đó cho tất cả<span class="me2">nguyên tử</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">Chờ đợi</span></code>khoảng cách<code>false</code>                              std :: memory_order thành công, <span class="kw4">bay hơi</span>                              std :: memory_order thất bại) NoExcept;</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>hy vọng</td> <td>-</td> <td>bool compare_exchange_strong (T &amp; mong đợi, T mong muốn,</td>
</tr> <tr class="t-par"> <td>bool Atomic_compare_exchange_strong_explict</td> <td>-</td> <td>    . </td>
</tr> <tr class="t-par"> <td>      Typename std :: Atomic &lt;T&gt; :: value_type mong muốn,</td> <td>-</td> <td>      std :: memory_order thành công, std :: memory_order thất bại) NoExcept;</td>
</tr> <tr class="t-par"> <td>Mẫu &lt;Class T&gt;</td> <td>-</td> <td>bool Atomic_compare_exchange_strong_explict</td>
</tr> <tr class="t-par"> <td>Thay thế nguyên tử giá trị được trỏ đến bởi</td> <td>-</td> <td>                              std :: memory_order thành công, </td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code>true</code>                              STD :: Memory_order Fails) NoExcept biến động;<code>false</code>Nếu đối số đầu tiên là</p>
<h3 id="Notes">Ghi chú</h3> <p>bool compare_exchange_strong (T &amp; mong đợi, T mong muốn,<code><a href="../../string/byte/memcmp" title="cpp/string/byte/memcmp">std::memcmp</a></code>Và<code><a href="../../string/byte/memcpy" title="cpp/string/byte/memcpy">std::memcpy</a></code>                              STD :: Memory_order Order = </p>
<p><code>compare_exchange_weak</code>                                  std :: memory_order_seq_cst) noExcept;<code>*this != expected</code>bool compare_exchange_strong<code>compare_exchange_weak</code>    (T &amp; mong đợi, T mong muốn,</p>
<p>      std :: memory_order order = std :: memory_order_seq_cst) noexcept dễ bay hơi;<code>compare_exchange_weak</code>với<code>compare_exchange_strong</code>. Nếu đó là Bitwise-Equal, hãy thay thế cái trước bằng<code>compare_exchange_strong</code>(Thực hiện hoạt động đọc biến đổi-viết). Nếu không, tải giá trị thực tế được lưu trữ trong<code>T</code>của đối tượng được chỉ ra bởi<span class="t-rev-inl t-until-cxx20"><span>với đối tượng được chỉ ra bởi</span><span><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></span></span>bộ nhớ_order_relaxed<code>compare_exchange_weak</code>Nó không được dùng</p>
<p>(Thực hiện hoạt động đọc biến đổi-viết). Nếu không, tải giá trị thực tế được trỏ đến bởi</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>vào trong</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <h3 id="Example">Ví dụ</h3> <div class="t-example">
<p>Và bất kỳ<a class="extiw" href="https://en.wikipedia.org/wiki/Non-blocking_algorithm" title="enwiki:Non-blocking algorithm">lock-free</a>Quá tải tham gia vào độ phân giải quá tải.</p>
<div class="cpp source-cpp"><pre data-language="cpp">tham chiếu đến giá trị dự kiến ​​sẽ được tìm thấy trong đối tượng nguyên tử</pre></div> </div> <div class="t-example">
<p>thứ tự đồng bộ hóa bộ nhớ cho cả hai hoạt động<code>std::compare_exchange_strong</code>Nếu giá trị nguyên tử cơ bản đã được thay đổi thành công,</p>
<div class="cpp source-cpp"><pre data-language="cpp">Việc so sánh và sao chép là bitwise (tương tự như</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">); Không có hàm tạo, toán tử gán hoặc toán tử so sánh được sử dụng.</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../atomic_compare_exchange" title="cpp/atomic/atomic compare exchange"> <span class="t-lines"><span>Atomic_compare_exchange_weak</span><span>Atomic_compare_exchange_weak_explict</span><span>Atomic_compare_exchange_strong</span><span>Atomic_compare_exchange_strong_explict</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>so sánh về mặt nguyên tử với giá trị của đối tượng nguyên tử với đối số không nguyên tử và thực hiện trao đổi nguyên tử nếu tải trọng hoặc nguyên tử nếu không<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange">https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange</a>
</p>
</div>
