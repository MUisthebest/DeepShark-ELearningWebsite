 <h1 class="firstHeading" id="firstHeading">std :: memory_order</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/atomic" title="cpp/header/atomic">&lt;atomic&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx20"> <td><pre data-language="cpp">typedef enum memory_order {</pre></td> <td class="t-dcl-nopad"> </td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">    memory_order_relaxed,</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p><code>std::memory_order</code>    memory_order_consume,</p>
<p>    memory_order_acquire,<i>    memory_order_release,</i>    memory_order_acq_rel,<code>std::memory_order</code>    bộ nhớ_order_seq_cst</p>
<h3 id="Constants">Hằng số</h3> <table class="t-dsc-begin"> <tr class="t-dsc-header"> <th colspan="2">C Thư viện<code><a href="../header/atomic" title="cpp/header/atomic">&lt;atomic&gt;</a></code> </th>
</tr> <tr class="t-dsc-hitem"> <th>vĩ mô</th> <th>Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</th>
</tr> <tr class="t-dsc"> <td> <code>memory_order_relaxed</code> </td> <td>enum class memory_order: / * không xác định * / {<a href="#Relaxed_ordering">Relaxed ordering</a>: Không đọc hoặc ghi trong chuỗi hiện tại có thể được sắp xếp lại sau cửa hàng này. Tất cả các ghi trong luồng hiện tại đều có thể nhìn thấy trong các luồng khác có cùng biến nguyên tử (xem</td>
</tr> <tr class="t-dsc"> <td> <code>memory_order_consume</code> </td> <td>};<i>, tải nguyên tử trong luồng B từ cùng một biến là một</i>Inline ConstExPR Memory_order Memory_order_consume = memory_order :: Tiêu thụ;<a href="#Release-Consume_ordering">Release-Consume ordering</a>: Không đọc hoặc ghi trong chuỗi hiện tại có thể được sắp xếp lại sau cửa hàng này. Tất cả các ghi trong luồng hiện tại đều có thể nhìn thấy trong các luồng khác có cùng biến nguyên tử (xem</td>
</tr> <tr class="t-dsc"> <td> <code>memory_order_acquire</code> </td> <td>Inline ConsexPR Memory_order Memory_order_release = memory_order :: phát hành;<i>: Nếu một tác dụng phụ (một ghi) x trên một đối tượng nguyên tử m</i>Inline ConsexPR Memory_order Memory_order_seq_cst = memory_order :: SEQ_CST;<a href="#Release-Acquire_ordering">Release-Acquire ordering</a>: Không đọc hoặc ghi trong chuỗi hiện tại có thể được sắp xếp lại sau cửa hàng này. Tất cả các ghi trong luồng hiện tại đều có thể nhìn thấy trong các luồng khác có cùng biến nguyên tử (xem</td>
</tr> <tr class="t-dsc"> <td> <code>memory_order_release</code> </td> <td>Hành vi mặc định của tất cả các hoạt động nguyên tử trong thư viện cung cấp cho<i>Nếu một cửa hàng nguyên tử trong chuỗi A là</i>(Xem Thảo luận dưới đây). Mặc định đó có thể làm tổn thương hiệu suất, nhưng các hoạt động nguyên tử của thư viện có thể được cung cấp thêm<a href="#Release-Acquire_ordering">Release-Acquire ordering</a>Đối số để chỉ định các ràng buộc chính xác, ngoài tính nguyên tử, rằng trình biên dịch và bộ xử lý phải thực thi cho hoạt động đó.<a href="#Release-Consume_ordering">Release-Consume ordering</a>: Không đọc hoặc ghi trong chuỗi hiện tại có thể được sắp xếp lại sau cửa hàng này. Tất cả các ghi trong luồng hiện tại đều có thể nhìn thấy trong các luồng khác có cùng biến nguyên tử (xem</td>
</tr> <tr class="t-dsc"> <td> <code>memory_order_acq_rel</code> </td> <td>Hoạt động thư giãn: Không có các ràng buộc đồng bộ hoặc đặt hàng áp đặt cho các lần đọc hoặc ghi khác, chỉ có tính chất hoạt động này được đảm bảo (xem<i>: Nếu một tác dụng phụ (một ghi) x trên một đối tượng nguyên tử m</i>và a<i>Nếu một cửa hàng nguyên tử trong chuỗi A là</i>tiêu thụ hoạt động</td>
</tr> <tr class="t-dsc"> <td> <code>memory_order_seq_cst</code> </td> <td>Trên vị trí bộ nhớ bị ảnh hưởng: Không ghi hoặc ghi trong luồng hiện tại phụ thuộc vào giá trị hiện đang được tải có thể được sắp xếp lại trước khi tải này. Viết vào các biến phụ thuộc vào dữ liệu trong các luồng khác giải phóng cùng một biến nguyên tử có thể nhìn thấy trong luồng hiện tại. Trên hầu hết các nền tảng, điều này chỉ ảnh hưởng đến tối ưu hóa trình biên dịch (xem<i>: Nếu một tác dụng phụ (một ghi) x trên một đối tượng nguyên tử m</i>Hoạt động tải với thứ tự bộ nhớ này thực hiện<i>Nếu một cửa hàng nguyên tử trong chuỗi A là</i>Trên vị trí bộ nhớ bị ảnh hưởng: Không ghi hoặc ghi trong luồng hiện tại có thể được sắp xếp lại trước khi tải này. Tất cả các ghi trong các luồng khác giải phóng cùng một biến nguyên tử có thể nhìn thấy trong luồng hiện tại (xem<i>: Nếu một tác dụng phụ (một ghi) x trên một đối tượng nguyên tử m</i>và a<i>Nếu một cửa hàng nguyên tử trong chuỗi A là</i>Phát hành hoạt động<a href="#Sequentially-consistent_ordering">Sequentially-consistent ordering</a>: Không đọc hoặc ghi trong chuỗi hiện tại có thể được sắp xếp lại sau cửa hàng này. Tất cả các ghi trong luồng hiện tại đều có thể nhìn thấy trong các luồng khác có cùng biến nguyên tử (xem</td>
</tr> </table> <h3 id="Formal_description">bên dưới) và viết rằng mang một sự phụ thuộc vào biến nguyên tử có thể nhìn thấy trong các luồng khác tiêu thụ cùng một nguyên tử (xem</h3> <p>dưới).<i>Một hoạt động đọc sửa đổi-viết với thứ tự bộ nhớ này là cả một</i>Và<i>có được hoạt động</i>Phát hành hoạt động</p>
<h4 id="Sequenced-before">. Không có bộ nhớ đọc hoặc ghi trong luồng hiện tại có thể được sắp xếp lại trước khi tải, cũng như sau cửa hàng. Tất cả các ghi trong các chủ đề khác giải phóng cùng một biến nguyên tử có thể nhìn thấy trước khi sửa đổi và sửa đổi có thể nhìn thấy trong các luồng khác có được cùng một biến nguyên tử.</h4> <p>Hoạt động tải với thứ tự bộ nhớ này thực hiện<i>{</i>, một cửa hàng thực hiện một<a href="../language/eval_order" title="cpp/language/eval order">evaluation order</a>.</p>
<h4 id="Carries_dependency">Phát hành hoạt động</h4> <p>và đọc sửa đổi-viết-viết thực hiện cả một<i>{</i>Phát hành hoạt động</p>
<div class="t-li1">
<span class="t-li">1)</span>, cộng với một đơn đặt hàng duy nhất tồn tại trong đó tất cả các luồng quan sát tất cả các sửa đổi theo cùng một thứ tự (xem<b>                             STD :: Memory_order Order) NoExcept;</b>
</div> <div class="t-li2">
<span class="t-li">}</span>Mô tả chính thức<code><a href="kill_dependency" title="cpp/atomic/kill dependency">std::kill_dependency</a></code>Thì</div> <div class="t-li2">
<span class="t-li">{</span>đánh giá<code>&amp;&amp;</code>Thì<code>||</code>Thì<code>?:</code>, hoặc<code>,</code>tác dụng phụ</div> <div class="t-li1">
<span class="t-li">2)</span>của các biểu thức được đặt hàng giữa các luồng thực thi khác nhau. Chúng được định nghĩa trong các điều khoản sau:</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Giải trình tự-trước</div> <h4 id="Modification_order">Trong cùng một chủ đề, đánh giá A có thể</h4> <p>giải trình tự-trước</p>
<p>Đánh giá B, như được mô tả trong</p>
<div class="t-li1">
<span class="t-li">1)</span> <b>Mang sự phụ thuộc</b>Trong cùng một chủ đề, đánh giá A là<i>Nhà sản xuất void ()</i>Đánh giá B cũng có thể mang sự phụ thuộc vào B (nghĩa là B phụ thuộc vào A), nếu bất kỳ điều nào sau đây là đúng:<i>phát hành</i>xảy ra-trước</div> <div class="t-li1">
<span class="t-li">2)</span> <b>Nếu B là một cuộc gọi đến</b>Tất cả các sửa đổi đối với bất kỳ biến nguyên tử cụ thể nào xảy ra theo tổng số đơn đặt hàng cụ thể cho biến nguyên tử này.<i>Nhà sản xuất void ()</i>người vận hành.<i>phát hành</i>xảy ra-trước</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span> <b>Thứ tự sửa đổi</b>Tất cả các sửa đổi đối với bất kỳ biến nguyên tử cụ thể nào xảy ra theo tổng số đơn đặt hàng cụ thể cho biến nguyên tử này.<i>Nhà sản xuất void ()</i>Viết kết hợp-viết<i>phát hành</i>xảy ra-trước</div> <div class="t-li1">
<span class="t-li">là trong</span> <b>Đánh giá B sửa đổi M, sau đó A xuất hiện sớm hơn B trong</b>thứ tự sửa đổi<i>Nhà sản xuất void ()</i>Đọc kết hợp đọc</div> <h4 id="Release_sequence">: Nếu tính toán giá trị A của một số nguyên tử m (A Read)</h4> <p>xảy ra-trước<i>Nếu một cửa hàng nguyên tử trong chuỗi A là</i>thứ tự sửa đổi</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <span class="t-li">1)</span>của M.</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> </table> <div class="t-li1">
<span class="t-li">2)</span>Đọc-write gắn kết</div> <p>: Nếu tính toán giá trị A của một số nguyên tử m (A Read)<i>xảy ra-trước</i>.</p>
<h4 id="Synchronizes_with">Một thao tác B trên M (A ghi), sau đó giá trị của A xuất phát từ hiệu ứng phụ (A viết) X xuất hiện sớm hơn B trong</h4> <p>thứ tự sửa đổi<i>Nếu một cửa hàng nguyên tử trong chuỗi A là</i>Viết-đọc kết hợp<i>: Nếu một tác dụng phụ (một ghi) x trên một đối tượng nguyên tử m</i>r2 = x.load (std :: memory_order_relaxed); // C <i>y.store (42, std :: memory_order_relaxed); // d</i>#include &lt;Vector&gt;</p>
<p>Sau a<i>Phát hành hoạt động</i>A được thực hiện trên một đối tượng nguyên tử M, chuỗi con liên tục dài nhất của thứ tự sửa đổi của M bao gồm:</p>
<h4 id="Dependency-ordered_before">Viết được thực hiện bởi cùng một chủ đề đã thực hiện A.</h4> <p>Các hoạt động đọc biến đổi nguyên tử được thực hiện cho M bởi bất kỳ chủ đề nào.<i>#include &lt;Chủ đề&gt;</i>giải trình tự-trước</p>
<div class="t-li1">
<span class="t-li">1)</span>Đồng bộ hóa với<i>Nếu một cửa hàng nguyên tử trong chuỗi A là</i>Phát hành hoạt động<i>, tải nguyên tử trong luồng B từ cùng một biến là một</i>có được hoạt động<span class="t-rev-inl t-until-cxx20"><span>và tải trọng trong luồng B đọc một giá trị được viết bởi cửa hàng trong luồng A, sau đó là cửa hàng trong luồng a</span><span><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></span></span>đồng bộ hóa với</div> <div class="t-li1">
<span class="t-li">2)</span>tải trong luồng B.</div> <h4 id="Inter-thread_happens-before">Ngoài ra, một số cuộc gọi thư viện có thể được xác định là</h4> <p>Đồng bộ hóa với<i>giải trình tự-trước</i>giải trình tự-trước</p>
<div class="t-li1">
<span class="t-li">1)</span>MỘT<i>y.store (42, std :: memory_order_relaxed); // d</i>        mong đợi = 1;</div> <div class="t-li1">
<span class="t-li">2)</span>    // memory_order_relaxed là ổn vì đây là một RMW,<i>#include &lt;Chủ đề&gt;</i>        mong đợi = 1;</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>MỘT<i>y.store (42, std :: memory_order_relaxed); // d</i>tiêu thụ hoạt động<i>{</i>        mong đợi = 1;</div> <div class="t-li1">
<span class="t-li">là trong</span>    // memory_order_relaxed là ổn vì đây là một RMW,<i>{</i>đồng bộ hóa với<i>B.</i>        mong đợi = 1;</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>MỘT<i>B.</i>đồng bộ hóa với<i>B.</i>        mong đợi = 1;</div> <h4 id="Happens-before">Đã đặt hàng phụ thuộc trước</h4> <p>Đánh giá B Nếu bất kỳ điều nào sau đây là đúng:<i>Nhà sản xuất void ()</i>giải trình tự-trước</p>
<div class="t-li1">
<span class="t-li">1)</span>    // memory_order_relaxed là ổn vì đây là một RMW,<i>{</i>        mong đợi = 1;</div> <div class="t-li1">
<span class="t-li">2)</span>MỘT<i>giải trình tự-trước</i>        mong đợi = 1;</div> <p>Liên hệ xảy ra trước khi<i>Nhà sản xuất void ()</i>Liên hệ xảy ra trước khi<a class="external text" href="https://www.cl.cam.ac.uk/~pes20/cpp/popl085ap-sewell.pdf" rel="nofollow">Batty et al</a>).</p>
<p>Một số đánh giá x và x<a href="../language/memory_model" title="cpp/language/memory model">data race</a>Liên hệ xảy ra trước khi<i>Nhà sản xuất void ()</i>Xảy ra-trước</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <h4 id="Simply_happens-before">Bất kể chủ đề, đánh giá a</h4> <p>Đánh giá B Nếu bất kỳ điều nào sau đây là đúng:<i>B.</i>giải trình tự-trước</p>
<span class="t-li">1)</span>    // memory_order_relaxed là ổn vì đây là một RMW,<i>{</i>        mong đợi = 1;<span class="t-li">2)</span>MỘT<i>y.store (42, std :: memory_order_relaxed); // d</i>        mong đợi = 1;<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>MỘT<i>B.</i>mạnh mẽ xảy ra-trước<i>B.</i>        mong đợi = 1;<p>xảy ra-trước<i>B.</i>Và<i>Nhà sản xuất void ()</i>Bất kể chủ đề, đánh giá a</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <h4 id="Strongly_happens-before">chỉ đơn giản là xảy ra-trước</h4> <p>Đánh giá B Nếu bất kỳ điều nào sau đây là đúng:<i>{</i>giải trình tự-trước</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <span class="t-li">1)</span>    // memory_order_relaxed là ổn vì đây là một RMW,<i>{</i>        mong đợi = 1;<span class="t-li">2)</span>MỘT<i>y.store (42, std :: memory_order_relaxed); // d</i>        mong đợi = 1;<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>MỘT<i>{</i>mạnh mẽ xảy ra-trước<i>{</i>        mong đợi = 1;</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <span class="t-li">1)</span>    // memory_order_relaxed là ổn vì đây là một RMW,<i>{</i>        mong đợi = 1;<span class="t-li">2)</span>MỘT<i>Bất kể chủ đề, đánh giá a</i>mạnh mẽ xảy ra-trước<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>    // memory_order_relaxed là ổn vì đây là một RMW,<i>{</i>giải trình tự-trước<i>B.</i>đồng bộ hóa với<i>{</i>        mong đợi = 1;<span class="t-li">là trong</span>MỘT<i>{</i>mạnh mẽ xảy ra-trước<i>{</i>        mong đợi = 1;<p>giải trình tự-trước<i>{</i>Đồng bộ hóa với</p>
<p>Ghi chú:<i>{</i>A là</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <h4 id="Visible_side-effects">giải trình tự-trước</h4> <p>X, x<i>chỉ đơn giản là xảy ra-trước</i>Y, và y là</p>
<div class="t-li1">
<span class="t-li">1)</span>MỘT<i>Nhà sản xuất void ()</i>        mong đợi = 1;</div> <div class="t-li1">
<span class="t-li">2)</span>mạnh mẽ xảy ra-trước<i>Nhà sản xuất void ()</i>mạnh mẽ xảy ra-trước<i>Nhà sản xuất void ()</i>        mong đợi = 1;</div> <p>mạnh mẽ xảy ra-trước<i>phát hành</i>mạnh mẽ xảy ra-trước<i>cho kiểm soát chuỗi phụ thuộc hạt mịn.</i>Tác dụng phụ có thể nhìn thấy<i>Hiệu ứng phụ A trên vô hướng M (ghi) là</i>dễ thấy</p>
<p>liên quan đến tính toán giá trị B trên m (a đọc) nếu cả hai điều sau đây là đúng:</p>
<h4 id="Consume_operation">xảy ra-trước</h4> <p>xảy ra-trước<code>memory_order_consume</code>Không có tác dụng phụ khác x đến m trong đó một<code><a href="atomic_thread_fence" title="cpp/atomic/atomic thread fence">std::atomic_thread_fence</a></code>xảy ra-trước</p>
<h4 id="Acquire_operation">X và x</h4> <p>xảy ra-trước<code>memory_order_acquire</code>B.<a href="../named_req/mutex" title="cpp/named req/Mutex">Mutex</a>Nếu hiệu ứng phụ A có thể nhìn thấy đối với tính toán giá trị B, thì tập hợp con tiếp giáp dài nhất của các tác dụng phụ thành M, trong<code><a href="atomic_thread_fence" title="cpp/atomic/atomic thread fence">std::atomic_thread_fence</a></code>thứ tự sửa đổi</p>
<h4 id="Release_operation">, nơi B không</h4> <p>xảy ra-trước<code>memory_order_release</code>nó được gọi là<a href="../named_req/mutex" title="cpp/named req/Mutex">Mutex</a>Trình tự có thể nhìn thấy của các tác dụng phụ<code><a href="atomic_thread_fence" title="cpp/atomic/atomic thread fence">std::atomic_thread_fence</a></code>(Giá trị của M, được xác định bởi B, sẽ là giá trị được lưu trữ bởi một trong những tác dụng phụ này).</p>
<h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3> <h4 id="Relaxed_ordering">Tiêu thụ hoạt động</h4> <p>Nếu một cửa hàng nguyên tử trong chuỗi A được gắn thẻ<code>memory_order_relaxed</code>hoặc mạnh hơn là một hoạt động tiêu thụ. Lưu ý rằng</p>
<p>#include &lt;Chủ đề&gt;<code>x</code>Và<code>y</code> </p>
<div class="cpp source-cpp"><pre data-language="cpp">Tải nguyên tử với</pre></div> <p>dữ liệu int;<code>r1 == r2 == 42</code>cũng là một hoạt động có được. Lưu ý rằng<i>{</i>Phát hành hoạt động<i>Cửa hàng nguyên tử với</i>hoặc mạnh hơn là một hoạt động phát hành. Hoạt động mở khóa () trên một</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>cũng là một hoạt động phát hành. Lưu ý rằng<code>x</code>Và<code>y</code> </p>
<div class="cpp source-cpp"><pre data-language="cpp">Giải thích</pre></div> <p>Đặt hàng thư giãn<code>r1 == r2 == 42</code>Hoạt động nguyên tử được gắn thẻ</p>
</td> <td><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></td>
</tr> </table> <p>không phải là hoạt động đồng bộ hóa; Họ không áp đặt một đơn đặt hàng giữa các truy cập bộ nhớ đồng thời. Họ chỉ đảm bảo tính nhất quán của nguyên tử và sửa đổi.<code><a href="../memory/shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>Ví dụ, với</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">ban đầu không,</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">// Chủ đề 1:</pre></div> </div> <h4 id="Release-Acquire_ordering">r1 = y.Load (std :: memory_order_relaxed); // MỘT</h4> <p>, vì điều này chỉ yêu cầu tính nguyên tử, nhưng không đặt hàng hoặc đồng bộ hóa (lưu ý rằng việc giảm các bộ đếm chia sẻ_ptr yêu cầu có được sự đồng bộ hóa giải phóng với chất phá hủy).<code>memory_order_release</code>#include &lt;Atomic&gt;<code>memory_order_acquire</code>r2 = x.load (std :: memory_order_relaxed); // C <i>y.store (42, std :: memory_order_relaxed); // d</i>#include &lt;Vector&gt;</p>
<p>bởi vì, mặc dù A là<i>và tải trọng trong luồng B đọc một giá trị được viết bởi cửa hàng trong luồng A, sau đó là cửa hàng trong luồng a</i> <i>void f ()</i>D Trong luồng 2, không có gì ngăn d xuất hiện trước A theo thứ tự sửa đổi của y và b xuất hiện trước c theo thứ tự sửa đổi của x. Hiệu ứng phụ của D trên y có thể được hiển thị đối với tải a trong luồng 1 trong khi tác dụng phụ của B trên X có thể được hiển thị với tải C trong luồng 2. Đặc biệt, điều này có thể xảy ra nếu D hoàn thành trước C trong luồng 2, do trình biên dịch sắp xếp lại hoặc khi chạy.</p>
<p>}<i> </i>Và<i>// Chủ đề 1:</i>{</p>
<p>if (r1 == 42) x.store (r1, std :: memory_order_relaxed);</p>
<p>// Chủ đề 2:<code><a href="../thread/mutex" title="cpp/thread/mutex">std::mutex</a></code>hoặc<a href="atomic_flag" title="cpp/atomic/atomic flag">atomic spinlock</a>r2 = x.load (std :: memory_order_relaxed);</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">if (r2 == 42) y.store (42, std :: memory_order_relaxed);</pre></div> </div> <div class="t-example">
<p>không được phép sản xuất</p>
<div class="cpp source-cpp"><pre data-language="cpp">Vì cửa hàng từ 42 đến Y chỉ có thể nếu cửa hàng đến X Store 42, điều này phụ thuộc vào cửa hàng để lưu trữ 42. Lưu ý rằng cho đến khi C ++ 14, điều này được cho phép về mặt kỹ thuật bởi đặc điểm kỹ thuật, nhưng không được đề xuất cho người thực hiện.</pre></div> </div> <h4 id="Release-Consume_ordering">Sử dụng điển hình để đặt hàng bộ nhớ thư giãn là các bộ đếm tăng, chẳng hạn như các bộ đếm tham chiếu của</h4> <p>, vì điều này chỉ yêu cầu tính nguyên tử, nhưng không đặt hàng hoặc đồng bộ hóa (lưu ý rằng việc giảm các bộ đếm chia sẻ_ptr yêu cầu có được sự đồng bộ hóa giải phóng với chất phá hủy).<code>memory_order_release</code>#include &lt;Atomic&gt;<code>memory_order_consume</code>#include &lt;Istream&gt;<i>#include &lt;Chủ đề&gt;</i>#include &lt;Vector&gt;</p>
<p> <i>và tải trọng trong luồng B đọc một giá trị được viết bởi cửa hàng trong luồng A, sau đó là cửa hàng trong luồng a</i> <i>void f ()</i>{<i>    for (int n = 0; n &lt;1000; ++ n)</i>        cnt.fetch_add (1, std :: memory_order_relaxed);</p>
<p>}<i> </i>Và<i>int main ()</i>{</p>
<p>    std :: vector &lt;std :: thread&gt; v;</p>
<p>    for (int n = 0; n &lt;10; ++ n)<a class="extiw" href="https://en.wikipedia.org/wiki/Read-copy-update" title="enwiki:Read-copy-update">rcu_dereference</a>.</p>
<p>(chức năng)<code><a href="kill_dependency" title="cpp/atomic/kill dependency">std::kill_dependency</a></code>Và<code>[[<a href="../language/attributes/carries_dependency" title="cpp/language/attributes/carries dependency">carries_dependency</a>]]</code>        v.emplace_back (f);</p>
<p>    for (auto &amp; t: v)</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>        T.Join ();<code>memory_order_consume</code>    std :: cout &lt;&lt; "Giá trị bộ đếm cuối cùng là" &lt;&lt; cnt &lt;&lt; '\ n';</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <div class="t-example">
<p>}</p>
<div class="cpp source-cpp"><pre data-language="cpp">Giá trị truy cập cuối cùng là 10000</pre></div> </div> <h4 id="Sequentially-consistent_ordering">Phát hành-Acquire đặt hàng</h4> <p>Nếu một cửa hàng nguyên tử trong chuỗi A được gắn thẻ<code>memory_order_seq_cst</code>, một tải nguyên tử trong luồng B từ cùng một biến được gắn thẻ<i>và tải trọng trong luồng B đọc một giá trị được viết bởi cửa hàng trong luồng A, sau đó là cửa hàng trong luồng a</i>đồng bộ hóa với<i>tải trong luồng B.</i>Tất cả bộ nhớ ghi (bao gồm nguyên tử không phải nguyên tử và thư giãn)<i>đã xảy ra-trước</i>cửa hàng nguyên tử từ quan điểm của chủ đề A, trở thành</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td>std :: Atomic &lt;Int&gt; flag = {0};<p>Trong luồng B. nghĩa là, một khi tải nguyên tử được hoàn thành, Thread B được đảm bảo sẽ thấy mọi thứ ARREAD A đã viết vào bộ nhớ. Lời hứa này chỉ giữ nếu B thực sự trả về giá trị được lưu trữ hoặc giá trị từ sau này trong chuỗi phát hành.<code>memory_order_seq_cst</code>Việc đồng bộ hóa chỉ được thiết lập giữa các luồng</p>
<ul>
<li>phát hành</li>
<li>có được<code>memory_order_seq_cst</code>cùng một biến nguyên tử. Các luồng khác có thể thấy thứ tự khác nhau của truy cập bộ nhớ so với hoặc cả hai luồng được đồng bộ hóa.<i>cho kiểm soát chuỗi phụ thuộc hạt mịn.</i>Khóa loại trừ lẫn nhau, chẳng hạn như</li>
<li>, là một ví dụ về đồng bộ hóa Acquire phát hành: khi khóa được giải phóng bởi luồng A và được lấy bởi Thread B, mọi thứ diễn ra trong phần quan trọng (trước khi phát hành) trong bối cảnh của luồng A phải được hiển thị để chủ đề B (sau khi thu được) đang thực hiện cùng một phần quan trọng.<code>memory_order_seq_cst</code>.</li>
</ul> <p>#include &lt;Atomic&gt;<code>memory_order_seq_cst</code> <code><a href="atomic_thread_fence" title="cpp/atomic/atomic thread fence">std::atomic_thread_fence</a></code>#include &lt;Cassert&gt;<i>{</i>#include &lt;Chủ đề&gt;</p>
<ul>
<li> <code>memory_order_seq_cst</code>std :: Atomic &lt;std :: chuỗi*&gt; ptr;</li>
<li>dữ liệu int;</li>
</ul> <p> <code>memory_order_seq_cst</code> <code><a href="atomic_thread_fence" title="cpp/atomic/atomic thread fence">std::atomic_thread_fence</a></code>Nhà sản xuất void ()<i>{</i>    std :: Thread t2 (người tiêu dùng);<i>{</i>    ptr.store (p, std :: memory_order_release);</p>
<ul>
<li>}</li>
<li> </li>
</ul> <p>vô hiệu hóa người tiêu dùng ()</p>
<ul>
<li>{<code>memory_order_seq_cst</code> <code><a href="atomic_thread_fence" title="cpp/atomic/atomic thread fence">std::atomic_thread_fence</a></code>    std :: chuỗi* p2;<i>{</i>        ;</li>
<li>    khẳng định (*p2 == "xin chào"); // Không bao giờ bắn<code>memory_order_seq_cst</code> <code><a href="atomic_thread_fence" title="cpp/atomic/atomic thread fence">std::atomic_thread_fence</a></code>    khẳng định (dữ liệu == 42); // Không bao giờ bắn<i>{</i> </li>
<li>int main ()<code>memory_order_seq_cst</code> <code><a href="atomic_thread_fence" title="cpp/atomic/atomic thread fence">std::atomic_thread_fence</a></code>{<i>{</i>    std :: Thread t2 (người tiêu dùng);<i>{</i>}</li>
</ul> <p>Ví dụ sau đây cho thấy việc đặt hàng tiền điện tử chuyển tiếp trên ba luồng, sử dụng trình tự phát hành.</p>
<span class="t-li">1)</span>    ptr.store (p, std :: memory_order_release);<code>memory_order_seq_cst</code>#include &lt;Cassert&gt;<span class="t-li">2)</span>#include &lt;Chủ đề&gt;<i>{</i> <i>Nhà sản xuất void ()</i>).</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td>std :: Atomic &lt;Int&gt; flag = {0};<p> <i>    // Nếu chúng ta đọc giá trị 2 từ cờ nguyên tử, chúng ta sẽ thấy 42 trong vectơ</i>{</p>
<span class="t-li">1)</span>    data.push_back (42);<span class="t-li">2)</span>    cờ.store (1, std :: memory_order_release);<i>phát hành</i> <span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>void thread_2 ()<i>phát hành</i>    int dự kiến ​​= 1;<span class="t-li">là trong</span>    // memory_order_relaxed là ổn vì đây là một RMW,<i>    // Nếu chúng ta đọc giá trị 2 từ cờ nguyên tử, chúng ta sẽ thấy 42 trong vectơ</i>    while (! flag.compare_exchange_strong (dự kiến, 2, std :: memory_order_relaxed)))<i>    // Nếu chúng ta đọc giá trị 2 từ cờ nguyên tử, chúng ta sẽ thấy 42 trong vectơ</i>        mong đợi = 1;<p>    }<code>memory_order_seq_cst</code>}</p>
<span class="t-li">1)</span> <code>memory_order_seq_cst</code>void thread_3 ()<i>{</i>    while (flag.load (std :: memory_order_acquire) &lt;2)<span class="t-li">2)</span>        ;<i>    // Nếu chúng ta đọc giá trị 2 từ cờ nguyên tử, chúng ta sẽ thấy 42 trong vectơ</i>    khẳng định (data.at (0) == 42); // sẽ không bao giờ bắn<span class="t-li">}</span> <code>memory_order_seq_cst</code>int main ()<span class="t-li">{</span>    std :: Chủ đề A (Thread_1);<code>memory_order_seq_cst</code>    std :: Thread B (Thread_2);<i>Nhà sản xuất void ()</i>Một<code>memory_order_seq_cst</code>    A.Join (); B.Join (); c.join ();<span class="t-li">}</span>Tất cả bộ nhớ đều ghi (nguyên tử không phải là nguyên tử và thư giãn)<code>memory_order_seq_cst</code>đã xảy ra-trước<i>Nhà sản xuất void ()</i>và tải trọng trong luồng B đọc một giá trị được viết bởi cửa hàng trong luồng A, sau đó là cửa hàng trong luồng A là<code>memory_order_seq_cst</code>Đã đặt hàng phụ thuộc trước<span class="t-li">tải trong luồng B.</span>Tất cả bộ nhớ đều ghi (nguyên tử không phải là nguyên tử và thư giãn)<code>memory_order_seq_cst</code>đã xảy ra-trước<i>Nhà sản xuất void ()</i>Tác dụng phụ có thể nhìn thấy<i>Nhà sản xuất void ()</i>Một<code>memory_order_seq_cst</code>mang sự phụ thuộc<p>, nghĩa là, một khi tải nguyên tử được hoàn thành, các toán tử và chức năng trong luồng B sử dụng giá trị thu được từ tải được đảm bảo để xem chủ đề A đã viết vào bộ nhớ.</p>
<span class="t-li">1)</span>Việc đồng bộ hóa chỉ được thiết lập giữa các luồng<i>phát hành</i>tiêu thụ<span class="t-li">2)</span>Một<code>memory_order_seq_cst</code>cùng một biến nguyên tử. Các luồng khác có thể thấy thứ tự khác nhau của truy cập bộ nhớ so với hoặc cả hai luồng được đồng bộ hóa.<code>memory_order_seq_cst</code>Trên tất cả các CPU chính thống khác với DEC alpha, thứ tự phụ thuộc là tự động, không có hướng dẫn CPU bổ sung nào được cấp cho chế độ đồng bộ hóa này, chỉ có một số tối ưu hóa trình biên dịch nhất định bị ảnh hưởng (ví dụ: trình biên dịch bị cấm thực hiện tải trọng đầu cơ trên các đối tượng liên quan đến chuỗi phụ thuộc).<code>memory_order_seq_cst</code>Các trường hợp sử dụng điển hình cho đơn đặt hàng này liên quan đến việc đọc quyền truy cập vào các cấu trúc dữ liệu đồng thời hiếm khi được viết (bảng định tuyến, cấu hình, chính sách bảo mật, quy tắc tường lửa, v.v.) và nhà xuất bản-subscriber có thể xuất bản Kiến trúc đặt hàng yếu). Một ví dụ về kịch bản như vậy là<i>cho kiểm soát chuỗi phụ thuộc hạt mịn.</i>Lưu ý rằng hiện tại (2/2015) không có trình biên dịch sản xuất nào được biết theo dõi chuỗi phụ thuộc: Hoạt động tiêu thụ được nâng lên để có được các hoạt động.<code>memory_order_seq_cst</code>Đặc điểm kỹ thuật của việc đặt hàng trong việc phát hành đang được sửa đổi và việc sử dụng<p>tạm thời nản lòng.<i>Nhà sản xuất void ()</i>#include &lt;Atomic&gt;<code>memory_order_acquire</code>Và<code>memory_order_release</code>#include &lt;Cassert&gt;<code>memory_order_acquire</code>Và<code>memory_order_release</code>#include &lt;chuỗi&gt;<code>memory_order_seq_cst</code>.</p>
<p>#include &lt;Chủ đề&gt;<code>x</code>Và<code>y</code> </p>
<div class="cpp source-cpp"><pre data-language="cpp">std :: Atomic &lt;std :: chuỗi*&gt; ptr;</pre></div> <p>dữ liệu int;<code>r1 == 1 &amp;&amp; r2 == 3 &amp;&amp; r3 == 0</code> <i>Nhà sản xuất void ()</i>{<code>memory_order_seq_cst</code>    std :: chuỗi* p = new std :: chuỗi ("xin chào");<a class="external text" href="https://plv.mpi-sws.org/scfix/paper.pdf" rel="nofollow">Lahav et al</a>).</p>
<p>    Dữ liệu = 42;</p>
<span class="t-li">1)</span>    ptr.store (p, std :: memory_order_release);<code>memory_order_seq_cst</code>}<span class="t-li">2)</span> <code>memory_order_seq_cst</code>vô hiệu hóa người tiêu dùng ()</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <p>{</p>
<p>    std :: chuỗi* p2;</p>
<div class="t-example">
<p>    while (! (p2 = ptr.load (std :: memory_order_consume))))<code>c</code>Và<code>d</code>        ;<code>x</code>Và<code>y</code>    khẳng định (*p2 == "xin chào"); // Không bao giờ bắn: *P2 mang sự phụ thuộc từ PTR</p>
<div class="cpp source-cpp"><pre data-language="cpp">    khẳng định (dữ liệu == 42); // Có thể hoặc không bắn: Dữ liệu không mang sự phụ thuộc từ PTR</pre></div> </div> <h3 id="Relationship_with_volatile">}<span class="kw4">bay hơi</span>
</h3> <p> <a href="../language/cv" title="cpp/language/cv">volatile glvalues</a>int main ()<i>{</i>hoặc<i>    std :: Thread t1 (nhà sản xuất);</i>    std :: Thread t2 (người tiêu dùng);</p>
<p>    t1.join (); t2.join ();<a href="../language/memory_model" title="cpp/language/memory model">data race</a>}</p>
<p>Thứ tự liên tục theo thứ tự<a class="external text" href="https://docs.microsoft.com/en-us/cpp/cpp/volatile-cpp" rel="nofollow">Microsoft Docs</a>Hoạt động nguyên tử được gắn thẻ<code>volatile</code>không chỉ đặt hàng bộ nhớ giống như bản phát hành/có được thứ tự (mọi thứ<code><a href="../utility/program/signal" title="cpp/utility/program/signal">std::signal</a></code>đã xảy ra-trước<code>sig_atomic_t</code>một cửa hàng trong một chủ đề trở thành một</p>
<h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">C documentation</a></span>vì<span class=""><span>Tác dụng phụ có thể nhìn thấy</span></span> </td>
</tr> </table> <h3 id="External_links">Liên kết bên ngoài</h3> <table> <tr style="vertical-align:top;"> <td># Nếu __HAS_CPP_ATTRIBUTE (không dùng nữa) // Kiểm tra thuộc tính</td> <td>
<a class="extiw" href="https://en.wikipedia.org/wiki/MOESI_protocol" title="enwiki:MOESI protocol">MOESI protocol</a> </td>
</tr> <tr style="vertical-align:top;"> <td># Xác định mất giá (MSG) [[không dùng nữa (MSG)]]]]</td> <td>
<a class="external text" href="https://www.cl.cam.ac.uk/~pes20/weakmemory/cacm.pdf" rel="nofollow">x86-TSO: A Rigorous and Usable Programmer’s Model for x86 Multiprocessors</a>trong chủ đề đã tải), nhưng cũng thiết lập một</td>
</tr> <tr style="vertical-align:top;"> <td>đơn đặt hàng tổng số sửa đổi</td> <td>
<a class="external text" href="https://www.cl.cam.ac.uk/~pes20/ppc-supplemental/test7.pdf" rel="nofollow">A Tutorial Introduction to the ARM and POWER Relaxed Memory Models</a>của tất cả các hoạt động nguyên tử được gắn thẻ.</td>
</tr> <tr style="vertical-align:top;"> <td>Chính thức,</td> <td>
<a class="external text" href="https://researchspace.auckland.ac.nz/bitstream/handle/2292/11594/MESIF-2009.pdf?sequence=6" rel="nofollow">MESIF: A Two-Hop Cache Coherency Protocol for Point-to-Point Interconnects</a>mỗi</td>
</tr> <tr style="vertical-align:top;"> <td>Hoạt động B tải từ biến nguyên tử M, quan sát một trong những điều sau đây:</td> <td>
<a class="external text" href="https://research.swtch.com/mm" rel="nofollow">Memory Models</a>Kết quả của hoạt động cuối cùng A đã sửa đổi m, xuất hiện trước B trong tổng số đơn hàng,</td>
</tr>
</table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/atomic/memory_order">https://en.cppreference.com/w/cpp/atomic/memory_order</a>
</p>
</div>
