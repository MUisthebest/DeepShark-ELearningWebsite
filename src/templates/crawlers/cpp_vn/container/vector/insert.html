 <h1 class="firstHeading" id="firstHeading">STD :: Vector &lt;T, Alolocator&gt; :: Chèn</h1> <table class="t-dcl-begin"> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">iterator chèn (const_iterator pos, const t &amp; value);</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">ConstExpr iterator chèn (const_iterator pos, const t &amp; value);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(2)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx20"> <td><pre data-language="cpp">iterator chèn (const_iterator pos, t &amp;&amp; value);</pre></td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">ConstExpr iterator chèn (const_iterator pos, t &amp;&amp; value);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(3)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">iterator chèn (const_iterator pos, size_type Count, const t &amp; value);</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">iterator constexpr</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(4)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;Class Inputit&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">    Chèn (const_iterator pos, size_type đếm, const t &amp; value);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">             Không có p);</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx20"> <td><pre data-language="cpp">iterator chèn (const_iterator pos, đầu vào đầu tiên, inputit cuối cùng);</pre></td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Class Inputit&gt;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>iterator chèn (const_iterator pos, std :: initizer_list &lt;t&gt; ilist);</p>
<div class="t-li1">
<span class="t-li">Đầu vào</span>Chèn<code>value</code>Mẫu &lt;Class execPolicy, class forwardit1, class forwardit2,<code>pos</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Chèn<code>count</code>Chèn<code>value</code>Mẫu &lt;Class execPolicy, class forwardit1, class forwardit2,<code>pos</code>.</div> <div class="t-li1">
<span class="t-li">là trong</span>bản sao của<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Mẫu &lt;Class execPolicy, class forwardit1, class forwardit2,<code>pos</code>.<table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <p>. Hành vi không được xác định nếu một trong hai đối số là một trình lặp lại<span class="t-v">(3)</span>nếu như<code>InputIt</code>khái niệm tích phân = std :: is_integral_v &lt;t&gt;;</p>
</td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> <p>                const std :: chrono :: sys_time &lt;thời gian&gt; &amp; tp);<code>InputIt</code>Chèn các phần tử từ phạm vi<a href="../../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>Xây dựng một thùng chứa mới từ nhiều nguồn dữ liệu khác nhau, tùy chọn sử dụng bộ phân bổ do người dùng cung cấp<span class="t-v">(3)</span>.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table>đến một phạm vi khác kết thúc tại<code>first</code>Và<code>last</code>đủ điều kiện là<code>*this</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>là người lặp vào<code>ilist</code>Mẫu &lt;Class execPolicy, class forwardit1, class forwardit2,<code>pos</code>.</div> <p>constexpr void append_range (R &amp;&amp; rg);<a href="size" title="cpp/container/vector/size"><code>size()</code></a>Nếu sau khi hoạt động mới<a href="capacity" title="cpp/container/vector/capacity"><code>capacity()</code></a>lớn hơn cũ<a href="end" title="cpp/container/vector/end"><code>end()</code></a>ConstExpr iterator xuất hiện (const_iterator pos, args &amp;&amp; ... args);</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>POS</td> <td>-</td> <td>Chèn các yếu tố từ danh sách khởi tạo<code>pos</code>Trình lặp trước đó nội dung sẽ được chèn (<a href="end" title="cpp/container/vector/end"><code>end()</code></a>Có thể là</td>
</tr> <tr class="t-par"> <td>được phân vùng liên quan đến</td> <td>-</td> <td>người lặp lại)</td>
</tr> <tr class="t-par"> <td>(Niebloid)</td> <td>-</td> <td>giá trị phần tử để chèn</td>
</tr> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>Số lượng các yếu tố để chèn</td>
</tr> <tr class="t-par"> <td>Quá tải</td> <td>-</td> <td>Phạm vi của các phần tử cần chèn, không thể là người rút vào thùng chứa mà chèn được gọi</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a>Và<a href="../../named_req/copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a>is_array_v</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/moveassignable" title="cpp/named req/MoveAssignable">MoveAssignable</a>Và<a href="../../named_req/moveinsertable" title="cpp/named req/MoveInsertable">MoveInsertable</a>Mảng tích hợp để được chuyển đổi</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a>Và<a href="../../named_req/copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a>Danh sách khởi tạo để chèn các giá trị từ</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a>Để sử dụng quá tải (4,5).</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/moveassignable" title="cpp/named req/MoveAssignable">MoveAssignable</a>Và<a href="../../named_req/moveinsertable" title="cpp/named req/MoveInsertable">MoveInsertable</a>Consexpr iterator chèn (const_iterator pos, inputit đầu tiên, đầu vào cuối cùng);<code>InputIt</code>Phần cuối của phạm vi ban đầu<a href="../../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>Constexpr Iterator chèn (const_iterator pos,<a href="../../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>.<span class="t-mark-rev t-until-cxx17">xáo trộn</span> </td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/swappable" title="cpp/named req/Swappable">Swappable</a>Thì<a href="../../named_req/moveassignable" title="cpp/named req/MoveAssignable">MoveAssignable</a>Thì<a href="../../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>Và<a href="../../named_req/moveinsertable" title="cpp/named req/MoveInsertable">MoveInsertable</a>Để sử dụng quá tải (4,5).<span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">Đầu vào</span>Để sử dụng quá tải (4,5).<code>value</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Trình lặp chỉ vào phần tử đầu tiên được chèn hoặc<code>pos</code>nếu như<code>count == 0</code>.</div> <div class="t-li1">
<span class="t-li">là trong</span>Trình lặp chỉ vào phần tử đầu tiên được chèn hoặc<code>pos</code>nếu như<code>first == last</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Trình lặp chỉ vào phần tử đầu tiên được chèn hoặc<code>pos</code>nếu như<code>ilist</code>...</div> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <div class="t-li1">
<span class="t-li">Đầu vào</span>                           std :: initizer_list &lt;t&gt; ilist);<code>pos</code>iterator) và tất cả các tham chiếu đến các yếu tố bị vô hiệu. Mặt khác, chỉ có trình lặp và tài liệu tham khảo trước khi điểm chèn vẫn còn hiệu lực.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>bool is_heap (execPolicy &amp;&amp; chính sách,<code>count</code>Không đổi cộng với tuyến tính trong khoảng cách giữa<code>pos</code>iterator) và tất cả các tham chiếu đến các yếu tố bị vô hiệu. Mặt khác, chỉ có trình lặp và tài liệu tham khảo trước khi điểm chèn vẫn còn hiệu lực.</div> <div class="t-li1">
<span class="t-li">là trong</span>bool is_heap (execPolicy &amp;&amp; chính sách,<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>Không đổi cộng với tuyến tính trong khoảng cách giữa<code>pos</code>iterator) và tất cả các tham chiếu đến các yếu tố bị vô hiệu. Mặt khác, chỉ có trình lặp và tài liệu tham khảo trước khi điểm chèn vẫn còn hiệu lực.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>bool is_heap (execPolicy &amp;&amp; chính sách,<code>ilist.size()</code>Không đổi cộng với tuyến tính trong khoảng cách giữa<code>pos</code>iterator) và tất cả các tham chiếu đến các yếu tố bị vô hiệu. Mặt khác, chỉ có trình lặp và tài liệu tham khảo trước khi điểm chèn vẫn còn hiệu lực.</div> <h3 id="Exceptions">Ngoại lệ</h3> <p>cộng với tuyến tính trong các khoảng cách nhỏ hơn giữa</p>
<ul><li>Nếu một ngoại lệ được ném khác với<code>T</code>Thì</li></ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li>hàm tạo bản sao của<code>T</code>Thì</li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <ul><li>hàm tạo di chuyển của<code>T</code>Thì</li></ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li>toán tử gán bản sao của<code>T</code>Thì</li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <ul><li>bất kì<code>InputIt</code>cộng với tuyến tính trong khoảng cách giữa</li></ul> <p>cộng với tuyến tính trong khoảng cách giữa<a href="../../language/exceptions#Exception_safety" title="cpp/language/exceptions">strong exception safety guarantee</a>).</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>cộng với tuyến tính trong khoảng cách giữa<code>T</code>khoảng cách<a href="../../named_req/copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a>hoặc<code><a href="http://en.cppreference.com/w/cpp/types/is_move_constructible"><span class="kw549">Điều đó cho tất cả<span class="me2">is_nothrow_move_constructible</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span></code>khoảng cách<code>true</code>hoạt động,<a href="../../named_req/copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a> <code>T</code>Không có hiệu ứng. Nếu một ngoại lệ được ném trong khi chèn một phần tử duy nhất ở hai đầu, không có hiệu ứng. Mặt khác, nếu một ngoại lệ bị ném bởi hàm tạo di chuyển của một</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Các chức năng này không có tác dụng (</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">#include &lt;Istream&gt;</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue149" rel="nofollow">LWG 149</a> </td> <td>C ++ 98</td> <td>#include &lt;iterator&gt;</td> <td>#include &lt;Deque&gt;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue247" rel="nofollow">LWG 247</a> </td> <td>C ++ 98</td> <td>Nếu một ngoại lệ được ném khi chèn một phần tử ở cuối và</td> <td>, chức năng này không có hiệu lực (đảm bảo ngoại lệ mạnh). Mặt khác, nếu một ngoại lệ bị ném bởi hàm tạo di chuyển của một</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue406" rel="nofollow">LWG 406</a> </td> <td>C ++ 98</td> <td>#include &lt;Istream&gt;<br/>#include &lt;iterator&gt;<code>InputIt</code>#include &lt;Vector&gt;</td> <td> </td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="emplace" title="cpp/container/vector/emplace"> <span class="t-lines"><span>Giảm sử dụng bộ nhớ bằng cách giải phóng bộ nhớ không sử dụng</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>Xóa nội dung<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="push_back" title="cpp/container/vector/push back"> <span class="t-lines"><span>Chèn_range</span></span></a></div> </td> <td>chèn một loạt các yếu tố<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../iterator/inserter" title="cpp/iterator/inserter"> <span class="t-lines"><span>người đưa vào</span></span></a></div> </td> <td>tạo ra a<code><a href="../../iterator/insert_iterator" title="cpp/iterator/insert iterator">std::insert_iterator</a></code>loại được suy ra từ đối số<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/vector/insert">https://en.cppreference.com/w/cpp/container/vector/insert</a>
</p>
</div>
