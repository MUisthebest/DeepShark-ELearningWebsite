 <h1 class="firstHeading" id="firstHeading">STD :: Unordered_multimap</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/unordered_map" title="cpp/header/unordered map">&lt;unordered_map&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">mẫu &lt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">    khóa lớp,</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <p><code>std::unordered_multimap</code>    lớp T,</p>
<p>    Lớp băm = std :: Hash &lt;key&gt;,</p>
<p>    lớp keyequal = std :: quis_to &lt;key&gt;,<code><a href="../algorithm/equal" title="cpp/algorithm/equal">std::equal</a></code>    Class Allocator = std :: Allocator &lt;std :: cặp &lt;const key, t &gt;&gt;<code>std::unordered_multimap</code>&gt; lớp unetered_multimap;<i>tương đương</i>không gian tên PMR {<code><a href="unordered_multimap/key_eq" title="cpp/container/unordered multimap/key eq">key_eq()</a></code>    mẫu &lt;<code><a href="unordered_multimap/equal_range" title="cpp/container/unordered multimap/equal range">equal_range()</a></code>.</p>
<p><code>std::unordered_multimap</code>. Tuy nhiên, hoạt động hiệu quả hơn nếu<a href="../named_req/container" title="cpp/named req/Container">Container</a>Thì<a href="../named_req/allocatorawarecontainer" title="cpp/named req/AllocatorAwareContainer">AllocatorAwareContainer</a>Thì<a href="../named_req/unorderedassociativecontainer" title="cpp/named req/UnorderedAssociativeContainer">UnorderedAssociativeContainer</a>.</p>
<h3 id="Template_parameters">là không xác định.</h3> <h3 id="Member_types">nhà điều hành ()</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>ATOMIC_UNSIGNED_LOCK_FREE</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code>key_type</code> </td> <td> <code>Key</code> </td>
</tr> <tr class="t-dsc"> <td> <code>mapped_type</code> </td> <td> <code>T</code> </td>
</tr> <tr class="t-dsc"> <td> <code>value_type</code> </td> <td> <a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1099">Điều đó cho tất cả<span class="me2">đôi</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span>    &gt; Sử dụng map = std :: map &lt;key, t, so sánh,<span class="sy1">&lt;</span> </td>
</tr> <tr class="t-dsc"> <td> <code>size_type</code> </td> <td>Ghi chú không hợp lệ<code><a href="../types/size_t" title="cpp/types/size t">std::size_t</a></code>)</td>
</tr> <tr class="t-dsc"> <td> <code>difference_type</code> </td> <td>Khi chèn ở hai đầu của deque, các tài liệu tham khảo không bị vô hiệu hóa bởi<code><a href="../types/ptrdiff_t" title="cpp/types/ptrdiff t">std::ptrdiff_t</a></code>)</td>
</tr> <tr class="t-dsc"> <td> <code>hasher</code> </td> <td> <code>Hash</code> </td>
</tr> <tr class="t-dsc"> <td> <code>key_equal</code> </td> <td> <code>KeyEqual</code> </td>
</tr> <tr class="t-dsc"> <td> <code>allocator_type</code> </td> <td> <code>Allocator</code> </td>
</tr> <tr class="t-dsc"> <td> <code>reference</code> </td> <td> <code>value_type&amp;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>const_reference</code> </td> <td> <span class="kw4">hằng số</span>// hoặc *(d_first + 1) = op (val1, std :: di chuyển (acc)); cho quá tải (2)<span class="sy3">Không có giá trị</span> </td>
</tr> <tr class="t-dsc"> <td> <code>pointer</code> </td> <td> <a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span>Người phân bổ<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">Không làm mất hiệu lực bất kỳ tài liệu tham khảo nào về các yếu tố của deque.</span> </td>
</tr> <tr class="t-dsc"> <td> <code>const_pointer</code> </td> <td> <a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span>Người phân bổ<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">Khi xóa ở hai đầu của deque, các tham chiếu đến các phần tử không bị bệnh không bị vô hiệu hóa bởi</span> </td>
</tr> <tr class="t-dsc"> <td> <code>iterator</code> </td> <td> <a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>ĐẾN<code>value_type</code> </td>
</tr> <tr class="t-dsc"> <td> <code>const_iterator</code> </td> <td> <a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>ĐẾN<span class="kw4">hằng số</span>// hoặc *(d_first + 1) = op (val1, std :: di chuyển (acc)); cho quá tải (2)</td>
</tr> <tr class="t-dsc"> <td> <code>local_iterator</code> </td> <td>là một thùng chứa kết hợp có chứa các cặp giá trị khóa với các khóa duy nhất. Tìm kiếm, chèn và loại bỏ các yếu tố có độ phức tạp thời gian không đổi trung bình.<br/>Trong nội bộ, các yếu tố không được sắp xếp theo bất kỳ thứ tự cụ thể nào, mà được tổ chức thành các thùng. Cái xô nào một phần tử được đặt vào hoàn toàn phụ thuộc vào băm của chìa khóa của nó. Các khóa có cùng mã băm xuất hiện trong cùng một nhóm. Điều này cho phép truy cập nhanh vào các yếu tố riêng lẻ, vì một khi băm được tính toán, nó đề cập đến nhóm chính xác mà phần tử được đặt vào.<code>iterator</code>Hai chìa khóa được xem xét<br/>Nếu vị từ bình đẳng chính của bản đồ trở lại đúng khi thông qua các khóa đó. Nếu hai khóa tương đương, hàm băm phải trả về cùng một giá trị cho cả hai khóa.</td>
</tr> <tr class="t-dsc"> <td> <code>const_local_iterator</code> </td> <td>là một thùng chứa kết hợp có chứa các cặp giá trị khóa với các khóa duy nhất. Tìm kiếm, chèn và loại bỏ các yếu tố có độ phức tạp thời gian không đổi trung bình.<br/>Trong nội bộ, các yếu tố không được sắp xếp theo bất kỳ thứ tự cụ thể nào, mà được tổ chức thành các thùng. Cái xô nào một phần tử được đặt vào hoàn toàn phụ thuộc vào băm của chìa khóa của nó. Các khóa có cùng mã băm xuất hiện trong cùng một nhóm. Điều này cho phép truy cập nhanh vào các yếu tố riêng lẻ, vì một khi băm được tính toán, nó đề cập đến nhóm chính xác mà phần tử được đặt vào.<code>const_iterator</code>Hai chìa khóa được xem xét<br/>Nếu vị từ bình đẳng chính của bản đồ trở lại đúng khi thông qua các khóa đó. Nếu hai khóa tương đương, hàm băm phải trả về cùng một giá trị cho cả hai khóa.</td>
</tr> <tr class="t-dsc"> <td> <code>node_type</code> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> <td>                           std :: pmr :: đa hình_allocator &lt;std :: cặp &lt;const key, t &gt;&gt;&gt;;<a href="node_handle" title="cpp/container/node handle">node handle</a>}</td>
</tr> </table> <h3 id="Member_functions">nếu không thì</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/unordered_multimap" title="cpp/container/unordered multimap/unordered multimap"> <span class="t-lines"><span>chuyên môn)</span></span></a></div> </td> <td>Với kích thước nhỏ hơn không làm mất hiệu lực bất kỳ tài liệu tham khảo nào đối với các yếu tố không bị hỏng.<code>unordered_multimap</code> <br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/~unordered_multimap" title="cpp/container/unordered multimap/~unordered multimap"> <span class="t-lines"><span>một đối tượng ngoại lệ khác để gán với</span></span></a></div> </td> <td>với kích thước lớn hơn không làm mất hiệu lực bất kỳ tài liệu tham khảo nào về các yếu tố của deque.<code>unordered_multimap</code> <br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/operator=" title="cpp/container/unordered multimap/operator="> <span class="t-lines"><span>chuyên môn)</span></span></a></div> </td> <td>con trỏ<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/get_allocator" title="cpp/container/unordered multimap/get allocator"> <span class="t-lines"><span>phá hủy các</span></span></a></div> </td> <td>gán các giá trị cho container<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Iterators">Trình lặp</h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/begin" title="cpp/container/unordered multimap/begin"> <span class="t-lines"><span>bắt đầu</span><span>cbegin</span></span></a></div> </td> <td>mặt sau<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/end" title="cpp/container/unordered multimap/end"> <span class="t-lines"><span>kết thúc</span><span>Cend</span></span></a></div> </td> <td>Truy cập phần tử cuối cùng<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Capacity">Dung tích</h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/empty" title="cpp/container/unordered multimap/empty"> <span class="t-lines"><span>trống</span></span></a></div> </td> <td>Kiểm tra xem container có trống không<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/size" title="cpp/container/unordered multimap/size"> <span class="t-lines"><span>kích cỡ</span></span></a></div> </td> <td>trả về một trình lặp đến cuối<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/max_size" title="cpp/container/unordered multimap/max size"> <span class="t-lines"><span>trả về một trình lặp ngược lại cho đầu</span></span></a></div> </td> <td>trả về một trình lặp ngược về cuối<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Modifiers">Sửa đổi</h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/clear" title="cpp/container/unordered multimap/clear"> <span class="t-lines"><span>thông thoáng</span></span></a></div> </td> <td>gán một loạt các giá trị cho container<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/insert" title="cpp/container/unordered multimap/insert"> <span class="t-lines"><span>get_allocator</span></span></a></div> </td> <td>Trả về người phân bổ liên quan<span class="t-rev-inl t-since-cxx17"><span>, các trình lặp lại có thể điều chỉnh được</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span> <br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/insert_range" title="cpp/container/unordered multimap/insert range"> <span class="t-lines"><span>thu hẹp_to_fit</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td>Dr*<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/emplace" title="cpp/container/unordered multimap/emplace"> <span class="t-lines"><span>Giảm sử dụng bộ nhớ bằng cách giải phóng bộ nhớ không sử dụng</span></span></a></div> </td> <td>Xóa nội dung<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/emplace_hint" title="cpp/container/unordered multimap/emplace hint"> <span class="t-lines"><span>so sánh</span></span></a></div> </td> <td>(riêng tư)<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/erase" title="cpp/container/unordered multimap/erase"> <span class="t-lines"><span>Prepend_range</span></span></a></div> </td> <td>chèn các yếu tố<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/swap" title="cpp/container/unordered multimap/swap"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>Trả về số lượng phần tử tối đa có thể<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/extract" title="cpp/container/unordered multimap/extract"> <span class="t-lines"><span>Emplace_Hint</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>, với<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/merge" title="cpp/container/unordered multimap/merge"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>(ít nhất là lớn nhất nếu sử dụng so sánh mặc định).<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Lookup">Tra cứu</h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/count" title="cpp/container/unordered multimap/count"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>chèn_or_assign<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/find" title="cpp/container/unordered multimap/find"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>Chèn tại chỗ nếu khóa không tồn tại, không làm gì nếu khóa tồn tại<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/contains" title="cpp/container/unordered multimap/contains"> <span class="t-lines"><span>                           Forwardit2 first2, forwardit2 last2,</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Chèn một phần tử hoặc gán cho phần tử hiện tại nếu khóa đã tồn tại<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/equal_range" title="cpp/container/unordered multimap/equal range"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Bucket_interface">Tất cả chỉ đọc các hoạt động,</h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/begin2" title="cpp/container/unordered multimap/begin2"> <span class="t-lines"><span>bắt đầu<span class="t-dsc-small">Các chức năng hoán đổi không làm mất hiệu lực bất kỳ trình lặp nào bên trong thùng chứa, nhưng chúng làm mất hiệu lực trình lặp đánh dấu đầu cuối của vùng hoán đổi.</span></span><span>cbegin<span class="t-dsc-small">Các chức năng hoán đổi không làm mất hiệu lực bất kỳ trình lặp nào bên trong thùng chứa, nhưng chúng làm mất hiệu lực trình lặp đánh dấu đầu cuối của vùng hoán đổi.</span></span></span></a></div> </td> <td>Chỉ khi nguyên nhân làm lại<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/end2" title="cpp/container/unordered multimap/end2"> <span class="t-lines"><span>kết thúc<span class="t-dsc-small">Các chức năng hoán đổi không làm mất hiệu lực bất kỳ trình lặp nào bên trong thùng chứa, nhưng chúng làm mất hiệu lực trình lặp đánh dấu đầu cuối của vùng hoán đổi.</span></span><span>Cend<span class="t-dsc-small">Các chức năng hoán đổi không làm mất hiệu lực bất kỳ trình lặp nào bên trong thùng chứa, nhưng chúng làm mất hiệu lực trình lặp đánh dấu đầu cuối của vùng hoán đổi.</span></span></span></a></div> </td> <td>Tài liệu tham khảo và con trỏ đến khóa hoặc dữ liệu được lưu trữ trong container chỉ bị vô hiệu hóa bằng cách xóa phần tử đó, ngay cả khi trình lặp tương ứng bị vô hiệu.<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/bucket_count" title="cpp/container/unordered multimap/bucket count"> <span class="t-lines"><span>Một loại lặp có danh mục, giá trị, sự khác biệt, con trỏ và</span></span></a></div> </td> <td>Các loại tham chiếu giống như<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/max_bucket_count" title="cpp/container/unordered multimap/max bucket count"> <span class="t-lines"><span>. Người lặp này</span></span></a></div> </td> <td>có thể được sử dụng để lặp lại thông qua một thùng nhưng không phải trên các thùng<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/bucket_size" title="cpp/container/unordered multimap/bucket size"> <span class="t-lines"><span>Một loại lặp có danh mục, giá trị, sự khác biệt, con trỏ và</span></span></a></div> </td> <td>Các loại tham chiếu giống như<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/bucket" title="cpp/container/unordered multimap/bucket"> <span class="t-lines"><span>. Người lặp này</span></span></a></div> </td> <td>có thể được sử dụng để lặp lại thông qua một thùng nhưng không phải trên các thùng<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Hash_policy">Giao diện xô</h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/load_factor" title="cpp/container/unordered multimap/load factor"> <span class="t-lines"><span>(size_type)</span></span></a></div> </td> <td>(size_type)<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/max_load_factor" title="cpp/container/unordered multimap/max load factor"> <span class="t-lines"><span>Trả về một người lặp về đầu của thùng được chỉ định</span></span></a></div> </td> <td>(size_type)<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/rehash" title="cpp/container/unordered multimap/rehash"> <span class="t-lines"><span>(size_type)</span></span></a></div> </td> <td>trả về một người lặp vào cuối thùng được chỉ định<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/reserve" title="cpp/container/unordered multimap/reserve"> <span class="t-lines"><span>xô_Count</span></span></a></div> </td> <td>Trả về số lượng thùng<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Observers">Quan sát viên</h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/hash_function" title="cpp/container/unordered multimap/hash function"> <span class="t-lines"><span>MAX_Bucket_Count</span></span></a></div> </td> <td>Trả về số lượng thùng tối đa<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/key_eq" title="cpp/container/unordered multimap/key eq"> <span class="t-lines"><span>Xô</span></span></a></div> </td> <td>Trả về số lượng phần tử trong thùng cụ thể<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <h3 id="Non-member_functions">Các chức năng không phải thành viên</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/operator_cmp" title="cpp/container/unordered multimap/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span></span></div> </td> <td>        khóa lớp,<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/swap2" title="cpp/container/unordered multimap/swap2"> <span class="t-lines"><span>chuyên về<span class="t-dsc-small">Thuật toán</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>quá tải<code><a href="../algorithm/swap" title="cpp/algorithm/swap">std::swap</a></code>Thuật toán<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multimap/erase_if" title="cpp/container/unordered multimap/erase if"> <span class="t-lines"><span>thêm một loạt các yếu tố vào đầu<span class="t-dsc-small">Thuật toán</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>pop_front<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <h3 id="Deduction_guides"> <a href="unordered_multimap/deduction_guides" title="cpp/container/unordered multimap/deduction guides">Deduction guides</a>
</h3> </td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <h3 id="Notes">Ghi chú</h3> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../feature_test#cpp_lib_containers_ranges" title="cpp/feature test"><code>__cpp_lib_containers_ranges</code></a></td> <td><span class="nu0">và không trả lại gì.</span></td> <td><span class="t-mark">Phạm vi :: IOTA</span></td> <td>Xóa phần tử đầu tiên</td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2050" rel="nofollow">LWG 2050</a> </td> <td>C ++ 11</td> <td>load_factor<code>reference</code>Thì<code>const_reference</code>Thì<code>pointer</code><br/>Và<code>const_pointer</code>Trả về số lượng phần tử trung bình trên mỗi thùng<code>allocator_type</code> </td> <td>max_load_factor<code>value_type</code>Và<br/><code><a href="../memory/allocator_traits" title="cpp/memory/allocator traits">std::allocator_traits</a></code> </td>
</tr>
</table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/unordered_multimap">https://en.cppreference.com/w/cpp/container/unordered_multimap</a>
</p>
</div>
