 <h1 class="firstHeading" id="firstHeading">std :: stack &lt;t, container&gt; :: stack</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">stack (): stack (container ()) {}</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(2)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx11"> <td><pre data-language="cpp">Ngăn xếp rõ ràng (container const &amp; cont = container ());</pre></td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Ngăn xếp rõ ràng (container const &amp; cont);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">ngăn xếp rõ ràng (container &amp;&amp; cont);</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">ngăn xếp (const Stack &amp; other);</pre>
</td> <td>(4)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">ngăn xếp (ngăn xếp &amp;&amp; khác);</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td><pre data-language="cpp">Mẫu &lt;Class Inputit&gt;</pre></td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Ngăn xếp (đầu vào đầu tiên, đầu vào cuối cùng);</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;Class Alloc&gt;</pre>
</td> <td>            Nhị phân p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">ngăn xếp rõ ràng (const alloc &amp; alloc);</pre>
</td> <td>(9)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;Class Alloc&gt;</pre>
</td> <td>(10)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Ngăn xếp (container const &amp; cont, const alloc &amp; alloc);</pre>
</td> <td>(11)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td><pre data-language="cpp">Mẫu &lt;Class Alloc&gt;</pre></td> <td>(12)</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td> </tr> <tr class="t-dcl t-since-cxx23"> <td><pre data-language="cpp">ngăn xếp (container &amp;&amp; cont, const alloc &amp; alloc);</pre></td> <td>(13)</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td> </tr> <tr class="t-dcl t-since-cxx23"> <td><pre data-language="cpp">Mẫu &lt;Class Alloc&gt;</pre></td> <td>(14)</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td> </tr> </table> <p>Mẫu &lt;Class Alloc&gt;</p>
<div class="t-li1">
<span class="t-li">1)</span>Hàng đợi (const xếp hàng &amp; khác, const alloc &amp; alloc);</div> <div class="t-li1">
<span class="t-li">2)</span>Mẫu &lt;Class Alloc&gt;<code>c</code>Mẫu &lt;Class Alloc&gt;<code>cont</code>.<span class="t-rev-inl t-until-cxx11"><span>ưu tiên_queue (const priority_queue &amp; other, const alloc &amp; alloc);</span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span>
</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Mẫu &lt;Class Alloc&gt;<code>c</code>với<code>std::move(cont)</code>.</div> <div class="t-li1">
<span class="t-li">là trong</span> <a href="../../language/copy_constructor" title="cpp/language/copy constructor">Copy constructor</a>Mẫu &lt;Class Alloc&gt;<code>other.c</code>.<span class="t-mark">(Lưu ý rằng khởi tạo mặc định có thể dẫn đến các giá trị không xác định cho lớp không</span>
</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span> <a href="../../language/move_constructor" title="cpp/language/move constructor">Move constructor</a>Hàng đợi (Hàng đợi &amp;&amp; Khác, Const Alloc &amp; Alloc);<code>std::move(other.c)</code>.<span class="t-mark">(Lưu ý rằng khởi tạo mặc định có thể dẫn đến các giá trị không xác định cho lớp không</span>
</div> <div class="t-li1">
<span class="t-li">từ_sys</span>Mẫu &lt;class inputit, class alloc&gt;<code>c</code>Hàng đợi (đầu vào đầu tiên, đầu vào cuối cùng, const alloc &amp; alloc);<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Thực hiện các hoạt động số học cơ bản giữa hai thời lượng hoặc giữa thời lượng và số lượng đánh dấu.<code>InputIt</code>Phần cuối của phạm vi ban đầu<a href="../../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;phạm vi tương thích container &lt;T&gt; r&gt;</span>Hàng đợi (std :: from_range_t, r &amp;&amp; rg);<code><a href="http://en.cppreference.com/w/cpp/memory/uses_allocator"><span class="kw706">Điều đó cho tất cả<span class="me2">sử dụng_allocator</span></span></a><span class="sy1">is_trivently_destructible_v</span>Container, Alloc<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span></code>khoảng cách<code>true</code>Mẫu &lt;<code>stack</code>).</div> <div class="t-li1">
<span class="t-li">6)</span>Hàm tạo mặc định. Giá trị-khởi đầu hóa bộ so sánh và container cơ bản.<code>alloc</code>. Sao chép lại các functor so sánh<code>c(alloc)</code>.</div> <div class="t-li1">
<span class="t-li">. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu biểu thức</span>Bản sao chép lại<code>cont</code>        sử dụng std :: hoán đổi;<code>alloc</code>. Sao chép lại các functor so sánh<code>c(cont, alloc)</code>.</div> <div class="t-li1">
<span class="t-li">được hình thành tốt. Chương trình không được hình thành nếu</span>Bản sao chép lại<code>cont</code>. Sau đó gọi<code>alloc</code>. Sao chép lại các functor so sánh<code>c(std::move(cont), alloc)</code>.</div> <div class="t-li1">
<span class="t-li">Toán tử bool constexpr&gt; (const std :: Chrono :: sys_time &lt;fending&gt; &amp; x,</span>Hàm tạo mặc định. Giá trị-khởi đầu hóa container.<code>other.c</code>        sử dụng std :: hoán đổi;<code>alloc</code>. Sao chép lại các functor so sánh<code>c(other.c, alloc)</code>.</div> <div class="t-li1">
<span class="t-li">                           const std :: Chrono :: Leap_Second &amp; y) noExcept;</span>Hàm tạo mặc định. Giá trị-khởi đầu hóa container.<code>other</code>. Sau đó gọi<code>alloc</code>. Sao chép lại các functor so sánh<code>c(std::move(other.c), alloc)</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;Lớp thời lượng&gt;</span>. Bộ điều hợp được sao chép bản sao với nội dung của<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>    Count_if (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);<code>alloc</code>. Sao chép lại các functor so sánh<code>c(first, last, alloc)</code>Thực hiện các hoạt động số học cơ bản giữa hai thời lượng hoặc giữa thời lượng và số lượng đánh dấu.<code>InputIt</code>Phần cuối của phạm vi ban đầu<a href="../../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</div> <div class="t-li1">
<span class="t-li">. Di chuyển-constructs</span>Cấu trúc container cơ bản<code><a href="http://en.cppreference.com/w/cpp/ranges/to"><span class="kw3606">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">ĐẾN</span></span></a><span class="sy1">is_trivently_destructible_v</span>Container<span class="sy1">&lt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">&lt;</span><span class="br0">.</span>rg<span class="br0">)</span><span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">Các hàm tạo cặp lặp mở rộng phân bổ. Giống như</span>Cấu trúc container cơ bản<code><a href="http://en.cppreference.com/w/cpp/ranges/to"><span class="kw3606">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">ĐẾN</span></span></a><span class="sy1">is_trivently_destructible_v</span>Container<span class="sy1">&lt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">&lt;</span><span class="br0">.</span>rg<span class="br0">)</span>, alloc<span class="br0">)</span></code>.</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Sử dụng ngữ nghĩa di chuyển. Người phân bổ có được bằng cách xây dựng di chuyển từ bộ phân bổ thuộc</td> <td>-</td> <td>Là người phân bổ. Gọi một cách hiệu quả</td>
</tr> <tr class="t-par"> <td>khác</td> <td>-</td> <td>. Bản sao chép lại</td>
</tr> <tr class="t-par"> <td>Xây dựng các thùng chứa cơ bản với nội dung của</td> <td>-</td> <td>như người phân bổ, như thể bằng cách</td>
</tr> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>với nội dung của phạm vi<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>7-12)</td>
</tr> <tr class="t-par"> <td>được hủy bỏ chính xác một lần.</td> <td>-</td> <td>Một<a href="../../ranges/to#container_compatible_range" title="cpp/ranges/to">container compatible range</a>RG<a href="../../ranges/input_range" title="cpp/ranges/input range"><code>input_range</code></a>, đó là, một<code>T</code> </td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>Alloc</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/allocator" title="cpp/named req/Allocator">Allocator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>Container</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/container" title="cpp/named req/Container">Container</a>Các hàm tạo này chỉ tham gia vào độ phân giải quá tải nếu<code>Container</code>. Tuy nhiên, hoạt động hiệu quả hơn nếu<a href="../../named_req/allocatorawarecontainer" title="cpp/named req/AllocatorAwareContainer">AllocatorAwareContainer</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>InputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</td>
</tr>
</table> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>, nghĩa là, nếu thùng chứa cơ bản là một thùng chứa nhận thức phân bổ (đúng với tất cả các thùng chứa thư viện tiêu chuẩn có thể được sử dụng với</p>
<h3 id="Notes">Ghi chú</h3> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../../feature_test#cpp_lib_adaptor_iterator_pair_constructor" title="cpp/feature test"><code>__cpp_lib_adaptor_iterator_pair_constructor</code></a></td> <td><span class="nu0">Chỉ giải thích*</span></td> <td><span class="t-mark">Phạm vi :: IOTA</span></td> <td>Trình xây dựng cặp vòng lặp cho<code><a href="../queue" title="cpp/container/queue">std::queue</a></code>Và<code><a href="../stack" title="cpp/container/stack">std::stack</a></code>. Nếu không tìm thấy yếu tố như vậy, quá khứ (xem<span class="t-v">.<a href="#Version_6">6</a>)</span>Và<span class="t-v">.<a href="#Version_12">12</a>)</span> </td>
</tr> <tr> <td><a href="../../feature_test#cpp_lib_containers_ranges" title="cpp/feature test"><code>__cpp_lib_containers_ranges</code></a></td> <td><span class="nu0">và không trả lại gì.</span></td> <td><span class="t-mark">Phạm vi :: IOTA</span></td> <td>
<a href="../../ranges/to#container_compatible_range" title="cpp/ranges/to">Ranges-aware</a>đối tượng chức năng so sánh để sử dụng cho tất cả các so sánh của các khóa<span class="t-v">.<a href="#Version_13">13</a>)</span>Và<span class="t-v">.<a href="#Version_14">14</a>)</span> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">ngăn xếp (const Stack &amp; other, const alloc &amp; alloc);</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/P0935R0" rel="nofollow">P0935R0</a> </td> <td>C ++ 11</td> <td>Xây dựng bộ điều hợp với nội dung của</td> <td>3,5,12)</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="operator=" title="cpp/container/stack/operator="> <span class="t-lines"><span>chuyên môn)</span></span></a></div> </td> <td>đối tượng của loại<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/stack/stack">https://en.cppreference.com/w/cpp/container/stack/stack</a>
</p>
</div>
