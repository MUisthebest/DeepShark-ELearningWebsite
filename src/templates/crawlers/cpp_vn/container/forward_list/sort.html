 <h1 class="firstHeading" id="firstHeading">std :: forward_list &lt;t, allocator&gt; :: sort</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">void sort ();</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;class so sánh&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> </table> <p>void sort (so sánh comp);</p>
<div class="t-li1">
<span class="t-li">1)</span>Chuyển tiếp adjacent_find (forwardit first, forwardit cuối cùng, nhị phân p);<code>operator&lt;</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>Chuyển tiếp adjacent_find (forwardit first, forwardit cuối cùng, nhị phân p);<code>comp</code>.</div> <p>Sắp xếp các yếu tố và bảo tồn thứ tự của các yếu tố tương đương. Không có tài liệu tham khảo hoặc lặp lại trở nên vô hiệu.<code>*this</code>Mẫu &lt;Class Randomit, Class So sánh&gt;</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>sau đó</td> <td>-</td> <td>LO, xin chào<a href="../../named_req/compare" title="cpp/named req/Compare">Compare</a>Constexpr bool bao gồm (đầu vào đầu tiên1, đầu vào1, last1,<code>true</code>cũng là<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>                         Inputit2 First2, Inputit2 Last2, so sánh comp);<i>Mẫu &lt;Class execPolicy, class forwardit1, class forwardit2,</i>          Lớp so sánh&gt;<br/> <p>Hàm so sánh trả về giá trị số nguyên âm nếu đối số đầu tiên là</p>
<p><span class="t-cc"><code>bool cmp(const Type1&amp; a, const Type2&amp; b);</code></span></p>
<p>&gt;&gt;<span class="kw4">hằng số</span><span class="sy3">Không có giá trị</span>is_execut_policy_v<code>Type1</code>Và<code>Type2</code>Remove_cvref_t<a href="../../language/value_category" title="cpp/language/value category">value category</a>&gt;&gt;<code>Type1&amp;</code>phạm vi của các yếu tố để kiểm tra<span class="t-rev-inl t-since-cxx11"><span>P<code>Type1</code>vị từ nhị phân trả về<code>Type1</code>Nếu các yếu tố nên được coi là bằng nhau.</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>).<br/>không được sắp xếp với người so sánh tương ứng hoặc<span class="sy1">is_trivently_destructible_v</span>Nếu một ngoại lệ được ném, thứ tự của các yếu tố trong<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">const_iterator</span>T,</p>
</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>Compare</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/compare" title="cpp/named req/Compare">Compare</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Gán cho đã cho</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>. Thuật toán bản sao này ổn định: Thứ tự tương đối của các yếu tố được sao chép được bảo tồn.<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>begin<span class="br0">.</span><span class="br0">)</span>, end<span class="br0">.</span><span class="br0">)</span><span class="br0">)</span></code>:</p>
<div class="t-li1">
<span class="t-li">1)</span>T, phân bổ<code>operator&lt;</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>Xấp xỉ \ (\ scriptsize n \ cdot log (n) \) n · log (n) so sánh bằng cách sử dụng<code>comp</code>.</div> <h3 id="Notes">Ghi chú</h3> <p><code><a href="../../algorithm/sort" title="cpp/algorithm/sort">std::sort</a></code>Xấp xỉ \ (\ scriptsize n \ cdot log (n) \) n · log (n) Ứng dụng của hàm so sánh<code>forward_list</code>yêu cầu các trình lặp lại truy cập ngẫu nhiên và do đó không thể được sử dụng với<code><a href="../../algorithm/sort" title="cpp/algorithm/sort">std::sort</a></code>. Chức năng này cũng khác với<code>forward_list</code>ở đó nó không yêu cầu loại phần tử của</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Để được trao đổi, bảo tồn các giá trị của tất cả các trình lặp và thực hiện một loại ổn định.</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">#include &lt;Timoning_list&gt;</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="reverse" title="cpp/container/forward list/reverse"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>xây dựng các phần tử tại chỗ sau một phần tử<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/forward_list/sort">https://en.cppreference.com/w/cpp/container/forward_list/sort</a>
</p>
</div>
