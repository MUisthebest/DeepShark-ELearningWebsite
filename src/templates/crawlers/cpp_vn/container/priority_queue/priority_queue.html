 <h1 class="firstHeading" id="firstHeading">std :: ưu tiên_queue &lt;t, container, so sánh&gt; :: ưu tiên_queue</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">ưu tiên_queue (): ưu tiên_queue (so sánh (), container ()) {}</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Rõ ràng ưu tiên_queue (const so sánh &amp; so sánh)</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(3)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx11"> <td><pre data-language="cpp">    : ưu tiên_queue (so sánh, container ()) {}</pre></td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Rõ ràng ưu tiên_queue (const so sánh &amp; so sánh = so sánh (),</pre>
</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">                         container container &amp; cont = container ());</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">ưu tiên_queue (const so sánh &amp; so sánh, container conts &amp; cont);</pre>
</td> <td>             Không có p);</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">ưu tiên_queue (const so sánh &amp; so sánh, container &amp;&amp; cont);</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Ưu tiên_Queue (Const Priority_queue &amp; Khác);</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">            Nhị phân p);</td> <td></td> </tr> <tr class="t-dcl t-until-cxx11"> <td><pre data-language="cpp">ưu tiên_queue (ưu tiên_queue &amp;&amp; khác);</pre></td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;Class Inputit&gt;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">ưu tiên_queue (đầu vào đầu tiên, đầu vào cuối cùng,</pre>
</td> <td>(9)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">                const so sánh &amp; so sánh = so sánh ());</pre>
</td> <td>(10)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;Class Inputit&gt;</pre>
</td> <td>(11)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">ưu tiên_queue (đầu vào đầu tiên, đầu vào cuối cùng,</pre>
</td> <td>(12)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">                const so sánh &amp; so sánh = so sánh (),</pre>
</td> <td>(13)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">                container container &amp; cont = container ());</pre>
</td> <td>(14)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;Class Inputit&gt;</pre>
</td> <td>(15)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">ưu tiên_queue (đầu vào đầu tiên, đầu vào cuối cùng,</pre>
</td> <td>(16)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">                const so sánh &amp; so sánh, container const &amp; cont);</pre>
</td> <td>Nhà điều hành Auto Auto của Const</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;Class Inputit&gt;</pre>
</td> <td>    -&gt; std :: Chrono :: tháng_day_last;</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">ưu tiên_queue (đầu vào đầu tiên, đầu vào cuối cùng,</pre>
</td> <td>    -&gt; std :: Chrono :: tháng_day_last;</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td><pre data-language="cpp">                const so sánh &amp; so sánh, container &amp;&amp; cont);</pre></td> <td>                          const std :: Chrono :: tháng &amp; m) Noexcept</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">Mẫu &lt;Class Alloc&gt;</pre>
</td> <td>Toán tử Auto Auto của Const</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">ưu tiên rõ ràng_queue (const alloc &amp; alloc);</pre>
</td> <td>Nhà điều hành Auto Auto của Const</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> </table> <p>Mẫu &lt;Class Alloc&gt;</p>
<div class="t-li1">
<span class="t-li">1)</span>ưu tiên_queue (const so sánh &amp; so sánh, const alloc &amp; alloc);</div> <div class="t-li1">
<span class="t-li">2)</span>Mẫu &lt;Class Alloc&gt;<code>comp</code>Mẫu &lt;Class Alloc&gt;<code>compare</code>                const alloc &amp; alloc);<code>c</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Mẫu &lt;Class Alloc&gt;<code>c</code>Mẫu &lt;Class Alloc&gt;<code>cont</code>ưu tiên_queue (ưu tiên_queue &amp;&amp; other, const alloc &amp; alloc);<code>comp</code>Mẫu &lt;Class Alloc&gt;<code>compare</code>               NOExcept (/ * Xem bên dưới */);<code><a href="http://en.cppreference.com/w/cpp/algorithm/make_heap"><span class="kw1640">Điều đó cho tất cả<span class="me2">(Niebloid)</span></span></a><span class="br0">.</span>c.<span class="me1">bắt đầu</span><span class="br0">.</span><span class="br0">)</span>, c.<span class="me1">kết thúc</span><span class="br0">.</span><span class="br0">)</span>, comp<span class="br0">)</span></code>.<span class="t-rev-inl t-until-cxx11"><span>ưu tiên_queue (const priority_queue &amp; other, const alloc &amp; alloc);</span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span>
</div> <div class="t-li1">
<span class="t-li">là trong</span>Mẫu &lt;Class Alloc&gt;<code>c</code>với<code>std::move(cont)</code>ưu tiên_queue (ưu tiên_queue &amp;&amp; other, const alloc &amp; alloc);<code>comp</code>với<code>compare</code>               NOExcept (/ * Xem bên dưới */);<code><a href="http://en.cppreference.com/w/cpp/algorithm/make_heap"><span class="kw1640">Điều đó cho tất cả<span class="me2">(Niebloid)</span></span></a><span class="br0">.</span>c.<span class="me1">bắt đầu</span><span class="br0">.</span><span class="br0">)</span>, c.<span class="me1">kết thúc</span><span class="br0">.</span><span class="br0">)</span>, comp<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span> <a href="../../language/copy_constructor" title="cpp/language/copy constructor">Copy constructor</a>Mẫu &lt;class inputit, class alloc&gt;<code>other.c</code>ưu tiên_queue (đầu vào đầu tiên, đầu vào cuối cùng, const alloc &amp; alloc);<code>other.comp</code>.<span class="t-mark">(Lưu ý rằng khởi tạo mặc định có thể dẫn đến các giá trị không xác định cho lớp không</span>
</div> <div class="t-li1">
<span class="t-li">từ_sys</span> <a href="../../language/move_constructor" title="cpp/language/move constructor">Move constructor</a>Mẫu &lt;class inputit, class alloc&gt;<code>std::move(other.c)</code>ưu tiên_queue (đầu vào đầu tiên, đầu vào cuối cùng, const so sánh &amp; so sánh,<code>std::move(other.comp)</code>.<span class="t-mark">(Lưu ý rằng khởi tạo mặc định có thể dẫn đến các giá trị không xác định cho lớp không</span>
</div> <div class="t-li1">
<span class="t-li">ưu tiên_queue (đầu vào, đầu vào, alloc)</span>                const alloc &amp; alloc);<code>InputIt</code>Phần cuối của phạm vi ban đầu<a href="../../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</div> <div class="t-li1">
<span class="t-li">6)</span>Mẫu &lt;class inputit, class alloc&gt;<code>c</code>Mẫu &lt;Class T&gt;<code>c(first, last)</code>Và<code>comp</code>từ<code>compare</code>Là người phân bổ. Gọi một cách hiệu quả<code><a href="http://en.cppreference.com/w/cpp/algorithm/make_heap"><span class="kw1640">Điều đó cho tất cả<span class="me2">(Niebloid)</span></span></a><span class="br0">.</span>c.<span class="me1">bắt đầu</span><span class="br0">.</span><span class="br0">)</span>, c.<span class="me1">kết thúc</span><span class="br0">.</span><span class="br0">)</span>, comp<span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>.</div> <div class="t-li1">
<span class="t-li">. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu biểu thức</span>                container const &amp; cont, const alloc &amp; alloc);<code>c</code>từ<code>cont</code>Và<code>comp</code>từ<code>compare</code>Là người phân bổ. Gọi một cách hiệu quả<code>c.insert(c.end(), first, last);</code>                const so sánh &amp; so sánh = so sánh ());<code><a href="http://en.cppreference.com/w/cpp/algorithm/make_heap"><span class="kw1640">Điều đó cho tất cả<span class="me2">(Niebloid)</span></span></a><span class="br0">.</span>c.<span class="me1">bắt đầu</span><span class="br0">.</span><span class="br0">)</span>, c.<span class="me1">kết thúc</span><span class="br0">.</span><span class="br0">)</span>, comp<span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>.</div> <div class="t-li1">
<span class="t-li">được hình thành tốt. Chương trình không được hình thành nếu</span>                Container &amp;&amp; cont, const alloc &amp; alloc);<code>c</code>từ<code>std::move(cont)</code>Mẫu &lt;<code>comp</code>từ<code>compare</code>Là người phân bổ. Gọi một cách hiệu quả<code>c.insert(c.end(), first, last);</code>                const so sánh &amp; so sánh = so sánh ());<code><a href="http://en.cppreference.com/w/cpp/algorithm/make_heap"><span class="kw1640">Điều đó cho tất cả<span class="me2">(Niebloid)</span></span></a><span class="br0">.</span>c.<span class="me1">bắt đầu</span><span class="br0">.</span><span class="br0">)</span>, c.<span class="me1">kết thúc</span><span class="br0">.</span><span class="br0">)</span>, comp<span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;</span>ưu tiên_queue (std :: from_range_t, r &amp;&amp; rg,<code><a href="http://en.cppreference.com/w/cpp/memory/uses_allocator"><span class="kw706">Điều đó cho tất cả<span class="me2">sử dụng_allocator</span></span></a><span class="sy1">is_trivently_destructible_v</span>container_type, Alloc<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span></code>khoảng cách<code>true</code>                const so sánh &amp; so sánh, const alloc &amp; alloc);</div> <div class="t-li1">
<span class="t-li">Toán tử bool constexpr&gt; (const std :: Chrono :: sys_time &lt;fending&gt; &amp; x,</span>Hàm tạo mặc định. Giá trị-khởi đầu hóa bộ so sánh và container cơ bản.<code>alloc</code>, và sau đó gọi<code>c(alloc)</code>.<code>comp</code>Xây dựng container cơ bản mới của bộ điều hợp container từ nhiều nguồn dữ liệu khác nhau.</div> <div class="t-li1">
<span class="t-li">                           const std :: Chrono :: Leap_Second &amp; y) noExcept;</span>Hàm tạo mặc định. Giá trị-khởi đầu hóa bộ so sánh và container cơ bản.<code>alloc</code>, và sau đó gọi<code>c(alloc)</code>Xây dựng<code>comp</code>từ<code>compare</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;Lớp thời lượng&gt;</span>Bản sao chép lại<code>cont</code>        sử dụng std :: hoán đổi;<code>alloc</code>. Sao chép lại các functor so sánh<code>c(cont, alloc)</code>Xây dựng<code>comp</code>từ<code>compare</code>Là người phân bổ. Gọi một cách hiệu quả<code><a href="http://en.cppreference.com/w/cpp/algorithm/make_heap"><span class="kw1640">Điều đó cho tất cả<span class="me2">(Niebloid)</span></span></a><span class="br0">.</span>c.<span class="me1">bắt đầu</span><span class="br0">.</span><span class="br0">)</span>, c.<span class="me1">kết thúc</span><span class="br0">.</span><span class="br0">)</span>, comp<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">. Di chuyển-constructs</span>Bản sao chép lại<code>cont</code>Di chuyển-xây dựng container bên dưới<code>alloc</code>. Sao chép lại các functor so sánh<code>c(std::move(cont), alloc)</code>Xây dựng<code>comp</code>từ<code>compare</code>Là người phân bổ. Gọi một cách hiệu quả<code><a href="http://en.cppreference.com/w/cpp/algorithm/make_heap"><span class="kw1640">Điều đó cho tất cả<span class="me2">(Niebloid)</span></span></a><span class="br0">.</span>c.<span class="me1">bắt đầu</span><span class="br0">.</span><span class="br0">)</span>, c.<span class="me1">kết thúc</span><span class="br0">.</span><span class="br0">)</span>, comp<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">Các hàm tạo cặp lặp mở rộng phân bổ. Giống như</span>Bản sao chép lại<code>other.c</code>        sử dụng std :: hoán đổi;<code>alloc</code>, và sau đó gọi<code>c(other.c, alloc)</code>Xây dựng<code>comp</code>từ<code>other.comp</code>.</div> <div class="t-li1">
<span class="t-li">, ngoại trừ điều đó</span>Bản sao chép lại<code>other</code>. Sau đó gọi<code>alloc</code>, và sau đó gọi<code>c(std::move(other.c), alloc)</code>Di chuyển-constructs<code>comp</code>từ<code>other.comp</code>.</div> <div class="t-li1">
<span class="t-li">và sao chép-xây dựng</span>. Sau đó gọi<span class="t-v">Mẫu &lt;class inputit, class comp, class alloc&gt;</span>, và sau đó gọi<code>alloc</code>10-15)<code><a href="http://en.cppreference.com/w/cpp/memory/uses_allocator"><span class="kw706">Điều đó cho tất cả<span class="me2">sử dụng_allocator</span></span></a><span class="sy1">is_trivently_destructible_v</span>container_type, Alloc<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span></code>khoảng cách<code>true</code>Và<code>InputIt</code>Phần cuối của phạm vi ban đầu<a href="../../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</div> <div class="t-li1">
<span class="t-li">Nhà điều hành Auto Auto của Const</span>Khởi tạo<code>comp</code>với<code>compare</code>Và<code>c</code>với<code><a href="http://en.cppreference.com/w/cpp/ranges/to"><span class="kw3606">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">ĐẾN</span></span></a><span class="sy1">is_trivently_destructible_v</span>Container<span class="sy1">&lt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">&lt;</span><span class="br0">.</span>rg<span class="br0">)</span><span class="br0">)</span></code>Là người phân bổ. Gọi một cách hiệu quả<code><a href="http://en.cppreference.com/w/cpp/algorithm/make_heap"><span class="kw1640">Điều đó cho tất cả<span class="me2">(Niebloid)</span></span></a><span class="br0">.</span>c.<span class="me1">bắt đầu</span><span class="br0">.</span><span class="br0">)</span>, c.<span class="me1">kết thúc</span><span class="br0">.</span><span class="br0">)</span>, comp<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">                          const std :: Chrono :: weekday_indexed &amp; wdi) NoExcept</span>Khởi tạo<code>comp</code>với<code>compare</code>Và<code>c</code>với<code><a href="http://en.cppreference.com/w/cpp/ranges/to"><span class="kw3606">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">ĐẾN</span></span></a><span class="sy1">is_trivently_destructible_v</span>Container<span class="sy1">&lt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">&lt;</span><span class="br0">.</span>rg<span class="br0">)</span>, alloc<span class="br0">)</span></code>Là người phân bổ. Gọi một cách hiệu quả<code><a href="http://en.cppreference.com/w/cpp/algorithm/make_heap"><span class="kw1640">Điều đó cho tất cả<span class="me2">(Niebloid)</span></span></a><span class="br0">.</span>c.<span class="me1">bắt đầu</span><span class="br0">.</span><span class="br0">)</span>, c.<span class="me1">kết thúc</span><span class="br0">.</span><span class="br0">)</span>, comp<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">Cấu trúc container cơ bản bằng cách sử dụng</span>Khởi tạo<code>c</code>với<code><a href="http://en.cppreference.com/w/cpp/ranges/to"><span class="kw3606">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">ĐẾN</span></span></a><span class="sy1">is_trivently_destructible_v</span>Container<span class="sy1">&lt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">&lt;</span><span class="br0">.</span>rg<span class="br0">)</span>, alloc<span class="br0">)</span></code>Là người phân bổ. Gọi một cách hiệu quả<code><a href="http://en.cppreference.com/w/cpp/algorithm/make_heap"><span class="kw1640">Điều đó cho tất cả<span class="me2">(Niebloid)</span></span></a><span class="br0">.</span>c.<span class="me1">bắt đầu</span><span class="br0">.</span><span class="br0">)</span>, c.<span class="me1">kết thúc</span><span class="br0">.</span><span class="br0">)</span>, comp<span class="br0">)</span></code>.</div> <p>được cung cấp giá trị.<a href="../../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>Cấu trúc container cơ bản bằng cách sử dụng</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Sử dụng ngữ nghĩa di chuyển. Người phân bổ có được bằng cách xây dựng di chuyển từ bộ phân bổ thuộc</td> <td>-</td> <td>Là người phân bổ. Gọi một cách hiệu quả</td>
</tr> <tr class="t-par"> <td>khác</td> <td>-</td> <td>. Bản sao chép lại</td>
</tr> <tr class="t-par"> <td>Xây dựng các thùng chứa cơ bản với nội dung của</td> <td>-</td> <td>như người phân bổ, như thể bằng cách</td>
</tr> <tr class="t-par"> <td>so sánh các đối tượng thuộc loại</td> <td>-</td> <td>. Bản sao chép lại</td>
</tr> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>. Sau đó gọi<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>13)</td>
</tr> <tr class="t-par"> <td>được hủy bỏ chính xác một lần.</td> <td>-</td> <td>Một<a href="../../ranges/to#container_compatible_range" title="cpp/ranges/to">container compatible range</a>RG<a href="../../ranges/input_range" title="cpp/ranges/input range"><code>input_range</code></a>, đó là, một<code>T</code> </td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>Alloc</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/allocator" title="cpp/named req/Allocator">Allocator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>Compare</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/compare" title="cpp/named req/Compare">Compare</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>Container</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/container" title="cpp/named req/Container">Container</a>Xây dựng các thùng chứa cơ bản với nội dung của<code>Container</code>. Tuy nhiên, hoạt động hiệu quả hơn nếu<a href="../../named_req/allocatorawarecontainer" title="cpp/named req/AllocatorAwareContainer">AllocatorAwareContainer</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>InputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</td>
</tr>
</table> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <div class="t-li1">
<span class="t-li">Đầu vào</span>trình rút vào các yếu tố để hoán đổi</div> <div class="t-li1">
<span class="t-li">sử dụng ngữ nghĩa di chuyển trong khi sử dụng</span>Bộ điều hợp container khác được sử dụng làm nguồn để khởi tạo container bên dưới<code>value_type</code>cont<code>cont.size()</code>.</div> <div class="t-li1">
<span class="t-li">là trong</span>16-19)<code>cont.size()</code>.</div> <div class="t-li1">
<span class="t-li">từ_sys</span>trình rút vào các yếu tố để hoán đổi</div> <div class="t-li1">
<span class="t-li">14)</span>Xây dựng các thùng chứa cơ bản với nội dung của<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">Là người phân bổ. Gọi một cách hiệu quả</span>. Bản sao chép lại<code>value_type</code>cont<code>cont.size()</code>người phân bổ sử dụng cho tất cả các phân bổ bộ nhớ của thùng chứa cơ bản<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">được hình thành tốt. Chương trình không được hình thành nếu</span>sử dụng ngữ nghĩa di chuyển trong khi sử dụng<code>cont.size()</code>người phân bổ sử dụng cho tất cả các phân bổ bộ nhớ của thùng chứa cơ bản<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">Xây dựng một thùng chứa trống.</span>trình rút vào các yếu tố để hoán đổi</div> <div class="t-li1">
<span class="t-li">. Di chuyển-constructs</span>16-19)<code>cont.size()</code>.</div> <div class="t-li1">
<span class="t-li">Các hàm tạo cặp lặp mở rộng phân bổ. Giống như</span>các yếu tố có thể chuyển đổi thành<code>other</code>.</div> <div class="t-li1">
<span class="t-li">, ngoại trừ điều đó</span>Toán tử bool &lt;(const std :: deque &lt;t, alloc&gt; &amp; lhs,<code>Alloc</code>được sử dụng để xây dựng container bên dưới. Những quá tải này chỉ tham gia vào độ phân giải quá tải nếu<code>other</code>. Sau đó gọi<code>other</code>Nếu đối số đầu tiên là</div> <div class="t-li1">
<span class="t-li">. Sau đó gọi</span>22)<code>value_type</code>. Sau đó gọi<code>Alloc</code>Lưu ý rằng cách triển khai kiểm tra xem một loại có thỏa mãn<code>other</code>không xác định, ngoại trừ các loại tích phân được yêu cầu bị từ chối.<code>cont.size()</code>người phân bổ sử dụng cho tất cả các phân bổ bộ nhớ của thùng chứa cơ bản<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">Nhà điều hành Auto Auto của Const</span>Bộ điều hợp container khác được sử dụng làm nguồn để khởi tạo container bên dưới<code>value_type</code>cont<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3142">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>rg<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">container được sử dụng làm nguồn để khởi tạo container bên dưới</span> </div> <h3 id="Notes">Ghi chú</h3> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../../feature_test#cpp_lib_containers_ranges" title="cpp/feature test"><code>__cpp_lib_containers_ranges</code></a></td> <td><span class="nu0">và không trả lại gì.</span></td> <td><span class="t-mark">Phạm vi :: IOTA</span></td> <td>
<a href="../../ranges/to#container_compatible_range" title="cpp/ranges/to">Ranges-aware</a>đối tượng chức năng so sánh để sử dụng cho tất cả các so sánh của các khóa<span class="t-v">.<a href="#Version_20">20-22</a>)</span> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">đối tượng hàm so sánh để khởi tạo chức năng so sánh cơ bản</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">một phạm vi</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/P0935R0" rel="nofollow">P0935R0</a> </td> <td>C ++ 11</td> <td>các yếu tố để khởi tạo với<span class="t-v">(4)</span>. Các hàm tạo phân cấp mở rộng chỉ được xác định nếu</td> <td>3,5,12)</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3506" rel="nofollow">LWG 3506</a> </td> <td>C ++ 11</td> <td>\ (\ scriptsize \ mathcal {o} {(n)} \) o (n) so sánh và \ (\ scriptsize \ mathcal</td> <td>Được cho</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3522" rel="nofollow">LWG 3522</a> </td> <td>C ++ 11</td> <td>, trong đó \ (\ scriptsize n \) n là</td> <td>Được cho</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3529" rel="nofollow">LWG 3529</a> </td> <td>C ++ 11</td> <td>\ (\ scriptsize \ mathcal {o} {(n)} \) o (n) so sánh, trong đó \ (\ scriptsize n \)<code>insert</code> </td> <td>7,16,17)</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="operator=" title="cpp/container/priority queue/operator="> <span class="t-lines"><span>chuyên môn)</span></span></a></div> </td> <td>đối tượng của loại<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/priority_queue/priority_queue">https://en.cppreference.com/w/cpp/container/priority_queue/priority_queue</a>
</p>
</div>
