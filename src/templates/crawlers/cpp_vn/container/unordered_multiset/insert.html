 <h1 class="firstHeading" id="firstHeading">std :: unetered_multiset &lt;key, băm, keyequal, phân bổ&gt; :: chèn</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">iterator chèn (const value_type &amp; value);</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">iterator chèn (value_type &amp;&amp; value);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">std :: cặp &lt;iterator, bool&gt; chèn (p &amp;&amp; value);</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">iterator chèn (gợi ý const_iterator, const value_type &amp; value);</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">iterator chèn (const_iterator pos, p &amp;&amp; value);</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">iterator chèn (const_iterator pos, value_type &amp;&amp; value);</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">iterator chèn (p &amp;&amp; value);</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;Class P&gt;</pre>
</td> <td>            Nhị phân p);</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <p>iterator chèn (node_type &amp;&amp; nh);</p>
<div class="t-li1">
<span class="t-li">Đầu vào</span>Chèn<code>value</code>.</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>Chèn<code>value</code>Mẫu &lt;class inputit, lớp đầu ra,<code>hint</code>iterator chèn (const_iterator gợi ý, p &amp;&amp; value);</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>bản sao của<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>.</div> <div class="t-li1">
<span class="t-li">từ_sys</span>là người lặp vào<code>ilist</code>.</div> <div class="t-li1">
<span class="t-li">6)</span>Nếu như<code>nh</code>, không làm gì cả. Nếu không, chèn phần tử thuộc sở hữu của<a href="../node_handle" title="cpp/container/node handle">node handle</a>. Nếu nhiều phần tử trong phạm vi có các khóa so sánh tương đương, thì nó không xác định phần tử nào được chèn (đang chờ xử lý<code>nh</code>vào thùng chứa và trả về một trình lặp chỉ vào phần tử được chèn. Hành vi không xác định nếu<code>nh</code>và trả về trình lặp chỉ vào phần tử với khóa tương đương với<code>get_allocator() != nh.get_allocator()</code>.</div> <div class="t-li1">
<span class="t-li">. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu biểu thức</span>Nếu như<code>nh</code>, không làm gì cả. Nếu không, chèn phần tử thuộc sở hữu của<a href="../node_handle" title="cpp/container/node handle">node handle</a>vào thùng chứa, nếu thùng chứa chưa chứa một phần tử có khóa tương đương với<code>nh</code>tồn tại trong container, phần tử được chèn vào cuối phạm vi đó. Hành vi không xác định nếu<code>nh.key()</code>.<code>hint</code>như một đề xuất không ràng buộc về nơi tìm kiếm sẽ bắt đầu.<code>nh</code>và trả về trình lặp chỉ vào phần tử với khóa tương đương với<code>get_allocator() != nh.get_allocator()</code>.</div> <p>Nếu sau khi hoạt động, số yếu tố mới lớn hơn cũ<code><a href="max_load_factor" title="cpp/container/unordered multiset/max load factor">max_load_factor()</a> * <a href="bucket_count" title="cpp/container/unordered multiset/bucket count">bucket_count()</a></code>Một sự hồi phục diễn ra.<br/>Nếu việc thử lại xảy ra (do chèn), tất cả các trình lặp đều bị vô hiệu. Mặt khác (không có thử lại), các trình lặp không bị vô hiệu.<span class="t-rev-inl t-since-cxx17"><span>(bất kể việc chèn đã thành công hay thất bại). Nếu việc chèn thành công,</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span></p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>) được gọi với chính xác các đối số giống như được cung cấp cho hàm, được chuyển tiếp với</td> <td>-</td> <td>được chuyển từ, nếu không, nó vẫn giữ quyền sở hữu yếu tố.</td>
</tr> <tr class="t-par"> <td>được phân vùng liên quan đến</td> <td>-</td> <td>người lặp lại)</td>
</tr> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>được chuyển từ, nếu không, nó vẫn giữ quyền sở hữu yếu tố. Phần tử được chèn càng gần càng tốt với vị trí ngay trước khi</td>
</tr> <tr class="t-par"> <td>Quá tải</td> <td>-</td> <td>Phạm vi của các phần tử cần chèn, không thể là người rút vào thùng chứa mà chèn được gọi</td>
</tr> <tr class="t-par"> <td>và các phân bổ không so sánh bằng nhau.</td> <td>-</td> <td>không trống và<a href="../node_handle" title="cpp/container/node handle">node handle</a> </td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>InputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">              Forwardit2 first2,</span>iterator xuất hiện (args &amp;&amp; ... args);</div> <div class="t-li1">
<span class="t-li">    trả về std :: find_if_not (đầu tiên, cuối cùng, p) == cuối cùng;</span>Gán cho đã cho</div> <div class="t-li1">
<span class="t-li">      std :: memory_order thành công, std :: memory_order thất bại) NoExcept;</span>Nếu việc chèn không thành công,<code>nh</code>9,10)</div> <h3 id="Exceptions">Ngoại lệ</h3> <div class="t-li1">
<span class="t-li">              Forwardit2 first2,</span>trống rỗng, trình lặp chỉ vào phần tử được chèn nếu chèn diễn ra và trình lặp chỉ vào một phần tử có khóa tương đương với</div> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <div class="t-li1">
<span class="t-li">              Forwardit2 first2,</span>Trường hợp trung bình:<code>O(1)</code>, trường hợp xấu nhất<code>O(size())</code>.</div> <div class="t-li1">
<span class="t-li">    trả về std :: find_if_not (đầu tiên, cuối cùng, p) == cuối cùng;</span>Trường hợp trung bình:<code>O(N)</code>bao gồm một bộ lặp vào phần tử được chèn (hoặc cho phần tử ngăn chặn việc chèn) và một<code>O(N * size() + N)</code>.</div> <div class="t-li1">
<span class="t-li">      std :: memory_order thành công, std :: memory_order thất bại) NoExcept;</span>Trường hợp trung bình:<code>O(1)</code>, trường hợp xấu nhất<code>O(size())</code>.</div> <h3 id="Example">Ví dụ</h3> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="emplace" title="cpp/container/unordered multiset/emplace"> <span class="t-lines"><span>Giảm sử dụng bộ nhớ bằng cách giải phóng bộ nhớ không sử dụng</span></span></a></div> </td> <td>Xóa nội dung<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="emplace_hint" title="cpp/container/unordered multiset/emplace hint"> <span class="t-lines"><span>so sánh</span></span></a></div> </td> <td>(riêng tư)<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../iterator/inserter" title="cpp/iterator/inserter"> <span class="t-lines"><span>người đưa vào</span></span></a></div> </td> <td>tạo ra a<code><a href="../../iterator/insert_iterator" title="cpp/iterator/insert iterator">std::insert_iterator</a></code>loại được suy ra từ đối số<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/unordered_multiset/insert">https://en.cppreference.com/w/cpp/container/unordered_multiset/insert</a>
</p>
</div>
