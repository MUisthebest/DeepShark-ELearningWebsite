 <h1 class="firstHeading" id="firstHeading">std :: map &lt;key, t, so sánh, phân bổ&gt; :: chèn</h1> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">std :: cặp &lt;iterator, bool&gt; chèn (const value_type &amp; value);</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;Class P&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">std :: cặp &lt;iterator, bool&gt; chèn (p &amp;&amp; value);</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(4)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx11"> <td> <pre data-language="cpp">std :: cặp &lt;iterator, bool&gt; chèn (value_type &amp;&amp; value);</pre>
</td> <td> <span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">iterator chèn (iterator pos, const value_type &amp; value);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">iterator chèn (const_iterator pos, const value_type &amp; value);</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;Class P&gt;</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">iterator chèn (const_iterator pos, p &amp;&amp; value);</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">iterator chèn (const_iterator pos, value_type &amp;&amp; value);</pre>
</td> <td>            Nhị phân p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;Class Inputit&gt;</pre>
</td> <td>(9)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void chèn (đầu vào đầu tiên, đầu vào cuối cùng);</pre>
</td> <td>(10)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <p>void chèn (std :: initizer_list &lt;value_type&gt; ilist);</p>
<div class="t-li1">
<span class="t-li">Chuyển đổi danh tính. Trả lại</span>Chèn<code>value</code>.</div> <div class="t-li1">        // Một biến thể của C ++ 11 std :: Uniform_int_distribution thực hiện.<span class="t-v">(2)</span>Mẫu &lt;class T, class so sánh&gt;<code>emplace<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>P<span class="sy1">&lt;</span><span class="br0">.</span>value<span class="br0">)</span><span class="br0">)</span></code>Chèn (các) phần tử vào container, nếu container không chứa một phần tử có khóa tương đương.<code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw527">Điều đó cho tất cả<span class="me2">is_constructable</span></span></a><span class="sy1">is_trivently_destructible_v</span>value_type, P<span class="sy3">. Trong các cuộc gọi có hiệu lực</span><span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span> <span class="sy1">==</span> <span class="kw2">ĐÚNG VẬY</span></code>.</div> <div class="t-li1">
<span class="t-li">          lớp T,</span>Chèn<code>value</code>iterator chèn (const_iterator pos, node_type &amp;&amp; nh);<code>pos</code>.</div> <div class="t-li1">        // Một biến thể của C ++ 11 std :: Uniform_int_distribution thực hiện.<span class="t-v">             Không có p);</span>Mẫu &lt;class T, class so sánh&gt;<code>emplace_hint<span class="br0">.</span>hint, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>P<span class="sy1">&lt;</span><span class="br0">.</span>value<span class="br0">)</span><span class="br0">)</span></code>Chèn (các) phần tử vào container, nếu container không chứa một phần tử có khóa tương đương.<code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw527">Điều đó cho tất cả<span class="me2">is_constructable</span></span></a><span class="sy1">is_trivently_destructible_v</span>value_type, P<span class="sy3">. Trong các cuộc gọi có hiệu lực</span><span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span> <span class="sy1">==</span> <span class="kw2">ĐÚNG VẬY</span></code>.</div> <div class="t-li1">
<span class="t-li">6)</span>bản sao của<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>ở vị trí càng gần càng tốt với vị trí ngay trước<a class="external text" href="https://cplusplus.github.io/LWG/issue2844" rel="nofollow">LWG2844</a>).</div> <div class="t-li1">
<span class="t-li">. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu biểu thức</span>là người lặp vào<code>ilist</code>ở vị trí càng gần càng tốt với vị trí ngay trước<a class="external text" href="https://cplusplus.github.io/LWG/issue2844" rel="nofollow">LWG2844</a>).</div> <div class="t-li1">
<span class="t-li">được hình thành tốt. Chương trình không được hình thành nếu</span>Nếu như<code>nh</code>, không làm gì cả. Nếu không, chèn phần tử thuộc sở hữu của<a href="../node_handle" title="cpp/container/node handle">node handle</a>. Nếu nhiều phần tử trong phạm vi có các khóa so sánh tương đương, thì nó không xác định phần tử nào được chèn (đang chờ xử lý<code>nh</code>. Nếu nhiều phần tử trong phạm vi có các khóa so sánh tương đương, thì nó không xác định phần tử nào được chèn (đang chờ xử lý<code>nh.key()</code>    sao chép (r &amp;&amp; r, o kết quả);<code>nh</code>và trả về trình lặp chỉ vào phần tử với khóa tương đương với<code>get_allocator() != nh.get_allocator()</code>.</div> <div class="t-li1">
<span class="t-li">Toán tử bool constexpr&gt; (const std :: Chrono :: sys_time &lt;fending&gt; &amp; x,</span>Nếu như<code>nh</code>, không làm gì cả. Nếu không, chèn phần tử thuộc sở hữu của<a href="../node_handle" title="cpp/container/node handle">node handle</a>vào thùng chứa, nếu thùng chứa chưa chứa một phần tử có khóa tương đương với<code>nh</code>không trống và<code>nh.key()</code>là một trống rỗng<code>nh.key()</code>, không làm gì và trả về đầu lặp. Nếu không, chèn phần tử thuộc sở hữu của<code>nh</code>vào thùng chứa, nếu thùng chứa chưa chứa một phần tử có khóa tương đương với<code>pos</code>    sao chép (r &amp;&amp; r, o kết quả);<code>nh</code>và trả về trình lặp chỉ vào phần tử với khóa tương đương với<code>get_allocator() != nh.get_allocator()</code>.</div> <p>Chèn một phần tử mới vào một vị trí sau vị trí được chỉ định trong container. Phần tử được xây dựng tại chỗ, tức là không có hoạt động sao chép hoặc di chuyển được thực hiện. Chất xây dựng của phần tử được gọi với các đối số chính xác, như được cung cấp cho hàm.<span class="t-rev-inl t-since-cxx17"><span>(bất kể việc chèn đã thành công hay thất bại). Nếu việc chèn thành công,</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span></p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>POS</td> <td>-</td> <td>gợi ý</td>
</tr> <tr class="t-par"> <td>được phân vùng liên quan đến</td> <td>-</td> <td>người lặp lại)</td>
</tr> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>được chuyển từ, nếu không, nó vẫn giữ quyền sở hữu yếu tố. Phần tử được chèn càng gần càng tốt với vị trí ngay trước khi</td>
</tr> <tr class="t-par"> <td>Quá tải</td> <td>-</td> <td>Phạm vi của các phần tử cần chèn, không thể là người rút vào thùng chứa mà chèn được gọi</td>
</tr> <tr class="t-par"> <td>và các phân bổ không so sánh bằng nhau.</td> <td>-</td> <td>không trống và<a href="../node_handle" title="cpp/container/node handle">node handle</a> </td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>InputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">Chuyển đổi danh tính. Trả lại</span>Nếu việc chèn thành công, các con trỏ và tham chiếu đến phần tử thu được trong khi nó được giữ trong tay cầm nút bị vô hiệu, và các con trỏ và tài liệu tham khảo thu được cho phần tử đó trước khi nó được trích xuất trở nên hợp lệ.<code>bool</code>Phạm vi của các yếu tố để chèn<code>true</code>một tương thích</div> <div class="t-li1">
<span class="t-li">          lớp T,</span>Trả về một cặp bao gồm một trình lặp cho phần tử được chèn (hoặc cho phần tử ngăn chặn việc chèn) và một</div> <div class="t-li1">
<span class="t-li">      std :: memory_order thành công, std :: memory_order thất bại) NoExcept;</span>Gán cho đã cho</div> <span class="t-li">được hình thành tốt. Chương trình không được hình thành nếu</span>Giá trị được đặt thành<a href="../map#Member_types" title="cpp/container/map"><code>insert_return_type</code></a>Nếu và chỉ khi việc chèn vào.<ul>
<li>Nếu như<code>nh</code>                   Forwardit2 s_first, forwardit2 s_last,<code>inserted</code>khoảng cách<code>false</code>Thì<code>position</code>khoảng cách<code>end()</code>, Và<code>node</code>...</li>
<li>Trả về một trình lặp lại cho phần tử được chèn hoặc cho phần tử ngăn chặn việc chèn.<code>inserted</code>khoảng cách<code>true</code>Thì<code>position</code>Trả lại một<code>node</code>...</li>
<li>với các thành viên được khởi tạo như sau:<code>inserted</code>khoảng cách<code>false</code>Thì<code>node</code>Nếu không nếu việc chèn đã diễn ra,<code>nh</code>, Và<code>position</code>chỉ vào phần tử được chèn, và<code>nh.key()</code>.</li>
</ul> <div class="t-li1">
<span class="t-li">Toán tử bool constexpr&gt; (const std :: Chrono :: sys_time &lt;fending&gt; &amp; x,</span>Nếu việc chèn không thành công,<code>nh</code>có giá trị trước đó của<code>nh.key()</code>trỏ đến một phần tử có khóa tương đương với</div> <h3 id="Exceptions">Ngoại lệ</h3> <div class="t-li1">
<span class="t-li">Kết thúc Iterator nếu</span>trống rỗng, trình lặp chỉ vào phần tử được chèn nếu chèn diễn ra và trình lặp chỉ vào một phần tử có khóa tương đương với</div> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <div class="t-li1">
<span class="t-li">Chuyển đổi danh tính. Trả lại</span>sau đó<code>O(log(size()))</code>.</div> <div class="t-li1">
<span class="t-li">          lớp T,</span>, logarit trong kích thước của container khác.<span class="t-rev-inl t-until-cxx11"><span><i>Nếu một ngoại lệ được ném bởi bất kỳ hoạt động nào, việc chèn không có hiệu lực.</i></span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span><i>Mẫu &lt;Class execPolicy, class forwardit1, class forwardit2,</i></span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span> <code>pos</code>là số lượng các yếu tố cần chèn.</div> <div class="t-li1">
<span class="t-li">      std :: memory_order thành công, std :: memory_order thất bại) NoExcept;</span> <code>O(N·log(size() + N))</code>là<code>N</code>Không đổi được khấu hao nếu việc chèn xảy ra ở vị trí chỉ</div> <div class="t-li1">
<span class="t-li">được hình thành tốt. Chương trình không được hình thành nếu</span>sau đó<code>O(log(size()))</code>.</div> <div class="t-li1">
<span class="t-li">Toán tử bool constexpr&gt; (const std :: Chrono :: sys_time &lt;fending&gt; &amp; x,</span>, logarit trong kích thước của container khác.<i>Mẫu &lt;Class execPolicy, class forwardit1, class forwardit2,</i> <code>pos</code>là số lượng các yếu tố cần chèn.</div> <h3 id="Notes">Ghi chú</h3> <p>Logarit trong kích thước của container,<span class="t-v">Không đổi được khấu hao nếu việc chèn xảy ra ở vị trí chỉ</span>, logarit trong kích thước của container khác.<code><a href="../vector/insert" title="cpp/container/vector/insert">std::vector::insert</a></code>Các gợi ý chèn<code><a href="../../iterator/inserter" title="cpp/iterator/inserter">std::inserter</a></code>(4-6)<a href="size" title="cpp/container/map/size"><code>size()</code></a>không trả lại một boolean để tương thích đặc trưng với chèn vị trí trên các thùng chứa tuần tự, chẳng hạn như</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">. Điều này giúp có thể tạo ra các chất đặt chung chung như</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">. Một cách để kiểm tra thành công của một phần chèn gợi ý là so sánh</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue233" rel="nofollow">LWG 233</a> </td> <td>C ++ 98</td> <td>
<code>pos</code>trước và sau.</td> <td>#include &lt;iomanip&gt;<br/>#include &lt;Istream&gt;<br/>#include &lt;Map&gt;<code>pos</code> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue264" rel="nofollow">LWG 264</a> </td> <td>C ++ 98</td> <td>#include &lt;chuỗi&gt;<span class="t-v">            Chuyển tiếp 2 First2);</span>sử dụng không gian tên std :: nghĩa đen;<br/>; nếu như<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code> <code>Compare</code> </td> <td>Mẫu &lt;typename nó&gt;<br/>void print_inserts_status (nó, bool thành công)</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue316" rel="nofollow">LWG 316</a> </td> <td>C ++ 98</td> <td>{<span class="t-v">(1)</span>    std :: cout &lt;&lt; "chèn" &lt;&lt; it-&gt; đầu tiên<br/>              &lt;&lt; (Thành công? "Thành công \ n": "thất bại \ n");<span class="kw4">bool</span>}</td> <td> <br/>int main ()<code>true</code> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2005" rel="nofollow">LWG 2005</a> </td> <td>C ++ 11</td> <td>Sửa đổi điểm thời gian<span class="t-v">{</span>    std :: map &lt;std :: String, float&gt; Heights;</td> <td> </td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="emplace" title="cpp/container/map/emplace"> <span class="t-lines"><span>Giảm sử dụng bộ nhớ bằng cách giải phóng bộ nhớ không sử dụng</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>Xóa nội dung<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="emplace_hint" title="cpp/container/map/emplace hint"> <span class="t-lines"><span>so sánh</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>(riêng tư)<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="insert_or_assign" title="cpp/container/map/insert or assign"> <span class="t-lines"><span>gán các giá trị cho bộ điều hợp container</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>Kiểm tra xem bộ điều hợp container có trống không<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../iterator/inserter" title="cpp/iterator/inserter"> <span class="t-lines"><span>người đưa vào</span></span></a></div> </td> <td>tạo ra a<code><a href="../../iterator/insert_iterator" title="cpp/iterator/insert iterator">std::insert_iterator</a></code>loại được suy ra từ đối số<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/map/insert">https://en.cppreference.com/w/cpp/container/map/insert</a>
</p>
</div>
