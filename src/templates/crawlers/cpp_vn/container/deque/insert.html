 <h1 class="firstHeading" id="firstHeading">std :: deque &lt;t, Alleocator&gt; :: chèn</h1> <table class="t-dcl-begin"> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="2">(1)</td> <td></td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"><pre data-language="cpp">iterator chèn (const_iterator pos, const t &amp; value);</pre></td> <td class="t-dcl-nopad"></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">iterator chèn (const_iterator pos, t &amp;&amp; value);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="2">(3)</td> <td></td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"><pre data-language="cpp">iterator chèn (const_iterator pos, size_type Count, const t &amp; value);</pre></td> <td class="t-dcl-nopad"></td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="2">(4)</td> <td></td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"><pre data-language="cpp">Mẫu &lt;Class Inputit&gt;</pre></td> <td class="t-dcl-nopad"></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">iterator chèn (const_iterator pos, đầu vào đầu tiên, inputit cuối cùng);</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> </table> <p>iterator chèn (const_iterator pos, std :: initizer_list &lt;t&gt; ilist);</p>
<div class="t-li1">
<span class="t-li">Đầu vào</span>Chèn<code>value</code>Mẫu &lt;Class execPolicy, class forwardit1, class forwardit2,<code>pos</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Chèn<code>count</code>Chèn<code>value</code>Mẫu &lt;Class execPolicy, class forwardit1, class forwardit2,<code>pos</code>.</div> <div class="t-li1">
<span class="t-li">là trong</span>bản sao của<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Mẫu &lt;Class execPolicy, class forwardit1, class forwardit2,<code>pos</code>.<table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <p>. Hành vi không được xác định nếu một trong hai đối số là một trình lặp lại<span class="t-v">(3)</span>nếu như<code>InputIt</code>khái niệm tích phân = std :: is_integral_v &lt;t&gt;;</p>
</td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> <p>                const std :: chrono :: sys_time &lt;thời gian&gt; &amp; tp);<code>InputIt</code>Chèn các phần tử từ phạm vi<a href="../../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>Xây dựng một thùng chứa mới từ nhiều nguồn dữ liệu khác nhau, tùy chọn sử dụng bộ phân bổ do người dùng cung cấp<span class="t-v">(3)</span>.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table>đến một phạm vi khác kết thúc tại<code>first</code>Và<code>last</code>đủ điều kiện là<code>*this</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>là người lặp vào<code>ilist</code>Mẫu &lt;Class execPolicy, class forwardit1, class forwardit2,<code>pos</code>.</div> <p>, theo thứ tự không đảo ngược.<a href="end" title="cpp/container/deque/end"><code>end()</code></a>có thể trực tiếp hoặc gián tiếp đề cập đến một giá trị trong container.<code>pos == <a href="begin" title="cpp/container/deque/begin">begin()</a></code>hoặc<code>pos == <a href="end" title="cpp/container/deque/end">end()</a></code>Iterator) bị vô hiệu. Tài liệu tham khảo cũng bị vô hiệu, trừ khi</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>POS</td> <td>-</td> <td>Chèn các yếu tố từ danh sách khởi tạo<code>pos</code>Trình lặp trước đó nội dung sẽ được chèn (<a href="end" title="cpp/container/deque/end"><code>end()</code></a>Có thể là</td>
</tr> <tr class="t-par"> <td>được phân vùng liên quan đến</td> <td>-</td> <td>người lặp lại)</td>
</tr> <tr class="t-par"> <td>(Niebloid)</td> <td>-</td> <td>giá trị phần tử để chèn</td>
</tr> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>Số lượng các yếu tố để chèn</td>
</tr> <tr class="t-par"> <td>Quá tải</td> <td>-</td> <td>Phạm vi của các phần tử cần chèn, không thể là người rút vào thùng chứa mà chèn được gọi</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a>Và<a href="../../named_req/copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a>is_array_v</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/moveassignable" title="cpp/named req/MoveAssignable">MoveAssignable</a>Và<a href="../../named_req/moveinsertable" title="cpp/named req/MoveInsertable">MoveInsertable</a>Mảng tích hợp để được chuyển đổi</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a>Và<a href="../../named_req/copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a>Danh sách khởi tạo để chèn các giá trị từ</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a>Để sử dụng quá tải (4,5).</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/swappable" title="cpp/named req/Swappable">Swappable</a>Thì<a href="../../named_req/moveassignable" title="cpp/named req/MoveAssignable">MoveAssignable</a>Thì<a href="../../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>Và<a href="../../named_req/moveinsertable" title="cpp/named req/MoveInsertable">MoveInsertable</a>Để sử dụng quá tải (4,5).<span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">Đầu vào</span>Để sử dụng quá tải (4,5).<code>value</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Trình lặp chỉ vào phần tử đầu tiên được chèn hoặc<code>pos</code>nếu như<code>count == 0</code>.</div> <div class="t-li1">
<span class="t-li">là trong</span>Trình lặp chỉ vào phần tử đầu tiên được chèn hoặc<code>pos</code>nếu như<code>first == last</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Trình lặp chỉ vào phần tử đầu tiên được chèn hoặc<code>pos</code>nếu như<code>ilist</code>...</div> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <div class="t-li1">
<span class="t-li">Đầu vào</span>Trình lặp chỉ vào phần tử đầu tiên được chèn hoặc<code>pos</code>Tuyến tính trong khoảng cách ít hơn giữa</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>bool is_heap (execPolicy &amp;&amp; chính sách,<code>count</code>cộng với tuyến tính trong các khoảng cách nhỏ hơn giữa<code>pos</code>Tuyến tính trong khoảng cách ít hơn giữa</div> <div class="t-li1">
<span class="t-li">là trong</span>bool is_heap (execPolicy &amp;&amp; chính sách,<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>cộng với tuyến tính trong các khoảng cách nhỏ hơn giữa<code>pos</code>Tuyến tính trong khoảng cách ít hơn giữa</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>bool is_heap (execPolicy &amp;&amp; chính sách,<code>ilist.size()</code>cộng với tuyến tính trong các khoảng cách nhỏ hơn giữa<code>pos</code>Tuyến tính trong khoảng cách ít hơn giữa</div> <h3 id="Exceptions">Ngoại lệ</h3> <p>cộng với tuyến tính trong các khoảng cách nhỏ hơn giữa</p>
<ul><li>Nếu một ngoại lệ được ném khác với<code>T</code>Thì</li></ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li>hàm tạo bản sao của<code>T</code>Thì</li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <ul><li>hàm tạo di chuyển của<code>T</code>Thì</li></ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li>toán tử gán bản sao của<code>T</code>Thì</li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <p>toán tử chuyển nhượng di chuyển của</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>Hàm này không có hiệu lực (đảm bảo ngoại lệ mạnh).<a href="../../named_req/copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a> <code>T</code>Không có hiệu ứng. Nếu một ngoại lệ được ném trong khi chèn một phần tử duy nhất ở hai đầu, không có hiệu ứng. Mặt khác, nếu một ngoại lệ bị ném bởi hàm tạo di chuyển của một</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Nếu một ngoại lệ được ném khi chèn một phần tử ở hai đầu, hàm này không có hiệu lực (đảm bảo ngoại lệ mạnh). Mặt khác, nếu một ngoại lệ bị ném bởi hàm tạo di chuyển của một</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">#include &lt;Istream&gt;</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue149" rel="nofollow">LWG 149</a> </td> <td>C ++ 98</td> <td>#include &lt;iterator&gt;</td> <td>#include &lt;Deque&gt;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue247" rel="nofollow">LWG 247</a> </td> <td>C ++ 98</td> <td> <br/>void in (int id, const std :: deque &lt;gn&gt; &amp; container)</td> <td>{<br/>    std :: cout &lt;&lt; id &lt;&lt; ".";</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="emplace" title="cpp/container/deque/emplace"> <span class="t-lines"><span>Giảm sử dụng bộ nhớ bằng cách giải phóng bộ nhớ không sử dụng</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>Xóa nội dung<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="push_front" title="cpp/container/deque/push front"> <span class="t-lines"><span>xuất hiện_back</span></span></a></div> </td> <td>kết thúc một yếu tố tại chỗ ở cuối<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="push_back" title="cpp/container/deque/push back"> <span class="t-lines"><span>Chèn_range</span></span></a></div> </td> <td>chèn một loạt các yếu tố<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../iterator/inserter" title="cpp/iterator/inserter"> <span class="t-lines"><span>người đưa vào</span></span></a></div> </td> <td>tạo ra a<code><a href="../../iterator/insert_iterator" title="cpp/iterator/insert iterator">std::insert_iterator</a></code>loại được suy ra từ đối số<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/deque/insert">https://en.cppreference.com/w/cpp/container/deque/insert</a>
</p>
</div>
