 <h1 class="firstHeading" id="firstHeading">STD :: Danh sách &lt;T, Allecator&gt; :: Hợp nhất</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx98"> <td> <pre data-language="cpp">void Merge (Danh sách &amp; Khác);</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">void Merge (Danh sách &amp;&amp; Khác);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx98"> <td> <pre data-language="cpp">Mẫu &lt;class so sánh&gt; </pre>
</td> <td>(3)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">void Merge (Danh sách &amp; Khác, So sánh Comp);</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> </table> <p>Mẫu &lt;class so sánh&gt; <code>other</code>có thể được hủy bỏ và sau đó được chuyển đổi hoàn toàn thành cả hai. ​<code>*this</code>.</p>
<p>Chức năng không làm gì nếu<code>other</code>Mẫu &lt;Class T&gt;<code>*this</code>đề cập đến cùng một đối tượng như<code>other</code>Nếu không, hợp nhất<code>*this</code>. Cả hai danh sách nên được sắp xếp. Không có phần tử nào được sao chép và container<code>other</code>trở nên trống rỗng sau khi hợp nhất. Hoạt động này ổn định: Đối với các yếu tố tương đương trong hai danh sách, các yếu tố từ<code>*this</code>Và<code>other</code>luôn luôn đi trước các yếu tố từ</p>
<p>và thứ tự các yếu tố tương đương của<code>*this</code>không thay đổi.<code>*this</code>Không có trình lặp hoặc tài liệu tham khảo trở nên vô hiệu. Các con trỏ và tài liệu tham khảo về các yếu tố đã được chuyển từ<code>other</code>.</p>
<div class="t-li1">
<span class="t-li">Đầu vào</span>Chuyển tiếp adjacent_find (forwardit first, forwardit cuối cùng, nhị phân p);<code>operator&lt;</code>.</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>Chuyển tiếp adjacent_find (forwardit first, forwardit cuối cùng, nhị phân p);<code>comp</code>.</div> <p>Nếu như<code>*this</code>hoặc<code>other</code>, cũng như các trình lặp lại đề cập đến các yếu tố này, sẽ đề cập đến các yếu tố tương tự của<code>get_allocator() != other.get_allocator()</code>Hoạt động tương đương cho quá tải</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>khác</td> <td>-</td> <td>, thay vì</td>
</tr> <tr class="t-par"> <td>sau đó</td> <td>-</td> <td>LO, xin chào<a href="../../named_req/compare" title="cpp/named req/Compare">Compare</a>Constexpr bool bao gồm (đầu vào đầu tiên1, đầu vào1, last1,<code>true</code>cũng là<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>                         Inputit2 First2, Inputit2 Last2, so sánh comp);<i>Mẫu &lt;Class execPolicy, class forwardit1, class forwardit2,</i>          Lớp so sánh&gt;<br/> <p>Hàm so sánh trả về giá trị số nguyên âm nếu đối số đầu tiên là</p>
<p><span class="t-cc"><code>bool cmp(const Type1&amp; a, const Type2&amp; b);</code></span></p>
<p>&gt;&gt;<span class="kw4">hằng số</span><span class="sy3">Không có giá trị</span>is_execut_policy_v<code>Type1</code>Và<code>Type2</code>Remove_cvref_t<a href="../../language/value_category" title="cpp/language/value category">value category</a>&gt;&gt;<code>Type1&amp;</code>phạm vi của các yếu tố để kiểm tra<span class="t-rev-inl t-since-cxx11"><span>P<code>Type1</code>vị từ nhị phân trả về<code>Type1</code>Nếu các yếu tố nên được coi là bằng nhau.</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>).<br/>Mẫu &lt;class so sánh&gt; <span class="sy1">is_trivently_destructible_v</span>một thùng chứa khác để hợp nhất<span class="sy3">Không có giá trị</span>Loại Type1 và Type2 phải sao cho một đối tượng của PROWING_LIST<span class="sy4">Số lượng các yếu tố để sao chép</span>Người phân bổ<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">const_iterator</span>T,</p>
</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>Compare</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/compare" title="cpp/named req/Compare">Compare</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Gán cho đã cho</p>
<h3 id="Exceptions">Ngoại lệ</h3> <p>Nếu một ngoại lệ được ném vì bất kỳ lý do gì, các chức năng này không có hiệu lực (<a href="../../language/exceptions#Exception_safety" title="cpp/language/exceptions">strong exception safety guarantee</a>nbsp</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Nếu như<code>other</code>có thể được hủy bỏ và sau đó được chuyển đổi hoàn toàn thành cả hai. ​<code>*this</code>). Ngoại trừ nếu ngoại lệ đến từ một so sánh.</p>
<p>đề cập đến cùng một đối tượng như<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>begin<span class="br0">.</span><span class="br0">)</span>, end<span class="br0">.</span><span class="br0">)</span><span class="br0">)</span></code>, không có so sánh được thực hiện.<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>other.<span class="me1">bắt đầu</span><span class="br0">.</span><span class="br0">)</span>, other.<span class="me1">kết thúc</span><span class="br0">.</span><span class="br0">)</span><span class="br0">)</span></code>:</p>
<div class="t-li1">
<span class="t-li">Đầu vào</span>Nếu không, đã cho \ (\ scriptsize n \) n như<code>operator&lt;</code>.</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>và \ (\ scriptsize r \) r như<code>comp</code>.</div> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">void hợp nhất (list &amp;&amp; other, so sánh comp);</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Nhiều nhất \ (\ scriptsize n+r-1 \) n+r-1 ứng dụng của hàm so sánh</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue300" rel="nofollow">LWG 300</a> </td> <td>C ++ 98</td> <td>Loại loại 1 và type2 phải sao cho một đối tượng thuộc loại danh sách<code>*this</code>Và<code>other</code>#include &lt;Istream&gt;<br/>#include &lt;Danh sách&gt;</td> <td> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue1207" rel="nofollow">LWG 1207</a> </td> <td>C ++ 98</td> <td>STD :: Ostream &amp; Toán tử &lt;&lt; (STD :: Ostream &amp; Ostr, Const Std :: Danh sách &lt;Int&gt; &amp; List)</td> <td>{</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue1215" rel="nofollow">LWG 1215</a> </td> <td>C ++ 98</td> <td>#include &lt;Istream&gt;<br/><code>get_allocator() != other.get_allocator()</code> </td> <td>là giá trị trả về, vẫn có thể giảm được, nhưng bản thân các yếu tố có giá trị không xác định. Một cuộc gọi đến<br/>kích cỡ.</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="splice" title="cpp/container/list/splice"> <span class="t-lines"><span>    sử dụng danh sách = std :: list &lt;t, std :: pmr :: đa hình_allocator &lt;t &gt;&gt;;</span></span></a></div> </td> <td>xuất hiện_after<code>list</code> <br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../algorithm/merge" title="cpp/algorithm/merge"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../algorithm/inplace_merge" title="cpp/algorithm/inplace merge"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../algorithm/ranges/merge" title="cpp/algorithm/ranges/merge"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../algorithm/ranges/inplace_merge" title="cpp/algorithm/ranges/inplace merge"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/list/merge">https://en.cppreference.com/w/cpp/container/list/merge</a>
</p>
</div>
