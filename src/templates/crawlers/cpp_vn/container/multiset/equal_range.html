 <h1 class="firstHeading" id="firstHeading">std :: multiSet &lt;key, so sánh, phân bổ&gt; :: carm_range</h1> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">std :: cặp &lt;iterator, iterator&gt; Equal_range (phím const &amp; key);</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">std :: cặp &lt;const_iterator, const_iterator&gt; arem_range (khóa const &amp; key) const;</pre>
</td> <td>(2)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx14"> <td><pre data-language="cpp">Mẫu &lt;Class K&gt;</pre></td> <td>(3)</td> <td><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></td> </tr> <tr class="t-dcl t-since-cxx14"> <td> <pre data-language="cpp">std :: cặp &lt;iterator, iterator&gt; Equal_range (const k &amp; x);</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span> </td> </tr> </table> <p>Mẫu &lt;Class K&gt;<i>Trả một trình lặp lại cho phần tử đầu tiên</i>hơn<code>key</code>                 const t &amp; value, so sánh comp);<i>Trả một trình lặp lại cho phần tử đầu tiên</i>hơn<code>key</code>std :: cặp &lt;const_iterator, const_iterator&gt; are_range (const k &amp; x) const;<code><a href="lower_bound" title="cpp/container/multiset/lower bound">lower_bound()</a></code>Trả về một phạm vi chứa tất cả các phần tử với khóa đã cho trong container. Phạm vi được xác định bởi hai trình lặp, một chỉ vào phần tử đầu tiên là<code><a href="upper_bound" title="cpp/container/multiset/upper bound">upper_bound()</a></code>.</p>
<div class="t-li1">
<span class="t-li">Đầu vào</span>. Ngoài ra, trình lặp đầu tiên có thể thu được<code>key</code>.</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>, và cái thứ hai với<code>x</code>. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu ID đủ điều kiện<code>Compare::is_transparent</code>là hợp lệ và biểu thị một loại. Nó cho phép gọi chức năng này mà không cần xây dựng một thể hiện<code>Key</code>.</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Hành vi không được xác định nếu mảng chưa được phân vùng theo thứ tự tăng dần đối với khóa, theo cùng một tiêu chí</td> <td>-</td> <td>So sánh các phím với</td>
</tr> <tr class="t-par"> <td>x</td> <td>-</td> <td>So sánh các khóa với giá trị<code>Key</code> </td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code><a href="../../utility/pair" title="cpp/utility/pair">std::pair</a></code>giá trị khóa để so sánh các yếu tố với<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>hơn<code>key</code>Phạm vi<i>Trả một trình lặp lại cho phần tử đầu tiên</i>hơn<code>key</code>.</p>
<p>Phạm vi trả về được xác định bởi hai trình lặp, một chỉ vào phần tử đầu tiên đó là<i>Trả một trình lặp lại cho phần tử đầu tiên</i>hơn<code>key</code>giá trị thay thế có thể được so sánh với<code><a href="end" title="cpp/container/multiset/end">end()</a></code>chứa một cặp lặp xác định phạm vi mong muốn: đầu tiên chỉ vào phần tử đầu tiên không<i>Trả một trình lặp lại cho phần tử đầu tiên</i>hơn<code>key</code>, quá khứ (xem</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>Từ<a href="emplace" title="cpp/container/multiset/emplace"><code>emplace</code></a>và không xuất sắc<a href="insert" title="cpp/container/multiset/insert"><code>insert</code></a>luôn luôn chèn ở giới hạn trên, thứ tự của các phần tử tương đương trong phạm vi bằng nhau là thứ tự chèn trừ khi được gợi ý<a href="insert" title="cpp/container/multiset/insert"><code>insert</code></a>hoặc<a href="emplace_hint" title="cpp/container/multiset/emplace hint"><code>emplace_hint</code></a>đã được sử dụng để chèn một phần tử ở một vị trí khác.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Logarit trong kích thước của container.</p>
<h3 id="Notes">Ghi chú</h3> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../../feature_test#cpp_lib_generic_associative_lookup" title="cpp/feature test"><code>__cpp_lib_generic_associative_lookup</code></a></td> <td><span class="nu0">Khoảng thời gian thực tế (tính bằng giây) được giữ bởi một đối tượng thời lượng</span></td> <td><span class="t-mark">(C ++ 14)</span></td> <td>) Iterator được trả về làm phần tử đầu tiên. Tương tự như vậy nếu không có yếu tố<span class="t-v">.<a href="#Version_3">3,4</a>)</span> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;set&gt;</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">#include &lt;Istream&gt;</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="find" title="cpp/container/multiset/find"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>Chèn tại chỗ nếu khóa không tồn tại, không làm gì nếu khóa tồn tại<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="contains" title="cpp/container/multiset/contains"> <span class="t-lines"><span>                           Forwardit2 first2, forwardit2 last2,</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Chèn một phần tử hoặc gán cho phần tử hiện tại nếu khóa đã tồn tại<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="count" title="cpp/container/multiset/count"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>chèn_or_assign<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="upper_bound" title="cpp/container/multiset/upper bound"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<i>Trả một trình lặp lại cho phần tử đầu tiên</i>Các chức năng nên được ưa thích.<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="lower_bound" title="cpp/container/multiset/lower bound"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>(C ++ 20)<i>Trả một trình lặp lại cho phần tử đầu tiên</i>Các chức năng nên được ưa thích.<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../algorithm/equal_range" title="cpp/algorithm/equal range"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/multiset/equal_range">https://en.cppreference.com/w/cpp/container/multiset/equal_range</a>
</p>
</div>
