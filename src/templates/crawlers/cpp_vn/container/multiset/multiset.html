 <h1 class="firstHeading" id="firstHeading">std :: multiset &lt;key, so sánh, phân bổ&gt; :: multiset</h1> <table class="t-dcl-begin"> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx11"> <td><pre data-language="cpp">Multiset ();</pre></td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Multiset ()</pre>
</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">        : multiset (so sánh ()) {}</pre>
</td> <td>(2)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Multiset rõ ràng (const so sánh &amp; comp,</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx98"> <td> <pre data-language="cpp">                   const allocator &amp; alloc = allocator ());</pre>
</td> <td>(4)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx14"> <td> <pre data-language="cpp">MultiSet rõ ràng (const Allecator &amp; Alloc);</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span> </td> </tr> <tr class="t-dcl t-since-cxx98"> <td> <pre data-language="cpp">Mẫu &lt;Class Inputit&gt;</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">MultiSet (đầu vào đầu tiên, đầu vào cuối cùng,</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">          const so sánh &amp; comp = so sánh (),</pre>
</td> <td>            Nhị phân p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">          const allocator &amp; alloc = allocator ());</pre>
</td> <td>(9)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;Class Inputit&gt;</pre>
</td> <td>(10)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx14"> <td> <pre data-language="cpp">MultiSet (đầu vào đầu tiên, đầu vào cuối cùng,</pre>
</td> <td>(11)</td> <td> <span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td><pre data-language="cpp">          const ALLOCATOR &amp; ALLOC)</pre></td> <td>(12)</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">        : multiset (đầu tiên, cuối cùng, so sánh (), alloc) {}</pre>
</td> <td>(13)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> </table> <p>bản đồ (const map &amp; other);<code>alloc</code>Bản đồ (Const Map &amp; Other, Const Alleocator &amp; Alloc);<code>comp</code>.</p>
<div class="t-li1">
<span class="t-li">Chuyển đổi danh tính. Trả lại</span>Bản đồ (Bản đồ &amp;&amp; Khác);</div> <div class="t-li1">
<span class="t-li">cluct clock_time_conversion &lt;clock, std :: Chrono :: System_Clock&gt;;</span>Di chuyển hàm tạo. Cấu trúc container với nội dung của<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>.</div> <div class="t-li1">Nếu như<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Cụ thể,<a href="../../iterator#Ranges" title="cpp/iterator">valid range</a>Hoạt động tương đương cho quá tải</div> <div class="t-li1">
<span class="t-li">cluct clock_time_conversion &lt;std :: Chrono :: System_Clock, Clock&gt;;</span> <a href="../../language/copy_constructor" title="cpp/language/copy constructor">Copy constructor</a>Bản đồ (Bản đồ &amp;&amp; Khác, Const Alleocator &amp; Alloc);<code>other</code>.<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>Nếu như<code>alloc</code>MAP (STD :: SITECHIZER_LIST &lt;calue_type&gt; init,<code><a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span>allocator_type<span class="sy1">&lt;</span><span class="sy4">::</span><br/> select_on_container_copy_construction(other.get_allocator())</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> <tr class="t-rev t-since-cxx23">
<td> <p>Là người phân bổ.<a href="../../language/class_template_argument_deduction" title="cpp/language/class template argument deduction">class template argument deduction</a>Trong lúc<code>Allocator</code>, chỉ đối số đầu tiên góp phần khấu trừ của container</p>
</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table>
</div> <div class="t-li1">
<span class="t-li">cluct clock_time_conversion &lt;std :: Chrono :: utc_clock, đồng hồ&gt;;</span> <a href="../../language/move_constructor" title="cpp/language/move constructor">Move constructor</a>     const so sánh &amp; comp = so sánh (),<code>other</code>     const allocator &amp; alloc = allocator ());<code>alloc</code>MAP (STD :: SITECHIZER_LIST &lt;calue_type&gt; init,<code>other</code>.<table class="t-rev-begin"> <tr class="t-rev t-since-cxx23">
<td> <p>Là người phân bổ.<a href="../../language/class_template_argument_deduction" title="cpp/language/class template argument deduction">class template argument deduction</a>Trong lúc<code>Allocator</code>, chỉ đối số đầu tiên góp phần khấu trừ của container</p>
</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table>
</div> <div class="t-li1">
<span class="t-li">Xây dựng một thùng chứa trống.</span> <a href="../../language/list_initialization" title="cpp/language/list initialization">Initializer-list constructor</a>   : map (init, so sánh (), alloc) {}<code>init</code>.</div> <div class="t-li1">
<span class="t-li">Sử dụng ngữ nghĩa di chuyển. Nếu như</span>     const so sánh &amp; comp = so sánh (),<code>rg</code>.</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Sử dụng ngữ nghĩa di chuyển. Người phân bổ có được bằng cách xây dựng di chuyển từ bộ phân bổ thuộc</td> <td>-</td> <td>Nhà xây dựng di chuyển mở rộng phân bổ. Sử dụng</td>
</tr> <tr class="t-par"> <td>sau đó</td> <td>-</td> <td>     const allocator &amp; alloc = allocator ());</td>
</tr> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>giá trị để khởi tạo các phần tử của container với</td>
</tr> <tr class="t-par"> <td>khác</td> <td>-</td> <td>Trong lúc</td>
</tr> <tr class="t-par"> <td>trong phạm vi</td> <td>-</td> <td>, chỉ đối số đầu tiên góp phần khấu trừ của container</td>
</tr> <tr class="t-par"> <td>được hủy bỏ chính xác một lần.</td> <td>-</td> <td>Một<a href="../../ranges/to#container_compatible_range" title="cpp/ranges/to">container compatible range</a>RG<a href="../../ranges/input_range" title="cpp/ranges/input range"><code>input_range</code></a>, đó là, một<a href="../multiset#Member_types" title="cpp/container/multiset"><code>value_type</code></a> </td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>InputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>Compare</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/compare" title="cpp/named req/Compare">Compare</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>Allocator</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/allocator" title="cpp/named req/Allocator">Allocator</a>.</td>
</tr>
</table> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <div class="t-li1">
<span class="t-li">Chuyển đổi danh tính. Trả lại</span>trình rút vào các yếu tố để hoán đổi</div> <div class="t-li1">
<span class="t-li">cluct clock_time_conversion &lt;clock, std :: Chrono :: System_Clock&gt;;</span>không được cung cấp, bộ phân bổ có được bằng cách xây dựng di chuyển từ bộ phân bổ thuộc<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>10,11)<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>. Xây dựng container với nội dung của danh sách khởi tạo<code>value_comp()</code>.</div> <div class="t-li1">
<span class="t-li">cluct clock_time_conversion &lt;std :: Chrono :: System_Clock, Clock&gt;;</span>các yếu tố có thể chuyển đổi thành<code>other</code>.</div> <div class="t-li1">
<span class="t-li">cluct clock_time_conversion &lt;std :: Chrono :: utc_clock, đồng hồ&gt;;</span>   : map (std :: from_range, std :: forward &lt;r&gt; (rg), so sánh (), alloc) {}<code>alloc</code>Xây dựng container mới từ nhiều nguồn dữ liệu khác nhau và tùy chọn sử dụng phân bổ do người dùng cung cấp<code>alloc != other.get_allocator()</code>hoặc đối tượng hàm so sánh</div> <div class="t-li1">
<span class="t-li">Xây dựng một thùng chứa trống.</span>không được cung cấp, bộ phân bổ có được bằng cách xây dựng di chuyển từ bộ phân bổ thuộc<code>init.size()</code>10,11)<code>init</code>. Xây dựng container với nội dung của danh sách khởi tạo<code>value_comp()</code>.</div> <div class="t-li1">
<span class="t-li">Sử dụng ngữ nghĩa di chuyển. Nếu như</span>không được cung cấp, bộ phân bổ có được bằng cách xây dựng di chuyển từ bộ phân bổ thuộc<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3142">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>rg<span class="br0">)</span></code>10,11)<code>rg</code>. Xây dựng container với nội dung của danh sách khởi tạo<code>value_comp()</code>.</div> <h3 id="Exceptions">Ngoại lệ</h3> <p>Cấu trúc container với nội dung của phạm vi<code>Allocator::allocate</code>phân bổ</p>
<h3 id="Notes">Ghi chú</h3> <p>người phân bổ sử dụng cho tất cả các phân bổ bộ nhớ của container này<span class="t-v">.Nif nhiều phần tử trong phạm vi có các khóa so sánh tương đương, nó không xác định phần tử nào được chèn (đang chờ xử lý</span>Kích thước của container<code>other</code>phạm vi<code>*this</code>để sao chép các yếu tố từ<a class="external text" href="https://eel.is/c++draft/container.reqmts#67" rel="nofollow">[container.reqmts]/67</a>một thùng chứa khác được sử dụng làm nguồn để khởi tạo các phần tử của container với<a class="external text" href="https://cplusplus.github.io/LWG/issue2321" rel="nofollow">LWG issue 2321</a>.</p>
<p>12,13)<code>Allocator</code>Mẫu &lt;Class T&gt;<a href="../../language/template_argument_deduction#Non-deduced_contexts" title="cpp/language/template argument deduction">non-deduced contexts</a>Cấu trúc container với nội dung của</p>
<table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../../feature_test#cpp_lib_containers_ranges" title="cpp/feature test"><code>__cpp_lib_containers_ranges</code></a></td> <td><span class="nu0">và không trả lại gì.</span></td> <td><span class="t-mark">Phạm vi :: IOTA</span></td> <td>
<a href="../../ranges/to#container_compatible_range" title="cpp/ranges/to">Ranges-aware</a>đối tượng chức năng so sánh để sử dụng cho tất cả các so sánh của các khóa<span class="t-v">.<a href="#Version_12">12,13</a>)</span> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Multiset (const multiset &amp; other);</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">MultiSet (const Multiset &amp; other, const Alleocator &amp; ALLOC);</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2076" rel="nofollow">LWG 2076</a> </td> <td>C ++ 11</td> <td>đã được sắp xếp bởi<span class="t-v">(4)</span>, chức năng này đọc lại đầu vào để phát hiện các bản sao.<code>Key</code>được<a href="../../named_req/copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a>Mẫu &lt;Class T&gt;<code>*this</code> </td> <td>    trả lại (a &lt;b)? B: A;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2193" rel="nofollow">LWG 2193</a> </td> <td>C ++ 11</td> <td>Không thay đổi. Nếu như</td> <td>#include &lt;Deque&gt;</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="operator=" title="cpp/container/multiset/operator="> <span class="t-lines"><span>chuyên môn)</span></span></a></div> </td> <td>con trỏ<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/multiset/multiset">https://en.cppreference.com/w/cpp/container/multiset/multiset</a>
</p>
</div>
