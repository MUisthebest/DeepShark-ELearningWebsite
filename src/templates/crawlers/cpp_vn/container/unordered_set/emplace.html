 <h1 class="firstHeading" id="firstHeading">std :: unetered_set &lt;key, băm, keyequal, studocator&gt; :: emplace</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;class ... args&gt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> </table> <p>std :: cặp &lt;iterator, bool&gt; place (args &amp;&amp; ... args);<code>args</code>Chèn một phần tử mới vào container được xây dựng tại chỗ với</p>
<p>Nếu không có phần tử với khóa trong container.<code>emplace</code>Cho phép phần tử mới được xây dựng trong khi tránh các hoạt động sao chép hoặc di chuyển không cần thiết. Hàm tạo của phần tử mới được gọi với các đối số chính xác như được cung cấp cho<code>emplace</code>) được gọi với chính xác các đối số giống như được cung cấp cho<code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span>args<span class="br0">)</span>...</code>, chuyển tiếp qua</p>
<p>Nếu sau khi hoạt động, số yếu tố mới lớn hơn cũ<code><a href="max_load_factor" title="cpp/container/unordered set/max load factor">max_load_factor()</a> * <a href="bucket_count" title="cpp/container/unordered set/bucket count">bucket_count()</a></code>Một sự hồi phục diễn ra.<br/>Nếu việc thử lại xảy ra (do chèn), tất cả các trình lặp đều bị vô hiệu. Mặt khác (không có thử lại), các trình lặp không bị vô hiệu.</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>iterator trước đó phần tử mới sẽ được xây dựng</td> <td>-</td> <td>Args</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>. Phần tử có thể được xây dựng ngay cả khi đã có một phần tử có khóa trong container, trong trường hợp đó, phần tử mới được xây dựng sẽ bị phá hủy ngay lập tức.<span class="kw4">bool</span>Trả về một cặp bao gồm một trình lặp cho phần tử được chèn hoặc phần tử đã tồn tại nếu không có sự chèn nào và một<span class="kw2">ĐÚNG VẬY</span>biểu thị liệu việc chèn có diễn ra không (<span class="kw2">SAI</span>Nếu chèn xảy ra,</p>
<h3 id="Exceptions">Ngoại lệ</h3> <p>tham chiếu emplace_front (args &amp;&amp; ... args);<a href="../../language/exceptions#Exception_safety" title="cpp/language/exceptions">strong exception safety guarantee</a>).</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Hằng số được khấu hao trung bình, trường hợp xấu nhất tuyến tính trong kích thước của container.</p>
<h3 id="Example">Ví dụ</h3> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="emplace_hint" title="cpp/container/unordered set/emplace hint"> <span class="t-lines"><span>so sánh</span></span></a></div> </td> <td>(riêng tư)<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="insert" title="cpp/container/unordered set/insert"> <span class="t-lines"><span>get_allocator</span></span></a></div> </td> <td>Trả về người phân bổ liên quan<span class="t-rev-inl t-since-cxx17"><span>, các trình lặp lại có thể điều chỉnh được</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span> <br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/unordered_set/emplace">https://en.cppreference.com/w/cpp/container/unordered_set/emplace</a>
</p>
</div>
