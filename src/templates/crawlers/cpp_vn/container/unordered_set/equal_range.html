 <h1 class="firstHeading" id="firstHeading">std :: unetered_set &lt;key, băm, keyequal, allocator&gt; :: arem_range</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">std :: cặp &lt;iterator, iterator&gt; Equal_range (phím const &amp; key);</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">std :: cặp &lt;const_iterator, const_iterator&gt; arem_range (khóa const &amp; key) const;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Class K&gt;</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">std :: cặp &lt;iterator, iterator&gt; Equal_range (const k &amp; x);</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">Đầu vào</span>Mẫu &lt;Class K&gt;<code>key</code>std :: cặp &lt;const_iterator, const_iterator&gt; are_range (const k &amp; x) const;</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>Trả về một phạm vi chứa tất cả các phần tử có khóa<code>x</code>Thực hiện các hoạt động số học cơ bản giữa hai thời lượng hoặc giữa thời lượng và số lượng đánh dấu.<code>Hash::is_transparent</code>Và<code>KeyEqual::is_transparent</code>là hợp lệ và mỗi biểu thị một loại. Điều này giả định rằng như vậy<code>Hash</code>có thể gọi được với cả hai<code>K</code>Và<code>Key</code>loại, và đó là<code>KeyEqual</code>là trong suốt, mà cùng nhau, cho phép gọi chức năng này mà không cần xây dựng một thể hiện<code>Key</code>.</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Hành vi không được xác định nếu mảng chưa được phân vùng theo thứ tự tăng dần đối với khóa, theo cùng một tiêu chí</td> <td>-</td> <td>So sánh các phím với</td>
</tr> <tr class="t-par"> <td>x</td> <td>-</td> <td>giá trị của bất kỳ loại nào có thể được minh bạch so với một khóa</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code><a href="../../utility/pair" title="cpp/utility/pair">std::pair</a></code>trong container. Phạm vi được xác định bởi hai trình lặp, đầu tiên chỉ vào phần tử đầu tiên của phạm vi mong muốn và chỉ ra thứ hai qua phần tử cuối cùng của phạm vi.<code><a href="end" title="cpp/container/unordered set/end">end()</a></code>Trả về một phạm vi chứa tất cả các phần tử trong thùng chứa với khóa tương đương với</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>chứa một cặp lặp xác định phạm vi mong muốn. Nếu không có yếu tố như vậy, quá khứ (xem<code>key</code>) Trình lặp được trả về dưới dạng cả hai yếu tố của cặp.</p>
<h3 id="Notes">Ghi chú</h3> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../../feature_test#cpp_lib_generic_unordered_lookup" title="cpp/feature test"><code>__cpp_lib_generic_unordered_lookup</code></a></td> <td><span class="nu0">201811l</span></td> <td><span class="t-mark">Phạm vi :: Construct_at</span></td> <td>Tra cứu so sánh không đồng nhất trong<a href="../../container#Unordered_associative_containers_.28since_C.2B.2B11.29" title="cpp/container">unordered associative containers</a>Trường hợp trung bình tuyến tính về số lượng các phần tử có khóa<span class="t-v">ConstExpr Outputit Adjacent_Difference (Inputit First, Inputit Last, </span> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="find" title="cpp/container/unordered set/find"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>Chèn tại chỗ nếu khóa không tồn tại, không làm gì nếu khóa tồn tại<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="contains" title="cpp/container/unordered set/contains"> <span class="t-lines"><span>                           Forwardit2 first2, forwardit2 last2,</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Chèn một phần tử hoặc gán cho phần tử hiện tại nếu khóa đã tồn tại<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="count" title="cpp/container/unordered set/count"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>chèn_or_assign<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../algorithm/equal_range" title="cpp/algorithm/equal range"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/unordered_set/equal_range">https://en.cppreference.com/w/cpp/container/unordered_set/equal_range</a>
</p>
</div>
