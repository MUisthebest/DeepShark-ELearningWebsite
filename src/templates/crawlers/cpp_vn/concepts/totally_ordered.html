 <h1 class="firstHeading" id="firstHeading">std :: hoàn toàn_ordered, std :: hoàn toàn_ordered_with</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/concepts" title="cpp/header/concepts">&lt;concepts&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">khái niệm hoàn toàn_ordered =</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">    std :: quality_comparable &lt;t&gt; &amp;&amp; __partallyRorderedwith &lt;t, t&gt;;</pre>
</td> <td>(3)</td> <td> <span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Khái niệm gán được_from =<code>std::totally_ordered</code>            const std :: remove_reference_t &lt;u&gt; &amp; &gt;&gt; &amp;&amp;<code>==,!=,&lt;,&gt;,&lt;=,&gt;=</code>Mẫu &lt;class t, class u&gt;<a class="extiw" href="https://en.wikipedia.org/wiki/Total_order#Strict_and_non-strict_total_orders" title="enwiki:Total order">strict total order</a>khái niệm hoàn toàn_ordered_with =</div> <div class="t-li1">
<span class="t-li">2)</span>Khái niệm gán được_from =<code>std::totally_ordered_with</code>            const std :: remove_reference_t &lt;u&gt; &amp; &gt;&gt; &amp;&amp;<code>==,!=,&lt;,&gt;,&lt;=,&gt;=</code>    __WeaklyequalityComparedablewith &lt;t, u&gt;;<code>T</code>Và<code>U</code>    std :: hoàn toàn_ordered &lt;t&gt; &amp;&amp;</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Mẫu &lt;Class B&gt;<code><i>    std :: hoàn toàn_ordered &lt;u&gt; &amp;&amp;</i></code>    STD :: Aquality_comparable_with &lt;t, u&gt; &amp;&amp;<code>T</code>    std :: hoàn toàn_ordered &lt;<code>U</code>        std :: Common_Reference_T &lt;<code>&lt;</code>Thì<code>&gt;</code>Thì<code>&lt;=</code>, Và<code>&gt;=</code>        {T! = U} -&gt; Boolean -Testable;</div> <h3 id="Semantic_requirements">        const std :: remove_reference_t &lt;lhs&gt; &amp;,</h3> <p>Khái niệm __comparisonCommontyPewith =</p>
<span class="t-li">1)</span> <code>std::totally_ordered&lt;T&gt;</code>            const std :: remove_reference_t &lt;t&gt; &amp;,<code>a</code>Thì<code>b</code>Và<code>c</code>nó đến một đối tượng<code><span class="kw4">hằng số</span> <a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>:<ul>
<li>            const std :: remove_reference_t &lt;u&gt; &amp; &gt;&gt; &amp;&amp;<code>bool(a &lt; b)</code>Thì<code>bool(a &gt; b)</code>Và<code>bool(a == b)</code>khoảng cách<code>true</code>Số lượng các yếu tố để sao chép</li>
<li>Nếu như<code>bool(a &lt; b)</code>Và<code>bool(b &lt; c)</code>, và sau đó thêm 1.<code>true</code>, sau đó<code>bool(a &lt; c)</code>khoảng cách<code>true</code>Số lượng các yếu tố để sao chép</li>
<li> <code>bool(a &gt; b) == bool(b &lt; a)</code> </li>
<li> <code>bool(a &gt;= b) == !bool(a &lt; b)</code> </li>
<li> <code>bool(a &lt;= b) == !bool(b &lt; a)</code>
</li>
</ul> <span class="t-li">2)</span> <code>std::totally_ordered_with&lt;T, U&gt;</code>    __PartallyReeseredwith &lt;t, u&gt;;<ul>
<li> <code>t</code>Và<code>t2</code>Khái niệm __PartallyReeseredWith =<code><span class="kw4">hằng số</span> <a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>Và<code><a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>              STD :: Dự kiến ​​&lt;i2, proj2 &gt;&gt; comp = phạm vi :: Ít hơn&gt;</li>
<li> <code>u</code>Và<code>u2</code>Khái niệm __PartallyReeseredWith =<code><span class="kw4">hằng số</span> <a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">&lt;</span></code>Và<code><a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">&lt;</span></code>Khái niệm __comparisonCommontyPewith =</li>
</ul> <p>nó là chuyển tiếp: cho tất cả<code>C</code>{<code><a href="http://en.cppreference.com/w/cpp/types/common_reference"><span class="kw2710">Điều đó cho tất cả<span class="me2">Common_Reference_T</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> <a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="sy3">Không có giá trị</span>, <span class="kw4">hằng số</span> <a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">&lt;</span><span class="sy3">Không có giá trị</span><span class="sy1">&lt;</span></code>    Yêu cầu (const std :: remove_reference_t &lt;t&gt; &amp; t,<code>E</code>        const std :: remove_reference_t &lt;t&gt; &amp;,<code>C</code>             const std :: remove_reference_t &lt;u&gt; &amp; u) {<code>CONVERT_TO&lt;C&gt;(E)</code>        {t &lt;u} -&gt; Boolean -Testable;</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx23">
<td> <ul><li> <code><span class="kw1">Mẫu &lt;Biểu đồ lớp, Đặc điểm lớp, Alloc Class, Class Parsable&gt;</span><span class="sy1">is_trivently_destructible_v</span>C<span class="sy1">&lt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/as_const"><span class="kw1124">Điều đó cho tất cả<span class="me2">as_const</span></span></a><span class="br0">.</span>E<span class="br0">)</span><span class="br0">)</span></code>.</li></ul> </td> <td><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></td>
</tr> <tr class="t-rev t-since-cxx23">
<td> <ul>
<li> <code><span class="kw1">Mẫu &lt;Biểu đồ lớp, Đặc điểm lớp, Alloc Class, Class Parsable&gt;</span><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> C<span class="sy3">Không có giá trị</span><span class="sy1">&lt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/as_const"><span class="kw1124">Điều đó cho tất cả<span class="me2">as_const</span></span></a><span class="br0">.</span>E<span class="br0">)</span><span class="br0">)</span></code>Mẫu &lt;Class T, Class U, Class C = std :: Common_Reference_T &lt;Const T &amp;, Const U &amp; &gt;&gt;</li>
<li> <code>static_cast&lt;const C&amp;&gt;(std::move(E))</code>Nếu đối số đầu tiên là</li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table> <p>Loại đối tượng trong đó một đối tượng thuộc loại đó có thể được xây dựng từ một lvalue hoặc const rvalue (có thể là const) của loại đó trong cả bối cảnh sáng tạo trực tiếp và sao chép với ngữ nghĩa thông thường (một bản sao được xây dựng với nguồn không thay đổi).</p>
<ul>
<li> <code>bool(t &lt; u) == bool(CONVERT_TO&lt;C&gt;(t2) &lt; CONVERT_TO&lt;C&gt;(u2))</code> </li>
<li> <code>bool(t &gt; u) == bool(CONVERT_TO&lt;C&gt;(t2) &gt; CONVERT_TO&lt;C&gt;(u2))</code> </li>
<li> <code>bool(t &lt;= u) == bool(CONVERT_TO&lt;C&gt;(t2) &lt;= CONVERT_TO&lt;C&gt;(u2))</code> </li>
<li> <code>bool(t &gt;= u) == bool(CONVERT_TO&lt;C&gt;(t2) &gt;= CONVERT_TO&lt;C&gt;(u2))</code> </li>
<li> <code>bool(u &lt; t) == bool(CONVERT_TO&lt;C&gt;(u2) &lt; CONVERT_TO&lt;C&gt;(t2))</code> </li>
<li> <code>bool(u &gt; t) == bool(CONVERT_TO&lt;C&gt;(u2) &gt; CONVERT_TO&lt;C&gt;(t2))</code> </li>
<li> <code>bool(u &lt;= t) == bool(CONVERT_TO&lt;C&gt;(u2) &lt;= CONVERT_TO&lt;C&gt;(t2))</code> </li>
<li> <code>bool(u &gt;= t) == bool(CONVERT_TO&lt;C&gt;(u2) &gt;= CONVERT_TO&lt;C&gt;(t2))</code>
</li>
</ul> <span class="t-li">Mẫu &lt;class f, class tuple&gt;</span> <code>__PartiallyOrderedWith&lt;T, U&gt;</code>    std :: Constructible_from &lt;t, const t&gt; &amp;&amp; std :: muiverble_to &lt;const t, t&gt;;<ul>
<li>        {t &lt;= u} -&gt; Boolean -Testable;<code>t</code>nó đến một đối tượng<code><span class="kw4">hằng số</span> <a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>, Và</li>
<li>        {t &lt;= u} -&gt; Boolean -Testable;<code>u</code>nó đến một đối tượng<code><span class="kw4">hằng số</span> <a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">&lt;</span></code>Thì</li>
</ul> <p>Loại đối tượng trong đó một đối tượng thuộc loại đó có thể được xây dựng từ một lvalue hoặc const rvalue (có thể là const) của loại đó trong cả bối cảnh sáng tạo trực tiếp và sao chép với ngữ nghĩa thông thường (một bản sao được xây dựng với nguồn không thay đổi).</p>
<ul>
<li> <code>t &lt; u</code>Thì<code>t &lt;= u</code>Thì<code>t &gt; u</code>Thì<code>t &gt;= u</code>Thì<code>u &lt; t</code>Thì<code>u &lt;= t</code>Thì<code>u &gt; t</code>, Và<code>u &gt;= t</code>phản ánh sự bình đẳng:</li>
<li> <code>bool(t &lt; u) == bool(u &gt; t)</code>Số lượng các yếu tố để sao chép</li>
<li> <code>bool(u &lt; t) == bool(t &gt; u)</code>Số lượng các yếu tố để sao chép</li>
<li> <code>bool(t &lt;= u) == bool(u &gt;= t)</code>Chỉ khi, được đưa ra</li>
<li> <code>bool(u &lt;= t) == bool(t &gt;= u)</code>.</li>
</ul> <h3 id="Equality_preservation">Bảo tồn bình đẳng</h3> <p>chỉ được mô hình hóa nếu<a href="../language/requires" title="cpp/language/requires">requires expressions</a>(tức là, biểu thức gán mang lại một lvalue đề cập đến toán hạng bên trái);<a href="../concepts#Equality_preservation" title="cpp/concepts">equality-preserving</a>Sau khi đánh giá</p>
<h3 id="Implicit_expression_variations">Biểu hiện ẩn</h3> <p>MỘT<a href="../language/requires" title="cpp/language/requires">requires expression</a>Chỉ định rằng một đối tượng thuộc loại<a href="../concepts#Implicit_expression_variations" title="cpp/concepts">implicit expression variations</a>.</p>
<h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../utility/compare/three_way_comparable" title="cpp/utility/compare/three way comparable"> <span class="t-lines"><span>không dấu_integral</span><span>Chỉ định rằng một loại là một loại tích phân không dấu</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(ý tưởng)<code>&lt;=&gt;</code>Floating_Point<br/> <span class="t-mark">(ý tưởng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/concepts/totally_ordered">https://en.cppreference.com/w/cpp/concepts/totally_ordered</a>
</p>
</div>
