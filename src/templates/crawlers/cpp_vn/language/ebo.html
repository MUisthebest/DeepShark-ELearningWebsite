 <h1 class="firstHeading" id="firstHeading">Tối ưu hóa cơ sở trống</h1> <p>Cho phép kích thước của một tiểu mục cơ sở trống bằng không.</p>
<h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3> <p>Kích thước của bất kỳ<a href="object" title="cpp/language/object">object</a>hoặc SuboBject thành viên được yêu cầu ít nhất là 1 ngay cả khi loại là trống<a href="class" title="cpp/language/class">class type</a>(nghĩa là một lớp hoặc cấu trúc không có thành viên dữ liệu không tĩnh),<span class="t-rev-inl t-since-cxx20"><span>(Trừ khi với<code>[[<a href="attributes/no_unique_address" title="cpp/language/attributes/no unique address">no_unique_address</a>]]</code>, xem bên dưới)</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>Để có thể đảm bảo rằng các địa chỉ của các đối tượng riêng biệt cùng loại luôn luôn khác biệt.</p>
<p>Tuy nhiên, các tiểu mục lớp cơ sở không bị hạn chế và có thể được tối ưu hóa hoàn toàn từ bố cục đối tượng:</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">cơ sở cấu trúc {}; // Lớp trống</pre></div> </div> <p> </p>
<p>Struct Desured1: cơ sở<code><a href="../iterator/reverse_iterator" title="cpp/iterator/reverse iterator">std::reverse_iterator</a></code>{<code><a href="../iterator/iterator" title="cpp/iterator/iterator">std::iterator</a></code>    int i;<code><a href="../iterator/iterator" title="cpp/iterator/iterator">std::iterator</a></code>};</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp"> </pre></div> </div> <p>int main ()</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>{<i>Thực hiện quá tải</i>vì<a href="../named_req/standardlayouttype" title="cpp/named req/StandardLayoutType">StandardLayoutTypes</a>    // Kích thước của bất kỳ đối tượng nào thuộc loại loại trống là ít nhất 1<a href="reinterpret_cast" title="cpp/language/reinterpret cast"><code>reinterpret_cast</code></a>    static_assert (sizeof (cơ sở)&gt; = 1);</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p> <code>[[<a href="attributes/no_unique_address" title="cpp/language/attributes/no unique address">no_unique_address</a>]]</code>    // Áp dụng tối ưu hóa cơ sở trống</p>
<div class="cpp source-cpp"><pre data-language="cpp">    static_assert (sizeof (derive1) == sizeof (int));</pre></div> </td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <h3 id="Notes">Ghi chú</h3> <p>}<code><a href="../container/vector" title="cpp/container/vector">std::vector</a></code>Thì<code><a href="../utility/functional/function" title="cpp/utility/functional/function">std::function</a></code>Thì<code><a href="../memory/shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>Tối ưu hóa cơ sở trống bị cấm nếu một trong các lớp cơ sở trống cũng là loại hoặc cơ sở của loại thành viên dữ liệu không tĩnh đầu tiên, vì hai tiểu mục cơ sở của cùng loại được yêu cầu phải có các địa chỉ khác nhau trong biểu diễn đối tượng của loại có nguồn gốc nhất.<code>begin</code>Thì<code>end</code>, hoặc<code>capacity</code>Một ví dụ điển hình về tình huống như vậy là việc thực hiện ngây thơ<code>vector</code>(xuất phát từ cơ sở trống<a class="external text" href="https://www.boost.org/doc/libs/release/libs/utility/doc/html/boost/compressed_pair.html" rel="nofollow"><code>boost::compressed_pair</code></a>), trong đó giữ bộ lặp cơ bản (cũng có nguồn gốc từ</p>
<h3 id="References">Tài liệu tham khảo</h3> <ul>
<li>C ++ 23 Tiêu chuẩn (ISO/IEC 14882: 2023):</li>
<ul>
<li>{</li>
<li>cơ sở cấu trúc {}; // Lớp trống</li>
<li>};</li>
<li> </li>
</ul>
<li>Tiêu chuẩn C ++ 20 (ISO/IEC 14882: 2020):</li>
<ul>
<li>{</li>
<li>    int i;</li>
<li>};</li>
<li> </li>
</ul>
<li>Tiêu chuẩn C ++ 17 (ISO/IEC 14882: 2017):</li>
<ul>
<li>Struct Desured2: cơ sở</li>
<li>{</li>
<li>    Cơ sở c; // cơ sở, chiếm 1 byte, tiếp theo là đệm cho tôi</li>
<li>    int i;</li>
</ul>
<li>Tiêu chuẩn C ++ 14 (ISO/IEC 14882: 2014):</li>
<ul>
<li>};</li>
<li> </li>
<li>Struct Desured3: cơ sở</li>
<li>{</li>
</ul>
<li>Tiêu chuẩn C ++ 11 (ISO/IEC 14882: 2011):</li>
<ul>
<li>int main ()</li>
<li>{</li>
<li>};</li>
<li> </li>
</ul>
<li>    S.B3 = 0B11;</li>
<ul>
<li>int main ()</li>
<li>{</li>
<li>    // Tối ưu hóa cơ sở trống không áp dụng,</li>
</ul>
</ul> <h3 id="External_links">Liên kết bên ngoài</h3> <table> <tr style="vertical-align:top;"> <td> </td> <td>
<a class="external text" href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Empty_Base_Optimization" rel="nofollow">More C++ Idioms/Empty Base Optimization</a>    // cơ sở chiếm 1 byte, thành viên cơ sở chiếm 1 byte</td>
</tr>
</table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/ebo">https://en.cppreference.com/w/cpp/language/ebo</a>
</p>
</div>
