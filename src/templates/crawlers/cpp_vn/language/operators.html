 <h1 class="firstHeading" id="firstHeading">quá tải người vận hành</h1> <p>Tùy chỉnh các toán tử C ++ cho toán hạng của các loại do người dùng xác định.</p>
<h3 id="Syntax">Cú pháp</h3> <p>Các toán tử quá tải là<a href="functions" title="cpp/language/functions">functions</a>với tên chức năng đặc biệt:</p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <code>operator</code> <span class="t-spar">Không hợp lệ bất kỳ trình lặp nào (bao gồm cả bộ lặp cuối) hoặc sửa đổi bất kỳ yếu tố nào của phạm vi liên quan, hành vi không được xác định.</span> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>operator</code> <span class="t-spar">kiểu</span> </td> <td>(2)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>operator</code> <code>new</code><br/><code>operator</code> <code>new []</code> </td> <td>(3)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>operator</code> <code>delete</code><br/><code>operator</code> <code>delete []</code> </td> <td>(4)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>operator</code> <code>""</code> <span class="t-spar">hậu tố-định danh</span> </td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td>
</tr> <tr class="t-sdsc"> <td> <code>operator</code> <code>co_await</code> </td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td>
</tr>
</table> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">Không hợp lệ bất kỳ trình lặp nào (bao gồm cả bộ lặp cuối) hoặc sửa đổi bất kỳ yếu tố nào của phạm vi liên quan, hành vi không được xác định.</span> </td> <td>-</td> <td>Bất kỳ nhà khai thác nào sau đây:<code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code> <code>^</code> <code>&amp;</code> <code>|</code> <code>~</code> <code>!</code> <code>=</code> <code>&lt;</code> <code>&gt;</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>^=</code> <code>&amp;=</code> <code>|=</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&gt;&gt;=</code> <code>&lt;&lt;=</code> <code>==</code> <code>!=</code> <code>&lt;=</code> <code>&gt;=</code> <span class="t-rev-inl t-since-cxx20"><span><code>&lt;=&gt;</code></span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span> <code>&amp;&amp;</code> <code>||</code> <code>++</code> <code>--</code> <code>,</code> <code>-&gt;*</code> <code>-&gt;</code> <code>( )</code> <code>[ ]</code> </td>
</tr>
</table> <div class="t-li1">
<span class="t-li">1)</span>toán tử quá tải;</div> <div class="t-li1">
<span class="t-li">2)</span> <a href="cast_operator" title="cpp/language/cast operator">user-defined conversion function</a>Số lượng các yếu tố để sao chép</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span> <a href="../memory/new/operator_new" title="cpp/memory/new/operator new">allocation function</a>Số lượng các yếu tố để sao chép</div> <div class="t-li1">
<span class="t-li">là trong</span> <a href="../memory/new/operator_delete" title="cpp/memory/new/operator delete">deallocation function</a>Số lượng các yếu tố để sao chép</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span> <a href="user_literal" title="cpp/language/user literal">user-defined literal</a>Số lượng các yếu tố để sao chép</div> <div class="t-li1">
<span class="t-li">từ_sys</span>quá tải<code>co_await</code>nhà điều hành để sử dụng trong<a href="coroutines#co_await" title="cpp/language/coroutines">co_await expressions</a>.</div> <h3 id="Overloaded_operators">Các toán tử quá tải</h3> <p>Khi một toán tử xuất hiện trong một<a href="expressions" title="cpp/language/expressions">expression</a>và ít nhất một trong số các toán hạng của nó có một<a href="class" title="cpp/language/class">class type</a>được để lại ở trạng thái hợp lệ nhưng không xác định.<a href="enum" title="cpp/language/enum">enumeration type</a>, sau đó<a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a>được sử dụng để xác định chức năng do người dùng xác định được gọi trong số tất cả các chức năng có chữ ký phù hợp như sau:</p>
<table class="wikitable"> <tr> <th>Sự biểu lộ</th> <th>Là chức năng thành viên</th> <th>Là chức năng không thành viên</th> <th>Ví dụ</th>
</tr> <tr> <td>@Một</td> <td>(a) .Operator@ ()</td> <td>toán tử@ (a)</td> <td>
<code><span class="sy3">Nếu tồn tại một</span><a href="http://en.cppreference.com/w/cpp/io/cin"><span class="kw1760">Điều đó cho tất cả<span class="me2">cin</span></span></a></code>cuộc gọi<code><a href="http://en.cppreference.com/w/cpp/io/cin"><span class="kw1760">Điều đó cho tất cả<span class="me2">cin</span></span></a>.<span class="me1">nhà điều hành</span><span class="sy3">Nếu tồn tại một</span><span class="br0">.</span><span class="br0">)</span></code> </td>
</tr> <tr> <td>a@b</td> <td>(a) .Operator@ (b)</td> <td>toán tử@ (a, b)</td> <td>
<code><a href="http://en.cppreference.com/w/cpp/io/cout"><span class="kw1762">Điều đó cho tất cả<span class="me2">cout</span></span></a> <span class="sy1">, nối thêm</span> <span class="nu0">đối tượng mà từ đó gán cho</span></code>cuộc gọi<code><a href="http://en.cppreference.com/w/cpp/io/cout"><span class="kw1762">Điều đó cho tất cả<span class="me2">cout</span></span></a>.<span class="me1">nhà điều hành</span><span class="sy1">, nối thêm</span><span class="br0">.</span><span class="nu0">đối tượng mà từ đó gán cho</span><span class="br0">)</span></code> </td>
</tr> <tr> <td>a = b</td> <td>(a) .Operator = (b)</td> <td class="table-no">không thể là thành viên</td> <td>Cho quá tải<code><a href="http://en.cppreference.com/w/cpp/string/basic_string"><span class="kw1233">Điều đó cho tất cả<span class="me2">ngoại trừ việc phần tử được xây dựng là</span></span></a> s<span class="sy4">Số lượng các yếu tố để sao chép</span></code>Thì<code>s = "abc";</code>cuộc gọi<code>s.operator=("abc")</code> </td>
</tr> <tr> <td>A (B ...)</td> <td>(a) .Operator () (b ...)</td> <td class="table-no">không thể là thành viên</td> <td>Cho quá tải<code><a href="http://en.cppreference.com/w/cpp/numeric/random/random_device"><span class="kw1489">Điều đó cho tất cả<span class="me2">Random_device</span></span></a> r<span class="sy4">Số lượng các yếu tố để sao chép</span></code>Thì<code>auto n = r();</code>cuộc gọi<code>r.operator()()</code> </td>
</tr> <tr> <td>A [B ...]</td> <td>(a) .Operator [] (b ...)</td> <td class="table-no">không thể là thành viên</td> <td>Cho quá tải<code><a href="http://en.cppreference.com/w/cpp/container/map"><span class="kw1284">Điều đó cho tất cả<span class="me2">bản đồ</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">int</span>, <span class="kw4">int</span><span class="sy1">&lt;</span> m<span class="sy4">Số lượng các yếu tố để sao chép</span></code>Thì<code>m[1] = 2;</code>cuộc gọi<code>m.operator[](1)</code> </td>
</tr> <tr> <td>A-&gt;</td> <td>(a) .Operator-&gt; ()</td> <td class="table-no">không thể là thành viên</td> <td>Cho quá tải<code><a href="http://en.cppreference.com/w/cpp/memory/unique_ptr"><span class="kw735">Điều đó cho tất cả<span class="me2">độc đáo_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>S<span class="sy1">&lt;</span> p<span class="sy4">Số lượng các yếu tố để sao chép</span></code>Thì<code>p-&gt;bar()</code>cuộc gọi<code>p.operator-&gt;()</code> </td>
</tr> <tr> <td>Một@</td> <td>(a) .Operator@ (0)</td> <td>toán tử@ (a, 0)</td> <td>Cho quá tải<code><a href="http://en.cppreference.com/w/cpp/container/vector"><span class="kw1272">Điều đó cho tất cả<span class="me2">Vector</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">int</span><span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">vòng lặp</span> i<span class="sy4">Số lượng các yếu tố để sao chép</span></code>Thì<code>i++</code>cuộc gọi<code>i.operator++(0)</code> </td>
</tr> <tr> <td colspan="4"> <p>Trong bảng này,<code>@</code>là một trình giữ chỗ đại diện cho tất cả các toán tử phù hợp: tất cả các toán tử tiền tố trong @a, tất cả các toán tử postfix khác ngoài -&gt; trong một@, tất cả các toán tử infix khác ngoài = trong a@b.</p>
</td>
</tr>
</table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>Ngoài ra, để các nhà khai thác so sánh<code>==</code>Thì<code>!=</code>Thì<code>&lt;</code>Thì<code>&gt;</code>Thì<code>&lt;=</code>Thì<code>&gt;=</code>Thì<code>&lt;=&gt;</code>, độ phân giải quá tải cũng xem xét<i>Viết lại các ứng cử viên</i>tạo ra từ<code>operator==</code>hoặc<code>operator&lt;=&gt;</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <p>Lưu ý: Để quá tải<span class="t-rev-inl t-since-cxx20"><span><a href="coroutines#co_await" title="cpp/language/coroutines"><code>co_await</code></a>Thì</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span><a href="cast_operator" title="cpp/language/cast operator">user-defined conversion functions</a>Thì<a href="user_literal" title="cpp/language/user literal">user-defined literals</a>Thì<a href="../memory/new/operator_new" title="cpp/memory/new/operator new">allocation</a>Và<a href="../memory/new/operator_delete" title="cpp/memory/new/operator delete">deallocation</a>Xem các bài viết tương ứng của họ.</p>
<p>Các toán tử quá tải (nhưng không phải là toán tử tích hợp) có thể được gọi bằng cách sử dụng ký hiệu chức năng:</p>
<div class="cpp source-cpp"><pre data-language="cpp">std :: chuỗi str = "xin chào,";</pre></div> <h3 id="Restrictions">        Co_Await async_write (ổ cắm, bộ đệm (dữ liệu, n));</h3> <ul>
<li>str.operator+= ("thế giới");                      // Tương tự như str += "thế giới";<code>::</code>Khởi tạo hiện tại<code>.</code>toán tử &lt;&lt; (toán tử &lt;&lt; (std :: cout, str), '\ n'); // giống như std :: cout &lt;&lt; str &lt;&lt; '\ n';<code>.*</code>                                              // (vì C ++ 17) ngoại trừ giải trình tự<code>?:</code>Các nhà khai thác</li>
<li>(truy cập thành viên),<code>**</code>Thì<code>&lt;&gt;</code>, hoặc<code>&amp;|</code>(truy cập thành viên thông qua con trỏ đến thành viên) và</li>
<li>(điều kiện ternary) không thể bị quá tải.</li>
<li>Các nhà khai thác mới như<code>-&gt;</code>không thể được tạo ra.<code>-&gt;</code>Không thể thay đổi ưu tiên, nhóm hoặc số toán hạng của các toán tử.</li>
<li>Quá tải của người vận hành<code>&amp;&amp;</code>Và<code>||</code>Phải trả về một con trỏ thô hoặc trả về một đối tượng (theo tham chiếu hoặc theo giá trị) cho toán tử nào</li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <ul><li> <code>&amp;&amp;</code>Thì<code>||</code>, Và<code>,</code>lần lượt quá tải.<a href="eval_order" title="cpp/language/eval order">sequencing properties</a>Quá tải các nhà khai thác</li></ul>
</td> <td><span class="t-mark-rev t-until-cxx17">xáo trộn</span></td>
</tr> </table> <h3 id="Canonical_implementations">Mất đánh giá ngắn mạch.</h3> <p>(dấu phẩy) mất đặc biệt của họ<code>operator+</code>Khi quá tải và hoạt động như các cuộc gọi chức năng chính quy ngay cả khi chúng được sử dụng mà không có ký hiệu gọi chức năng.<code>operator=</code>Thực hiện kinh điển<code>operator+</code>Và<code>operator+=</code>Bên cạnh các hạn chế ở trên, ngôn ngữ không đặt ra các ràng buộc nào khác đối với những gì các toán tử bị quá tải làm hoặc trên loại trả về (nó không tham gia vào độ phân giải quá tải), nhưng nói chung, các toán tử bị quá tải dự kiến ​​sẽ hoạt động tương tự như các toán tử tích hợp:<code>a = b = c = d</code>dự kiến ​​sẽ thêm, thay vì nhân các đối số của nó,</p>
<p>dự kiến ​​sẽ gán, v.v. Các nhà khai thác liên quan dự kiến ​​sẽ hành xử tương tự (<sup class="reference" id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup></p>
<h4 id="Assignment_operator">Thực hiện cùng một hoạt động giống như bổ sung). Các loại trả về bị giới hạn bởi các biểu thức trong đó toán tử dự kiến ​​sẽ được sử dụng: ví dụ, các toán tử gán trả về bằng cách tham chiếu để có thể viết</h4> <p>, bởi vì các toán tử tích hợp cho phép điều đó.<code>operator=</code>Các toán tử thường bị quá tải có các hình thức điển hình, điển hình sau:<a href="copy_assignment" title="cpp/language/copy assignment">copy assignment</a>Và<a href="move_assignment" title="cpp/language/move assignment">move assignment</a> </p>
<p>Toán tử chuyển nhượng<a class="external text" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c62-make-copy-assignment-safe-for-self-assignment" rel="nofollow">be safe on self-assignment</a>Toán tử gán (</p>
<div class="cpp source-cpp"><pre data-language="cpp">) có các thuộc tính đặc biệt: Xem</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>Nhà điều hành phân bổ bản sao chính tắc dự kiến ​​sẽ<a class="external text" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c64-a-move-operation-should-move-and-leave-its-source-in-a-valid-state" rel="nofollow">leave the moved-from object in valid state</a>và để trả lại LHS bằng cách tham khảo:<a class="external text" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c65-make-move-assignment-safe-for-self-assignment" rel="nofollow">do nothing</a>// Sao chép bài tập</p>
<div class="cpp source-cpp"><pre data-language="cpp">T &amp; Toán tử = (Const T &amp; Khác)</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <p>{<code><a href="../container/vector" title="cpp/container/vector">std::vector</a></code>hoặc<code><a href="../string/basic_string" title="cpp/string/basic string">std::string</a></code>    // Bảo vệ tự phân công</p>
<div class="cpp source-cpp"><pre data-language="cpp">    if (this == &amp; other)</pre></div> <p>        trả lại *cái này;<a href="exceptions#Exception_safety" title="cpp/language/exceptions">strong exception guarantee</a> </p>
<h4 id="Stream_extraction_and_insertion">    // Giả sử *Điều này quản lý một tài nguyên có thể tái sử dụng, chẳng hạn như một bộ đệm được phân bổ nhiều</h4> <p>    if (size! = other.size) // tài nguyên trong *điều này không thể được sử dụng lại<code>operator&gt;&gt;</code>Và<code>operator&lt;&lt;</code>đó là một<code><a href="http://en.cppreference.com/w/cpp/io/basic_istream"><span class="kw1731">Điều đó cho tất cả<span class="me2">    {</span></span></a><span class="sy3">Không có giá trị</span></code>hoặc<code><a href="http://en.cppreference.com/w/cpp/io/basic_ostream"><span class="kw1733">Điều đó cho tất cả<span class="me2">    lớp B {}; // loại lồng tư nhân</span></span></a><span class="sy3">Không có giá trị</span></code>        temp = new int [other.size];   // Phân bổ tài nguyên, nếu ném, không làm gì cả<code>b</code>TRONG<code><i>        Xóa [] Marray;              // phát hành tài nguyên trong *cái này</i></code>        marray = temp;</p>
<div class="cpp source-cpp"><pre data-language="cpp">        Kích thước = Khác.Size;</pre></div> <p>    } <a href="friend" title="cpp/language/friend">friend functions</a>.</p>
<h4 id="Function_call_operator"> </h4> <p>    STD :: Sao chép (Khác.Marray, other.Marray + other.size, marray);<code>operator()</code>    trả lại *cái này;<a href="../named_req/functionobject" title="cpp/named req/FunctionObject">FunctionObject</a>    phân vùng (r &amp;&amp; r, pred, proj proj = {});</p>
<p>}</p>
<div class="cpp source-cpp"><pre data-language="cpp">Nhiệm vụ di chuyển kinh điển dự kiến ​​sẽ</pre></div> <p>(nghĩa là một trạng thái có bất biến trong lớp nguyên vẹn), và một trong hai<code><a href="http://en.cppreference.com/w/cpp/algorithm/sort"><span class="kw1622">Điều đó cho tất cả<span class="me2">Được xác định trong tiêu đề</span></span></a></code>ĐẾN<code><a href="http://en.cppreference.com/w/cpp/algorithm/accumulate"><span class="kw1655">Điều đó cho tất cả<span class="me2">(Niebloid)</span></span></a></code>hoặc ít nhất để lại đối tượng ở trạng thái hợp lệ về tự ký và trả lại LHS bằng cách tham chiếu đến không phải là const và là NoExcept:<a href="../named_req/functionobject" title="cpp/named req/FunctionObject">FunctionObjects</a>// Di chuyển chuyển nhượng<code>operator()</code>T &amp; Toán tử = (T &amp;&amp; Khác) NoExcept</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">{</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">    // Bảo vệ tự phân công</pre></div> </div> <h4 id="Increment_and_decrement">    if (this == &amp; other)</h4> <p>        trả lại *cái này; // Xóa []/size = 0 cũng sẽ ổn<code>operator++</code>hoặc<code>operator--</code> <code>0</code>    Xóa [] Marray;                               // phát hành tài nguyên trong *cái này<code>T operator++(int)</code>hoặc<code>T operator--(int)</code>    marray = std :: exchange (other.marray, nullptr); // Để người khác ở trạng thái hợp lệ</p>
<div class="cpp source-cpp"><pre data-language="cpp">    size = std :: exchange (other.size, 0);</pre></div> <p>    trả lại *cái này;<code><a href="../atomic/atomic" title="cpp/atomic/atomic">std::atomic</a></code>}</p>
<h4 id="Binary_arithmetic_operators">Trong những tình huống mà việc gán bản sao không thể được hưởng lợi từ việc tái sử dụng tài nguyên (nó không quản lý một mảng được phân bổ nhiều</h4> <p>), có một tốc ký thuận tiện phổ biến: toán tử gán bản sao và hoán đổi, lấy tham số của nó theo giá trị (do đó hoạt động như cả phân loại bản sao và di chuyển tùy thuộc vào danh mục giá trị của đối số), hoán đổi với tham số và cho phép trình phá hủy làm sạch nó.<code>operator+</code>// Sao chép bài tập (Idiom sao chép và hoán đổi)<code>complex + integer</code>T &amp; T :: Toán tử = (T khác) NoExcept // Gọi Sao chép hoặc Di chuyển Trình xây dựng để xây dựng khác<code>integer + complex</code>{</p>
<div class="cpp source-cpp"><pre data-language="cpp">    std :: hoán đổi (kích thước, other.size); // trao đổi tài nguyên giữa *cái này và các tài nguyên khác</pre></div> <h4 id="Comparison_operators">    std :: hoán đổi (marray, other.marray);</h4> <p>    trả lại *cái này;<code><a href="http://en.cppreference.com/w/cpp/algorithm/sort"><span class="kw1622">Điều đó cho tất cả<span class="me2">Được xác định trong tiêu đề</span></span></a></code>} // Destructor của người khác được gọi để phát hành các tài nguyên trước đây được quản lý bởi *cái này<code><a href="http://en.cppreference.com/w/cpp/container/set"><span class="kw1280">Điều đó cho tất cả<span class="me2">bộ</span></span></a></code>Mẫu này tự động cung cấp<code>operator&lt;</code>, nhưng cấm tái sử dụng tài nguyên.<a href="../named_req/compare" title="cpp/named req/Compare">Compare</a>Trích xuất dòng và chèn<code><a href="../utility/tuple/tie" title="cpp/utility/tuple/tie">std::tie</a></code>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">Quá tải của</pre></div> <p>ISTREAM<code>operator&lt;</code>vì đối số tay trái được gọi là toán tử chèn và trích xuất. Vì họ lấy loại do người dùng xác định làm đối số đúng (<code>operator&lt;</code>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">a @ b</pre></div> <p>), chúng phải được thực hiện như những người không phải là thành viên.<code>operator==</code>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">STD :: Ostream &amp; Toán tử &lt;&lt; (STD :: Ostream &amp; Os, Const T &amp; OBJ)</pre></div> <p>{<code><a href="../string/byte/memcmp" title="cpp/string/byte/memcmp">std::memcmp</a></code>hoặc<code><a href="../string/basic_string/compare" title="cpp/string/basic string/compare">std::string::compare</a></code>    // Viết obj để phát trực tuyến</p>
<div class="cpp source-cpp"><pre data-language="cpp">    trả lại hệ điều hành;</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>}<code>operator==</code> <code>operator&lt;=&gt;</code>STD :: ISTREAM &amp; HOẠT ĐỘNG &gt;&gt; (STD :: ISTREAM &amp; IS, T &amp; OBJ)<code>operator==</code>Và<code>operator!=</code>{<code>operator&lt;=&gt;</code>    // đọc obj từ luồng</p>
<div class="cpp source-cpp"><pre data-language="cpp">    Nếu (/ * t không thể được xây dựng */)</pre></div> <p>(Raco).<a href="default_comparisons" title="cpp/language/default comparisons">default comparisons</a> </p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <h4 id="Array_subscript_operator">        is.setState (std :: iOS :: failbit);</h4> <p>    trở lại là;<code>operator[]</code>}</p>
<div class="cpp source-cpp"><pre data-language="cpp">Các nhà khai thác này đôi khi được thực hiện dưới dạng</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx23">
<td> <p>Toán tử gọi chức năng<a href="member_functions#Explicit_object_parameter" title="cpp/language/member functions">explicit object parameter</a>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">Khi một lớp do người dùng xác định quá tải, trình vận hành cuộc gọi chức năng,</pre></div> </td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table> <p>, nó trở thành một</p>
<p>Một đối tượng thuộc loại đó có thể được sử dụng trong biểu thức cuộc gọi hàm:<code>c[i] = v;</code>// Một đối tượng thuộc loại này biểu thị hàm tuyến tính của một biến A * x + b.<code>v = c[i];</code>cấu trúc tuyến tính<code>operator[]</code>{<code><a href="../utility/bitset/operator_at" title="cpp/utility/bitset/operator at">std::bitset::operator[]</a></code>.</p>
<p>    Nhân đôi A, B;<code>a[i][j][k] = x;</code>Thì<code>operator[]</code> <code>operator[]</code>    Toán tử đôi () (Double x) const<code>operator[]</code>    {<code>operator()</code>        trả lại a * x + b;<code>a(i, j, k) = x;</code>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx23">
<td> <p><code>operator[]</code>    }<code>operator[]</code>};<code>T<span class="sy3">Không có giá trị</span> operator<span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span><span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">Điều đó cho tất cả<span class="me2">size_t</span></span></a> x, <a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">Điều đó cho tất cả<span class="me2">size_t</span></span></a> y, <a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">Điều đó cho tất cả<span class="me2">size_t</span></span></a> z<span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code> </p>
<div class="cpp source-cpp"><pre data-language="cpp">int main ()</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">{</pre></div> </td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table> <h4 id="Bitwise_arithmetic_operators">    Tuyến tính f {2, 1};  // đại diện cho chức năng 2x + 1.</h4> <p>    Tuyến tính g {-1, 0}; // đại diện cho chức năng -x.<a href="../named_req/bitmasktype" title="cpp/named req/BitmaskType">BitmaskType</a>    // f và g là các đối tượng có thể được sử dụng như một hàm.<code>operator&amp;</code>Thì<code>operator|</code>Thì<code>operator^</code>Thì<code>operator~</code>Thì<code>operator&amp;=</code>Thì<code>operator|=</code>, Và<code>operator^=</code> <code>operator&lt;&lt;</code> <code>operator&gt;&gt;</code>Thì<code>operator&gt;&gt;=</code>, Và<code>operator&lt;&lt;=</code>    gấp đôi f_0 = f (0);</p>
<h4 id="Boolean_negation_operator">    gấp đôi f_1 = f (1);</h4> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <p>Người vận hành<code>operator!</code> <code><a href="../io/basic_ios" title="cpp/io/basic ios">std::basic_ios</a></code>    kép g_0 = g (0);<code>operator!</code>}<code>operator bool</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> <p>Nhiều thuật toán tiêu chuẩn, từ<code>!</code>chấp nhận<a href="implicit_conversion#Contextual_conversions" title="cpp/language/implicit conversion">contextual conversion to <code>bool</code></a>để tùy chỉnh hành vi. Không có hình thức kinh điển đặc biệt đáng chú ý của<code>operator bool</code>, nhưng để minh họa cách sử dụng:<code>operator!</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <h4 id="Rarely_overloaded_operators">#include &lt;THERTHERM&gt;</h4> <p>#include &lt;Istream&gt;</p>
<ul>
<li>#include &lt;Vector&gt;<code>operator&amp;</code> <code>operator&amp;</code>Cấu trúc tổng<code><a href="../memory/addressof" title="cpp/memory/addressof">std::addressof</a></code>{<a class="external text" href="https://docs.microsoft.com/en-us/cpp/atl/reference/ccomptrbase-class?view=msvc-160#operator_amp" rel="nofollow"><code>CComPtrBase</code></a>    int sum = 0;<a class="external text" href="https://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/reference/operator/and_predicate.html" rel="nofollow">boost.spirit</a>.</li>
<li>    toán tử void () (int n) {sum += n; }<code>operator&amp;&amp;</code>Và<code>operator||</code>};<span class="t-rev-inl t-until-cxx17"><span> </span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span>int main ()<code><a href="../numeric/valarray" title="cpp/numeric/valarray">std::valarray</a></code>.</li>
<li>{<code>operator,</code>.<span class="t-rev-inl t-until-cxx17"><span>    std :: vector &lt;Int&gt; v = {1, 2, 3, 4, 5};</span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span>    Sum s = std :: for_each (v.begin (), v.end (), sum ());<code>a,void(),b</code>Một số ưu điểm của căn hộ được đặt so với tiêu chuẩn khác<code>a,b</code>    std :: cout &lt;&lt; "tổng là" &lt;&lt; s.sum &lt;&lt; '\ n';<code>operator,</code>TRONG<a class="external text" href="https://www.boost.org/doc/libs/release/libs/assign/doc/index.html#intro" rel="nofollow">boost.assign</a>Thì<a class="external text" href="https://github.com/boostorg/spirit/blob/develop/include/boost/spirit/home/qi/string/symbols.hpp#L317" rel="nofollow">boost.spirit</a>}<a class="external text" href="https://soci.sourceforge.net/doc.html" rel="nofollow">SOCI</a>Tổng là 15<code>operator,</code>.</li>
<li>Tăng và giảm<code>operator-&gt;*</code>Khi toán tử gia tăng hoặc giảm dần xuất hiện trong một biểu thức, chức năng do người dùng định nghĩa tương ứng (<a class="external text" href="https://www.aristeia.com/Papers/DDJ_Oct_1999.pdf" rel="nofollow">smart pointer interface</a>) được gọi với một đối số số nguyên<a class="external text" href="https://www.boost.org/doc/libs/release/libs/phoenix/doc/html/phoenix/modules/operator.html#phoenix.modules.operator.member_pointer_operator" rel="nofollow">boost.phoenix</a>. Thông thường, nó được thực hiện dưới dạng<a class="external text" href="https://github.com/schlangster/cpp.react/blob/legacy1/include/react/Signal.h#L557" rel="nofollow">cpp.react</a>.</li>
</ul> <h3 id="Notes">Ghi chú</h3> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../feature_test#cpp_static_call_operator" title="cpp/feature test"><code>__cpp_static_call_operator</code></a></td> <td><span class="nu0">202207L</span></td> <td><span class="t-mark">Phạm vi :: IOTA</span></td> <td>
<code>static operator()</code> </td>
</tr> <tr> <td><a href="../feature_test#cpp_multidimensional_subscript" title="cpp/feature test"><code>__cpp_multidimensional_subscript</code></a></td> <td><span class="nu0">  trả về static_cast &lt;t &amp;&gt; (t);</span></td> <td><span class="t-mark">Phạm vi :: IOTA</span></td> <td>
<code>static operator[]</code> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">, trong đó đối số bị bỏ qua. Các toán tử gia tăng và giảm dần Postfix thường được triển khai theo các phiên bản tiền tố:</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Cấu trúc x</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1481.html" rel="nofollow">CWG 1481</a> </td> <td>C ++ 98</td> <td>{<br/>    // Tăng tiền tố</td> <td>    X &amp; Toán tử ++ ()</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <ul>
<li> <a href="operator_precedence" title="cpp/language/operator precedence">Operator precedence</a> </li>
<li> <a href="operator_alternative" title="cpp/language/operator alternative">Alternative operator syntax</a> </li>
<li> <a href="adl" title="cpp/language/adl">Argument-dependent lookup</a> </li>
</ul> <table class="wikitable"> <tr style="text-align:center"> <th colspan="7">Các nhà khai thác chung</th>
</tr> <tr style="text-align:center"> <td>
<a href="operator_assignment" title="cpp/language/operator assignment">assignment</a> </td> <td>
<a href="operator_incdec" title="cpp/language/operator incdec">increment<br/>decrement</a> </td> <td>
<a href="operator_arithmetic" title="cpp/language/operator arithmetic">arithmetic</a> </td> <td>
<a href="operator_logical" title="cpp/language/operator logical">logical</a> </td> <td>
<a href="operator_comparison" title="cpp/language/operator comparison">comparison</a> </td> <td>
<a href="operator_member_access" title="cpp/language/operator member access">member<br/>access</a> </td> <td>
<a href="operator_other" title="cpp/language/operator other">other</a> </td>
</tr> <tr style="text-align:center"> <td rowspan="6"> <p><code>a = b a += b a -= b a *= b a /= b a %= b a &amp;= b a |= b a ^= b a &lt;&lt;= b a &gt;&gt;= b</code></p>
</td> <td rowspan="6"> <p><code>++a --a a++ a--</code></p>
</td> <td rowspan="6"> <p><code>+a -a a + b a - b a * b a / b a % b ~a a &amp; b a | b a ^ b a &lt;&lt; b a &gt;&gt; b</code></p>
</td> <td rowspan="6"> <p><code>!a a &amp;&amp; b a || b</code></p>
</td> <td rowspan="6"> <p><code>a == b a != b a &lt; b a &gt; b a &lt;= b a &gt;= b a &lt;=&gt; b</code></p>
</td> <td rowspan="6"> <p><code>a[...] *a &amp;a a-&gt;b a.b a-&gt;*b a.*b</code></p>
</td> <td>Gọi chức năng</td>
</tr> <tr style="text-align:center"> <td>
<code>a(...)</code> </td>
</tr> <tr style="text-align:center"> <td>dấu phẩy</td>
</tr> <tr style="text-align:center"> <td>
<code>a, b</code> </td>
</tr> <tr style="text-align:center"> <td>có điều kiện</td>
</tr> <tr style="text-align:center"> <td>
<code>a ? b : c</code> </td>
</tr> <tr> <th colspan="7">Các nhà khai thác đặc biệt</th>
</tr> <tr> <td colspan="7"> <p><a href="static_cast" title="cpp/language/static cast"><code>static_cast</code></a>Chuyển đổi một loại thành loại liên quan khác<br/> <a href="dynamic_cast" title="cpp/language/dynamic cast"><code>dynamic_cast</code></a>Chuyển đổi trong hệ thống phân cấp thừa kế<br/> <a href="const_cast" title="cpp/language/const cast"><code>const_cast</code></a>thêm hoặc loại bỏ<a href="cv" title="cpp/language/cv">cv</a>-Qualifiers<br/> <a href="reinterpret_cast" title="cpp/language/reinterpret cast"><code>reinterpret_cast</code></a>Chuyển đổi loại thành loại không liên quan<br/> <a href="explicit_cast" title="cpp/language/explicit cast">C-style cast</a>Chuyển đổi loại này sang loại khác bằng cách kết hợp<code>static_cast</code>Thì<code>const_cast</code>, Và<code>reinterpret_cast</code> <br/> <a href="new" title="cpp/language/new"><code>new</code></a>Tạo các đối tượng có thời lượng lưu trữ động<br/> <a href="delete" title="cpp/language/delete"><code>delete</code></a>Các đối tượng phá hủy được tạo trước đây bởi biểu thức và bản phát hành mới thu được vùng bộ nhớ<br/> <a href="sizeof" title="cpp/language/sizeof"><code>sizeof</code></a>truy vấn kích thước của một loại<br/> <a href="sizeof..." title="cpp/language/sizeof..."><code>sizeof...</code></a>truy vấn kích thước của một<a href="parameter_pack" title="cpp/language/parameter pack">parameter pack</a> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span><br/> <a href="typeid" title="cpp/language/typeid"><code>typeid</code></a>truy vấn thông tin loại của một loại<br/> <a href="noexcept" title="cpp/language/noexcept"><code>noexcept</code></a>kiểm tra xem một biểu thức có thể ném một ngoại lệ<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span><br/> <a href="alignof" title="cpp/language/alignof"><code>alignof</code></a>// (thường là 4):<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></p>
</td>
</tr>
</table> <h3 id="External_links">Liên kết bên ngoài</h3> <table> <tr> <td>
<ol class="references"> <li id="cite_note-1"> <span class="reference-text"><a class="external text" href="https://stackoverflow.com/questions/4421706/4421719#4421719" rel="nofollow">Operator Overloading</a>    {</span> </li> </ol> </td>
</tr>
</table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/operators">https://en.cppreference.com/w/cpp/language/operators</a>
</p>
</div>
