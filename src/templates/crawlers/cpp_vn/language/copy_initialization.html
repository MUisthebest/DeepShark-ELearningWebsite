 <h1 class="firstHeading" id="firstHeading">Sao chép-khởi tạo</h1> <p>Khởi tạo một đối tượng từ một đối tượng khác.</p>
<h3 id="Syntax">Cú pháp</h3> <table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <span class="t-spar">T</span> <span class="t-spar">sự vật</span> <code>=</code> <span class="t-spar">khác</span><code>;</code> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">T</span> <span class="t-spar">sự vật</span> <code>=</code> <code>{</code><span class="t-spar">khác</span><code>};</code> </td> <td>(2)</td> <td> <span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">có thể sửa đổi các phần tử của phạm vi thông qua trình lặp được thu hút. Nếu như</span><code>(</code><span class="t-spar">khác</span><code>)</code> </td> <td>(3)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>return</code> <span class="t-spar">khác</span><code>;</code> </td> <td>(4)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>throw </code><span class="t-spar">sự vật</span><code>;</code> <p><code>catch (</code><span class="t-spar">T</span> <span class="t-spar">sự vật</span><code>)</code></p>
</td> <td>             Không có p);</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">T</span> <span class="t-spar">Mảng</span><code>[</code><span class="t-spar">N</span><code>] = {</code><span class="t-spar">chuỗi khác</span><code>};</code> </td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3> <p>Sao chép-khởi tạo được thực hiện trong các tình huống sau:</p>
<div class="t-li1">
<span class="t-li">1)</span>Khi một biến được đặt tên (tự động, tĩnh hoặc địa lý) của một loại không tham chiếu<code>T</code>được khai báo với bộ khởi tạo bao gồm một dấu bằng theo sau là một biểu thức.</div> <div class="t-li1">
<span class="t-li">2)</span> <span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span>Khi một biến được đặt tên của một loại vô hướng<code>T</code>được khai báo với bộ khởi tạo bao gồm một dấu bằng theo sau là biểu thức được bao bọc bằng niềng (lưu ý: như C ++ 11, điều này được phân loại là<a href="list_initialization" title="cpp/language/list initialization">list initialization</a>, và không được phép chuyển đổi không được phép).</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>      std :: memory_order order = std :: memory_order_seq_cst) noexcept dễ bay hơi;<a href="operator_other#Built-in_function_call_operator" title="cpp/language/operator other">passing an argument</a>đến một hàm theo giá trị.</div> <div class="t-li1">
<span class="t-li">là trong</span>      std :: memory_order order = std :: memory_order_seq_cst) noexcept dễ bay hơi;<a href="return" title="cpp/language/return">returning</a>từ một hàm trả về theo giá trị.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>      std :: memory_order order = std :: memory_order_seq_cst) noexcept dễ bay hơi;<a href="throw" title="cpp/language/throw">throwing</a>hoặc<a href="try_catch" title="cpp/language/try catch">catching</a>một ngoại lệ theo giá trị.</div> <div class="t-li1">
<span class="t-li">từ_sys</span>Như một phần của<a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate initialization</a>, để khởi tạo từng phần tử mà bộ khởi tạo được cung cấp.</div> <p>Những ảnh hưởng của việc bắt đầu sao chép là:</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <ul><li>Đầu tiên, nếu<code>T</code>là loại lớp và trình khởi tạo là một<a href="value_category" title="cpp/language/value category">prvalue</a>Biểu thức có loại CV-UNQUITEDY giống như<code>T</code>, Bản thân biểu thức khởi tạo, thay vì một vật chất tạm thời từ nó, được sử dụng để khởi tạo đối tượng đích: Xem<a href="copy_elision" title="cpp/language/copy elision">copy elision</a>.</li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <ul>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>T</code>là loại lớp và phiên bản<span class="t-spar">khác</span>khoảng cách<code>T</code>hoặc một lớp học xuất phát từ<code>T</code>    toán tử-= (const std :: chrono :: tháng &amp; dm) const noexcept;<a href="converting_constructor" title="cpp/language/converting constructor">non-explicit constructors</a>của<code>T</code>được kiểm tra và phù hợp tốt nhất được chọn bởi độ phân giải quá tải. Trình xây dựng đó sau đó được gọi để khởi tạo đối tượng.</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>T</code>là loại lớp và phiên bản CV-Unquilified của loại<span class="t-spar">khác</span># Elif __has_include (&lt;thử nghiệm/tùy chọn&gt;) // Kiểm tra phiên bản thử nghiệm<code>T</code>hoặc bắt nguồn từ<code>T</code>Xây dựng một khoảng một khung nhìn trong phạm vi<code>T</code>là loại không thuộc lớp, nhưng loại<span class="t-spar">khác</span>là một loại lớp,<a class="mw-redirect" href="implicit_cast" title="cpp/language/implicit cast">user-defined conversion sequences</a>có thể chuyển đổi từ loại<span class="t-spar">khác</span>ĐẾN<code>T</code>(hoặc một loại có nguồn gốc từ<code>T</code>nếu như<code>T</code>là loại lớp và chức năng chuyển đổi có sẵn) được kiểm tra và loại tốt nhất được chọn thông qua độ phân giải quá tải. Kết quả của việc chuyển đổi, đó là một<span class="t-rev-inl t-until-cxx11"><span>Rvalue tạm thời</span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx11 t-until-cxx17"><span>prvalue tạm thời</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span><span class="t-rev-inl t-since-cxx17"><span>Biểu thức prvalue</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>của phiên bản CV-Unquef<code>T</code>Tất cả bộ nhớ đều ghi (nguyên tử không phải là nguyên tử và thư giãn)<a href="converting_constructor" title="cpp/language/converting constructor">converting constructor</a>đã được sử dụng, sau đó được sử dụng để<a href="direct_initialization" title="cpp/language/direct initialization">direct-initialize</a>đối tượng.<span class="t-rev-inl t-until-cxx17"><span>Bước cuối cùng thường là<a href="copy_elision" title="cpp/language/copy elision">optimized out</a>và kết quả của việc chuyển đổi được xây dựng trực tiếp trong bộ nhớ được phân bổ cho đối tượng đích, nhưng hàm tạo thích hợp (di chuyển hoặc sao chép) được yêu cầu truy cập mặc dù nó không được sử dụng.</span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span> </li>
<li>Nếu không (nếu không<code>T</code>cũng không phải loại<span class="t-spar">khác</span>là các loại lớp),<a class="mw-redirect" href="implicit_cast" title="cpp/language/implicit cast">standard conversions</a>được sử dụng, nếu cần thiết, để chuyển đổi giá trị của<span class="t-spar">khác</span>đến phiên bản CV-Unquilified của<code>T</code>.</li>
</ul> <h3 id="Notes">Ghi chú</h3> <p>Sao chép-khởi tạo ít cho phép hơn so với khởi tạo trực tiếp:<a href="explicit" title="cpp/language/explicit">explicit constructors</a>cũng không a<a href="converting_constructor" title="cpp/language/converting constructor">converting constructors</a>và không được xem xét để bắt đầu bản sao.</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct exp {rõ ràng exp (const char*) {}}; // không chuyển đổi từ const char*</pre></div> <p>Exp e1 ("ABC");  // ĐƯỢC RỒI<code>T</code>Exp e2 = "abc"; // Lỗi, sao chép sao chép sao chép không xem xét hàm tạo rõ ràng<code>T</code> </p>
<div class="cpp source-cpp"><pre data-language="cpp">struct imp {imp (const char*) {}}; // chuyển đổi từ const char*</pre></div> <p>Nếu như<span class="t-spar">khác</span>Imp i1 ("ABC");  // ĐƯỢC RỒI<a href="move_constructor" title="cpp/language/move constructor">move constructor</a>Imp i2 = "ABC"; // ĐƯỢC RỒI</p>
<p><a class="mw-redirect" href="implicit_cast" title="cpp/language/implicit cast">Implicit conversion</a>Ngoài ra, việc chuyển đổi ngầm trong khởi tạo sao chép phải tạo ra<code>T</code>trực tiếp từ bộ khởi tạo, trong khi, ví dụ: khởi tạo trực tiếp mong đợi một sự chuyển đổi ngầm từ bộ khởi tạo sang đối số<code>E</code>, sau đó<code>E</code>. Hàm tạo này chỉ tham gia vào độ phân giải quá tải nếu<code>T</code>.</p>
<p>nhà xây dựng.<code>=</code>struct s {s (std :: chuỗi) {}}; // có thể chuyển đổi hoàn toàn từ STD :: Chuỗi</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">S S ("ABC");   // ok: chuyển đổi từ const char [4] sang std :: chuỗi</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/5.html" rel="nofollow">CWG 5</a> </td> <td>C ++ 98</td> <td>S s = "abc";  // Lỗi: Không chuyển đổi từ const char [4] sang s<br/>S s = "abc" s; // OK: Chuyển đổi từ STD :: Chuỗi thành S</td> <td>là một biểu thức rvalue, một</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/177.html" rel="nofollow">CWG 177</a> </td> <td>C ++ 98</td> <td>sẽ được chọn bởi độ phân giải quá tải và được gọi trong quá trình khởi tạo sao chép. Điều này vẫn được coi là khởi tạo sao chép; Không có thuật ngữ đặc biệt (ví dụ: bắt đầu di chuyển) cho trường hợp này.<br/>được xác định theo các điều khoản khởi tạo sao chép: nếu một đối tượng thuộc loại</td> <td>có thể được sao chép bản sao với biểu thức</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <ul>
<li> <a href="copy_elision" title="cpp/language/copy elision">copy elision</a> </li>
<li> <a href="converting_constructor" title="cpp/language/converting constructor">converting constructor</a> </li>
<li> <a href="copy_assignment" title="cpp/language/copy assignment">copy assignment</a> </li>
<li> <a href="copy_constructor" title="cpp/language/copy constructor">copy constructor</a> </li>
<li> <a href="default_constructor" title="cpp/language/default constructor">default constructor</a> </li>
<li> <a href="destructor" title="cpp/language/destructor">destructor</a> </li>
<li> <a href="explicit" title="cpp/language/explicit"><code>explicit</code></a> </li>
<li> <a href="initialization" title="cpp/language/initialization">initialization</a> <ul>
<li> <a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate initialization</a> </li>
<li> <a href="constant_initialization" title="cpp/language/constant initialization">constant initialization</a> </li>
<li> <a href="default_initialization" title="cpp/language/default initialization">default initialization</a> </li>
<li> <a href="direct_initialization" title="cpp/language/direct initialization">direct initialization</a> </li>
<li> <a class="mw-redirect" href="initializer_list" title="cpp/language/initializer list">initializer list</a> </li>
<li> <a href="list_initialization" title="cpp/language/list initialization">list initialization</a> </li>
<li> <a href="reference_initialization" title="cpp/language/reference initialization">reference initialization</a> </li>
<li> <a href="value_initialization" title="cpp/language/value initialization">value initialization</a> </li>
<li> <a href="zero_initialization" title="cpp/language/zero initialization">zero initialization</a> </li>
</ul> </li>
<li> <a href="move_assignment" title="cpp/language/move assignment">move assignment</a> </li>
<li> <a href="move_constructor" title="cpp/language/move constructor">move constructor</a> </li>
<li> <a href="new" title="cpp/language/new"><code>new</code></a> </li>
</ul> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/copy_initialization">https://en.cppreference.com/w/cpp/language/copy_initialization</a>
</p>
</div>
