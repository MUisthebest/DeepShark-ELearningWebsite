 <h1 class="firstHeading" id="firstHeading">Các<code>this</code>Không làm mất hiệu lực bất kỳ tài liệu tham khảo nào về các yếu tố của deque.</h1> <h3 id="Syntax">Cú pháp</h3> <table class="t-sdsc-begin"> <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <code>this</code> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <p>              Không có p);<code>this</code>Điều đó như vậy<a href="value_category#prvalue" title="cpp/language/value category">prvalue</a> <a href="expressions" title="cpp/language/expressions">expression</a>giá trị của ai là địa chỉ của<a href="overload_resolution#Implicit_object_parameter" title="cpp/language/overload resolution">implicit object parameter</a>(đối tượng mà<span class="t-rev-inl t-until-cxx23"><span>Chức năng thành viên không tĩnh</span><span><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></span></span><span class="t-rev-inl t-since-cxx23"><span>        // Tuyên bố trên tương đương với hai khai báo riêng biệt:</span><span><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></span></span>đang được gọi). Nó có thể xuất hiện trong các bối cảnh sau:</p>
<div class="t-li1">
<span class="t-li">1)</span>Trong cơ thể của bất kỳ<span class="t-rev-inl t-until-cxx23"><span><a href="member_functions" title="cpp/language/member functions">non-static member function</a></span><span><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></span></span><span class="t-rev-inl t-since-cxx23"><span><a href="member_functions" title="cpp/language/member functions">implicit object member function</a></span><span><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></span></span>, bao gồm<a class="mw-redirect" href="initializer_list" title="cpp/language/initializer list">member initializer list</a><span class="t-rev-inl t-since-cxx11"><span>, Và<a href="lambda#closure_type_fun_operator" title="cpp/language/lambda">lambda expression body</a></span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>.</div> <div class="t-li1">
<span class="t-li">2)</span>Trong<a href="function" title="cpp/language/function">declaration</a>xuất hiện trong bối cảnh ngay lập tức của một khởi tạo mẫu.<span class="t-rev-inl t-until-cxx23"><span>Chức năng thành viên không tĩnh</span><span><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></span></span><span class="t-rev-inl t-since-cxx23"><span>        // Tuyên bố trên tương đương với hai khai báo riêng biệt:</span><span><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></span></span>Bất cứ nơi nào sau chuỗi trình điều khiển CV (tùy chọn), bao gồm cả<table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <ul><li> <a href="except_spec" title="cpp/language/except spec">dynamic exception specification</a>Thì</li></ul> </td> <td><span class="t-mark-rev t-until-cxx17">xáo trộn</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul>
<li> <a href="noexcept_spec" title="cpp/language/noexcept spec">noexcept specification</a>, Và</li>
<li>Loại trả về dấu vết.</li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table>
</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Ở trong<a href="data_members#Member_initialization" title="cpp/language/data members">default member initializer</a>.<span class="t-li">là trong</span>Ở trong<a href="lambda#Lambda_capture" title="cpp/language/lambda">lambda-expression capture</a>danh sách.</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3> <p><code>this</code>Chỉ có thể liên kết với lớp kèm theo bên trong của sự xuất hiện của nó, ngay cả khi sự xuất hiện không hợp lệ trong bối cảnh:</p>
<div class="cpp source-cpp"><pre data-language="cpp">lớp ngoài</pre></div> <p>Loại của<code>this</code>{<code>X</code>khoảng cách<code>X*</code>    int a [sizeof (*this)];            // Lỗi: không bên trong hàm thành viên<a href="member_functions#member_functions_with_cv-qualifiers" title="cpp/language/member functions">declared with a cv-qualifier sequence</a> <i>không ngụ ý rằng</i>, loại<code>this</code>khoảng cách<code><i>không ngụ ý rằng</i> X*</code>    unsign int sz = sizeof (*this); // OK: trong bộ khởi tạo thành viên mặc định<code>this</code> <code>X*</code>    void f ()</p>
<p>    {<code>this</code>        int b [sizeof (*this)];     // ĐƯỢC RỒI<code>this-&gt;</code> </p>
<p>        Cấu trúc bên trong<code>this</code>Điều đó như vậy<a href="dependent_name" title="cpp/language/dependent name">dependent expression</a>        {<code>this-&gt;</code>            int c [sizeof (*this)]; // Lỗi: không bên trong hàm thành viên của bên trong</p>
<div class="cpp source-cpp"><pre data-language="cpp">                                  // 'cái này' không liên quan đến bên ngoài</pre></div> <p><a href="constructor" title="cpp/language/constructor">During construction</a>                                  // ngay cả khi nó ở bên trong chức năng thành viên của bên ngoài<code>this</code>        };</p>
<div class="cpp source-cpp"><pre data-language="cpp">    }</pre></div> <p>};<code>delete this;</code>Trong một chức năng thành viên của lớp<code>this</code>(Con trỏ tới x). Nếu hàm thành viên là<code>delete this;</code>(Con trỏ tới X-Thủ định CV giống hệt nhau). Vì các hàm tạo và hàm hủy không thể được khai báo với các trình điều chỉnh CV, nên loại<code>this</code>trong họ luôn luôn</p>
<p>, ngay cả khi xây dựng hoặc phá hủy một đối tượng const.<span class="t-rev-inl t-since-cxx11"><span>Khi một thành viên lớp không tĩnh được sử dụng trong bất kỳ bối cảnh nào trong đó<code><a href="../memory/shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>)</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Từ khóa được cho phép (các cơ quan chức năng thành viên không tĩnh, danh sách khởi tạo thành viên, bộ khởi tạo thành viên mặc định), ẩn</p>
<div class="cpp source-cpp"><pre data-language="cpp">được tự động thêm trước tên, dẫn đến biểu thức truy cập thành viên (nếu thành viên là hàm thành viên ảo, kết quả là một cuộc gọi chức năng ảo).</pre></div> <h3 id="Keywords">không định nghĩa macro như vậy. Tuy nhiên, nó xác định hằng số macro</h3> <p><a href="../keyword/this" title="cpp/keyword/this"><code>this</code></a></p>
<h3 id="Example">Ví dụ</h3> <div class="cpp source-cpp"><pre data-language="cpp">Trong các mẫu lớp,</pre></div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/760.html" rel="nofollow">CWG 760</a> </td> <td>C ++ 98</td> <td>Chuyển đổi danh tính:<code>this</code>, và rõ ràng<br/>có thể được sử dụng để buộc một biểu thức khác trở nên phụ thuộc.<br/>Mẫu &lt;Typename T&gt;</td> <td>
<code>this</code>cấu trúc b<br/>{<br/>    int var;<br/>};</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2271.html" rel="nofollow">CWG 2271</a> </td> <td>C ++ 98</td> <td>
<code>this</code> </td> <td>Mẫu &lt;Typename T&gt;<br/>Struct D: B &lt;t&gt;</td>
</tr>
</table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/this">https://en.cppreference.com/w/cpp/language/this</a>
</p>
</div>
