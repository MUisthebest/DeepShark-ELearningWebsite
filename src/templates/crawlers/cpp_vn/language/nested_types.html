 <h1 class="firstHeading" id="firstHeading">/*Rref*/</h1> <p>Một tuyên bố của một<a href="class" title="cpp/language/class">class/struct</a>hoặc<a href="union" title="cpp/language/union">union</a>có thể xuất hiện trong một lớp khác. Tuyên bố như vậy tuyên bố một<i>lớp lồng nhau</i>.</p>
<h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3> <p>Tên của lớp lồng nhau tồn tại trong phạm vi của lớp kèm theo và tra cứu tên từ chức năng thành viên của một lớp lồng nhau đến thăm phạm vi của lớp kèm theo sau khi kiểm tra phạm vi của lớp lồng nhau. Giống như bất kỳ thành viên nào trong lớp bao quanh của nó, lớp lồng nhau có quyền truy cập vào tất cả các tên (riêng tư, được bảo vệ, v.v.) mà lớp bao quanh có quyền truy cập, nhưng nó là độc lập và không có quyền truy cập đặc biệt vào<a href="this" title="cpp/language/this"><code>this</code> pointer</a>của lớp kèm theo. Tuyên bố trong một lớp lồng nhau có thể sử dụng bất kỳ thành viên nào trong lớp kèm theo, theo sau<a href="data_members#Usage" title="cpp/language/data members">usual usage rules</a>cho các thành viên không tĩnh.</p>
<div class="cpp source-cpp"><pre data-language="cpp">int x, y; // toàn cầu</pre></div> <p><a href="friend" title="cpp/language/friend">Friend</a>lớp bao quanh // lớp kèm theo</p>
<p>{</p>
<div class="cpp source-cpp"><pre data-language="cpp">    // Lưu ý: Thành viên tư nhân</pre></div> <p>    int x;</p>
<div class="cpp source-cpp"><pre data-language="cpp">    tĩnh in s;</pre></div> <p>công cộng:<a href="access" title="cpp/language/access">member access</a>    cấu trúc bên trong // lớp lồng nhau</p>
<div class="cpp source-cpp"><pre data-language="cpp">    {</pre></div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/45.html" rel="nofollow">CWG 45</a> </td> <td>C ++ 98</td> <td>        void f (int i)<br/>        {</td> <td>            x = i; // Lỗi: không thể ghi vào bao gồm không tĩnh :: x mà không có ví dụ<br/>            int a = sizeof x; // lỗi cho đến khi C ++ 11,<br/>                              // OK trong C ++ 11: Toán tử Sizeof không được đánh giá,</td>
</tr>
</table> <h3 id="References">Tài liệu tham khảo</h3> <ul>
<li>C ++ 23 Tiêu chuẩn (ISO/IEC 14882: 2023):</li>
<ul><li>                              // Việc sử dụng bao gồm không tĩnh :: x được cho phép.</li></ul>
<li>Tiêu chuẩn C ++ 20 (ISO/IEC 14882: 2020):</li>
<ul><li>            s = i;   // OK: có thể gán cho bao vây tĩnh :: s</li></ul>
<li>Tiêu chuẩn C ++ 17 (ISO/IEC 14882: 2017):</li>
<ul><li>            :: x = i; // ok: có thể gán cho toàn cầu x</li></ul>
<li>Tiêu chuẩn C ++ 14 (ISO/IEC 14882: 2014):</li>
<ul><li> </li></ul>
<li>Tiêu chuẩn C ++ 11 (ISO/IEC 14882: 2011):</li>
<ul><li> </li></ul>
<li>    S.B3 = 0B11;</li>
<ul><li> </li></ul>
</ul> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/nested_types">https://en.cppreference.com/w/cpp/language/nested_types</a>
</p>
</div>
