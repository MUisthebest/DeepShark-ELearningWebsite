 <h1 class="firstHeading" id="firstHeading">Chức năng chuyển đổi do người dùng xác định</h1> <p>Cho phép<a class="mw-redirect" href="implicit_cast" title="cpp/language/implicit cast">implicit conversion</a>hoặc<a href="explicit_cast" title="cpp/language/explicit cast">explicit conversion</a>từ a<a href="class" title="cpp/language/class">class type</a>sang loại khác.</p>
<h3 id="Syntax">Cú pháp</h3> <p>Hàm chuyển đổi được khai báo giống như một<a href="member_functions" title="cpp/language/member functions">non-static member function</a>hoặc thành viên<a href="function_template" title="cpp/language/function template">function template</a>Không có tham số, không có loại trả về rõ ràng và với tên của biểu mẫu:</p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <code>operator</code> <span class="t-spar">};</span> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>explicit</code> <code>operator</code> <span class="t-spar">};</span> </td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td>
</tr> <tr class="t-sdsc"> <td> <code>explicit (</code> <span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span> <code>)</code> <code>operator</code> <span class="t-spar">};</span> </td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td>
</tr>
</table> <div class="t-li1">
<span class="t-li">1)</span>Tuyên bố chức năng chuyển đổi do người dùng xác định<a class="mw-redirect" href="implicit_cast" title="cpp/language/implicit cast">implicit</a>Và<a href="explicit_cast" title="cpp/language/explicit cast">explicit conversions</a>.</div> <div class="t-li1">
<span class="t-li">2)</span>Tuyên bố chức năng chuyển đổi do người dùng xác định<a href="direct_initialization" title="cpp/language/direct initialization">direct-initialization</a>Và<a href="explicit_cast" title="cpp/language/explicit cast">explicit conversions</a>chỉ một.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Khai báo chức năng chuyển đổi do người dùng xác định<a href="explicit" title="cpp/language/explicit">conditionally explicit</a>.</div> <p><span class="t-spar">};</span>Điều đó như vậy<a href="type#Type_naming" title="cpp/language/type">type-id</a>ngoại trừ các toán tử chức năng và mảng đó<code>[]</code>hoặc<code>()</code>không được phép trong bộ khai báo của nó (do đó chuyển đổi thành các loại như con trỏ sang mảng yêu cầu một bí danh/typedef hoặc một mẫu nhận dạng: xem bên dưới). Bất kể typedef,<span class="t-spar">};</span>không thể đại diện cho một mảng hoặc một loại chức năng.</p>
<p>Mặc dù loại trả về không được phép trong khai báo chức năng chuyển đổi do người dùng xác định<span class="t-spar">DEM-SPECIFIER-SEQ</span>của<a href="declarations#Specifiers" title="cpp/language/declarations">the declaration grammar</a>có thể có mặt và có thể bao gồm bất kỳ trình xác định nào khác ngoài<span class="t-spar">loại-specifier</span>hoặc từ khóa<code>static</code>, Đặc biệt, bên cạnh<a href="explicit" title="cpp/language/explicit"><code>explicit</code></a>, các nhà xác định<a href="inline" title="cpp/language/inline"><code>inline</code></a>Thì<a href="virtual" title="cpp/language/virtual"><code>virtual</code></a><span class="t-rev-inl t-since-cxx11"><span>Thì<a href="constexpr" title="cpp/language/constexpr"><code>constexpr</code></a></span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx20"><span>Thì<a href="consteval" title="cpp/language/consteval"><code>consteval</code></a></span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>, Và<a href="friend" title="cpp/language/friend"><code>friend</code></a>cũng được phép (lưu ý rằng<code>friend</code>Yêu cầu một tên đủ điều kiện:<code>friend A::operator B();</code>).</p>
<p>Khi chức năng thành viên đó được khai báo trong lớp X, nó sẽ thực hiện chuyển đổi từ X sang<span class="t-spar">};</span>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">Cấu trúc x</pre></div> <h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3> <p>{<a class="mw-redirect" href="implicit_cast" title="cpp/language/implicit cast">implicit conversion</a>    // Chuyển đổi ẩn<a href="converting_constructor" title="cpp/language/converting constructor">converting constructor</a>    toán tử int () const {return 7; }</p>
<p> <a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a>TRONG<a href="copy_initialization" title="cpp/language/copy initialization">copy-initialization</a>Và<a href="reference_initialization" title="cpp/language/reference initialization">reference-initialization</a>    // Chuyển đổi rõ ràng<a href="direct_initialization" title="cpp/language/direct initialization">direct-initialization</a>    toán tử rõ ràng int*() const {return nullPtr; }</p>
<div class="cpp source-cpp"><pre data-language="cpp"> </pre></div> <p>    // Lỗi: Toán tử mảng không được phép trong loại chuyển đổi-ID<code>void</code>// toán tử int (*) [3] () const {return nullPtr; }<a href="virtual" title="cpp/language/virtual">virtual</a> </p>
<div class="cpp source-cpp"><pre data-language="cpp">    sử dụng ARR_T = int [3];</pre></div> <p>    toán tử ARR_T*() const {return nullPtr; } // ok nếu được thực hiện thông qua typedef</p>
<div class="cpp source-cpp"><pre data-language="cpp">// toán tử ARR_T () const; // Lỗi: chuyển đổi sang mảng không được phép trong mọi trường hợp</pre></div> <p>};<span class="t-spar">};</span>int main ()<span class="t-spar">};</span> <span class="t-rev-inl t-since-cxx11"><span>    X x;</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>:</p>
<div class="cpp source-cpp"><pre data-language="cpp"> </pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>Người giữ chỗ<a href="auto" title="cpp/language/auto">auto</a>có thể được sử dụng trong<span class="t-spar">};</span>    int m = x;                     // ok: đặt m thành 7<a href="function#Return_type_deduction" title="cpp/language/function">deduced return type</a>:</p>
<div class="cpp source-cpp"><pre data-language="cpp"> </pre></div> <p>    int* p = static_cast &lt;int*&gt; (x); // OK: Đặt P thành NULL<a href="member_template#Conversion_function_templates" title="cpp/language/member template">conversion function template</a>// int* q = x; // Lỗi: Không chuyển đổi ngầm</p>
</td> <td><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></td>
</tr> </table> <p> <a href="virtual" title="cpp/language/virtual">virtual</a>    int (*pa) [3] = x;  // ĐƯỢC RỒI<a href="static" title="cpp/language/static">static</a>}</p>
<p>Chức năng chuyển đổi do người dùng xác định được gọi trong giai đoạn thứ hai của<a href="../memory/auto_ptr/operator_auto_ptr" title="cpp/memory/auto ptr/operator auto ptr"><code>std::auto_ptr&lt;T&gt;::operator auto_ptr&lt;Y&gt;</code></a>, bao gồm 0 hoặc một<a href="member_template#Conversion_function_templates" title="cpp/language/member template">member template</a>Và<a href="template_argument_deduction#Conversion_function_template" title="cpp/language/template argument deduction">template argument deduction</a>hoặc không hoặc một chức năng chuyển đổi do người dùng xác định.</p>
<h3 id="Defect_Reports">&gt; Multiset lớp;</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/296.html" rel="nofollow">CWG 296</a> </td> <td>C ++ 98</td> <td>Nếu cả hai hàm chuyển đổi và các hàm tạo chuyển đổi có thể được sử dụng để thực hiện một số chuyển đổi do người dùng xác định</td> <td>bối cảnh, nhưng chỉ các nhà xây dựng được xem xét trong</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2016.html" rel="nofollow">CWG 2016</a> </td> <td>C ++ 98</td> <td>bối cảnh.<br/>cấu trúc để<span class="t-spar">};</span> </td> <td>    To () = mặc định;<br/>    To (const struct từ &amp;) {} // Trình xây dựng chuyển đổi</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2175.html" rel="nofollow">CWG 2175</a> </td> <td>C ++ 11</td> <td>};<code>[[noreturn]]</code>TRONG<br/><code>operator int [[noreturn]] ();</code> <br/><span class="t-spar">Noptr-Declarator</span>cấu trúc từ<span class="t-spar">};</span> </td> <td>    toán tử đến () const {return to ();} // hàm chuyển đổi<br/><span class="t-spar">};</span> </td>
</tr>
</table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/cast_operator">https://en.cppreference.com/w/cpp/language/cast_operator</a>
</p>
</div>
