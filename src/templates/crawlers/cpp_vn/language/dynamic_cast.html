 <h1 class="firstHeading" id="firstHeading">
<code>dynamic_cast</code>chuyển đổi</h1> <p>Chuyển đổi an toàn các con trỏ và tham chiếu đến các lớp học lên, xuống và đi ngang dọc theo hệ thống phân cấp kế thừa.</p>
<h3 id="Syntax">Cú pháp</h3> <table class="t-sdsc-begin"> <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <code>dynamic_cast&lt;</code> <span class="t-spar">Loại mục tiêu</span> <code>&gt;(</code> <span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span> <code>)</code> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">Loại mục tiêu</span> </td> <td>-</td> <td>Con trỏ để hoàn thành loại lớp, tham chiếu đến loại lớp hoàn chỉnh hoặc con trỏ tới (tùy chọn đủ điều kiện CV)<span class="kw4">Vô hiệu</span> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span> </td> <td>-</td> <td> <span class="t-rev-inl t-until-cxx11"><span>lvalue</span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>glvalue</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>thuộc loại lớp hoàn chỉnh nếu<span class="t-spar">Loại mục tiêu</span>là một tài liệu tham khảo, prvalue của một con trỏ để hoàn thành loại lớp nếu<span class="t-spar">Loại mục tiêu</span>là một con trỏ</td>
</tr>
</table> <p>Nếu diễn viên thành công,<span class="kw1">Dynamic_cast</span>Trả về một giá trị của loại<span class="t-spar">Loại mục tiêu</span>. Nếu các diễn viên thất bại và<span class="t-spar">Loại mục tiêu</span>là một loại con trỏ, nó trả về một con trỏ null thuộc loại đó. Nếu các diễn viên thất bại và<span class="t-spar">Loại mục tiêu</span>là một loại tham chiếu, nó ném một ngoại lệ phù hợp với một người xử lý loại<code><a href="../types/bad_cast" title="cpp/types/bad cast">std::bad_cast</a></code>.</p>
<h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3> <p>Để thuận tiện cho mô tả, "<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>hoặc kết quả là một tham chiếu đến<code>T</code>"có nghĩa là" nó là một glvalue loại<code>T</code>", theo quy ước của<a href="decltype" title="cpp/language/decltype"><code>decltype</code></a>.</p>
<p>Chỉ có thể thực hiện các chuyển đổi sau đây với<span class="kw1">Dynamic_cast</span>, ngoại trừ khi nào các chuyển đổi như vậy sẽ<a href="const_cast#Casting_away_constness" title="cpp/language/const cast">cast away constness</a>(hoặc biến động).</p>
<div class="t-li1">
<span class="t-li">1)</span>                               Không có p);<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>là chính xác<span class="t-spar">Loại mục tiêu</span>hoặc một phiên bản ít đủ điều kiện CV hơn của<span class="t-spar">Loại mục tiêu</span>, kết quả là giá trị của<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>, với loại<span class="t-spar">Loại mục tiêu</span>. (Nói cách khác,<code>dynamic_cast</code>có thể được sử dụng để thêm độ lệch. Chuyển đổi ngầm và<code>static_cast</code>cũng có thể thực hiện chuyển đổi này.)</div> <div class="t-li1">
<span class="t-li">2)</span>Nếu giá trị của<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>là giá trị con trỏ null, kết quả là giá trị con trỏ null của loại<span class="t-spar">Loại mục tiêu</span>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Nếu như<span class="t-spar">Loại mục tiêu</span>là một con trỏ hoặc tham chiếu đến<code>Base</code>và loại<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>là một con trỏ hoặc tham chiếu đến<code>Derived</code>là<code>Base</code>là một lớp cơ sở duy nhất, có thể truy cập của<code>Derived</code>, kết quả là một con trỏ hoặc tham chiếu đến<code>Base</code>Lớp tiểu mục trong<code>Derived</code>đối tượng được chỉ hoặc được xác định bởi<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>. (Lưu ý: một chuyển đổi ngầm và<code>static_cast</code>cũng có thể thực hiện chuyển đổi này.)</div> <div class="t-li1">
<span class="t-li">là trong</span>Nếu như<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>là một con trỏ tới<a href="object#Polymorphic_objects" title="cpp/language/object">polymorphic type</a>, Và<span class="t-spar">Loại mục tiêu</span>là một con trỏ để<code>void</code>, kết quả là một con trỏ đến đối tượng có nguồn gốc nhất được chỉ hoặc tham chiếu bởi<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Nếu như<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>là một con trỏ hoặc tham chiếu đến một<a href="object#Polymorphic_objects" title="cpp/language/object">polymorphic type</a> <code>Base</code>, Và<span class="t-spar">Loại mục tiêu</span>là một con trỏ hoặc tham chiếu đến loại<code>Derived</code>Kiểm tra thời gian chạy được thực hiện:</div> <div class="t-li2">
<span class="t-li">}</span>Đối tượng có nguồn gốc nhất được chỉ/xác định bởi<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>được kiểm tra. Nếu, trong đối tượng đó,<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>điểm/đề cập đến một cơ sở công cộng của<code>Derived</code>và nếu chỉ có một đối tượng của<code>Derived</code>Loại có nguồn gốc từ các tiểu mục chỉ/được xác định bởi<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>, sau đó là kết quả của các điểm/đề cập đến điều đó<code>Derived</code>sự vật. (Điều này được gọi là "Downcast".)</div> <div class="t-li2">
<span class="t-li">{</span>                        Forwardit2 d_first, pinarypredicate p);<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>Điểm/đề cập đến một cơ sở công khai của đối tượng có nguồn gốc nhất, và đồng thời, đối tượng có nguồn gốc nhất có một loại cơ sở công cộng rõ ràng<code>Derived</code>, kết quả của các điểm/đề cập đến điều đó<code>Derived</code>(Điều này được gọi là "sidecast".)</div> <div class="t-li2">
<span class="t-li">}</span>Nếu không, kiểm tra thời gian chạy không thành công. Nếu<code>dynamic_cast</code>được sử dụng trên con trỏ, giá trị con trỏ null của loại<span class="t-spar">Loại mục tiêu</span>được trả lại. Nếu nó được sử dụng trên các tài liệu tham khảo, ngoại lệ<code><a href="../types/bad_cast" title="cpp/types/bad cast">std::bad_cast</a></code>có thể được chuyển đổi hoàn toàn thành cả hai. Loại</div> <div class="t-li1">
<span class="t-li">từ_sys</span>      std :: memory_order order = std :: memory_order_seq_cst) noexcept dễ bay hơi;<code>dynamic_cast</code>được sử dụng trong một hàm tạo hoặc một chất phá hủy (trực tiếp hoặc gián tiếp), và<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>Đề cập đến đối tượng hiện đang được xây dựng/phá hủy, đối tượng được coi là đối tượng có nguồn gốc nhất. Nếu như<span class="t-spar">Loại mục tiêu</span>không phải là một con trỏ hoặc tham chiếu đến lớp riêng của nhà xây dựng/Destructor hoặc một trong các cơ sở của nó, hành vi không được xác định.</div> <p>Tương tự như các biểu thức diễn viên khác, kết quả là:</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <ul>
<li>Tham chiếu kết quả đề cập đến đối tượng ban đầu.<span class="t-spar">Loại mục tiêu</span>là loại tham chiếu</li>
<li>một rvalue nếu<span class="t-spar">Loại mục tiêu</span>là loại con trỏ</li>
</ul> </td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> <ul>
<li>Tham chiếu kết quả đề cập đến đối tượng ban đầu.<span class="t-spar">Loại mục tiêu</span>là loại tham chiếu Lvalue (<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>Phải là một lvalue)</li>
<li>. Giá trị con trỏ thành viên null có thể được chuyển đổi thành giá trị con trỏ thành viên null của<span class="t-spar">Loại mục tiêu</span>là loại tham chiếu rvalue (<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span> <span class="t-rev-inl t-until-cxx17"><span>có thể là lvalue hoặc rvalue</span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span><span class="t-rev-inl t-since-cxx17"><span>phải là một glvalue (prvalues ​​là<a href="implicit_conversion#Temporary_materialization" title="cpp/language/implicit conversion">materialized</a>)</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>thuộc loại lớp hoàn chỉnh)</li>
<li>một prvalue nếu<span class="t-spar">Loại mục tiêu</span>là loại con trỏ</li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <h3 id="Notes">Ghi chú</h3> <ul>
<li>Một downcast cũng có thể được thực hiện với<span class="kw1">Mẫu &lt;Biểu đồ lớp, Đặc điểm lớp, Alloc Class, Class Parsable&gt;</span>, giúp tránh chi phí kiểm tra thời gian chạy, nhưng nó chỉ an toàn nếu chương trình có thể đảm bảo (thông qua một số logic khác) mà đối tượng chỉ ra<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>là chắc chắn<code>Derived</code>.</li>
<li>Một số hình thức của<span class="kw1">Dynamic_cast</span>dựa vào<a class="extiw" href="https://en.wikipedia.org/wiki/Run-time_type_information" title="enwiki:Run-time type information">run-time type identification</a>(RTTI), nghĩa là thông tin về từng lớp đa hình trong chương trình được biên dịch. Trình biên dịch thường có các tùy chọn để vô hiệu hóa việc bao gồm thông tin này.</li>
</ul> <h3 id="Keywords">không định nghĩa macro như vậy. Tuy nhiên, nó xác định hằng số macro</h3> <p><a href="../keyword/dynamic_cast" title="cpp/keyword/dynamic cast"><code>dynamic_cast</code></a></p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;Istream&gt;</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c"> </pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1269.html" rel="nofollow">CWG 1269</a> </td> <td>C ++ 11</td> <td>Cấu trúc v<br/><span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>{<span class="t-spar">Loại mục tiêu</span>    ảo void f () {} // phải đa hình để sử dụng Dynamic_cast đã kiểm tra thời gian chạy</td> <td>};</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <ul>
<li> <a href="const_cast" title="cpp/language/const cast"><code>const_cast</code></a> </li>
<li> <a href="static_cast" title="cpp/language/static cast"><code>static_cast</code></a> </li>
<li> <a href="reinterpret_cast" title="cpp/language/reinterpret cast"><code>reinterpret_cast</code></a> </li>
<li> <a href="explicit_cast" title="cpp/language/explicit cast">explicit cast</a> </li>
<li> <a href="implicit_conversion" title="cpp/language/implicit conversion">implicit conversions</a> </li>
</ul> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/dynamic_cast">https://en.cppreference.com/w/cpp/language/dynamic_cast</a>
</p>
</div>
