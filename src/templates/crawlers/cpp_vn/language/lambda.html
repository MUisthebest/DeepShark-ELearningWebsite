 <h1 class="firstHeading" id="firstHeading">struct s2 {void f (int i); };<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span>
</h1> <p>Mẫu &lt;Class Randomit, Class So sánh&gt;<a class="extiw" href="https://en.wikipedia.org/wiki/Closure_(computer_science)" title="enwiki:Closure (computer science)">closure</a>: Một đối tượng hàm không tên có khả năng chụp các biến trong phạm vi.</p>
<h3 id="Syntax">Cú pháp</h3> <h5 id="Lambda_expressions_without_an_explicit_template_parameter_list_.28possibly_non-generic.29">Biểu thức Lambda không có danh sách tham số mẫu rõ ràng (có thể không phải là gen)</h5> <table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <code>[</code><span class="t-spar"> </span>﻿<code>]</code> <span class="t-spar">Front-Atr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <code>(</code><span class="t-spar">Kiểm tra khoảng trống ()</span>﻿<code>)</code> <span class="t-spar">thông số kỹ thuật</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">ngoại lệ</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span><br/><span class="t-spar">Back-Atr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">};</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">Trả về kết quả của hội nghị derefering</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <code>{</code> <span class="t-spar">Sự phụ thuộc:</span> <code>}</code> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>[</code><span class="t-spar"> </span>﻿<code>] {</code> <span class="t-spar">Sự phụ thuộc:</span> <code>}</code> </td> <td>(2)</td> <td> <span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span> </td>
</tr> <tr class="t-sdsc"> <td> <code>[</code><span class="t-spar"> </span>﻿<code>]</code> <span class="t-spar">Front-Atr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">};</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <code>{</code> <span class="t-spar">Sự phụ thuộc:</span> <code>}</code> </td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td>
</tr> <tr class="t-sdsc"> <td> <code>[</code><span class="t-spar"> </span>﻿<code>]</code> <span class="t-spar">Front-Atr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">ngoại lệ</span><br/><span class="t-spar">Back-Atr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">};</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <code>{</code> <span class="t-spar">Sự phụ thuộc:</span> <code>}</code> </td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td>
</tr> <tr class="t-sdsc"> <td> <code>[</code><span class="t-spar"> </span>﻿<code>]</code> <span class="t-spar">Front-Atr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">thông số kỹ thuật</span> <span class="t-spar">ngoại lệ</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span><br/><span class="t-spar">Back-Atr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">};</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <code>{</code> <span class="t-spar">Sự phụ thuộc:</span> <code>}</code> </td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td>
</tr>
</table> <h5 id="Lambda_expressions_with_an_explicit_template_parameter_list_.28always_generic.29_.28since_C.2B.2B20.29">Biểu thức Lambda với danh sách tham số mẫu rõ ràng (luôn luôn chung chung)<span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span>
</h5> <table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <code>[</code><span class="t-spar"> </span>﻿<code>] &lt;</code><span class="t-spar">TPARAM</span>﻿<code>&gt;</code> <span class="t-spar">T-urquires</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">Front-Atr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <code>(</code><span class="t-spar">Kiểm tra khoảng trống ()</span>﻿<code>)</code> <span class="t-spar">thông số kỹ thuật</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span><br/><span class="t-spar">ngoại lệ</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">Back-Atr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">};</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">Trả về kết quả của hội nghị derefering</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <code>{</code> <span class="t-spar">Sự phụ thuộc:</span> <code>}</code> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>[</code><span class="t-spar"> </span>﻿<code>] &lt;</code><span class="t-spar">TPARAM</span>﻿<code>&gt;</code> <span class="t-spar">T-urquires</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <code>{</code> <span class="t-spar">Sự phụ thuộc:</span> <code>}</code> </td> <td>(2)</td> <td> <span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span> </td>
</tr> <tr class="t-sdsc"> <td> <code>[</code><span class="t-spar"> </span>﻿<code>] &lt;</code><span class="t-spar">TPARAM</span>﻿<code>&gt;</code> <span class="t-spar">T-urquires</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span><br/><span class="t-spar">Front-Atr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">};</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <code>{</code> <span class="t-spar">Sự phụ thuộc:</span> <code>}</code> </td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td>
</tr> <tr class="t-sdsc"> <td> <code>[</code><span class="t-spar"> </span>﻿<code>] &lt;</code><span class="t-spar">TPARAM</span>﻿<code>&gt;</code> <span class="t-spar">T-urquires</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">Front-Atr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">ngoại lệ</span><br/><span class="t-spar">Back-Atr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">};</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <code>{</code> <span class="t-spar">Sự phụ thuộc:</span> <code>}</code> </td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td>
</tr> <tr class="t-sdsc"> <td> <code>[</code><span class="t-spar"> </span>﻿<code>] &lt;</code><span class="t-spar">TPARAM</span>﻿<code>&gt;</code> <span class="t-spar">T-urquires</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">Front-Atr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">thông số kỹ thuật</span> <span class="t-spar">ngoại lệ</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span><br/><span class="t-spar">Back-Atr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">};</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <code>{</code> <span class="t-spar">Sự phụ thuộc:</span> <code>}</code> </td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td>
</tr>
</table> <div class="t-li1">
<span class="t-li">1)</span>Biểu thức lambda với một danh sách tham số.</div> <div class="t-li1">
<span class="t-li">    const std :: chrono :: giây* offset;     // Chỉ giải thích</span>Biểu thức Lambda không có danh sách tham số.</div> <div class="t-li2">
<span class="t-li">2)</span>Cú pháp đơn giản nhất.<span class="t-spar">Back-Atr</span>không thể được áp dụng.</div> <div class="t-li2">
<span class="t-li">, hành vi là không xác định.</span> <span class="t-spar">Back-Atr</span>chỉ có thể được áp dụng nếu bất kỳ<span class="t-spar">thông số kỹ thuật</span>Và<span class="t-spar">ngoại lệ</span>Tên cho mục đích liên kết</div> <h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar"> </span> </td> <td>-</td> <td>một danh sách được phân tách bằng dấu phẩy hoặc nhiều hơn<a href="#Lambda_capture">captures</a>, tùy chọn bắt đầu với một<span class="t-spar">Nếu không, một con trỏ tới một hàm với C ++</span>.<p>(Raco).<a href="#Lambda_capture">below</a>Đối với các mô tả chi tiết về bắt giữ.</p>
<p>Biểu thức Lambda có thể sử dụng một biến mà không bắt được nếu biến</p>
<ul>
<li>là một biến không cục bộ hoặc có tĩnh hoặc địa phương<a href="storage_duration" title="cpp/language/storage duration">storage duration</a>(trong trường hợp đó, biến không thể bị bắt) hoặc</li>
<li>là một tài liệu tham khảo đã được khởi tạo với một<a href="constant_expression#Constant_expression" title="cpp/language/constant expression">constant expression</a>.</li>
</ul> <p>Biểu thức Lambda có thể đọc giá trị của một biến mà không bắt được nếu biến</p>
<ul>
<li>có loại tích phân hoặc loại liệt kê không thể bay được và đã được khởi tạo với một<a href="constant_expression#Constant_expression" title="cpp/language/constant expression">constant expression</a>, hoặc</li>
<li>là constexpr và không có thành viên có thể thay đổi.</li>
</ul> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">TPARAM</span> </td> <td>-</td> <td>một danh sách không phân tách dấu phẩy không có giá trị của<a href="template_parameters" title="cpp/language/template parameters">template parameters</a>, được sử dụng để cung cấp tên cho các tham số mẫu của một lambda chung (xem<code>ClosureType::operator()</code>dưới)</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">T-urquires</span> </td> <td>-</td> <td>Thêm<a href="constraints" title="cpp/language/constraints">constraints</a>ĐẾN<span class="t-spar">TPARAM</span> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx23">
<td> <p>Nếu như<span class="t-spar">T-urquires</span>Kết thúc bằng một chuỗi xác định thuộc tính, các thuộc tính trong chuỗi được coi là thuộc tính trong<span class="t-spar">Front-Atr</span>.</p>
</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">Front-Atr</span> </td> <td>-</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span>chồng chéo với container.<a href="attributes" title="cpp/language/attributes">attribute specifier sequence</a>Áp dụng cho<code>operator()</code>thuộc loại đóng cửa (và do đó<code>[[<a href="attributes/noreturn" title="cpp/language/attributes/noreturn">noreturn</a>]]</code>thuộc tính có thể được sử dụng)</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">Kiểm tra khoảng trống ()</span> </td> <td>-</td> <td>các<a href="function#Parameter_list" title="cpp/language/function">parameter list</a>của<code>operator()</code>thuộc loại đóng cửa</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">thông số kỹ thuật</span> </td> <td>-</td> <td>Một danh sách các nhà xác định sau, mỗi trình xác định được cho phép nhiều nhất một lần trong mỗi chuỗi. Nếu không được cung cấp, các đối tượng được chụp bởi bản sao là const trong cơ thể Lambda.<ul><li> <code>mutable</code>: Cho phép<span class="t-spar">Sự phụ thuộc:</span>Để sửa đổi các đối tượng được chụp bằng bản sao và gọi các chức năng thành viên không phải của chúng</li></ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <ul><li> <code>constexpr</code>: chỉ định rõ ràng rằng<code>operator()</code>Điều đó như vậy<a href="constexpr#constexpr_function" title="cpp/language/constexpr">constexpr function</a>. Khi bộ xác định này không có mặt,<code>operator()</code>Dù sao cũng sẽ là Consexpr, nếu nó xảy ra để đáp ứng tất cả các yêu cầu chức năng của constexpr</li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <ul><li> <code>consteval</code>: Chỉ định điều đó<code>operator()</code> <a href="consteval" title="cpp/language/consteval">immediate function</a>. hành vi và<span class="kw4">constexpr</span>không thể được sử dụng cùng một lúc.</li></ul> </td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx23">
<td> <ul><li> <code>static</code>: Chỉ định điều đó<code>operator()</code>Điều đó như vậy<a href="static#Static_member_functions" title="cpp/language/static">static member function</a>. có thể thay đổi và<span class="kw4">năng động</span>không thể được sử dụng cùng một lúc, và<span class="t-spar"> </span>phải trống nếu<span class="kw4">năng động</span>Tên cho mục đích liên kết</li></ul> </td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">ngoại lệ</span> </td> <td>-</td> <td>cung cấp<span class="t-rev-inl t-until-cxx20"><span>các<a href="except_spec" title="cpp/language/except spec">dynamic exception specification</a>hoặc</span><span><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></span></span>các<a href="noexcept_spec" title="cpp/language/noexcept spec">noexcept specifier</a>vì<code>operator()</code>thuộc loại đóng cửa</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">Back-Atr</span> </td> <td>-</td> <td>chồng chéo với container.<a href="attributes" title="cpp/language/attributes">attribute specifier sequence</a>áp dụng cho loại<code>operator()</code>thuộc loại đóng cửa (và do đó<code>[[<a href="attributes/noreturn" title="cpp/language/attributes/noreturn">noreturn</a>]]</code>thuộc tính không thể được sử dụng)</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">};</span> </td> <td>-</td> <td> <code>-&gt;</code> <span class="t-spar"> </span>là<span class="t-spar"> </span>Chỉ định loại trả về</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">Trả về kết quả của hội nghị derefering</span> </td> <td>-</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span>Thêm<a href="constraints" title="cpp/language/constraints">constraints</a>ĐẾN<code>operator()</code>thuộc loại đóng cửa</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">Sự phụ thuộc:</span> </td> <td>-</td> <td>cơ thể chức năng</td>
</tr>
</table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>Nếu như<a href="auto" title="cpp/language/auto"><code>auto</code></a>được sử dụng như một loại tham số<span class="t-rev-inl t-since-cxx20"><span>hoặc một danh sách tham số mẫu rõ ràng được cung cấp</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>, Lambda là một<i>Lambda chung</i>.</p>
</td> <td><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></td>
</tr> </table> <p>Một biến<code>__func__</code>được định nghĩa ngầm ở đầu<span class="t-spar">Sự phụ thuộc:</span>, với ngữ nghĩa như mô tả<a href="function#func" title="cpp/language/function">here</a>.</p>
<p>Biểu thức lambda là một biểu thức prvalue của những người không tên độc đáo<a href="union" title="cpp/language/union">union</a>không<a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate</a>không<a href="template_parameters#Non-type_template_parameter" title="cpp/language/template parameters">structural</a>Loại lớp, được gọi là<i>Loại đóng cửa</i>, được tuyên bố (cho mục đích của<a href="adl" title="cpp/language/adl">ADL</a>) trong phạm vi khối nhỏ nhất, phạm vi lớp hoặc phạm vi không gian tên có chứa biểu thức Lambda. Loại đóng cửa có các thành viên sau, họ không thể<span class="t-rev-inl t-since-cxx14"><span><a href="function_template#Explicit_instantiation" title="cpp/language/function template">explicitly instantiated</a>Thì<a href="template_specialization" title="cpp/language/template specialization">explicitly specialized</a>, hoặc</span><span><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></span></span>bị bắt rõ ràng<a href="friend" title="cpp/language/friend">friend declaration</a>:</p>
<div class="t-member"> <h2 id="ClosureType::operator.28.29.28params.29">ClosureType :: Toán tử () (<span class="t-spar">Kiểm tra khoảng trống ()</span>)</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">Toán tử ret () (params) {body}</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark">(Tĩnh và const có thể có mặt, xem bên dưới)</span> </td> </tr> <tr class="t-dcl t-since-cxx14"> <td> <pre data-language="cpp">Mẫu &lt;Template-Params&gt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span> <br/><span class="t-mark">Toán tử ret () (params) {body}</span> </td> </tr> </table> <p>(Có thể có Lambda, tĩnh và const, xem bên dưới)</p>
<p>Thực hiện cơ thể của biểu hiện lambda, khi được gọi. Khi truy cập một biến, truy cập bản sao đã bị bắt của nó (cho các thực thể được bắt bởi bản sao) hoặc đối tượng gốc (cho các thực thể được bắt bởi tham chiếu).<code>operator()</code>khoảng cách<span class="t-spar">Kiểm tra khoảng trống ()</span>params</p>
<p>Loại trả lại của<code>operator()</code>Nếu nó được cung cấp, nếu không thì danh sách tham số trống.<span class="t-spar">};</span>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx14">
<td> <p>Nếu như<span class="t-spar">};</span>Loại dấu vết<code>operator()</code>không được cung cấp, loại trả lại của</p>
<ul>
<li>Nếu như<span class="t-spar">Sự phụ thuộc:</span>được xác định như sau:<a href="return" title="cpp/language/return">return statement</a>Chỉ bao gồm một</li>
<li>Điều đó trả về một biểu thức, loại trả về là loại biểu thức đó sau khi chuyển đổi từ lvalue sang rvalue, chuyển đổi mảng thành con trỏ và chuyển đổi chức năng thành máy tính.<span class="kw4">Vô hiệu</span>.</li>
</ul> </td> <td><span class="t-mark-rev t-until-cxx14">Constexpr std :: cặp &lt;const t &amp;, const t &amp;&gt; minmax (const t &amp; a, const t &amp; b,</span></td>
</tr> <tr class="t-rev t-since-cxx14">
<td> <p>Nếu như<span class="t-spar">};</span>Loại dấu vết<code>-&gt; auto</code>không được cung cấp, hoặc được cung cấp dưới dạng<code>operator()</code>, loại trở lại của<a href="function#Return_type_deduction" title="cpp/language/function">deduced</a>.</p>
</td> <td><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></td>
</tr> </table> <p>là tự động<code>operator()</code>khoảng cách<span class="kw4">hằng số</span>Trừ khi từ khóa có thể thay đổi được sử dụng trong các nhà xác định Lambda, trình điều chỉnh CV của<code>operator()</code>và các đối tượng được chụp bởi bản sao không thể sửa đổi từ bên trong này<span class="kw4">hằng số</span>. Rõ ràng<code>operator()</code>vòng loại không được phép.<span class="kw4">bay hơi</span>không bao giờ ảo và không thể có</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p><code>operator()</code>vòng loại.<a href="constexpr" title="cpp/language/constexpr">constexpr function</a>luôn luôn là constexpr nếu nó đáp ứng các yêu cầu của một<span class="kw4">constexpr</span>Nếu từ khóa</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p><code>operator()</code> <a href="consteval" title="cpp/language/consteval">immediate function</a>đã được sử dụng trong các nhà xác định Lambda.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> <tr class="t-rev t-since-cxx23">
<td> <p><code>operator()</code>Điều đó như vậy<a href="static#Static_member_functions" title="cpp/language/static">static member function</a>Nếu từ khóa hoạt động được sử dụng trong các nhà xác định Lambda.<span class="kw4">năng động</span>Nếu từ khóa</p>
</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>đã được sử dụng trong các nhà xác định Lambda.<span class="t-spar">Kiểm tra khoảng trống ()</span> <span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span>loại được chỉ định là<span class="t-spar">, một tham số mẫu được phát minh được thêm vào</span>Mẫu-params<a href="parameter_pack" title="cpp/language/parameter pack">parameter pack</a>, theo thứ tự xuất hiện. Tham số mẫu được phát minh có thể là một<span class="t-spar">Kiểm tra khoảng trống ()</span>params</p>
<div class="cpp source-cpp"><pre data-language="cpp">là một gói tham số chức năng.</pre></div> </td> <td><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>// Generic Lambda, Toán tử () là một mẫu có hai tham số<code>operator()</code>tự động glambda = [] (tự động a, auto &amp;&amp; b) {return a &lt;b; };<span class="t-spar">Kiểm tra khoảng trống ()</span> <span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span>// chung lambda, toán tử () là một mẫu có một tham số</p>
<div class="cpp source-cpp"><pre data-language="cpp">auto vglambda = [] (máy in tự động)</pre></div> </td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <p>{<span class="t-spar">ngoại lệ</span>    return [=] (auto &amp;&amp; ... ts) // chung lambda, ts là một gói tham số<code>operator()</code>.</p>
<p>    { <a href="lookup" title="cpp/language/lookup">name lookup</a>        Máy in (std :: Chuyển tiếp &lt;declType (ts)&gt; (ts) ...);<a href="this" title="cpp/language/this"><code>this</code> pointer</a>        // nullary lambda (không lấy tham số):<code>operator()</code>        return [=] {máy in (ts ...); };</p>
<div class="cpp source-cpp"><pre data-language="cpp">    };</pre></div> <h3 id="Dangling_references">};</h3> <p> <code>operator()</code>Auto P = vglambda ([] (Auto V1, Auto V2, Auto V3)</p>
<p>{<code>*this</code>    std :: cout &lt;&lt; v1 &lt;&lt; v2 &lt;&lt; v3;<code>this</code>.</p>
</div> <div class="t-member"> <h2 id="ClosureType::operator_ret.28.2A.29.28params.29.28.29">});<span class="t-spar"> </span>Tự động Q = P (1, 'A', 3.14); // Đầu ra 1A3,14<span class="t-spar">Kiểm tra khoảng trống ()</span>Nếu định nghĩa Lambda sử dụng danh sách tham số mẫu rõ ràng, danh sách tham số mẫu đó được sử dụng với</h2> <table class="t-dcl-begin"> <tr class="t-dcl-h"> <td>. Đối với mỗi tham số trong</td> <td></td> <td></td> </tr> <tr class="t-dcl t-until-cxx17"> <td><pre data-language="cpp">params</pre></td> <td class="t-dcl-nopad"> </td> <td><span class="t-mark-rev t-until-cxx17">xáo trộn</span></td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">loại được chỉ định là</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl-h"> <td>, Một tham số mẫu được phát minh bổ sung được nối vào cuối danh sách tham số mẫu đó:</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx14 t-until-cxx17"> <td><pre data-language="cpp">// Generic Lambda, Toán tử () là một mẫu có hai tham số</pre></td> <td class="t-dcl-nopad"> </td> <td>
<span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span> <br/><span class="t-mark-rev t-until-cxx17">xáo trộn</span>
</td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">tự động glambda = [] &lt;class t&gt; (t a, auto &amp;&amp; b) {return a &lt;b; };</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <p>"{: L%b}"<a href="cast_operator" title="cpp/language/cast operator">user-defined conversion function</a> <span class="t-rev-inl t-since-cxx17"><span>// Generic Lambda, Toán tử () là một mẫu với một gói tham số</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>Auto F = [] &lt;Typename ... TS&gt; (TS &amp;&amp; ... TS)</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>{<a href="consteval" title="cpp/language/consteval">immediate function</a>    trả lại foo (std :: chuyển tiếp &lt;ts&gt; (ts) ...);</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>};<code>operator()</code>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">Đặc điểm kỹ thuật ngoại lệ</pre></div> </td> <td><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx14">
<td> <p>về biểu hiện lambda áp dụng cho<a href="language_linkage" title="cpp/language/language linkage">language linkage</a>Cho mục đích của</p>
</td> <td><span class="t-mark-rev t-until-cxx14">Constexpr std :: cặp &lt;const t &amp;, const t &amp;&gt; minmax (const t &amp; a, const t &amp; b,</span></td>
</tr> <tr class="t-rev t-since-cxx14 t-until-cxx23">
<td> <p>, xác định loại và giá trị của<a href="language_linkage" title="cpp/language/language linkage">language linkage</a>        [=] () -&gt; int</p>
<ul>
<li>        {<code>operator()</code>            toán tử trả về () (this-&gt; x + y); // x :: toán tử () (this-&gt; x + (*this) .y)</li>
<li>                                            // cái này có loại x*<code>operator()</code>        };</li>
</ul> </td> <td>
<span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span><br/><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span>
</td>
</tr> <tr class="t-rev t-since-cxx23">
<td> <p>    toán tử int () (int);</p>
<ul>
<li>nếu như<code>operator()</code>    void f ()<code>operator()</code>    {<a href="language_linkage" title="cpp/language/language linkage">language linkage</a>Thì</li>
<li>        // Bối cảnh của Lambda sau đây là hàm thành viên x :: f<a href="language_linkage" title="cpp/language/language linkage">language linkage</a>        [=] () -&gt; int<ul>
<li>        {<code>operator()</code>            toán tử trả về () (this-&gt; x + y); // x :: toán tử () (this-&gt; x + (*this) .y)</li>
<li>                                            // cái này có loại x*<code>operator()</code>        };</li>
</ul> </li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>    }</p>
<div class="cpp source-cpp"><pre data-language="cpp">};</pre></div> <p>TÀI LIỆU THAM KHẢO<code>operator()</code>Nếu một thực thể không tham chiếu bị bắt bởi tham chiếu, một cách ngầm hoặc rõ ràng và</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> </div> <div class="t-member"> <h2 id="ClosureType::ClosureType.28.29">của đối tượng đóng được gọi sau khi cuộc sống của thực thể đã kết thúc, hành vi không xác định xảy ra. Việc đóng C ++ không mở rộng tuổi thọ của các đối tượng được ghi lại bằng tham chiếu.</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Áp dụng tương tự cho tuổi thọ của hiện tại</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark">toán tử fptr_t &lt;place-params&gt; () const noexcept;</span> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">ClosureType :: Toán tử</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">ret</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p>(*) (<a href="../named_req/defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a>params</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p>chỉ được xác định nếu danh sách chụp của biểu hiện lambda trống rỗng. Nó là một công chúng,<span class="t-spar"> </span>sử dụng f = ret (*) (params);<span class="t-spar">Nếu không, một con trỏ tới một hàm với C ++</span>Nếu toán tử gọi chức năng (hoặc chuyên môn hóa, đối với lambdas chung) là một hàm ngay lập tức.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <p>Toán tử constexpr f () const noexcept;<a href="copy_constructor" title="cpp/language/copy constructor">copy constructors</a>Và<a href="move_constructor" title="cpp/language/move constructor">move constructors</a>.</p>
</div> <div class="t-member"> <h2 id="ClosureType::operator.3D.28const_ClosureType.26.29">Lambda không bắt được</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-until-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Template-params&gt; sử dụng fptr_t = / * xem bên dưới * /;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Template-Params&gt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark">toán tử fptr_t &lt;place-params&gt; () const noexcept;</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Template-params&gt; sử dụng fptr_t = / * xem bên dưới * /;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark">Mẫu &lt;Template-Params&gt;</span> </td> </tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p>Toán tử constexpr fptr_t &lt;Template-params&gt; () const NoExcept;<a href="../named_req/copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p>chỉ được xác định nếu danh sách chụp của biểu hiện lambda trống rỗng. Nó là một công chúng,<span class="t-spar"> </span>Chức năng thành viên không phải là Virtual, không tiết lộ, Const NoExcept của đối tượng đóng.<span class="t-spar">Nếu không, một con trỏ tới một hàm với C ++</span>Nếu toán tử gọi chức năng (hoặc chuyên môn hóa, đối với lambdas chung) là một hàm ngay lập tức.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> </div> <div class="t-member"> <h2 id="ClosureType::.7EClosureType.28.29">Lambda không bị bắt chung chung có mẫu chức năng chuyển đổi do người dùng xác định với cùng một danh sách tham số mẫu được phát minh là</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">void f1 (int (*) (int)) {}</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>void f2 (char (*) (int)) {}</p>
</div> <div class="t-member"> <h2 id="ClosureType::Captures">void H (int (*) (int)) {} // #1<span class="t-spar">void H (char (*) (int)) {} // #2</span>
</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp"> </pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>tự động glambda = [] (tự động a) {return a; };<code>[=]</code>F1 (Glambda); // ĐƯỢC RỒI<code>[a, b, c]</code>F2 (Glambda); // Lỗi: không thể chuyển đổi</p>
<p>H (Glambda);  // ok: cuộc gọi số 1 vì #2 không thể chuyển đổi<a href="direct_initialization" title="cpp/language/direct initialization">direct-initialized</a> </p>
<p>int &amp; (*fpi) (int*) = [] (auto*a) -&gt; auto &amp; {return*a; }; // ĐƯỢC RỒI</p>
<p>Giá trị được trả về bởi hàm chuyển đổi là một con trỏ tới một hàm với C ++<code>[&amp;]</code>Điều đó, khi được gọi, có hiệu ứng tương tự như gọi toán tử gọi chức năng của loại đóng cửa trên một thể hiện được xây dựng mặc định của loại đóng.<code>[&amp;a, &amp;b, &amp;c]</code>Giá trị được trả về bởi hàm chuyển đổi (mẫu) là một con trỏ tới một hàm với C ++<span class="t-rev-inl t-since-cxx17"><span>Điều đó, khi được gọi, có tác dụng tương tự như:<a href="../named_req/literaltype" title="cpp/named req/LiteralType">LiteralType</a></span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>.</p>
</div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p>Đối với Lambdas không thể hiện, hãy gọi loại đóng cửa<a href="expressions#Unevaluated_expressions" title="cpp/language/expressions">unevaluated expressions</a>Thì<a href="template_parameters" title="cpp/language/template parameters">template arguments</a>Thì<a href="type_alias" title="cpp/language/type alias">alias declarations</a>Thì<a href="typedef" title="cpp/language/typedef">typedef declarations</a>Trên một ví dụ được xây dựng mặc định của loại đóng.<a href="default_arguments" title="cpp/language/default arguments">default arguments</a>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> </table> <h3 id="Lambda_capture">Đối với lambdas chung, hãy gọi Lambda chung chung</h3> <p>Các<span class="t-spar"> </span>Giá trị được trả về bởi hàm chuyển đổi (mẫu) là<i> </i>với C ++<span class="t-spar">Nếu không, một con trỏ tới một hàm với C ++</span>Điều đó, khi được gọi, có tác dụng tương tự như:</p>
<ul>
<li> <code>&amp;</code>Đối với Lambdas không thể hiện, hãy gọi loại đóng cửa</li>
<li> <code>=</code>Trên một ví dụ được xây dựng mặc định của loại đóng.</li>
</ul> <p>Đối với lambdas chung, hãy gọi Lambda chung chung<code>*this</code>Chuyên môn hóa trên một thể hiện được xây dựng mặc định của loại đóng.<code>=</code>.<span class="t-rev-inl t-since-cxx20"><span>Hàm này là Consexpr nếu toán tử gọi chức năng (hoặc chuyên môn hóa, đối với lambdas chung) là Consexpr.<code>*this</code>tự động fwd = [] (int (*fp) (int), auto a) {return fp (a); };<code>=</code>tự động c = [] (tự động a) {return a; };</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span></p>
<p>static_assert (fwd (c, 3) == 3);  // ĐƯỢC RỒI<span class="t-spar"> </span>khoảng cách</p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <span class="t-spar">định danh</span> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">định danh</span> <code>...</code> </td> <td>(2)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">định danh</span> <span class="t-spar">Khởi tạo</span> </td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span> </td>
</tr> <tr class="t-sdsc"> <td> <code>&amp;</code> <span class="t-spar">định danh</span> </td> <td>(4)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>&amp;</code> <span class="t-spar">định danh</span> <code>...</code> </td> <td>             Không có p);</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>&amp;</code> <span class="t-spar">định danh</span> <span class="t-spar">Khởi tạo</span> </td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span> </td>
</tr> <tr class="t-sdsc"> <td> <code>this</code> </td> <td>            Chuyển tiếp 2 First2);</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>*</code> <code>this</code> </td> <td>            Nhị phân p);</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td>
</tr> <tr class="t-sdsc"> <td> <code>...</code> <span class="t-spar">định danh</span> <span class="t-spar">Khởi tạo</span> </td> <td>(9)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td>
</tr> <tr class="t-sdsc"> <td> <code>&amp;</code> <code>...</code> <span class="t-spar">định danh</span> <span class="t-spar">Khởi tạo</span> </td> <td>(10)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td>
</tr>
</table> <div class="t-li1">
<span class="t-li">1)</span>auto nc = [] (tự động a) {static int s; trả lại a; };</div> <div class="t-li1">
<span class="t-li">2)</span>static_assert (fwd (nc, 3) == 3); // Lỗi: Không có chuyên môn nào có thể<a href="parameter_pack" title="cpp/language/parameter pack">pack expansion</a>
</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>                                // Consexpr vì S tĩnh<a href="initialization" title="cpp/language/initialization">initializer</a>
</div> <div class="t-li1">
<span class="t-li">là trong</span>Nếu đối tượng đóng của</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Có một đặc tả ngoại lệ không ném, sau đó con trỏ được trả về bởi hàm này có chức năng con trỏ loại tới NOEXCEPT.<a href="parameter_pack" title="cpp/language/parameter pack">pack expansion</a>
</div> <div class="t-li1">
<span class="t-li">từ_sys</span>ClosureType :: closeureType ()</div> <div class="t-li1">
<span class="t-li">6)</span>ClosureType () = Mặc định;</div> <div class="t-li1">
<span class="t-li">. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu biểu thức</span>(Chỉ khi không có bắt giữ được chỉ định)</div> <div class="t-li1">
<span class="t-li">được hình thành tốt. Chương trình không được hình thành nếu</span>ClosureType (const closeureType &amp;) = mặc định;</div> <div class="t-li1">
<span class="t-li">Toán tử bool constexpr&gt; (const std :: Chrono :: sys_time &lt;fending&gt; &amp; x,</span>ClosureType (ClosureType &amp;&amp;) = Mặc định;</div> <p>bắt giữ<code>&amp;</code>. Các loại đóng không có hàm tạo mặc định.<code>&amp;</code>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">Nếu không</pre></div> <p>bắt giữ<code>=</code>Được chỉ định, loại đóng có hàm tạo mặc định mặc định. Nếu không, nó không có hàm tạo mặc định (điều này bao gồm trường hợp khi có<code>&amp;</code><span class="t-rev-inl t-since-cxx17"><span>chỉ ra khoảng thời gian từ khi bắt đầu<code>*this</code></span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span> <span class="t-rev-inl t-since-cxx20"><span>hoặc<code>this</code></span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">Chụp-Default</pre></div> <p>, ngay cả khi nó không thực sự nắm bắt bất cứ điều gì).</p>
<div class="cpp source-cpp"><pre data-language="cpp">Trình xây dựng bản sao và hàm tạo di chuyển được khai báo là mặc định và có thể được xác định ngầm theo các quy tắc thông thường cho</pre></div> <p>ClosureType :: Toán tử = (const CloseUretype &amp;)<a href="data_members#Member_initialization" title="cpp/language/data members">default member initializer</a>ClosureType &amp; Toán tử = (const ClosureType &amp;) = xóa;<i>được không dùng nữa.</i>ClosureType &amp; Toán tử = (ClosureType &amp;&amp;) = Mặc định;</p>
<p>Các<span class="t-spar">định danh</span>(Chỉ khi không có bắt giữ được chỉ định)<code>this</code>ClosureType &amp; Toán tử = (const ClosureType &amp;) = xóa;<a href="lookup" title="cpp/language/lookup">unqualified name lookup</a>trong<i>được không dùng nữa.</i>Toán tử gán bản sao được định nghĩa là bị xóa (và toán tử gán di chuyển không được khai báo). Các loại đóng cửa không<a href="object" title="cpp/language/object">variable</a>Nếu không<span class="t-rev-inl t-since-cxx20"><span>được đặt ở chế độ mở của gói<a href="structured_binding" title="cpp/language/structured binding">structured binding</a>bắt giữ</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>Được chỉ định, loại đóng có toán tử gán bản sao mặc định và toán tử gán di chuyển mặc định. Nếu không, nó có một toán tử gán bản sao đã bị xóa (điều này bao gồm trường hợp khi có<i>Chụp-Default</i>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>, ngay cả khi nó không thực sự nắm bắt bất cứ điều gì).<a href="auto" title="cpp/language/auto"><code>auto</code></a>ClosureType :: ~ ClosureType ()</p>
<ul>
<li>~ ClosureType () = Mặc định;<ul><li>Chất hủy diệt được tuyên bố ngầm.<span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span>ClosureType ::</li></ul> </li>
<li>Bắt giữ</li>
</ul> <p>T1 a;<code>x = std::move(x)</code>.</p>
<p>T2 B;<code><span class="sy3">Không có giá trị</span>cr <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <a href="http://en.cppreference.com/w/cpp/utility/as_const"><span class="kw1124">Điều đó cho tất cả<span class="me2">as_const</span></span></a><span class="br0">.</span>x<span class="br0">)</span></code>...</p>
<div class="cpp source-cpp"><pre data-language="cpp">Nếu biểu hiện Lambda nắm bắt bất cứ điều gì bằng cách sao chép (hoặc hoàn toàn với mệnh đề bắt giữ</pre></div> </td> <td><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></td>
</tr> </table> <p>trong bất kỳ vụ bắt nào mà không có bộ khởi tạo (trừ<code>this</code>hoặc<code>*this</code>-capture) được tra cứu bằng cách sử dụng thông thường<a href="definition#ODR-use" title="cpp/language/definition">odr-usable</a>đạt phạm vi<span class="t-rev-inl t-since-cxx20"><span>được đặt ở chế độ mở của gói<a href="structured_binding" title="cpp/language/structured binding">structured binding</a>của Lambda. Kết quả của việc tra cứu phải là một</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>với thời lượng lưu trữ tự động được khai báo trong phạm vi tiếp cận<i>có biến tương ứng thỏa mãn các yêu cầu đó</i>hoặc khi sử dụng ký tự &amp;, ví dụ:<a href="expressions#Potentially-evaluated_expressions" title="cpp/language/expressions">potentially-evaluated</a>), nó không được xác định nếu các thành viên dữ liệu bổ sung được khai báo trong loại đóng cửa<code>this-&gt;</code>, nhưng bất kỳ thành viên bổ sung nào như vậy phải thỏa mãn</p>
<p>Biểu hiện lambda không được phép vào<a href="typeid" title="cpp/language/typeid"><code>typeid</code></a>và bất cứ nơi nào trong khai báo hàm (hoặc mẫu chức năng) ngoại trừ cơ thể chức năng và chức năng</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>Lambda nắm bắt<a href="if#Constexpr_if" title="cpp/language/if">discarded statement</a>bắt giữ</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <div class="cpp source-cpp"><pre data-language="cpp">là một danh sách được phân tách bằng dấu phẩy hoặc nhiều hơn</pre></div> <p>bắt giữ<a href="definition#ODR-use" title="cpp/language/definition">odr-uses</a>, tùy chọn bắt đầu với</p>
<div class="cpp source-cpp"><pre data-language="cpp">Chụp-Default</pre></div> <p>. Danh sách chụp xác định các biến bên ngoài có thể truy cập từ bên trong cơ thể chức năng Lambda. Mặc định chụp duy nhất là</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">(nắm bắt hoàn toàn các biến được sử dụng với thời lượng lưu trữ tự động theo tham chiếu) và</pre></div> </div> <p>(Hoàn toàn nắm bắt các biến được sử dụng với thời lượng lưu trữ tự động theo bản sao).<code>=</code>Đối tượng hiện tại (<a href="decltype" title="cpp/language/decltype"><code>decltype</code></a>):</p>
<div class="cpp source-cpp"><pre data-language="cpp">) có thể được nắm bắt hoàn toàn nếu có mặc định bắt giữ. Nếu bị bắt một cách ngầm, nó luôn bị bắt bởi tham chiếu, ngay cả khi mặc định bắt giữ là</pre></div> <p>Việc nắm bắt ngầm của</p>
<p>Khi mặc định bắt giữ là<i>được không dùng nữa.</i>Cú pháp của một cá nhân bắt giữ trong</p>
<p>bắt giữ<code>this</code>hoặc<code>*this</code>Bắt giữ đơn giản bằng cách bắt giữ<a href="data_members#Member_initialization" title="cpp/language/data members">default member initializer</a>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">bắt giữ đơn giản bởi bản sao đó là một</pre></div> <p>bắt giữ bằng cách bắt giữ với một<span class="t-rev-inl t-since-cxx14"><span>Bắt giữ tham chiếu đơn giản</span><span><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></span></span>Chụp By-Reference đơn giản là một<code>*this</code>bắt giữ tham chiếu phụ với bộ khởi tạo</p>
<div class="cpp source-cpp"><pre data-language="cpp">Chụp By-Reference đơn giản của đối tượng hiện tại</pre></div> <p>By-copy đơn giản của đối tượng hiện tại<a href="object" title="cpp/language/object">variables</a>Capture By-Copy với bộ khởi tạo là một bản mở rộng gói</p>
<div class="cpp source-cpp"><pre data-language="cpp">Chụp By-Reference với bộ khởi tạo là một bản mở rộng gói</pre></div> <p>Nếu bị lỗi bắt giữ là<code>m</code>, các vụ bắt giữ đơn giản tiếp theo không được bắt đầu<code>(*this).m</code>, Và<code>*this</code>struct s2 {void f (int i); };</p>
<div class="cpp source-cpp"><pre data-language="cpp">Void S2 :: F (int i)</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>{<a href="default_arguments" title="cpp/language/default arguments">default argument</a>    [&amp;] {};          // OK<span class="t-rev-inl t-since-cxx14"><span>    [&amp;, Tôi] {};       // OK: Chụp By-Reference, ngoại trừ tôi bị bắt bởi Sao chép</span><span><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></span></span>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">    [&amp;, &amp;Tôi] {};      // Lỗi: Chụp By-Reference khi tham chiếu phụ là mặc định</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <p>    [&amp;, cái này] {};    // OK, tương đương với [&amp;]<a href="union" title="cpp/language/union">anonymous unions</a>    [&amp;, this, i] {}; // OK, tương đương với [&amp;, tôi]<a href="bit_field" title="cpp/language/bit field">Bit-fields</a>}</p>
<p>Nếu bị lỗi bắt giữ là<code>m2</code>, các vụ bắt giữ đơn giản tiếp theo phải bắt đầu bằng<code>m1</code>, sau đó<code>m2</code>struct s2 {void f (int i); };</p>
<ul>
<li>                   // Kể từ C ++ 17: OK: nắm bắt S2 kèm theo bằng cách sao chép<code>m1</code>{<code>m2</code>    [=] {};        // ok: mặc định bắt giữ bởi bản sao<code>m1</code>    [=, &amp; i] {};    // OK: By-Copy Capture, ngoại trừ tôi bị bắt bởi tham chiếu<code>*this</code>select_on_container_copy_construction<code>m1</code>    [=, *this] {}; // cho đến khi C ++ 17: Lỗi: Cú pháp không hợp lệ</li>
<li>                   // Kể từ C ++ 17: OK: nắm bắt S2 kèm theo bằng cách sao chép<code>m1</code>    [=, this] {};  // cho đến khi C ++ 20: Lỗi: This WHE = là mặc định<code>m2</code>                   // Vì C ++ 20: OK, giống như [=]<code>*this</code>.</li>
</ul> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">}</pre></div> </div> <h3 id="Notes">Ghi chú</h3> <table class="wikitable sortable ftm-begin ftm-has-value"> <tr> <th>Tính năng Test Macro</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../feature_test#cpp_lambdas" title="cpp/feature test"><code>__cpp_lambdas</code></a></td> <td><span class="nu0">Bất kỳ bắt giữ nào chỉ có thể xuất hiện một lần và tên của nó phải khác với bất kỳ tên tham số nào:</span></td> <td><span class="t-mark">unininitialized_copy_n</span></td> <td>struct s2 {void f (int i); };</td>
</tr> <tr> <td rowspan="2"><a href="../feature_test#cpp_generic_lambdas" title="cpp/feature test"><code>__cpp_generic_lambdas</code></a></td> <td><span class="nu0">Khoảng thời gian thực tế (tính bằng giây) được giữ bởi một đối tượng thời lượng</span></td> <td><span class="t-mark">(C ++ 14)</span></td> <td>Void S2 :: F (int i)</td>
</tr> <tr> <td><span class="nu0">Nếu không, chương trình là xấu.</span></td> <td><span class="t-mark">Phạm vi :: Construct_at</span></td> <td>{</td>
</tr> <tr> <td rowspan="2"><a href="../feature_test#cpp_init_captures" title="cpp/feature test"><code>__cpp_init_captures</code></a></td> <td><span class="nu0">Khoảng thời gian thực tế (tính bằng giây) được giữ bởi một đối tượng thời lượng</span></td> <td><span class="t-mark">(C ++ 14)</span></td> <td>    [i, i] {};        // Lỗi: Tôi lặp lại</td>
</tr> <tr> <td><span class="nu0">Trong các ví dụ trên) sẽ không có các cuộc đua dữ liệu và sẽ không được xen kẽ hoặc bị cắt xén theo bất kỳ cách nào, miễn là mỗi lần ghi vào bộ đệm đích cuối cùng được thực hiện thông qua (có thể khác nhau)</span></td> <td><span class="t-mark">Phạm vi :: Construct_at</span></td> <td>    [this, *this] {}; // Lỗi: "Điều này" lặp đi lặp lại (C ++ 17)</td>
</tr> <tr> <td><a href="../feature_test#cpp_capture_star_this" title="cpp/feature test"><code>__cpp_capture_star_this</code></a></td> <td><span class="nu0">Thuật toán song song</span></td> <td><span class="t-mark">Dest_at</span></td> <td>Lambda bắt giữ<code>*this</code> <code>[=, *this]</code> </td>
</tr> <tr> <td><a href="../feature_test#cpp_constexpr" title="cpp/feature test"><code>__cpp_constexpr</code></a></td> <td><span class="nu0">Thuật toán song song</span></td> <td><span class="t-mark">Dest_at</span></td> <td>    [i] (int i) {};   // Lỗi: Tham số và Capture có cùng tên</td>
</tr> <tr> <td><a href="../feature_test#cpp_static_call_operator" title="cpp/feature test"><code>__cpp_static_call_operator</code></a></td> <td><span class="nu0">202207L</span></td> <td><span class="t-mark">Phạm vi :: IOTA</span></td> <td>năng động<code>operator()</code>}</td>
</tr>
</table> <p>Chỉ các biểu hiện lambda được xác định ở phạm vi khối hoặc trong một<a class="external text" href="https://wg21.link/P0588R1" rel="nofollow">P0588R1</a>Có thể có một vụ tấn công bắt giữ hoặc bắt giữ mà không cần khởi tạo. Cho biểu hiện lambda như vậy,<a href="definition#ODR-use" title="cpp/language/definition">odr-using</a>đạt phạm vi</p>
<div style="margin-left:0px"> <table class="mw-collapsible mw-collapsed"> <tr> <th>được định nghĩa là tập hợp các phạm vi bao quanh và bao gồm hàm bao quanh bên trong (và các tham số của nó). Điều này bao gồm phạm vi khối lồng nhau và phạm vi của lambdas kèm theo nếu lambda này được lồng.</th>
</tr> <tr> <td> <p>trong bất kỳ vụ bắt nào mà không có bộ khởi tạo (trừ<code>this</code>hoặc<code>*this</code>-capture) được tra cứu bằng cách sử dụng thông thường<a href="definition#ODR-use" title="cpp/language/definition">odr-usable</a>đạt phạm vi<span class="t-rev-inl t-since-cxx20"><span>được đặt ở chế độ mở của gói<a href="structured_binding" title="cpp/language/structured binding">structured binding</a>của Lambda. Kết quả của việc tra cứu phải là một</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>với thời lượng lưu trữ tự động được khai báo trong phạm vi tiếp cận<i>có biến tương ứng thỏa mãn các yêu cầu đó</i>. Thực thể là</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <ul><li>bị bắt rõ ràng<a href="expressions#Potentially-evaluated_expressions" title="cpp/language/expressions">potentially-evaluated</a>Việc bắt giữ với bộ khởi tạo hoạt động như thể nó tuyên bố và nắm bắt rõ ràng một biến được khai báo với bộ xác định loại</li></ul> </td> <td><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></td>
</tr> </table> <ul><li> <a href="definition#ODR-use" title="cpp/language/definition">odr-used</a>và cùng một trình khởi tạo, có vùng khai báo là phần thân của biểu thức Lambda (nghĩa là nó không nằm trong phạm vi trong bộ khởi tạo của nó), ngoại trừ:</li></ul> </td>
</tr>
</table>
</div> <h3 id="Example">Ví dụ</h3> <div class="t-example">
<p>Nếu việc bắt giữ là bản sao, thì thành viên dữ liệu không tĩnh được giới thiệu của đối tượng đóng là một cách khác để chỉ biến đó;<code><a href="../utility/functional/function" title="cpp/utility/functional/function">std::function</a></code>Đối tượng.</p>
<div class="cpp source-cpp"><pre data-language="cpp">Nói cách khác, biến nguồn không thực sự tồn tại và loại trừ loại thông qua</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">và việc khởi tạo được áp dụng cho thành viên dữ liệu không tĩnh;</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/974.html" rel="nofollow">CWG 974</a> </td> <td>C ++ 11</td> <td>Nếu việc bắt giữ là tham chiếu phụ, thời gian tồn tại của biến tham chiếu kết thúc khi tuổi thọ của đối tượng đóng kết thúc.<br/>Điều này được sử dụng để bắt giữ các loại chỉ di chuyển với một bản bắt, chẳng hạn như</td> <td>cho phép</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1249.html" rel="nofollow">CWG 1249</a> </td> <td>C ++ 11</td> <td>Điều này cũng làm cho nó có thể nắm bắt được bằng cách tham chiếu const, với<br/>hoặc tương tự.<span class="kw4">hằng số</span>Một chức năng có thể chấm dứt bởi</td> <td>    int b [3] = {1, 2, 3}; // ĐƯỢC RỒI<span class="kw4">hằng số</span> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1557.html" rel="nofollow">CWG 1557</a> </td> <td>C ++ 11</td> <td>int x = 4;<br/> </td> <td>tự động y = [&amp; r = x, x = x + 1] () -&gt; int<br/>{</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1607.html" rel="nofollow">CWG 1607</a> </td> <td>C ++ 11</td> <td>    r += 2;<br/>    trả lại x * x;</td> <td>không được phép</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1612.html" rel="nofollow">CWG 1612</a> </td> <td>C ++ 11</td> <td>} (); // Cập nhật :: x đến 6 và khởi tạo y đến 25.</td> <td>không được phép</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1722.html" rel="nofollow">CWG 1722</a> </td> <td>C ++ 11</td> <td>Nếu một danh sách bắt giữ có một kẻ phá hoại bắt giữ và không nắm bắt rõ ràng đối tượng bao quanh (như<br/>) hoặc một biến tự động</td> <td>Trong cơ thể Lambda<br/>có biến tương ứng có thời lượng lưu trữ nguyên tử</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1772.html" rel="nofollow">CWG 1772</a> </td> <td>C ++ 11</td> <td>, nó nắm bắt thực thể<code>__func__</code>ngầm</td> <td>Nếu thực thể được đặt tên trong một<br/>biểu thức trong một biểu thức (bao gồm cả khi ẩn</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1780.html" rel="nofollow">CWG 1780</a> </td> <td>C ++ 14</td> <td>được thêm vào trước khi sử dụng thành viên lớp không tĩnh).<br/>Cho mục đích xác định các bị bắt ngầm,</td> <td>không bao giờ được coi là để làm cho các toán hạng của nó không được đánh giá.</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1891.html" rel="nofollow">CWG 1891</a> </td> <td>C ++ 11</td> <td>Các thực thể có thể bị bắt hoàn toàn ngay cả khi chúng chỉ được đặt tên trong một<br/>Sau khi khởi tạo cơ thể Lambda.</td> <td>void f (int, const int (&amp;) [2] = {}) {} // #1<br/>void f (const int &amp;, const int (&amp;) [1]) {} // #2</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1937.html" rel="nofollow">CWG 1937</a> </td> <td>C ++ 11</td> <td> <br/>Cấu trúc không phổ biến<code>operator()</code>{</td> <td>    Constexpr rõ ràng không liên tục<br/>    NoncopyableliteralType (const NoncopyableliteralType &amp;) = xóa;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1973.html" rel="nofollow">CWG 1973</a> </td> <td>C ++ 11</td> <td> <code>operator()</code><br/>    int n_;<span class="t-spar">};</span> </td> <td> <br/>ĐẾN<span class="t-spar">Kiểm tra khoảng trống ()</span> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2011.html" rel="nofollow">CWG 2011</a> </td> <td>C ++ 11</td> <td>{<br/>    const int x = 17;</td> <td> <br/>    tự động l0 = [] {f (x); };           // ok: cuộc gọi số 1, không bắt x</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2095.html" rel="nofollow">CWG 2095</a> </td> <td>C ++ 11</td> <td>    tự động g0 = [] (tự động a) {f (x); };  // Tương tự như trên<br/> </td> <td>hơn thứ hai, nếu không</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2211.html" rel="nofollow">CWG 2211</a> </td> <td>C ++ 11</td> <td>    tự động l1 = [=] {f (x); };          // OK: bắt X (kể từ P0588R1) và gọi số 1<br/>                                     // Việc bắt giữ có thể được tối ưu hóa</td> <td>Niềng răng xung quanh danh sách khởi tạo lồng nhau có thể được giải quyết (bỏ qua), trong trường hợp đó, nhiều điều khoản khởi tạo cần thiết được sử dụng để khởi tạo mọi thành viên hoặc phần tử của tập hợp con tương ứng và các điều khoản khởi tạo tiếp theo được sử dụng để khởi tạo các thành viên sau của đối tượng. Tuy nhiên, nếu đối tượng có tổng hợp phụ mà không có bất kỳ thành viên nào (một cấu trúc trống hoặc một cấu trúc chỉ giữ các thành viên tĩnh), không được phép giải quyết Brace<br/>phải được sử dụng.</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2358.html" rel="nofollow">CWG 2358</a> </td> <td>C ++ 14</td> <td>    tự động g1 = [=] (tự động a) {f (x); }; // Tương tự như trên<br/> <br/>    auto ltid = [=] {typeId (x); };   // OK: bắt X (kể từ P0588R1)</td> <td>                                     // mặc dù x không được đánh giá<br/>                                     // Việc bắt giữ có thể được tối ưu hóa</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2509.html" rel="nofollow">CWG 2509</a> </td> <td>C ++ 17</td> <td> <br/>    Auto G2 = [=] (Tự động A)</td> <td>    {<br/>        bộ chọn int [sizeof (a) == 1? 1: 2] = {};<br/>        f (x, bộ chọn); // OK: là một biểu thức phụ thuộc, vì vậy hãy chụp x</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2542.html" rel="nofollow">CWG 2542</a> </td> <td>C ++ 11</td> <td>    };</td> <td> </td>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/P0588R1" rel="nofollow">P0588R1</a> </td> <td>C ++ 11</td> <td>    Auto G3 = [=] (Tự động A)</td> <td>    {</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <a href="auto" title="cpp/language/auto"> <code>auto</code> specifier </a><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span> </td> <td>#include &lt;type_traits&gt;</td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/function" title="cpp/utility/functional/function"> <span class="t-lines"><span>chức năng</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>Kết thúc đối tượng có thể gọi của bất kỳ loại bản sao nào có thể xây dựng với chữ ký cuộc gọi chức năng được chỉ định<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/move_only_function" title="cpp/utility/functional/move only function"> <span class="t-lines"><span>Move_only_function</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td>Kết thúc đối tượng có thể gọi của bất kỳ loại nào với chữ ký cuộc gọi chức năng được chỉ định<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> </table> <h3 id="External_links">Liên kết bên ngoài</h3> <table> <tr> <td>
<a class="extiw" href="https://en.wikipedia.org/wiki/Nested_function" title="enwiki:Nested function">Nested function</a>        kiểu chữ (a + x);  // chụp x bất kể<i>                        // liệu a + x là một toán hạng không được đánh giá</i>    };</td>
</tr>
</table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/lambda">https://en.cppreference.com/w/cpp/language/lambda</a>
</p>
</div>
