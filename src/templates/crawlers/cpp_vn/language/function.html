 <h1 class="firstHeading" id="firstHeading">Tuyên bố chức năng</h1> <p>Một khai báo chức năng giới thiệu tên chức năng và loại của nó. Một định nghĩa chức năng liên kết tên/loại chức năng với cơ thể chức năng.</p>
<h3 id="Function_declaration">Tuyên bố chức năng</h3> <p>Khai báo chức năng có thể xuất hiện trong bất kỳ phạm vi nào. Một tuyên bố chức năng ở phạm vi lớp giới thiệu hàm thành viên lớp (trừ khi<span class="kw1">bạn</span>trình xác định được sử dụng), xem<a href="member_functions" title="cpp/language/member functions">member functions</a>Và<a href="friend" title="cpp/language/friend">friend functions</a> </p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <span class="t-spar">Noptr-Declarator</span> <code>(</code> <span class="t-spar">danh sách tham số</span> <code>)</code> <span class="t-spar">không ngụ ý rằng</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">Tham khảo</span>﻿ ﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">                             STD :: Memory_order Order) NoExcept;</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">attr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">Noptr-Declarator</span> <code>(</code> <span class="t-spar">danh sách tham số</span> <code>)</code> <span class="t-spar">không ngụ ý rằng</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">Tham khảo</span>﻿ ﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">                             STD :: Memory_order Order) NoExcept;</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">attr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span><br/><code>-&gt;</code> <span class="t-spar">Trailing</span> </td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td>
</tr>
</table> <p>    std :: chuỗi* p = new std :: chuỗi ("xin chào");<a href="declarations" title="cpp/language/declarations">Declarations</a>cho các hình thức khác của<span class="t-spar">người khai báo</span>Cú pháp)</p>
<div class="t-li1">
<span class="t-li">1)</span>Chức năng thông thường Cú pháp.</div> <div class="t-li1">
<span class="t-li">2)</span>Trailing Return loại khai báo. Các<span class="t-spar">DEM-SPECIFIER-SEQ</span>Trong trường hợp này phải chứa từ khóa<code>auto</code>.</div> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">Noptr-Declarator</span> </td> <td>-</td> <td>bất kỳ hợp lệ<span class="t-spar">người khai báo</span>, nhưng nếu nó bắt đầu với<code>*</code>Thì<code>&amp;</code>, hoặc<code>&amp;&amp;</code>, nó phải được bao quanh bởi dấu ngoặc đơn.</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">danh sách tham số</span> </td> <td>-</td> <td>Có thể trống, danh sách phân tách bằng dấu phẩy của các tham số chức năng (xem bên dưới để biết chi tiết)</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">attr</span> </td> <td>-</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span>Constexpr void gọi (tự động (*vui) (variadic ......), args ... args)<a href="attributes" title="cpp/language/attributes">attributes</a>. Các thuộc tính này được áp dụng cho loại chức năng, không phải chính chức năng. Các thuộc tính cho hàm xuất hiện sau khi định danh trong trình khai báo và được kết hợp với các thuộc tính xuất hiện ở đầu khai báo, nếu có.</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">không ngụ ý rằng</span> </td> <td>-</td> <td>trình độ điều trị/chất dễ bay hơi, chỉ được phép trong các khai báo chức năng thành viên không tĩnh</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">Tham khảo</span> </td> <td>-</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span>đủ điều kiện tham khảo, chỉ được phép trong các khai báo chức năng thành viên không tĩnh</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">                             STD :: Memory_order Order) NoExcept;</span> </td> <td>-</td> <td> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <p><a href="except_spec" title="cpp/language/except spec">dynamic exception specification</a></p>
</td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td>
</tr> <tr class="t-rev t-since-cxx11 t-until-cxx17">
<td> <p>nhiều nhất là một chuyển đổi đủ điều kiện, và<a href="except_spec" title="cpp/language/except spec">dynamic exception specification</a><br/>hoặc<a href="noexcept_spec" title="cpp/language/noexcept spec">noexcept specification</a></p>
</td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span><br/><span class="t-mark-rev t-until-cxx17">xáo trộn</span>
</td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <p><a href="noexcept_spec" title="cpp/language/noexcept spec">noexcept specification</a></p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <p>Lưu ý rằng đặc tả ngoại lệ không phải là một phần của loại chức năng</p>
</td> <td><span class="t-mark-rev t-until-cxx17">xáo trộn</span></td>
</tr> </table> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">Trailing</span> </td> <td>-</td> <td>Loại trả về theo dõi, hữu ích nếu loại trả về phụ thuộc vào tên đối số, chẳng hạn như<code>template&lt;class T, class U&gt; auto add(T t, U u) -&gt; decltype(t + u);</code>hoặc là phức tạp, chẳng hạn như trong<code>auto fpif(int)-&gt;int(*)(int)</code> </td>
</tr>
</table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>Như đã đề cập trong<a href="declarations#Declarators" title="cpp/language/declarations">Declarations</a>, người khai báo có thể được theo sau bởi một<i>Trả về kết quả của hội nghị derefering</i>mệnh đề, tuyên bố liên kết<a href="constraints" title="cpp/language/constraints">constraints</a>cho chức năng, phải được thỏa mãn để chức năng được chọn bởi<a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a>. (ví dụ:<code>void f1(int a) requires true;</code>) Lưu ý rằng ràng buộc liên quan là một phần của chữ ký chức năng, nhưng không phải là một phần của loại chức năng.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <p>Trình khai báo chức năng có thể được trộn với các trình khai báo khác, trong đó<span class="t-spar">DEM-SPECIFIER-SEQ</span>cho phép:</p>
<div class="cpp source-cpp"><pre data-language="cpp">// khai báo int, int*, một hàm và con trỏ tới một hàm</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>int a = 1, *p = null, f (), ( *pf) (gấp đôi);</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <p>//</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>// khai báo f () tuyên bố (nhưng không xác định)</p>
<div class="cpp source-cpp"><pre data-language="cpp">// một chức năng không có đối số và quay lại int</pre></div> <p> </p>
<div class="cpp source-cpp"><pre data-language="cpp">cấu trúc s</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <h3 id="Return_type_deduction">{</h3> <p>Consexpr ForwardIT Remove_if (ForwardIt First, ForwardIt Last,<span class="t-spar">DEM-SPECIFIER-SEQ</span>    ảo int f (char) const, g (int) &amp;&amp;; // Khai báo hai chức năng thành viên không tĩnh<span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span>    ảo int f (char), x; // Lỗi thời gian biên dịch: Virtual (trong Dec-Specifier-Seq)<a href="return" title="cpp/language/return">return</a>                            // chỉ được phép trong các tuyên bố không tĩnh<span class="br0">.</span><span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span><span class="br0">)</span>                            // Chức năng thành viên<a href="template_argument_deduction#Other_contexts" title="cpp/language/template argument deduction">template argument deduction</a>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">};</pre></div> <p>Sử dụng loại đối tượng đủ điều kiện dễ bay hơi làm loại tham số hoặc loại trả về được không dùng nữa.<span class="br0">.</span><span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span><span class="br0">)</span>Loại trả về của một hàm không thể là loại hàm hoặc loại mảng (nhưng có thể là một con trỏ hoặc tham chiếu đến chúng).<a href="decltype" title="cpp/language/decltype"><code>decltype</code></a>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">Như với bất kỳ tuyên bố nào, các thuộc tính xuất hiện trước khai báo và các thuộc tính xuất hiện ngay sau khi định danh trong trình khai báo đều áp dụng cho thực thể được khai báo hoặc xác định (trong trường hợp này, cho hàm):</pre></div> <p>[[Noreturn]] void f [[noreturn]] (); // Được rồi: cả hai thuộc tính đều áp dụng cho hàm f<span class="kw4">hằng số</span>Tuy nhiên, các thuộc tính xuất hiện sau khi khai báo (trong cú pháp trên), áp dụng cho loại hàm, không phải cho chính chức năng:<span class="br0">.</span><span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span><span class="br0">)</span><span class="sy3">Không có giá trị</span>void f () [[noreturn]]; // Lỗi: thuộc tính này không ảnh hưởng đến chính chức năng<span class="br0">.</span><span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span><span class="br0">)</span>Khấu trừ loại trở lại</p>
<p>của khai báo chức năng chứa từ khóa</p>
<div class="cpp source-cpp"><pre data-language="cpp">, loại trả về dấu vết có thể bị bỏ qua và sẽ được trình biên dịch suy luận từ loại biểu thức được sử dụng trong</pre></div> <p>tuyên bố. Nếu loại trả về không sử dụng declType<span class="br0">.</span><span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span><span class="br0">)</span>, các khoản khấu trừ tuân theo các quy tắc của<span class="kw4">Vô hiệu</span>int x = 1;<span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span>tự động f () {return x; } // loại trả về là int<span class="kw4">Vô hiệu</span>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">const auto &amp; f () {return x; } // loại trả về là const int &amp;</pre></div> <p>Nếu loại trả về bị từ chối</p>
<div class="cpp source-cpp"><pre data-language="cpp">, loại trả về là những gì sẽ thu được nếu biểu thức được sử dụng trong câu lệnh trả về</pre></div> <p>int x = 1;</p>
<div class="cpp source-cpp"><pre data-language="cpp">DeclType (tự động) f () {return x; } // Loại trả về là int, giống như declType (x)</pre></div> <p><a href="virtual" title="cpp/language/virtual">Virtual functions</a><span class="t-rev-inl t-since-cxx20"><span>Và<a href="coroutines" title="cpp/language/coroutines">coroutines</a></span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>DeclType (tự động) f () {return (x); } // Loại trả về là int &amp;, giống như declType ((x))</p>
<div class="cpp source-cpp"><pre data-language="cpp">(ghi chú: "</pre></div> <p><a href="function_template" title="cpp/language/function template">Function templates</a>REALLOCATION thường là các hoạt động tốn kém về mặt hiệu suất. Các<a href="cast_operator" title="cpp/language/cast operator">user-defined conversion functions</a>DeclType<a href="dependent_name" title="cpp/language/dependent name">dependent</a>"Là một lỗi, DeclType<a href="sfinae" title="cpp/language/sfinae">SFINAE</a>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">phải được sử dụng một mình)</pre></div> <p>Nếu có nhiều câu lệnh trả lại, tất cả chúng phải suy ra cùng một loại:</p>
<div class="cpp source-cpp"><pre data-language="cpp">Auto F (Bool Val)</pre></div> <p>{</p>
<div class="cpp source-cpp"><pre data-language="cpp">    if (val) trả về 123; // suy luận loại trả về int</pre></div> <p><a href="function_template#Explicit_instantiation" title="cpp/language/function template">Explicit instantiation declarations</a>    khác trả về 3.14F;   // Lỗi: khấu trừ loại phao trả lại</p>
<div class="cpp source-cpp"><pre data-language="cpp">}</pre></div> </td> <td><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></td>
</tr> </table> <h3 id="Parameter_list">Nếu không có câu lệnh trả về hoặc nếu đối số của câu lệnh trả về là biểu thức void, loại trả về được khai báo phải được từ chối</h3> <p>, trong trường hợp đó, loại trả lại suy luận là<i>, hoặc (có thể là đủ điều kiện CV)</i>, mỗi trong số đó có cú pháp sau:</p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <span class="t-spar">attr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">DEM-SPECIFIER-SEQ</span> <span class="t-spar">người khai báo</span> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">attr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">DEM-SPECIFIER-SEQ</span> <span class="t-spar">người khai báo</span> <code>=</code> <span class="t-spar">Khởi tạo</span> </td> <td>(2)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">attr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">DEM-SPECIFIER-SEQ</span> <span class="t-spar">TÓM TẮT KIẾN TRÚC</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> </td> <td>(3)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">attr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">DEM-SPECIFIER-SEQ</span> <span class="t-spar">TÓM TẮT KIẾN TRÚC</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <code>=</code> <span class="t-spar">Khởi tạo</span> </td> <td>(4)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>void</code> </td> <td>             Không có p);</td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <div class="t-li1">
<span class="t-li">1)</span>, trong trường hợp đó, loại trả lại suy luận sau đó (có đủ điều kiện CV)<span class="t-spar">DEM-SPECIFIER-SEQ</span>Và<span class="t-spar">người khai báo</span>, nhìn thấy<a href="declarations" title="cpp/language/declarations">declarations</a>.</div> <div class="t-li1">
<span class="t-cc"><code>int f(int a, int* p, int (*(*x)(double))[3]);</code></span>
</div> <div class="t-li1">
<span class="t-li">2)</span>tự động f () {} // trả về void<a href="default_arguments" title="cpp/language/default arguments">default value</a>.</div> <div class="t-li1">
<span class="t-cc"><code>int f(int a = 7, int* p = nullptr, int (*(*x)(double))[3] = nullptr);</code></span>
</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>tự động g () {return f (); } // trả về khoảng trống</div> <div class="t-li1">
<span class="t-cc"><code>int f(int, int*, int (*(*)(double))[3]);</code></span>
</div> <div class="t-li1">
<span class="t-li">là trong</span>auto* x () {} // lỗi: không thể suy ra tự động* từ void<a href="default_arguments" title="cpp/language/default arguments">default value</a>.</div> <div class="t-li1">
<span class="t-cc"><code>int f(int = 7, int* = nullptr, int (*(*)(double))[3] = nullptr);</code></span>
</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Khi một câu lệnh trả về đã được nhìn thấy trong một hàm, loại trả về được suy ra từ câu lệnh đó có thể được sử dụng trong phần còn lại của hàm, bao gồm trong các câu lệnh trả về khác:<code>int f(void);</code>Và<code>int f();</code>Auto Sum (int i)<code>void</code>{<code>int f(void, int);</code>Và<code>int f(const void);</code>    if (i == 1)<code>void*</code>        trả lại tôi;              // loại trả về sum sum là int<code>T</code>    khác<code>T = void</code>).</div> <p>        trả về tổng (i - 1) + i; // Được rồi: loại trả về Sum đã được biết đến<code>...</code>}<a href="variadic_arguments" title="cpp/language/variadic arguments">variadic function</a>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">Nếu câu lệnh trả về sử dụng danh sách khởi động giằng, không cho phép khấu trừ: không cho phép:</pre></div> <p>tự động func () {return {1, 2, 3}; } // lỗi</p>
<div class="cpp source-cpp"><pre data-language="cpp">Không thể sử dụng khấu trừ loại trả lại:</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <p>Các chất hủy diệt ảo thuần túy<span class="t-spar">DEM-SPECIFIER-SEQ</span>Cấu trúc f<a href="declarations#Specifiers" title="cpp/language/declarations">specifiers</a>{<span class="kw4">    tự động ảo f () {return 2; } // lỗi</span> <span class="t-rev-inl t-until-cxx11"><span>};<code>auto</code></span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span>Có thể sử dụng khấu trừ loại trả lại. Việc khấu trừ diễn ra ngay lập tức ngay cả khi biểu thức trong câu lệnh trả về không</p>
</td> <td><span class="t-mark-rev t-until-cxx17">xáo trộn</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>. Sự khởi tạo này không nằm trong bối cảnh ngay lập tức cho các mục đích của<i>};</i>Mẫu &lt;Class T&gt;<span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span>hoặc a<a href="../concepts" title="cpp/concepts">concept type</a>tự động f (t t) {return t; }<a href="function_template#Abbreviated_function_template" title="cpp/language/function template">abbreviated function template</a>    Constexpr tĩnh Int x = 42; // ngầm nội tuyến, định nghĩa S :: x</p>
<div class="cpp source-cpp"><pre data-language="cpp">typedef declType (f (1)) fint_t;    // Instantiates f &lt;int&gt; để suy ra loại trả về</pre></div> </td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <p> </p>
<p>Mẫu &lt;Class T&gt;</p>
<div class="t-li1">
<span class="t-li">1)</span>{<span class="t-spar">DEM-SPECIFIER-SEQ</span>tự động f (t * t) {return * t; }<a href="declarations" title="cpp/language/declarations">declaration</a>void g () {int (*p) (int*) = &amp; f; } // khởi tạo cả FS để xác định các loại trả về,</div> <div class="t-li1">
<span class="t-li">2)</span>                                  // chọn quá tải mẫu thứ hai</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Các thiết kế lại hoặc chuyên môn của các chức năng hoặc mẫu chức năng sử dụng khấu trừ loại trả về phải sử dụng cùng một loại trình giữ chỗ hoàn trả:</div> <div class="t-li1">
<span class="t-li">là trong</span>auto f (int num) {return num; }<code>int f(const int p, decltype(p)*);</code>Và<code>int f(int, const int*);</code>// int f (int num);            // Lỗi: không có loại trả về trình giữ chỗ</div> <p>// DeclType (tự động) f (int num); // Lỗi: Người giữ chỗ khác nhau</p>
<div class="cpp source-cpp"><pre data-language="cpp"> </pre></div> <p>Mẫu &lt;Typename T&gt;</p>
<div class="cpp source-cpp"><pre data-language="cpp">tự động g (t t) {return t; }</pre></div> <p>mẫu tự động g (int);     // Được rồi: loại trả về là int<span class="t-rev-inl t-since-cxx11"><span>- có thể sửa đổi giá trị được tham chiếu thông qua<a href="lambda" title="cpp/language/lambda">lambda expressions</a>)</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>// mẫu char g (char); // Lỗi: không phải là chuyên môn hóa mẫu chính G<span class="t-spar">người khai báo</span>Tương tự, việc tái cấu trúc hoặc chuyên môn của các hàm hoặc mẫu chức năng không sử dụng khấu trừ loại trả về không được sử dụng trình giữ chỗ:<a href="declarations#Specifiers" title="cpp/language/declarations">simple type specifier</a>int f (int num);</p>
<div class="cpp source-cpp"><pre data-language="cpp">// tự động f (int num) {return num; } // Lỗi: không phải là một sự tái cấu trúc của f</pre></div> <p> </p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>Mẫu &lt;Typename T&gt;<a href="variadic_arguments" title="cpp/language/variadic arguments">variadic arguments</a>T g (t t) {return t; }<a href="parameter_pack" title="cpp/language/parameter pack">parameter pack</a>mẫu int g (int);      // Được rồi: chuyên về T như int</p>
<div class="cpp source-cpp"><pre data-language="cpp">// mẫu tự động g (char); // Lỗi: không phải là chuyên môn hóa mẫu chính G</pre></div> <p>Không bản thân các mẫu chức năng khởi tạo sử dụng khấu trừ loại trả về:<a href="../types/is_function#Possible_implementation" title="cpp/types/is function">possible implementation</a>của<code><a href="../types/is_function" title="cpp/types/is function">std::is_function</a></code>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">Mẫu &lt;Typename T&gt;</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">tự động f (t t) {return t; }</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <h3 id="Function_type">mẫu bên ngoài tự động f (int); // không khởi tạo f &lt;Int&gt;</h3> <h4 id="Parameter-type-list"> </h4> <p>int (*p) (int) = f; // Instantiates f &lt;int&gt; để xác định loại trả về của nó,<i>. Độ phân giải là coi tên loại là</i>(tức là, nó kết thúc ở cuối</p>
<ol>
<li>                   // vẫn được yêu cầu ở đâu đó trong chương trình<span class="t-rev-inl t-since-cxx11"><span>Danh sách tham số<a href="parameter_pack" title="cpp/language/parameter pack">parameter packs</a>)</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Danh sách tham số xác định các đối số có thể được chỉ định khi hàm được gọi. Nó là một danh sách phân tách dấu phẩy của<a href="#Parameter_list">parameter declaration</a>.</li>
<li>Khai báo tham số<code>T</code>Khai báo một tham số (chính thức) được đặt tên. Cho ý nghĩa của<code>T</code>Tuyên bố một tham số (chính thức) được đặt tên với một<code>T</code>và người khai báo được kết hợp như trong bất kỳ</li>
<li>Tuyên bố một tham số không tên với một<a href="cv" title="cpp/language/cv">cv-qualifiers</a>Chỉ ra rằng hàm không có tham số, đó là từ đồng nghĩa chính xác cho danh sách tham số trống:</li>
<li>Tuyên bố cùng một chức năng. Lưu ý rằng loại<a href="variadic_arguments" title="cpp/language/variadic arguments">ellipsis</a><span class="t-rev-inl t-since-cxx11"><span>(có thể là đủ điều kiện CV) Không thể được sử dụng trong danh sách tham số nếu không:<a href="parameter_pack" title="cpp/language/parameter pack">parameter pack</a></span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>là lỗi (mặc dù các loại có nguồn gốc, chẳng hạn như</li>
</ol> <div class="cpp source-cpp"><pre data-language="cpp">có thể được sử dụng). Trong một mẫu, chỉ có thể sử dụng loại void không phụ thuộc (một hàm lấy một tham số duy nhất</pre></div> <h4 id="Determining_function_type">không trở thành hàm không tham số nếu được khởi tạo với</h4> <p>Để xác định loại.<span class="t-v">(1)</span>Nếu loại là "mảng T" hoặc "mảng không xác định giới hạn của T", thì nó sẽ được thay thế bằng loại "Con trỏ tới T".<span class="t-spar">Noptr-Declarator</span>Nếu loại là loại hàm F, nó được thay thế bằng loại "Con trỏ tới F".<span class="t-spar">Trừ khi nó đáp ứng tất cả các điều kiện sau:</span>hoặc<span class="t-spar">không đủ tiêu chuẩn-id</span>TRONG<span class="t-spar">Noptr-Declarator</span>Bộ định mức CV cấp cao nhất được loại bỏ khỏi loại tham số (điều chỉnh này chỉ ảnh hưởng đến loại chức năng, nhưng không sửa đổi thuộc tính của tham số:<code>T</code>int printf (const char* fmt, ...); // ok, giống như trên</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <ul><li>int f (char s [3]);<a href="noexcept_spec" title="cpp/language/noexcept spec">non-throwing</a>int f (char []);<br/>int f (char* s);<span class="kw1">Noexcept</span>int f (char* const);<br/>. Độ phân giải là coi tên loại là<span class="t-spar">không ngụ ý rằng</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">Tham khảo</span>﻿ ﻿<span class="t-mark">ATOMIC_INTPTR_T</span>(loại con trỏ tới loại chức năng):<code>T</code>và người khai báo được kết hợp như trong bất kỳ</li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <ul><li> <span class="t-rev-inl t-until-cxx17"><span>Các</span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span><span class="t-rev-inl t-since-cxx17"><span>int f (int (*g) ());</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>Một sự mơ hồ phát sinh trong danh sách tham số khi một tên loại được lồng trong ngoặc đơn<br/>. Trong trường hợp này, lựa chọn là giữa việc khai báo tham số loại con trỏ để chức năng và khai báo một tham số với dấu ngoặc đơn xung quanh định danh của<br/>. Độ phân giải là coi tên loại là<span class="t-spar">không ngụ ý rằng</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span><span class="t-rev-inl t-since-cxx11"><span> <span class="t-spar">Tham khảo</span>﻿ ﻿<span class="t-mark">ATOMIC_INTPTR_T</span></span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>(loại con trỏ tới loại chức năng):<code>T</code>và người khai báo được kết hợp như trong bất kỳ</li></ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>Để xác định loại.<span class="t-v">(2)</span>Nếu loại là "mảng T" hoặc "mảng không xác định giới hạn của T", thì nó sẽ được thay thế bằng loại "Con trỏ tới T".<span class="t-spar">Noptr-Declarator</span>Nếu loại là loại hàm F, nó được thay thế bằng loại "Con trỏ tới F".<span class="t-spar">Trừ khi nó đáp ứng tất cả các điều kiện sau:</span>hoặc<span class="t-spar">không đủ tiêu chuẩn-id</span>TRONG<span class="t-spar">Noptr-Declarator</span>Bộ định mức CV cấp cao nhất được loại bỏ khỏi loại tham số (điều chỉnh này chỉ ảnh hưởng đến loại chức năng, nhưng không sửa đổi thuộc tính của tham số:<code>T</code>Tuyên bố cùng một chức năng).<code>T</code>// thực hiện đầu tiên<span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span>Do các quy tắc này, các khai báo chức năng sau đây khai báo chính xác cùng một hàm:</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <ul><li>int f (char s [3]);<a href="noexcept_spec" title="cpp/language/noexcept spec">non-throwing</a>int f (char []);<br/>int f (char* s);<span class="kw1">Noexcept</span>int f (char* const);<br/>. Độ phân giải là coi tên loại là<span class="t-spar">không ngụ ý rằng</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">Tham khảo</span>﻿ ﻿<span class="t-mark">ATOMIC_INTPTR_T</span>(loại con trỏ tới loại chức năng):<span class="t-spar">Trailing</span>lớp C {};</li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <ul><li> <span class="t-rev-inl t-until-cxx17"><span>Các</span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span><span class="t-rev-inl t-since-cxx17"><span>int f (int (*g) ());</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>Một sự mơ hồ phát sinh trong danh sách tham số khi một tên loại được lồng trong ngoặc đơn<br/>. Trong trường hợp này, lựa chọn là giữa việc khai báo tham số loại con trỏ để chức năng và khai báo một tham số với dấu ngoặc đơn xung quanh định danh của<br/>. Độ phân giải là coi tên loại là<span class="t-spar">không ngụ ý rằng</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">Tham khảo</span>﻿ ﻿<span class="t-mark">ATOMIC_INTPTR_T</span>(loại con trỏ tới loại chức năng):<span class="t-spar">Trailing</span>lớp C {};</li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p><span class="t-spar">attr</span> </p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <div class="cpp source-cpp"><pre data-language="cpp">void f (int (c)) {} // void f (int (*fp) (c param)) {}</pre></div> <h4 id="Trailing_qualifiers">                  // không void f (int c) {}</h4> <p> <span class="t-spar">không ngụ ý rằng</span>﻿<span class="t-rev-inl t-since-cxx11"><span>hoặc<span class="t-spar">Tham khảo</span>﻿ ﻿</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>void g (int *(c [10])); // void g (int *( *fp) (c param [10]));<a href="typedef" title="cpp/language/typedef"><code>typedef</code></a>                      // không void g (int *c [10]);</p>
<ul>
<li>Loại tham số không thể là một loại bao gồm tham chiếu hoặc một con trỏ đến mảng bị ràng buộc không xác định, bao gồm một con trỏ/mảng đa cấp của các loại đó hoặc một con trỏ tới các hàm có tham số là các loại đó.<a href="member_functions" title="cpp/language/member functions">non-static member function</a>Thì</li>
<li>Dấu chấm lửng chỉ ra</li>
<li>không cần phải đi trước một dấu phẩy, ngay cả khi nó tuân theo dấu chấm lửng chỉ ra<span class="kw1">Mở rộng, vì vậy các mẫu chức năng sau giống hệt nhau:</span>tuyên ngôn<span class="t-rev-inl t-since-cxx11"><span>hoặc<a href="type_alias" title="cpp/language/type alias">alias declaration</a></span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Thì</li>
<li>các<a href="type#Type_naming" title="cpp/language/type">type-id</a>Mẫu &lt;typename ... args&gt;<a href="template_parameters#Type_template_parameter" title="cpp/language/template parameters">template type parameter</a>, hoặc</li>
<li>void f (args ..., ...);</li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp"> </pre></div> <h3 id="Function_definition">Mẫu &lt;typename ... args&gt;</h3> <p>void f (args ... ...);<a href="member_functions" title="cpp/language/member functions">member function</a> <a href="class" title="cpp/language/class">class definition</a>Mẫu &lt;typename ... args&gt;</p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <span class="t-spar">attr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">DEM-SPECIFIER-SEQ</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">người khai báo</span> <span class="t-spar">Virt-Specifier-seq</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">cơ thể chức năng</span> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <p>Ở đâu<span class="t-spar">cơ thể chức năng</span>void f (args ......);</p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <span class="t-spar">CTOR-initializer</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">Tệp hỗn hợp</span> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">Chức năng-thử khối</span> </td> <td>(2)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>=</code> <code>delete</code> <code>;</code> </td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td>
</tr> <tr class="t-sdsc"> <td> <code>=</code> <code>default</code> <code>;</code> </td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td>
</tr>
</table> <div class="t-li1">
<span class="t-li">1)</span>Một ví dụ về khi nào tuyên bố như vậy có thể được sử dụng là</div> <div class="t-li1">
<span class="t-li">2)</span> <a href="function-try-block" title="cpp/language/function-try-block">Function-try-block</a>#include &lt;Cstdio&gt;</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span> </div> <div class="t-li1">
<span class="t-li">là trong</span>Mẫu &lt;typename ... variadic, typename ... args&gt;<a href="member_functions#Special_member_functions" title="cpp/language/member functions">special member functions</a><span class="t-rev-inl t-since-cxx20"><span>Và<a href="default_comparisons" title="cpp/language/default comparisons">comparison operator functions</a></span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>.</div> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">attr</span> </td> <td>-</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span>Constexpr void gọi (tự động (*vui) (variadic ......), args ... args)<a href="attributes" title="cpp/language/attributes">attributes</a>{<span class="t-spar">người khai báo</span>    vui vẻ (args ...);</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">DEM-SPECIFIER-SEQ</span> </td> <td>-</td> <td>}<a href="declarations" title="cpp/language/declarations">declaration grammar</a> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">người khai báo</span> </td> <td>-</td> <td> <span class="t-rev-inl t-since-cxx20"><span>int main ()<span class="t-spar">tuyên ngôn;</span></span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">Virt-Specifier-seq</span> </td> <td>-</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <a href="override" title="cpp/language/override"><code>override</code></a>Thì<a href="final" title="cpp/language/final"><code>final</code></a>{</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">CTOR-initializer</span> </td> <td>-</td> <td> <a class="mw-redirect" href="initializer_list" title="cpp/language/initializer list">member initializer list</a>, chỉ được phép trong các nhà xây dựng</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">Tệp hỗn hợp</span> </td> <td>-</td> <td>các nẹp bao bọc<a href="statements#Compound_statements" title="cpp/language/statements">sequence of statements</a>cấu thành cơ thể của một chức năng</td>
</tr>
</table> <div class="cpp source-cpp"><pre data-language="cpp">    Gọi (std :: printf, "%dm •%dm •%dm =%d%s%c", 2,3,7, 2*3*7, "m³", '\ n');</pre></div> <p>}<a href="statements#Compound_statements" title="cpp/language/statements">compound statement</a>2m • 3m • 7m = 42m³</p>
<p>Loại chức năng<a class="mw-redirect" href="incomplete_type" title="cpp/language/incomplete type">incomplete</a> <a href="class" title="cpp/language/class">class types</a><span class="t-rev-inl t-since-cxx11"><span>Danh sách loại tham số</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Một chức năng<a href="member_functions" title="cpp/language/member functions">member functions</a>Danh sách loại tham số</p>
<p>Loại của mỗi tham số<span class="t-spar">người khai báo</span>(bao gồm cả chức năng<a href="scope" title="cpp/language/scope">in scope</a>được xác định từ chính nó</p>
<div class="cpp source-cpp"><pre data-language="cpp">Sau khi xác định loại của từng tham số, bất kỳ tham số nào của mảng</pre></div> <p>"Hoặc thuộc loại chức năng<a href="cv" title="cpp/language/cv">cv-qualifiers</a>được điều chỉnh để trở thành "con trỏ để</p>
<div class="cpp source-cpp"><pre data-language="cpp">”.</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <h3 id="Deleted_functions">Sau khi tạo danh sách các loại tham số, bất kỳ cấp cao nhất</h3> <p>Sửa đổi một loại tham số bị xóa khi hình thành loại chức năng.<code>= delete;</code>Danh sách kết quả của các loại tham số được chuyển đổi và sự hiện diện hoặc vắng mặt của<i>hoặc một chức năng</i>là danh sách loại tham số chức năng.<a href="expressions#Potentially-evaluated_expressions" title="cpp/language/expressions">potentially-evaluated</a>void f (char*);         // #1<a href="definition#ODR-use" title="cpp/language/definition">ODR-use</a>void f (char []) {} // xác định #1</p>
<p>void f (const char*) {} // ok, một quá tải khác<a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a>void f (char* const) {} // error: định nghĩa lại #1</p>
<div class="cpp source-cpp"><pre data-language="cpp"> </pre></div> <p>void g (char (*) [2]);   // #2</p>
<div class="cpp source-cpp"><pre data-language="cpp">void g (char [3] [2]) {} // xác định #2</pre></div> <h3 id="User-provided_functions">void g (char [3] [3]) {} // ok, một quá tải khác</h3> <p>Biểu thức không đổi được chuyển đổi theo ngữ cảnh<i> </i>void H (int x (const int)); // #3</p>
<div class="cpp source-cpp"><pre data-language="cpp">void H (int (*) (int)) {} // Xác định #3</pre></div> <h3 id="func">Xác định loại chức năng</h3> <p>Trong cú pháp<code>__func__</code>, giả sử</p>
<div class="cpp source-cpp"><pre data-language="cpp">như một tuyên bố độc lập, với loại</pre></div> <p>như danh sách loại DOCLARATOR</p>
<div class="cpp source-cpp"><pre data-language="cpp">"</pre></div> <div class="cpp source-cpp"><pre data-language="cpp">Nếu đặc tả ngoại lệ là</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">, loại chức năng được khai báo là</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <h3 id="Notes">Ghi chú</h3> <p>Danh sách loại xác thực<a href="direct_initialization#Notes" title="cpp/language/direct initialization">direct-initialization</a>.</p>
<table class="wikitable ftm-begin ftm-has-value"> <tr> <th>Tính năng Test Macro</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../feature_test#cpp_decltype_auto" title="cpp/feature test"><code>__cpp_decltype_auto</code></a></td> <td><span class="nu0">Khoảng thời gian thực tế (tính bằng giây) được giữ bởi một đối tượng thời lượng</span></td> <td><span class="t-mark">(C ++ 14)</span></td> <td>
<a href="auto" title="cpp/language/auto"><code>decltype(auto)</code></a> </td>
</tr> <tr> <td><a href="../feature_test#cpp_return_type_deduction" title="cpp/feature test"><code>__cpp_return_type_deduction</code></a></td> <td><span class="nu0">Khoảng thời gian thực tế (tính bằng giây) được giữ bởi một đối tượng thời lượng</span></td> <td><span class="t-mark">(C ++ 14)</span></td> <td>
<a href="#Return_type_deduction">Return type deduction for normal functions</a> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">chức năng của</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">Danh sách loại tham số</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/135.html" rel="nofollow">CWG 135</a> </td> <td>C ++ 98</td> <td>trở lại<br/>”.<br/>Nếu không,</td> <td>cho phép</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/332.html" rel="nofollow">CWG 332</a> </td> <td>C ++ 98</td> <td>loại chức năng được khai báo là<span class="kw4">Vô hiệu</span>kiểu</td> <td>bị cấm</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/393.html" rel="nofollow">CWG 393</a> </td> <td>C ++ 98</td> <td>Chức năng danh sách loại DROTAINATOR DOVARATOR của<br/>Danh sách loại tham số</td> <td>trở lại</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/452.html" rel="nofollow">CWG 452</a> </td> <td>C ++ 98</td> <td>”.</td> <td>Trong cú pháp<br/>, giả sử<br/>như một tuyên bố độc lập, với loại</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/577.html" rel="nofollow">CWG 577</a> </td> <td>C ++ 98</td> <td>Áp dụng cho một biểu thức phụ thuộc loại là một loại phụ thuộc duy nhất. Hai kết quả như vậy chỉ đề cập đến cùng một loại nếu biểu thức của chúng là<span class="kw4">Vô hiệu</span>như danh sách loại DOCLARATOR<br/>"(</td> <td>Trong trường hợp này):<br/><span class="kw4">Vô hiệu</span>        hoán đổi (đầu tiên [i], đầu tiên [std :: rand () % (i + 1)]);</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1327.html" rel="nofollow">CWG 1327</a> </td> <td>C ++ 11</td> <td>Nếu đặc tả ngoại lệ là<br/>, loại chức năng được khai báo là</td> <td>cho phép</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1355.html" rel="nofollow">CWG 1355</a> </td> <td>C ++ 11</td> <td>Danh sách loại xác thực</td> <td>chức năng của</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1394.html" rel="nofollow">CWG 1394</a> </td> <td>C ++ 11</td> <td>Danh sách loại tham số<br/>trở lại</td> <td>”.</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1824.html" rel="nofollow">CWG 1824</a> </td> <td>C ++ 98</td> <td>Nếu không,<br/>loại chức năng được khai báo là<br/>Chức năng danh sách loại DROTAINATOR DOVARATOR của</td> <td>loại chức năng cho một<br/>trở lại<br/>”.</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1877.html" rel="nofollow">CWG 1877</a> </td> <td>C ++ 14</td> <td>, nếu có, áp dụng cho loại chức năng.<code>return;</code>(1,3)<code>return void();</code> </td> <td>// loại hình của "f1" là<br/>// Chức năng của int return void, với thuộc tính Noreturn,<span class="kw4">Vô hiệu</span>                     Forwardit2 s_first, forwardit2 s_last,</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2015.html" rel="nofollow">CWG 2015</a> </td> <td>C ++ 11</td> <td>void f1 (int a) [[noreturn]];<br/> </td> <td>// loại hình của "f2" là<br/>// "Chức năng NoExcept Chức năng của con trỏ lên int int int"</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2044.html" rel="nofollow">CWG 2044</a> </td> <td>C ++ 14</td> <td>ConstExpr Auto F2 (int [] b) NoExcept -&gt; int;<span class="kw4">Vô hiệu</span><br/> <span class="br0">.</span><span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span><span class="br0">)</span> </td> <td>Cấu trúc x<br/>{</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2081.html" rel="nofollow">CWG 2081</a> </td> <td>C ++ 14</td> <td>    // loại hình của "f3" là<br/>    // Chức năng không có tham số const trả về const int ”</td> <td>không được phép</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2145.html" rel="nofollow">CWG 2145</a> </td> <td>C ++ 98</td> <td>các<span class="t-spar">người khai báo</span>    const int f3 () const;</td> <td>cho phép</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2259.html" rel="nofollow">CWG 2259</a> </td> <td>C ++ 11</td> <td>};<br/>Vòng loại theo dõi</td> <td>Một bảng liệt kê có thể được khởi tạo từ một số nguyên mà không cần đúc, sử dụng</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2430.html" rel="nofollow">CWG 2430</a> </td> <td>C ++ 98</td> <td>Một loại chức năng với<br/>(bao gồm một loại được đặt tên bởi<br/>Tên) chỉ có thể xuất hiện như:<a class="external text" href="https://cplusplus.github.io/CWG/issues/1824.html" rel="nofollow">CWG issue 1824</a> </td> <td>loại chức năng cho một<br/>loại chức năng mà một con trỏ đến thành viên đề cập,</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/function_declaration" title="c/language/function declaration">C documentation</a></span>vì<span class=""><span>loại chức năng cấp cao nhất của một hàm</span></span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/function">https://en.cppreference.com/w/cpp/language/function</a>
</p>
</div>
