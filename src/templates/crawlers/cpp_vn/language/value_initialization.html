 <h1 class="firstHeading" id="firstHeading">Giá trị bắt đầu</h1> <p>Đây là khởi tạo được thực hiện khi một đối tượng được xây dựng với một bộ khởi tạo trống.</p>
<h3 id="Syntax">Cú pháp</h3> <table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <span class="t-spar">T</span> <code>()</code> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>new</code> <span class="t-spar">T</span> <code>()</code> </td> <td>(2)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">Lớp học</span><code>::</code><span class="t-spar">Lớp học</span><code>(</code><span class="t-spar">...</span><code>)</code> <code>:</code> <span class="t-spar">là bộ lặp không đổi, nghĩa là, trình lặp không bao giờ có thể được sử dụng làm trình lặp đầu ra vì các phần tử sửa đổi không được phép.</span> <code>()</code> <code>{</code> <span class="t-spar">...</span> <code>}</code> </td> <td>(3)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">T</span> <span class="t-spar">sự vật</span> <code>{};</code> </td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">T</span> <code>{}</code> </td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td>
</tr> <tr class="t-sdsc"> <td> <code>new</code> <span class="t-spar">T</span> <code>{}</code> </td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">Lớp học</span><code>::</code><span class="t-spar">Lớp học</span><code>(</code><span class="t-spar">...</span><code>)</code> <code>:</code> <span class="t-spar">là bộ lặp không đổi, nghĩa là, trình lặp không bao giờ có thể được sử dụng làm trình lặp đầu ra vì các phần tử sửa đổi không được phép.</span> <code>{}</code> <code>{</code> <span class="t-spar">...</span> <code>}</code> </td> <td>            Chuyển tiếp 2 First2);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td>
</tr>
</table> <h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3> <p>Khởi tạo giá trị được thực hiện trong các tình huống này:</p>
<div class="t-li1">
<span class="t-li">              Nhị phân p);</span>Khi một đối tượng tạm thời không tên được tạo với bộ khởi tạo bao gồm một cặp dấu ngoặc đơn trống<span class="t-rev-inl t-since-cxx11"><span>hoặc niềng răng</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Số lượng các yếu tố để sao chép</div> <div class="t-li1">
<span class="t-li">hiện tại_p</span>Khi một đối tượng có thời lượng lưu trữ động được tạo bởi một<a href="new" title="cpp/language/new">new-expression</a>với bộ khởi tạo bao gồm một cặp dấu ngoặc đơn trống<span class="t-rev-inl t-since-cxx11"><span>hoặc niềng răng</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Số lượng các yếu tố để sao chép</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit1, class inputIt2, class BinaryPredicate&gt;</span>Khi một thành viên dữ liệu không tĩnh hoặc lớp cơ sở được khởi tạo bằng cách sử dụng<a class="mw-redirect" href="initializer_list" title="cpp/language/initializer list">member initializer</a>với một cặp dấu ngoặc đơn trống<span class="t-rev-inl t-since-cxx11"><span>hoặc niềng răng</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Số lượng các yếu tố để sao chép</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <span class="t-li">là trong</span>Khi một đối tượng được đặt tên (tự động, tĩnh hoặc địa lý chủ đề) được khai báo với bộ khởi tạo bao gồm một cặp niềng răng.</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <p>Trong mọi trường hợp, nếu cặp niềng răng trống<code>{}</code>được sử dụng và<code>T</code> <i>loại tổng hợp</i>Thì<a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate-initialization</a>được thực hiện thay vì khởi tạo giá trị.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>Nếu như<code>T</code>là loại lớp không có hàm tạo mặc định nhưng có hàm tạo<code><a href="http://en.cppreference.com/w/cpp/utility/initializer_list"><span class="kw962">Điều đó cho tất cả<span class="me2">Khởi tạo_list</span></span></a></code>Thì<a href="list_initialization" title="cpp/language/list initialization">list-initialization</a>được thực hiện.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <p>Những ảnh hưởng của việc bắt đầu giá trị là:</p>
<div class="t-li1">
<span class="t-li">1)</span>nếu như<code>T</code>là loại lớp không có<a href="default_constructor" title="cpp/language/default constructor">default constructor</a>hoặc với a<span class="t-rev-inl t-until-cxx11"><span>Người dùng bị tuyên bố</span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span><a href="function#User-provided_functions" title="cpp/language/function">user-provided</a>hoặc xóa</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>hàm tạo mặc định, đối tượng là<a href="default_initialization" title="cpp/language/default initialization">default-initialized</a>Số lượng các yếu tố để sao chép</div> <div class="t-li1">
<span class="t-li">2)</span>nếu như<code>T</code>là loại lớp có hàm tạo mặc định là<span class="t-rev-inl t-until-cxx11"><span>Không phải người dùng bị tuyên bố</span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>Không do người dùng cung cấp cũng không bị xóa</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>(nghĩa là, nó có thể là một lớp có hàm tạo mặc định được xác định ngầm hoặc mặc định), đối tượng là<a href="zero_initialization" title="cpp/language/zero initialization">zero-initialized</a>và các ràng buộc ngữ nghĩa cho việc khởi tạo mặc định được kiểm tra và nếu<code>T</code>có hàm tạo mặc định không tầm thường, đối tượng là<a href="default_initialization" title="cpp/language/default initialization">default-initialized</a>Số lượng các yếu tố để sao chép</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>nếu như<code>T</code>là một loại mảng, mỗi phần tử của mảng được khởi tạo giá trị;</div> <div class="t-li1">
<span class="t-li">là trong</span>Nếu không, đối tượng là<a href="zero_initialization" title="cpp/language/zero initialization">zero-initialized</a>.</div> <h3 id="Notes">Ghi chú</h3> <p>Cú pháp<code>T object();</code>không khởi tạo một đối tượng; nó tuyên bố một hàm không có đối số và trả về<code>T</code>. Cách để khởi tạo giá trị một biến được đặt tên trước C ++ 11 là<code>T object = T();</code>, có giá trị khởi tạo một tạm thời và sau đó sao chép khởi tạo đối tượng: hầu hết các trình biên dịch<a href="copy_elision" title="cpp/language/copy elision">optimize out the copy</a>Trong trường hợp này.</p>
<p>Tài liệu tham khảo không thể được cung cấp giá trị.</p>
<p>Quá tải không được khai báo<a href="explicit_cast" title="cpp/language/explicit cast">functional cast</a>, Cú pháp<code>T()</code> <span class="t-v">(1)</span>bị cấm đối với các mảng, trong khi<code>T{}</code> <span class="t-v">             Không có p);</span>được phép.</p>
<p>Tất cả các thùng chứa tiêu chuẩn (<code><a href="../container/vector" title="cpp/container/vector">std::vector</a></code>Thì<code><a href="../container/list" title="cpp/container/list">std::list</a></code>, v.v.) giá trị khởi tạo các yếu tố của chúng khi được xây dựng với một<code>size_type</code>tranh luận hoặc khi được phát triển bằng một cuộc gọi đến<code>resize()</code>, trừ khi người phân bổ của họ tùy chỉnh hành vi của<code>construct</code>.</p>
<p>Tiêu chuẩn chỉ định rằng không bắt đầu không được thực hiện khi lớp có hàm tạo mặc định do người dùng cung cấp hoặc bị xóa, ngụ ý rằng liệu hàm tạo mặc định nói có được chọn bởi độ phân giải quá tải không được xem xét. Tất cả các trình biên dịch đã biết thực hiện bổ sung không khởi tạo nếu một hàm tạo mặc định không bị xóa được chọn.</p>
<div class="cpp source-cpp"><pre data-language="cpp">Cấu trúc a</pre></div> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">{</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">đối tượng mà từ đó gán cho</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/178.html" rel="nofollow">CWG 178</a> </td> <td>C ++ 98</td> <td>    A () = mặc định;<br/> <code>new T()</code>}</td> <td>    Mẫu &lt;class = void&gt;<br/>Tài liệu tham khảo và các đối tượng vô hướng Const không thể được xác định mặc định.</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/543.html" rel="nofollow">CWG 543</a> </td> <td>C ++ 98</td> <td>#include &lt;Cassert&gt;<br/> <br/>    int x;<br/>};</td> <td> <br/>TESTEXPR INT TEST (A A)<br/>{<br/> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1301.html" rel="nofollow">CWG 1301</a> </td> <td>C ++ 11</td> <td>}<br/> </td> <td>Họ là<br/>Mẫu &lt;Class Salloc&gt;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1368.html" rel="nofollow">CWG 1368</a> </td> <td>C ++ 98</td> <td>constexpr int zero = test (a ());<br/>// không hình thành: tham số không được khởi tạo theo tiêu chuẩn,</td> <td>// dẫn đến hành vi không xác định làm cho chương trình bị biến dạng trong bối cảnh <br/> <br/>// Tuy nhiên, mã như vậy được chấp nhận bởi tất cả các trình biên dịch đã biết.</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1502.html" rel="nofollow">CWG 1502</a> </td> <td>C ++ 11</td> <td> <br/>void f ()<br/>{</td> <td>    A a = a (); // không được khởi tạo theo tiêu chuẩn<br/>               // Tuy nhiên, việc triển khai tạo ra mã để khởi tạo bằng không<br/>}</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1507.html" rel="nofollow">CWG 1507</a> </td> <td>C ++ 98</td> <td>#include &lt;Cassert&gt;<br/>#include &lt;Istream&gt;<br/>#include &lt;chuỗi&gt;</td> <td>#include &lt;Vector&gt;<br/> <br/>Cấu trúc T1</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <ul>
<li> <a href="default_constructor" title="cpp/language/default constructor">default constructor</a> </li>
<li> <a href="explicit" title="cpp/language/explicit"><code>explicit</code></a> </li>
<li> <a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate initialization</a> </li>
<li> <a href="list_initialization" title="cpp/language/list initialization">list-initialization</a> </li>
</ul> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/value_initialization">https://en.cppreference.com/w/cpp/language/value_initialization</a>
</p>
</div>
