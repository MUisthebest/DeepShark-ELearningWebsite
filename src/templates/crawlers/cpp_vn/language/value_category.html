 <h1 class="firstHeading" id="firstHeading">Danh mục giá trị</h1> <p>Mỗi C ​​++<a href="expressions" title="cpp/language/expressions">expression</a>(một toán tử có toán hạng của nó, một nghĩa đen, một tên biến, v.v.) được đặc trưng bởi hai thuộc tính độc lập: a<i><a href="type" title="cpp/language/type">type</a></i>và a<i>danh mục giá trị</i>. Mỗi biểu thức có một số loại không tham chiếu và mỗi biểu thức thuộc chính xác một trong ba loại giá trị chính:<i>prvalue</i>Thì<i>XVALUE</i>, Và<i>lvalue</i>.</p>
<ul>
<li>Một glvalue (Lvalue tổng quát hóa) là một biểu thức mà đánh giá xác định danh tính của một đối tượng hoặc chức năng;</li>
<li>một prvalue (rvalue tinh khiết ”) là một biểu hiện của họ đánh giá</li>
<li>tính toán giá trị của một toán hạng của toán tử tích hợp (như vậy prvalue không có<i>đối tượng kết quả</i>                       const t &amp; value, so sánh comp);</li>
<li>khởi tạo một đối tượng (prvalue như vậy được cho là có<i>đối tượng kết quả</i>).</li>
</ul>Đối tượng kết quả có thể là một biến, một đối tượng được tạo bởi<a href="new" title="cpp/language/new">new-expression</a>, tạm thời được tạo bởi<a href="implicit_conversion#Temporary_materialization" title="cpp/language/implicit conversion">temporary materialization</a>hoặc một thành viên của họ. Lưu ý rằng không<span class="kw4">Vô hiệu</span> <a href="expressions#Discarded-value_expressions" title="cpp/language/expressions">discarded</a>Biểu thức có một đối tượng kết quả (tạm thời được vật chất hóa). Ngoài ra, mỗi lớp và mảng prvalue đều có một đối tượng kết quả ngoại trừ khi đó là toán hạng của<a href="decltype" title="cpp/language/decltype">decltype</a>Số lượng các yếu tố để sao chép<ul>
<li>Một xvalue (một giá trị hết hạn của người Viking) là một glvalue biểu thị một đối tượng có tài nguyên có thể được sử dụng lại;</li>
<li>Một lvalue (được gọi là trong lịch sử, bởi vì các lvalues ​​có thể xuất hiện ở phía bên trái của biểu thức gán) là một glvalue không phải là xvalue;</li>
<li>Một rvalue (được gọi là trong lịch sử, bởi vì các rvalues ​​có thể xuất hiện ở phía bên tay phải của biểu thức gán) là một prvalue hoặc xvalue.</li>
</ul> <p>Lưu ý: Phân loại này đã trải qua những thay đổi đáng kể với các sửa đổi tiêu chuẩn C ++ trong quá khứ, xem<a href="#History">History</a>Dưới đây để biết chi tiết.</p>
<h3 id="Primary_categories">Danh mục chính</h3> <h4 id="lvalue">lvalue</h4> <p>Các biểu thức sau đây là<i>biểu thức lvalue</i>:</p>
<ul>
<li>tên của một biến, một hàm<span class="t-rev-inl t-since-cxx20"><span>có thể đại diện cho các phân số của ve.<a href="template_parameters#Non-type_template_parameter" title="cpp/language/template parameters">template parameter object</a></span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>, hoặc một thành viên dữ liệu, bất kể loại, chẳng hạn như<code><a href="http://en.cppreference.com/w/cpp/io/cin"><span class="kw1760">Điều đó cho tất cả<span class="me2">cin</span></span></a></code>hoặc<code><a href="http://en.cppreference.com/w/cpp/io/manip/endl"><span class="kw1795">Điều đó cho tất cả<span class="me2">endl</span></span></a></code>. Ngay cả khi loại của biến là tham chiếu rvalue, biểu thức bao gồm tên của nó là biểu thức lvalue (nhưng xem<a href="#Move-eligible_expressions">Move-eligible expressions</a>);</li>
<li>một cuộc gọi chức năng hoặc biểu thức toán tử bị quá tải, có loại trả về là tham chiếu lvalue, chẳng hạn như<code><a href="http://en.cppreference.com/w/cpp/string/basic_string/getline"><span class="kw1259">Điều đó cho tất cả<span class="me2">Getline</span></span></a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/io/cin"><span class="kw1760">Điều đó cho tất cả<span class="me2">cin</span></span></a>, str<span class="br0">)</span></code>Thì<code><a href="http://en.cppreference.com/w/cpp/io/cout"><span class="kw1762">Điều đó cho tất cả<span class="me2">cout</span></span></a> <span class="sy1">, nối thêm</span> <span class="nu0">, nếu như</span></code>Thì<code>str1 = str2</code>, hoặc<code>++it</code>Số lượng các yếu tố để sao chép</li>
<li> <code>a = b</code>Thì<code>a += b</code>Thì<code>a %= b</code>và tất cả các tích hợp khác<a href="operator_assignment" title="cpp/language/operator assignment">assignment and compound assignment</a>biểu cảm;</li>
<li> <code>++a</code>Và<code>--a</code>, tích hợp<a href="operator_incdec#Built-in_prefix_operators" title="cpp/language/operator incdec">pre-increment and pre-decrement</a>biểu cảm;</li>
<li> <code>*p</code>, tích hợp<a href="operator_member_access#Built-in_indirection_operator" title="cpp/language/operator member access">indirection</a>sự biểu lộ;</li>
<li> <code>a[n]</code>Và<code>p[n]</code>, tích hợp<a href="operator_member_access#Built-in_subscript_operator" title="cpp/language/operator member access">subscript</a>) mà cả hai có thể được chuyển đổi.<span class="t-rev-inl t-since-cxx11"><span>, nơi một toán hạng trong<code>a[n]</code>là một mảng lvalue</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Số lượng các yếu tố để sao chép</li>
<li> <code>a.m</code>    toán tử-= (const std :: chrono :: tháng &amp; dm) const noexcept;<a href="operator_member_access#Built-in_member_access_operators" title="cpp/language/operator member access">member of object</a>Biểu thức, ngoại trừ ở đâu<code>m</code>là người liệt kê thành viên hoặc chức năng thành viên không tĩnh hoặc ở đâu<code>a</code>bao gồm a<code>m</code>là thành viên dữ liệu không tĩnh của loại đối tượng;</li>
<li> <code>p-&gt;m</code>, tích hợp<a href="operator_member_access#Built-in_member_access_operators" title="cpp/language/operator member access">member of pointer</a>Biểu thức, ngoại trừ ở đâu<code>m</code>là người liệt kê thành viên hoặc chức năng thành viên không tĩnh;</li>
<li> <code>a.*mp</code>    toán tử-= (const std :: chrono :: tháng &amp; dm) const noexcept;<a href="operator_member_access#Built-in_pointer-to-member_access_operators" title="cpp/language/operator member access">pointer to member of object</a>Biểu thức, ở đâu<code>a</code>có giá trị là giá trị của người liệt kê;<code>mp</code>là một con trỏ đến thành viên dữ liệu;</li>
<li> <code>p-&gt;*mp</code>, tích hợp<a href="operator_member_access#Built-in_pointer-to-member_access_operators" title="cpp/language/operator member access">pointer to member of pointer</a>Biểu thức, ở đâu<code>mp</code>là một con trỏ đến thành viên dữ liệu;</li>
<li> <code>a, b</code>, tích hợp<a href="operator_other#Built-in_comma_operator" title="cpp/language/operator other">comma</a>Biểu thức, ở đâu<code>b</code>là một lvalue;</li>
<li> <code>a ? b : c</code>    toán tử-= (const std :: chrono :: tháng &amp; dm) const noexcept;<a href="operator_other#Conditional_operator" title="cpp/language/operator other">ternary conditional</a>Biểu thức chắc chắn<code>b</code>Và<code>c</code>(ví dụ: khi cả hai đều là lvalues ​​cùng loại, nhưng hãy xem<a href="operator_other#Conditional_operator" title="cpp/language/operator other">definition</a>để biết chi tiết);</li>
<li>Một<a href="string_literal" title="cpp/language/string literal">string literal</a>, chẳng hạn như<code>"Hello, world!"</code>Số lượng các yếu tố để sao chép</li>
<li>một biểu thức đúc cho loại tham chiếu lvalue, chẳng hạn như<code>static_cast&lt;int&amp;&gt;(x)</code>hoặc<code>static_cast&lt;void(&amp;)(int)&gt;(x)</code>Số lượng các yếu tố để sao chép</li>
<li>một loại không phải là kiểu<a href="template_parameters" title="cpp/language/template parameters">template parameter</a>của một loại tham chiếu lvalue;</li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul>
<li>một cuộc gọi chức năng hoặc biểu thức toán tử quá tải, có loại trả về là tham chiếu rvalue cho chức năng;</li>
<li>một biểu thức đúc để tham chiếu rvalue cho loại chức năng, chẳng hạn như<code>static_cast&lt;void(&amp;&amp;)(int)&gt;(x)</code>.</li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <p>Của cải:</p>
<ul>
<li>Giống như glvalue (bên dưới).</li>
<li>Địa chỉ của một lvalue có thể được thực hiện bởi nhà điều hành địa chỉ tích hợp:<code>&amp;++i</code><sup class="reference" id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup>Và<code><span class="sy3">Không có giá trị</span><a href="http://en.cppreference.com/w/cpp/io/manip/endl"><span class="kw1795">Điều đó cho tất cả<span class="me2">endl</span></span></a></code>là các biểu thức hợp lệ.</li>
<li>Một lvalue có thể sửa đổi có thể được sử dụng làm toán hạng bên trái của các toán tử gán tổng hợp và tập hợp tích hợp.</li>
<li>Một lvalue có thể được sử dụng để<a href="reference_initialization" title="cpp/language/reference initialization">initialize an lvalue reference</a>; Điều này liên kết một tên mới với đối tượng được xác định bởi biểu thức.</li>
</ul> <h4 id="prvalue">prvalue</h4> <p>Các biểu thức sau đây là<i>Biểu thức prvalue</i>:</p>
<ul>
<li>Một<a href="expressions#Literals" title="cpp/language/expressions">literal</a>(Ngoại trừ<a href="string_literal" title="cpp/language/string literal">string literal</a>), chẳng hạn như<code>42</code>Thì<code>true</code>hoặc<code>nullptr</code>Số lượng các yếu tố để sao chép</li>
<li>một cuộc gọi chức năng hoặc biểu thức toán tử bị quá tải, có loại trả về không tham chiếu, chẳng hạn như<code>str.substr(1, 2)</code>Thì<code>str1 + str2</code>, hoặc<code>it++</code>Số lượng các yếu tố để sao chép</li>
<li> <code>a++</code>Và<code>a--</code>, tích hợp<a href="operator_incdec#Built-in_postfix_operators" title="cpp/language/operator incdec">post-increment and post-decrement</a>biểu cảm;</li>
<li> <code>a + b</code>Thì<code>a % b</code>Thì<code>a &amp; b</code>Thì<code>a &lt;&lt; b</code>và tất cả các tích hợp khác<a href="operator_arithmetic" title="cpp/language/operator arithmetic">arithmetic</a>biểu cảm;</li>
<li> <code>a &amp;&amp; b</code>Thì<code>a || b</code>Thì<code>!a</code>, tích hợp<a href="operator_logical" title="cpp/language/operator logical">logical</a>biểu cảm;</li>
<li> <code>a &lt; b</code>Thì<code>a == b</code>Thì<code>a &gt;= b</code>và tất cả các tích hợp khác<a href="operator_comparison" title="cpp/language/operator comparison">comparison</a>biểu cảm;</li>
<li> <code>&amp;a</code>, tích hợp<a href="operator_member_access#Built-in_address-of_operator" title="cpp/language/operator member access">address-of</a>sự biểu lộ;</li>
<li> <code>a.m</code>    toán tử-= (const std :: chrono :: tháng &amp; dm) const noexcept;<a href="operator_member_access#Built-in_member_access_operators" title="cpp/language/operator member access">member of object</a>Biểu thức, ở đâu<code>m</code>là người liệt kê thành viên hoặc chức năng thành viên không tĩnh<sup class="reference" id="cite_ref-pmfc_2-0"><a href="#cite_note-pmfc-2">[2]</a></sup>Số lượng các yếu tố để sao chép</li>
<li> <code>p-&gt;m</code>, tích hợp<a href="operator_member_access#Built-in_member_access_operators" title="cpp/language/operator member access">member of pointer</a>Biểu thức, ở đâu<code>m</code>là người liệt kê thành viên hoặc chức năng thành viên không tĩnh<sup class="reference" id="cite_ref-pmfc_2-1"><a href="#cite_note-pmfc-2">[2]</a></sup>Số lượng các yếu tố để sao chép</li>
<li> <code>a.*mp</code>    toán tử-= (const std :: chrono :: tháng &amp; dm) const noexcept;<a href="operator_member_access#Built-in_pointer-to-member_access_operators" title="cpp/language/operator member access">pointer to member of object</a>Biểu thức, ở đâu<code>mp</code>là một chức năng con trỏ đến thành viên<sup class="reference" id="cite_ref-pmfc_2-2"><a href="#cite_note-pmfc-2">[2]</a></sup>Số lượng các yếu tố để sao chép</li>
<li> <code>p-&gt;*mp</code>, tích hợp<a href="operator_member_access#Built-in_pointer-to-member_access_operators" title="cpp/language/operator member access">pointer to member of pointer</a>Biểu thức, ở đâu<code>mp</code>là một chức năng con trỏ đến thành viên<sup class="reference" id="cite_ref-pmfc_2-3"><a href="#cite_note-pmfc-2">[2]</a></sup>Số lượng các yếu tố để sao chép</li>
<li> <code>a, b</code>, tích hợp<a href="operator_other#Built-in_comma_operator" title="cpp/language/operator other">comma</a>Biểu thức, ở đâu<code>b</code>là một prvalue;</li>
<li> <code>a ? b : c</code>    toán tử-= (const std :: chrono :: tháng &amp; dm) const noexcept;<a href="operator_other#Conditional_operator" title="cpp/language/operator other">ternary conditional</a>Biểu thức chắc chắn<code>b</code>Và<code>c</code>    std :: chuỗi* p = new std :: chuỗi ("xin chào");<a href="operator_other#Conditional_operator" title="cpp/language/operator other">definition</a>để biết chi tiết);</li>
<li>một biểu thức đúc cho loại không tham chiếu, chẳng hạn như<code>static_cast&lt;double&gt;(x)</code>Thì<code><a href="http://en.cppreference.com/w/cpp/string/basic_string"><span class="kw1233">Điều đó cho tất cả<span class="me2">ngoại trừ việc phần tử được xây dựng là</span></span></a><span class="br0">danh tính</span><span class="br0">{</span></code>, hoặc<code>(int)42</code>Số lượng các yếu tố để sao chép</li>
<li>các<a href="this" title="cpp/language/this"><code>this</code></a>con trỏ;</li>
<li>chồng chéo với container.<a href="enum" title="cpp/language/enum">enumerator</a>Số lượng các yếu tố để sao chép</li>
<li>một loại không phải là kiểu<a href="template_parameters" title="cpp/language/template parameters">template parameter</a>thuộc loại vô hướng;</li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li>Một<a href="lambda" title="cpp/language/lambda">lambda expression</a>, chẳng hạn như<code>[](int x){ return x * x; }</code>Số lượng các yếu tố để sao chép</li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <ul>
<li>Một<a href="constraints" title="cpp/language/constraints">requires-expression</a>, chẳng hạn như<code>requires (T i) { typename T::type; }</code>Số lượng các yếu tố để sao chép</li>
<li>một chuyên ngành của một<a href="constraints" title="cpp/language/constraints">concept</a>, chẳng hạn như<code><a href="http://en.cppreference.com/w/cpp/concepts/equality_comparable"><span class="kw2950">Điều đó cho tất cả<span class="me2">Common_with</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">int</span><span class="sy1">&lt;</span></code>.</li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <p>Của cải:</p>
<ul>
<li>Giống như rvalue (bên dưới).</li>
<li>Một prvalue không thể là<a href="object#Polymorphic_objects" title="cpp/language/object">polymorphic</a>: The<a href="type#Dynamic_type" title="cpp/language/type">dynamic type</a>của đối tượng nó biểu thị luôn là loại biểu thức.</li>
<li>Một prvalue không phải lớp không phải là lớp không thể<a href="cv" title="cpp/language/cv">cv-qualified</a><span class="t-rev-inl t-since-cxx17"><span>, trừ khi nó là<a href="implicit_conversion#Temporary_materialization" title="cpp/language/implicit conversion">materialized</a>để được<a href="reference_initialization" title="cpp/language/reference initialization">bound to a reference</a>đến một loại đủ điều kiện CV</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>. .</li>
<li>Một prvalue không thể có<a href="type#Incomplete_type" title="cpp/language/type">incomplete type</a>(Ngoại trừ loại<span class="kw4">Vô hiệu</span>, xem bên dưới, hoặc khi được sử dụng trong<a href="decltype" title="cpp/language/decltype"><code>decltype</code></a>chỉ định).</li>
<li>Một prvalue không thể có<a href="abstract_class" title="cpp/language/abstract class">abstract class type</a>hoặc một mảng của chúng.</li>
</ul> <h4 id="xvalue">XVALUE</h4> <p>Các biểu thức sau đây là<i>Biểu thức xValue</i>:</p>
<ul>
<li> <code>a.m</code>    toán tử-= (const std :: chrono :: tháng &amp; dm) const noexcept;<a href="operator_member_access#Built-in_member_access_operators" title="cpp/language/operator member access">member of object</a>Biểu thức, ở đâu<code>a</code>bao gồm a<code>m</code>là một thành viên dữ liệu không tĩnh của một loại đối tượng;</li>
<li> <code>a.*mp</code>    toán tử-= (const std :: chrono :: tháng &amp; dm) const noexcept;<a href="operator_member_access#Built-in_pointer-to-member_access_operators" title="cpp/language/operator member access">pointer to member of object</a>Biểu thức, ở đâu<code>a</code>bao gồm a<code>mp</code>là một con trỏ đến thành viên dữ liệu;</li>
<li> <code>a, b</code>, tích hợp<a href="operator_other#Built-in_comma_operator" title="cpp/language/operator other">comma</a>Biểu thức, ở đâu<code>b</code>là một xvalue;</li>
<li> <code>a ? b : c</code>    toán tử-= (const std :: chrono :: tháng &amp; dm) const noexcept;<a href="operator_other#Conditional_operator" title="cpp/language/operator other">ternary conditional</a>Biểu thức chắc chắn<code>b</code>Và<code>c</code>    std :: chuỗi* p = new std :: chuỗi ("xin chào");<a href="operator_other#Conditional_operator" title="cpp/language/operator other">definition</a>để biết chi tiết);</li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul>
<li>Một cuộc gọi chức năng hoặc biểu thức toán tử bị quá tải, có loại trả về là tham chiếu rvalue cho đối tượng, chẳng hạn như<code>std::move(x)</code>Số lượng các yếu tố để sao chép</li>
<li> <code>a[n]</code>, tích hợp<a href="operator_member_access#Built-in_subscript_operator" title="cpp/language/operator member access">subscript</a>Biểu thức, trong đó một toán hạng là một rvalue mảng;</li>
<li>một biểu thức đúc để tham chiếu rvalue cho loại đối tượng, chẳng hạn như<code>static_cast&lt;char&amp;&amp;&gt;(x)</code>Số lượng các yếu tố để sao chép</li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <ul><li>bất kỳ biểu thức nào chỉ định một đối tượng tạm thời, sau<a href="implicit_conversion#Temporary_materialization" title="cpp/language/implicit conversion">temporary materialization</a>Số lượng các yếu tố để sao chép</li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> <tr class="t-rev t-since-cxx23">
<td> <ul><li>Một<a href="#Move-eligible_expressions">move-eligible expression</a>.</li></ul> </td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table> <p>Của cải:</p>
<ul>
<li>Giống như rvalue (bên dưới).</li>
<li>Giống như glvalue (bên dưới).</li>
</ul> <p>Cụ thể, giống như tất cả các rvalues, xvalues ​​liên kết với các tài liệu tham khảo rvalue và giống như tất cả các glvalues, xvalues ​​có thể<a href="object#Polymorphic_objects" title="cpp/language/object">polymorphic</a>và Xvalues ​​không thuộc lớp có thể<a href="cv" title="cpp/language/cv">cv-qualified</a>.</p>
<h3 id="Mixed_categories">Các loại hỗn hợp</h3> <h4 id="glvalue">glvalue</h4> <p>MỘT<i>Biểu thức glvalue</i>là lvalue hoặc xvalue.</p>
<p>Của cải:</p>
<ul>
<li>Một glvalue có thể được chuyển đổi hoàn toàn thành prvalue với lvalue thành rvalue, mảng thành con trỏ hoặc chức năng để con trỏ<a href="implicit_conversion" title="cpp/language/implicit conversion">implicit conversion</a>.</li>
<li>Một glvalue có thể là<a href="object#Polymorphic_objects" title="cpp/language/object">polymorphic</a>: The<a href="type#Dynamic_type" title="cpp/language/type">dynamic type</a>của đối tượng nó xác định không nhất thiết là loại tĩnh của biểu thức.</li>
<li>Một glvalue có thể có<a href="type#Incomplete_type" title="cpp/language/type">incomplete type</a>, nơi được phép bởi biểu thức.</li>
</ul> <h4 id="rvalue">rvalue</h4> <p>MỘT<i>Biểu thức rvalue</i>là prvalue hoặc xvalue.</p>
<p>Của cải:</p>
<ul>
<li>Địa chỉ của một rvalue không thể được thực hiện bởi người vận hành địa chỉ tích hợp:<code>&amp;int()</code>Thì<code>&amp;i++</code><sup class="reference" id="cite_ref-3"><a href="#cite_note-3">[3]</a></sup>Thì<code>&amp;42</code>, Và<code>&amp;std::move(x)</code>không hợp lệ.</li>
<li>Một rvalue không thể được sử dụng làm toán hạng bên trái của các toán tử gán hoặc phân công tổng hợp tích hợp.</li>
<li>Một rvalue có thể được sử dụng để<a href="reference_initialization" title="cpp/language/reference initialization">initialize a const lvalue reference</a>, trong trường hợp đó, tuổi thọ của đối tượng tạm thời được xác định bởi rvalue là<a href="reference_initialization#Lifetime_of_a_temporary" title="cpp/language/reference initialization">extended</a>Cho đến khi phạm vi của tham chiếu kết thúc.</li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul>
<li>Một rvalue có thể được sử dụng để<a href="reference_initialization" title="cpp/language/reference initialization">initialize an rvalue reference</a>, trong trường hợp đó, tuổi thọ của đối tượng tạm thời được xác định bởi rvalue là<a href="reference_initialization#Lifetime_of_a_temporary" title="cpp/language/reference initialization">extended</a>Cho đến khi phạm vi của tham chiếu kết thúc.</li>
<li>Khi được sử dụng như một đối số chức năng và khi<a href="overload_resolution" title="cpp/language/overload resolution">two overloads</a>của hàm có sẵn, một tham số tham chiếu rvalue và tham chiếu lvalue khác vào tham số const, một rvalue liên kết với quá tải tham chiếu rvalue (do đó, nếu cả hai hàm tạo sao chép và di chuyển đều có sẵn, một đối số rvalue sẽ gọi<a href="move_constructor" title="cpp/language/move constructor">move constructor</a>và tương tự với các toán tử phân công sao chép và di chuyển).</li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <h3 id="Special_categories">Danh mục đặc biệt</h3> <h4 id="Pending_member_function_call">Cuộc gọi chức năng thành viên đang chờ xử lý</h4> <p>đều hợp lệ và mỗi biểu thị một loại;<code>a.mf</code>Và<code>p-&gt;mf</code>là<code>mf</code>Điều đó như vậy<a href="member_functions" title="cpp/language/member functions">non-static member function</a>và các biểu thức<code>a.*pmf</code>Và<code>p-&gt;*pmf</code>là<code>pmf</code>Điều đó như vậy<a href="pointer#Pointers_to_member_functions" title="cpp/language/pointer">pointer to member function</a>, được phân loại là các biểu thức prvalue, nhưng chúng không thể được sử dụng để khởi tạo các tài liệu tham khảo, như các đối số chức năng hoặc cho bất kỳ mục đích nào, trừ khi đối số bên trái của toán tử gọi hàm, ví dụ:<code>(p-&gt;*pmf)(args)</code>.</p>
<h4 id="Void_expressions">Biểu thức khoảng trống</h4> <p>Biểu thức cuộc gọi chức năng trả về<span class="kw4">Vô hiệu</span>, diễn viên biểu cảm cho<span class="kw4">Vô hiệu</span>, Và<a href="throw" title="cpp/language/throw">throw-expressions</a>được phân loại là biểu thức prvalue, nhưng chúng không thể được sử dụng để khởi tạo các tham chiếu hoặc làm đối số chức năng. Chúng có thể được sử dụng trong các bối cảnh giá trị bị loại bỏ (ví dụ: trên một dòng của riêng nó, như là toán hạng bên trái của toán tử dấu phẩy, v.v.) và trong<span class="kw1">Không chính thức,</span>tuyên bố trong một hàm trả về<span class="kw4">Vô hiệu</span>. Ngoài ra, biểu hiện ném có thể được sử dụng như là các toán hạng thứ hai và thứ ba của<a href="operator_other" title="cpp/language/operator other">conditional operator ?:</a>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>Biểu thức trống không có<i>đối tượng kết quả</i>.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <h4 id="Bit-fields">    Auto I = std :: bit_cast &lt;std :: uint16_t&gt; (s);</h4> <p>Một biểu thức chỉ định một<a href="bit_field" title="cpp/language/bit field">bit-field</a>(ví dụ.<code>a.m</code>là<code>a</code>                         Parsable &amp; tp, std :: Chrono :: Biên bản &amp; Offset);<span class="kw1">int a = x :: hướng :: trái; // chỉ được phép trong C ++ 11 trở lên</span>MỘT<span class="br0">danh tính</span> <span class="kw4">int</span>bắt buộc_span_size<span class="sy4">:</span> <span class="nu0">Yêu cầu std :: Constructible_From &lt;std :: iter_value_t &lt;i&gt;, std :: iter_reference_t &lt;i &gt;&gt;</span><span class="sy4">Số lượng các yếu tố để sao chép</span> <span class="br0">{</span>) là một biểu thức glvalue: nó có thể được sử dụng làm toán hạng bên trái của toán tử gán, nhưng địa chỉ của nó không thể được thực hiện và không thể tham khảo Lvalue không phải là const. Một tham chiếu liên kết hoặc tham chiếu rvalue có thể được khởi tạo từ một glvalue trường bit, nhưng một bản sao tạm thời của trường bit sẽ được tạo ra: nó sẽ không liên kết trực tiếp với trường bit.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <h4 id="Move-eligible_expressions">Biểu thức đủ điều kiện di chuyển</h4> <p>Mặc dù một biểu thức bao gồm tên của bất kỳ biến nào là biểu thức lvalue, nhưng biểu thức đó có thể đủ điều kiện di chuyển nếu nó xuất hiện dưới dạng toán hạng của</p>
<ul>
<li>Một<a href="return" title="cpp/language/return"><code>return</code></a>tuyên bố</li>
<li>Một<a href="coroutines" title="cpp/language/coroutines"><code>co_return</code></a>tuyên bố<span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </li>
<li>Một<a href="throw" title="cpp/language/throw"><code>throw</code></a>  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }<span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </li>
</ul> <p>Nếu một biểu thức đủ điều kiện di chuyển, nó sẽ được xử lý<span class="t-rev-inl t-until-cxx23"><span>Hoặc là một rvalue hoặc là một lvalue</span><span><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></span></span><span class="t-rev-inl t-since-cxx23"><span>như một rvalue</span><span><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></span></span>cho mục đích của<a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a>(Vì vậy, nó có thể chọn<a href="move_constructor" title="cpp/language/move constructor">move constructor</a>). Nhìn thấy<a href="return#Automatic_move_from_local_variables_and_parameters" title="cpp/language/return">Automatic move from local variables and parameters</a> </p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <h3 id="History">Lịch sử</h3> <h4 id="CPL">CPL</h4> <p>Ngôn ngữ lập trình<a class="extiw" href="https://en.wikipedia.org/wiki/CPL_(programming_language)" title="enwiki:CPL (programming language)">CPL</a>là lần đầu tiên giới thiệu các loại giá trị cho các biểu thức: tất cả các biểu thức CPL có thể được đánh giá ở "chế độ bên phải", nhưng chỉ một số loại biểu thức nhất định có ý nghĩa ở "chế độ bên trái". Khi được đánh giá ở chế độ bên phải, một biểu thức được coi là một quy tắc cho việc tính toán giá trị (giá trị bên phải hoặc giá trị<i>rvalue</i>). Khi được đánh giá ở chế độ bên trái, một biểu thức có hiệu quả cho một địa chỉ (giá trị bên trái hoặc<i>lvalue</i>). "Trái" và "phải" ở đây là viết tắt của "bên trái của nhiệm vụ" và "Quyền được chuyển nhượng".</p>
<h4 id="C">C</h4> <p>Ngôn ngữ lập trình C theo một phân loại tương tự, ngoại trừ vai trò của gán không còn đáng kể: các biểu thức C được phân loại giữa "biểu thức lvalue" và các biểu thức khác (chức năng và giá trị phi đối tượng), trong đó "lvalue" có nghĩa là một biểu thức xác định một đối tượng, "giá trị định vị"<sup class="reference" id="cite_ref-4"><a href="#cite_note-4">[4]</a></sup>.</p>
<h4 id="C.2B.2B98">C ++ 98</h4> <p>C ++ trước năm 2011 theo mô hình C, nhưng đã khôi phục tên "RValue" thành các biểu thức không lvalue, đã tạo ra các hàm thành Lvalues ​​và thêm quy tắc mà các tham chiếu có thể liên kết với Lvalues, nhưng chỉ tham chiếu đến const có thể liên kết với RValues. Một số biểu thức không lvalue c đã trở thành biểu thức Lvalue trong C ++.</p>
<h4 id="C.2B.2B11">C ++ 11</h4> <p>Với việc giới thiệu ngữ nghĩa di chuyển trong C ++ 11, các loại giá trị đã được xác định lại để mô tả hai thuộc tính độc lập của các biểu thức<sup class="reference" id="cite_ref-5"><a href="#cite_note-5">[5]</a></sup>:</p>
<ul>
<li> <i>có danh tính</i>: Có thể xác định xem biểu thức có đề cập đến cùng một thực thể với một biểu thức khác, chẳng hạn như bằng cách so sánh địa chỉ của các đối tượng hoặc các hàm mà chúng xác định (thu được trực tiếp hoặc gián tiếp);</li>
<li> <i>có thể được chuyển từ</i>:<a href="move_constructor" title="cpp/language/move constructor">move constructor</a>Thì<a href="move_assignment" title="cpp/language/move assignment">move assignment operator</a>, hoặc một chức năng khác quá tải mà thực hiện ngữ nghĩa di chuyển có thể liên kết với biểu thức.</li>
</ul> <p>Trong C ++ 11, các biểu thức rằng:</p>
<ul>
<li>có danh tính và không thể được chuyển từ được gọi là<i>lvalue</i>biểu cảm;</li>
<li>có danh tính và có thể được chuyển từ được gọi là<i>XVALUE</i>biểu cảm;</li>
<li>không có danh tính và có thể được chuyển từ<i>prvalue</i>("Rvalue thuần túy") Biểu thức;</li>
<li>không có danh tính và không thể di chuyển từ không được sử dụng<sup class="reference" id="cite_ref-6"><a href="#cite_note-6">[6]</a></sup>.</li>
</ul> <p>Các biểu thức có bản sắc được gọi là "biểu thức glvalue" (glvalue là viết tắt của "lvalue tổng quát"). Cả lvalues ​​và xvalues ​​đều là biểu thức glvalue.</p>
<p>Các biểu thức có thể được chuyển từ được gọi là "biểu thức rvalue". Cả prvalues ​​và xvalues ​​đều là biểu thức rvalue.</p>
<h4 id="C.2B.2B17">C ++ 17</h4> <p>Trong C ++ 17,<a href="copy_elision" title="cpp/language/copy elision">copy elision</a>đã được thực hiện bắt buộc trong một số tình huống và yêu cầu tách các biểu thức prvalue khỏi các đối tượng tạm thời được chúng khởi tạo bởi chúng, dẫn đến hệ thống chúng ta có ngày nay. Lưu ý rằng, trái ngược với sơ đồ C ++ 11, các prvalues ​​không còn được chuyển từ.</p>
<h3 id="Footnotes">Chú thích</h3> <ol class="references"> <li id="cite_note-1"> <span class="reference-text">Giả định<code>i</code>có loại tích hợp hoặc toán tử trước là<a href="operators" title="cpp/language/operators">overloaded</a>để trở lại bằng tài liệu tham khảo Lvalue.</span> </li> <li id="cite_note-pmfc-2"> <span class="reference-text">Danh mục rvalue đặc biệt, xem<a href="#Pending_member_function_call">pending member function call</a>.</span> </li> <li id="cite_note-3"> <span class="reference-text">Giả định<code>i</code>có loại tích hợp hoặc toán tử sau khi không<a href="operators" title="cpp/language/operators">overloaded</a>để trở lại bằng tài liệu tham khảo Lvalue.</span> </li> <li id="cite_note-4"> <span class="reference-text">"Một sự khác biệt về quan điểm trong cộng đồng C tập trung vào ý nghĩa của lvalue, một nhóm coi một lvalue là bất kỳ loại định vị đối tượng nào, một nhóm khác cho rằng một lvalue có ý nghĩa ở phía bên trái của một nhà điều hành gán. Ủy ban C89 đã áp dụng định nghĩa về Lvalue làm định vị đối tượng." - ANSI C Đặt vấn đề, 6.3.2.1/10.</span> </li> <li id="cite_note-5"> <span class="reference-text"><a class="external text" href="https://www.stroustrup.com/terminology.pdf" rel="nofollow">"New" Value Terminology</a>Bởi Bjarne Stroustrup, 2010.</span> </li> <li id="cite_note-6"> <span class="reference-text">const prvalues ​​(chỉ được phép cho các loại lớp) và const xvalues ​​không liên kết với<code>T&amp;&amp;</code>quá tải, nhưng chúng liên kết với<code>const T&amp;&amp;</code>Quá tải, cũng được phân loại là "hàm tạo di chuyển" và "toán tử chuyển nhượng di chuyển" theo tiêu chuẩn, thỏa mãn định nghĩa "có thể được di chuyển từ" cho mục đích phân loại này. Tuy nhiên, quá tải như vậy không thể sửa đổi các đối số của họ và không được sử dụng trong thực tế; trong sự vắng mặt của họ, const prvalues ​​và const xvalues ​​liên kết với<code>const T&amp;</code>quá tải.</span> </li> </ol> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/616.html" rel="nofollow">CWG 616</a> </td> <td>C ++ 11</td> <td>Truy cập thành viên và truy cập thành viên thông qua<br/>con trỏ tới thành viên của một rvalue dẫn đến prvalue</td> <td>    lớp B {};</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1059.html" rel="nofollow">CWG 1059</a> </td> <td>C ++ 11</td> <td>mảng prvalues ​​không thể được kiểm duyệt CV</td> <td>cho phép</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1213.html" rel="nofollow">CWG 1213</a> </td> <td>C ++ 11</td> <td> </td> <td>    lớp B {};</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/value_category" title="c/language/value category">C documentation</a></span>vì<span class=""><span>danh mục giá trị</span></span> </td>
</tr> </table> <h3 id="External_links">Liên kết bên ngoài</h3> <table> <tr> <td>, trừ khi<a class="external text" href="https://www.scs.stanford.edu/~dm/blog/decltype.html" rel="nofollow">C++ value categories and decltype demystified</a> </td>
</tr>
</table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/value_category">https://en.cppreference.com/w/cpp/language/value_category</a>
</p>
</div>
