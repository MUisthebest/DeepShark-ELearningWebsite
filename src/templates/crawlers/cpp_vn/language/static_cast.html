 <h1 class="firstHeading" id="firstHeading">
<code>static_cast</code>chuyển đổi</h1> <p>Chuyển đổi giữa các loại bằng cách sử dụng kết hợp các chuyển đổi ẩn và do người dùng xác định.</p>
<h3 id="Syntax">Cú pháp</h3> <table class="t-sdsc-begin"> <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <code>static_cast&lt;</code><span class="t-spar">Loại mục tiêu</span>﻿<code>&gt;(</code><span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>﻿<code>)</code> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <p>Trả về một giá trị của loại<span class="t-spar">Loại mục tiêu</span>.</p>
<h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3> <p>Chỉ có thể thực hiện các chuyển đổi sau đây với<span class="kw1">Mẫu &lt;Biểu đồ lớp, Đặc điểm lớp, Alloc Class, Class Parsable&gt;</span>, ngoại trừ khi nào các chuyển đổi như vậy sẽ<a href="const_cast#Casting_away_constness" title="cpp/language/const cast">cast away constness</a>(hoặc biến động).</p>
<div class="t-li1">
<span class="t-li">1)</span>Nếu như<span class="t-spar">Loại mục tiêu</span>là một tham chiếu đến một số lớp hoàn chỉnh<code>D</code>Và<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>là một lvalue của cơ sở không phải là Virtual của nó<code>B</code>, hoặc<span class="t-spar">Loại mục tiêu</span>là một con trỏ đến một số lớp hoàn chỉnh<code>D</code>Và<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>là một con trỏ prvalue đến cơ sở không phải là người Virtual của nó<code>B</code>Thì<code>static_cast</code>thực hiện a<i>hạ cấp</i>. (Downcast này không được hình thành nếu<code>B</code>là cơ sở mơ hồ, không thể truy cập hoặc ảo (hoặc cơ sở của một cơ sở ảo) của<code>D</code>    Yêu cầu std :: are thừng_as &lt;typename std :: Generator &lt;T2, V2, ALLOC2&gt; :: Măng sản, mang lại&gt;</div> <div class="t-li1">Downcast như vậy không kiểm tra thời gian chạy để đảm bảo rằng loại thời gian chạy của đối tượng thực sự<code>D</code>và chỉ có thể được sử dụng một cách an toàn nếu điều kiện tiên quyết này được đảm bảo bằng các phương tiện khác, chẳng hạn như khi thực hiện<a class="extiw" href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern#Static_polymorphism" title="enwiki:Curiously recurring template pattern">static polymorphism</a>. Downcast an toàn có thể được thực hiện với<a href="dynamic_cast" title="cpp/language/dynamic cast"><code>dynamic_cast</code></a>.</div> <div class="t-li1">Nếu đối tượng<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>đề cập hoặc điểm thực sự là một tiểu mục lớp cơ sở của một đối tượng thuộc loại<code>D</code>, kết quả đề cập đến đối tượng kèm theo loại<code>D</code>. Nếu không, hành vi không được xác định:<div class="cpp source-cpp"><pre data-language="cpp">struct b {};</pre></div>
</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <span class="t-li">2)</span>Nếu như<span class="t-spar">Loại mục tiêu</span>Cấu trúc D: B {B B; };<a href="reference_initialization#Definitions" title="cpp/language/reference initialization">reference-compatible</a> <span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>Thì<span class="kw1">Mẫu &lt;Biểu đồ lớp, Đặc điểm lớp, Alloc Class, Class Parsable&gt;</span>D d;<span class="t-rev-inl t-until-cxx17"><span>B &amp; br1 = d;</span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span><span class="t-rev-inl t-since-cxx17"><span>        {t &lt;= u} -&gt; Boolean -Testable;</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span> <span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>B &amp; BR2 = D.B;<span class="t-spar">Loại mục tiêu</span> <a href="bit_field" title="cpp/language/bit field">bit-field</a>static_cast &lt;d &amp;&gt; (br1); // ok: lvalue biểu thị đối tượng d ban đầu<span class="kw1">Mẫu &lt;Biểu đồ lớp, Đặc điểm lớp, Alloc Class, Class Parsable&gt;</span>static_cast &lt;d &amp;&gt; (br2); // UB: tiểu mục B không phải là tiểu đơn lớp cơ sở<code>std::move</code>.</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>là loại tham chiếu rvalue và loại được tham chiếu là<a href="implicit_conversion" title="cpp/language/implicit conversion">implicit conversion sequence</a>từ<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>ĐẾN<span class="t-spar">Loại mục tiêu</span>với loại<a href="direct_initialization" title="cpp/language/direct initialization">direct initialization</a>Chuyển đổi giá trị của<span class="t-spar">Loại mục tiêu</span>từ<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>glvalue, lớp prvalue hoặc mảng prvalue<code>static_cast&lt;target-type ﻿&gt;(expression ﻿)</code>đến xValue đề cập đến cùng một đối tượng với biểu thức hoặc đối tượng phụ cơ sở của nó (tùy thuộc vào<code>Temp</code>). Nếu loại mục tiêu là một cơ sở không thể tiếp cận hoặc mơ hồ của loại biểu thức, chương trình sẽ không được hình thành. Nếu biểu thức là một<code>target-type Temp(expression ﻿);</code>Lvalue, trước tiên nó được chuyển đổi thành prvalue thuộc loại cơ bản. Loại này của<a href="implicit_conversion" title="cpp/language/implicit conversion">implicit conversions</a>được sử dụng để thực hiện các ngữ nghĩa di chuyển trong<a href="constructor" title="cpp/language/constructor">constructor</a>của<span class="t-spar">Loại mục tiêu</span>Nếu có một<a href="cast_operator" title="cpp/language/cast operator">user-defined conversion operator</a>.<span class="t-rev-inl t-since-cxx17"><span>, hoặc nếu độ phân giải quá tải cho một<span class="t-spar">Loại mục tiêu</span>của một đối tượng hoặc tham chiếu của loại<code>static_cast</code>sẽ tìm thấy ít nhất một chức năng khả thi, sau đó</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>
</div> <div class="t-li1">
<span class="t-li">là trong</span>Nếu như<span class="t-spar">Loại mục tiêu</span>Trả về biến tưởng tượng<code>void</code>khởi tạo như thể bằng cách<code>static_cast</code>, có thể liên quan đến<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>, một cuộc gọi đến</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Để kiểm soát cách giải quyết thời gian địa phương mơ hồ hoặc không tồn tại. Đi qua<a href="implicit_conversion" title="cpp/language/implicit conversion">standard conversion</a>hoặc một cuộc gọi đến một<span class="t-spar">Loại mục tiêu</span>, nếu không (nếu<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>Cho không tham chiếu<span class="t-rev-inl t-since-cxx17"><span>, đối tượng kết quả của</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>Biểu thức prvalue là những gì được cung cấp trực tiếp.<code>static_cast</code>là loại</div> <div class="t-li1">
<span class="t-li">từ_sys</span>(có thể là đủ điều kiện CV),<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>ĐẾN<span class="t-spar">Loại mục tiêu</span>loại bỏ giá trị của<code>static_cast</code>.</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <span class="t-li">6)</span> <a href="enum" title="cpp/language/enum">Scoped enumeration</a>Sau khi đánh giá nó.<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p>Trình tự từ<span class="kw4">bool</span>tồn tại, không bao gồm lvalue-to-rvalue, mảng đến trỏ, chức năng để con trỏ, con trỏ null, con trỏ thành viên null, con trỏ thành viên,<code>false</code>con trỏ chức năng,<code>true</code>hoặc chuyển đổi boolean, sau đó</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p>Kết quả giống như<a href="implicit_conversion" title="cpp/language/implicit conversion">implicit conversion</a>Nếu chuyển đổi của</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <span class="t-li">. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu biểu thức</span>liên quan đến lvalue-to-rvalue, mảng thành con trỏ hoặc chuyển đổi chức năng thành máy tính, nó có thể được thực hiện rõ ràng bởi<a href="enum" title="cpp/language/enum">enumeration type</a>.<ul>
<li>Loại có thể được chuyển đổi thành một loại số nguyên hoặc dấu phẩy động.<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>Khi loại mục tiêu là</li>
<li>(có thể là đủ điều kiện CV), kết quả là<a href="implicit_conversion#Integral_conversions" title="cpp/language/implicit conversion">converting</a>Nếu giá trị ban đầu bằng không và</li>
</ul>cho tất cả các giá trị khác. Đối với các loại tích phân còn lại, kết quả là giá trị của enum nếu nó có thể được biểu diễn bằng loại mục tiêu và không xác định khác.<ul><li>Kết quả giống như<a href="implicit_conversion#Floating.E2.80.93integral_conversions" title="cpp/language/implicit conversion">converting</a>Từ loại cơ bản của Enum đến loại đích.</li></ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx23">
<td> <span class="t-li">được hình thành tốt. Chương trình không được hình thành nếu</span>Một giá trị của loại số nguyên hoặc loại liệt kê có thể được chuyển đổi thành bất kỳ hoàn chỉnh nào<ul>
<li>Chuyển đổi tích phân</li>
<li>Nếu loại cơ bản không cố định, hành vi không được xác định nếu giá trị của</li>
<li>Nếu không, hành vi là không xác định.</li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table> <div class="t-li1">
<span class="t-li">Toán tử bool constexpr&gt; (const std :: Chrono :: sys_time &lt;fending&gt; &amp; x,</span>nằm ngoài phạm vi (phạm vi là tất cả các giá trị có thể cho trường bit nhỏ nhất đủ lớn để giữ tất cả các điều tra viên của liệt kê mục tiêu).<code>D</code>Nếu loại cơ bản được cố định, kết quả cũng giống như<code>B</code>Giá trị ban đầu trước tiên cho loại bên dưới của bảng liệt kê và sau đó là loại liệt kê.<code>static_cast</code>Một giá trị của một loại điểm nổi cũng có thể được chuyển đổi thành bất kỳ loại liệt kê hoàn chỉnh nào.<code>B</code>được chuyển đổi thành một.</div> <span class="t-li">                           const std :: Chrono :: Leap_Second &amp; y) noExcept;</span>Kết quả giống như<span class="kw4">Vô hiệu</span>Giá trị ban đầu trước tiên cho loại bên dưới của bảng liệt kê, và sau đó là loại liệt kê.<code>T</code>.<ul>
<li>Một loại prvalue của loại dấu phẩy động có thể được chuyển đổi rõ ràng thành bất kỳ loại điểm nổi nào khác.<a href="pointer#Pointers" title="cpp/language/pointer">pointer value</a>Nếu giá trị nguồn nằm giữa hai giá trị đại diện của loại đích, kết quả là một trong hai giá trị đó (đó là định nghĩa thực hiện nào, mặc dù nếu số học của IEEE được hỗ trợ, làm tròn mặc định đến gần nhất).<code>T</code>Một con trỏ tới thành viên của một số lớp hoàn chỉnh</li>
<li>có thể được nâng lên một con trỏ tới thành viên của lớp cơ sở rõ ràng, dễ tiếp cận của nó<code>a</code>. Cái này<code>b</code>nó đến một đối tượng<a href="implicit_conversion#Similar_types" title="cpp/language/implicit conversion">similar</a>ĐẾN<code>T</code>          std :: Indirect_strict_weak_order &lt;<a href="#Pointer-interconvertible_objects">pointer-interconvertible</a>với<code>a</code>Không làm cho không kiểm tra để đảm bảo thành viên thực sự tồn tại trong loại thời gian chạy của đối tượng nhọn: nếu<code>b</code>.</li>
<li>Một prvalue của loại con trỏ để</li>
</ul> <div class="t-li1">(có thể là đủ điều kiện CV) có thể được chuyển đổi thành con trỏ sang bất kỳ loại đối tượng nào<code>void</code>Nếu bản gốc</div> <p>T2</p>
<ul><li>Tham chiếu kết quả đề cập đến đối tượng ban đầu.<span class="t-spar">Loại mục tiêu</span>Giá trị con trỏ null có thể được chuyển đổi thành giá trị con trỏ null của<span class="t-rev-inl t-since-cxx11"><span>Loại mục tiêu</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Số lượng các yếu tố để sao chép</li></ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li>. Giá trị con trỏ thành viên null có thể được chuyển đổi thành giá trị con trỏ thành viên null của<span class="t-spar">Loại mục tiêu</span>Như với tất cả các biểu thức diễn viên, kết quả là:</li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <ul><li>một lvalue nếu</li></ul> <h3 id="Pointer-interconvertible_objects">đại diện cho một địa chỉ của một byte trong bộ nhớ không đáp ứng yêu cầu liên kết của</h3> <p>, sau đó giá trị con trỏ kết quả là không xác định.<code>a</code>Và<code>b</code>&gt;<i>Con trỏ-interConvertible</i>{</p>
<ul>
<li>Mặt khác, nếu giá trị con trỏ gốc trỏ đến một đối tượng</li>
<li>và có một đối tượng</li>
<li>, kết quả là một con trỏ tới<a href="data_members#Standard-layout" title="cpp/language/data members">standard-layout</a>Nếu không, giá trị con trỏ không thay đổi.</li>
<li> <code>c</code>chỉ vào trình tự và mọi số nguyên không âm<code>a</code>Và<code>c</code>Chuyển đổi bất kỳ con trỏ nào thành con trỏ thành<code>c</code>Và<code>b</code>và trở lại loại con trỏ tới loại gốc (hoặc đủ điều kiện CV) bảo tồn giá trị ban đầu của nó.</li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">Con trỏ-interConvertible đối tượng</pre></div> <h3 id="Notes">Ghi chú</h3> <p><span class="kw1">Mẫu &lt;Biểu đồ lớp, Đặc điểm lớp, Alloc Class, Class Parsable&gt;</span>Hai đối tượng</p>
<div class="cpp source-cpp"><pre data-language="cpp">Họ là cùng một đối tượng, hoặc</pre></div> <h3 id="Keywords">không định nghĩa macro như vậy. Tuy nhiên, nó xác định hằng số macro</h3> <p><a href="../keyword/static_cast" title="cpp/keyword/static cast"><code>static_cast</code></a></p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Một là đối tượng của công đoàn và một là thành viên dữ liệu không tĩnh của đối tượng đó hoặc</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">một là a</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/137.html" rel="nofollow">CWG 137</a> </td> <td>C ++ 98</td> <td>Đối tượng lớp và khác là thành viên dữ liệu không tĩnh đầu tiên của đối tượng đó hoặc bất kỳ tiểu mục cơ sở nào của đối tượng đó hoặc<br/>là con trỏ-interConverbleble, và</td> <td>là con trỏ-interConverbleble.<br/>Union u {int a; kép b; } u;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/439.html" rel="nofollow">CWG 439</a> </td> <td>C ++ 98</td> <td>void* x = &amp; u;                        // giá trị của x là "con trỏ tới u"<br/>gấp đôi* y = static_cast &lt;double*&gt; (x); // Giá trị của Y là "con trỏ tới U.B"<br/>char* z = static_cast &lt;char*&gt; (x);     // giá trị của z là "con trỏ tới u"</td> <td>Cũng có thể được sử dụng để phân loại quá tải chức năng bằng cách thực hiện chuyển đổi chức năng thành con trỏ sang loại cụ thể, như trong<br/>std :: for_each (files.begin (), files.end (),</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1094.html" rel="nofollow">CWG 1094</a> </td> <td>C ++ 98</td> <td>              static_cast &lt;std :: Ostream &amp; (*) (std :: Ostream &amp;)&gt; (std :: flush));<br/>#include &lt;Istream&gt;</td> <td>Mẫu &lt;class inputit, class outputit&gt;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1320.html" rel="nofollow">CWG 1320</a> </td> <td>C ++ 11</td> <td>#include &lt;Vector&gt;<br/> </td> <td>Mẫu &lt;class inputit, class outputit&gt;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1447.html" rel="nofollow">CWG 1447</a> </td> <td>C ++ 11</td> <td>cấu trúc b<br/>{</td> <td>Mẫu &lt;class inputit, class outputit&gt;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1766.html" rel="nofollow">CWG 1766</a> </td> <td>C ++ 98</td> <td>    int m = 42;<br/>    const char* xin chào () const<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span> </td> <td>là giá trị trả về, vẫn có thể giảm được, nhưng bản thân các yếu tố có giá trị không xác định. Một cuộc gọi đến<br/>kích cỡ.</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1832.html" rel="nofollow">CWG 1832</a> </td> <td>C ++ 98</td> <td>        Trả lại "Xin chào thế giới, đây là b! \ n";<br/>    }<span class="t-spar">Loại mục tiêu</span>};</td> <td>không được phép</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2224.html" rel="nofollow">CWG 2224</a> </td> <td>C ++ 98</td> <td> <br/>Struct D: B</td> <td>là giá trị trả về, vẫn có thể giảm được, nhưng bản thân các yếu tố có giá trị không xác định. Một cuộc gọi đến<br/>kích cỡ.</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2254.html" rel="nofollow">CWG 2254</a> </td> <td>C ++ 11</td> <td>{<br/>    const char* xin chào () const</td> <td>    {<br/>{</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2284.html" rel="nofollow">CWG 2284</a> </td> <td>C ++ 11</td> <td>        Trở lại "Xin chào Thế giới, đây là d! \ n";<br/>    }</td> <td>Họ là</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2310.html" rel="nofollow">CWG 2310</a> </td> <td>C ++ 98</td> <td>};<br/> <br/>// Do đó, thêm vào const const vào CV3_K cho mỗi k trong [1, 2): CV3_1 trở thành const const.</td> <td>// t3 là con trỏ của người Viking tới con trỏ đến const char, tức là, const char * const *.</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2338.html" rel="nofollow">CWG 2338</a> </td> <td>C ++ 11</td> <td>lớp enum e {một = 1, hai, ba};<br/>enum eu {một = 1, hai, ba};<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span> </td> <td>int main ()<br/>{</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2499.html" rel="nofollow">CWG 2499</a> </td> <td>C ++ 11</td> <td>    // 1.<br/>    D d;</td> <td>    B &amp; br = d; // upcast thông qua chuyển đổi ngầm</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2718.html" rel="nofollow">CWG 2718</a> </td> <td>C ++ 98</td> <td>    std :: cout &lt;&lt; "1)" &lt;&lt; br.hello ();<br/>// Do đó, thêm vào const const vào CV3_K cho mỗi k trong [1, 2): CV3_1 trở thành const const.</td> <td>// t3 là con trỏ của người Viking tới con trỏ đến const char, tức là, const char * const *.</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <ul>
<li> <a href="const_cast" title="cpp/language/const cast"><code>const_cast</code></a> </li>
<li> <a href="dynamic_cast" title="cpp/language/dynamic cast"><code>dynamic_cast</code></a> </li>
<li> <a href="reinterpret_cast" title="cpp/language/reinterpret cast"><code>reinterpret_cast</code></a> </li>
<li> <a href="explicit_cast" title="cpp/language/explicit cast">explicit cast</a> </li>
<li> <a class="mw-redirect" href="implicit_cast" title="cpp/language/implicit cast">implicit conversions</a> </li>
</ul> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/static_cast">https://en.cppreference.com/w/cpp/language/static_cast</a>
</p>
</div>
