 <h1 class="firstHeading" id="firstHeading">Tuyên bố ràng buộc có cấu trúc<span class="t-mark-rev t-since-cxx17">(C ++ 20)</span>
</h1> <p>Liên kết các tên được chỉ định với các tiểu mục hoặc các phần tử của trình khởi tạo.</p>
<p>Giống như một tham chiếu, một ràng buộc có cấu trúc là một bí danh đối với một đối tượng hiện có. Không giống như một tham chiếu, một liên kết có cấu trúc không phải là loại tham chiếu.</p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <span class="t-spar">attr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">CV-Auto Ref-Qualifier</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <code>[</code> <span class="t-spar">Phạm vi liệt kê</span> <code>] =</code> <span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span> <code>;</code> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">attr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">CV-Auto Ref-Qualifier</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <code>[</code> <span class="t-spar">Phạm vi liệt kê</span> <code>]{</code> <span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span> <code>};</code> </td> <td>(2)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">attr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">CV-Auto Ref-Qualifier</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <code>[</code> <span class="t-spar">Phạm vi liệt kê</span> <code>](</code> <span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span> <code>);</code> </td> <td>(3)</td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">attr</span> </td> <td>-</td> <td>trình tự của bất kỳ số lượng nào<a href="attributes" title="cpp/language/attributes">attributes</a> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">CV-Auto</span> </td> <td>-</td> <td>có thể là trình xác định loại đủ điều kiện CV<code>auto</code><span class="t-rev-inl t-since-cxx20"><span>, cũng có thể bao gồm<a href="storage_duration" title="cpp/language/storage duration">storage-class-specifier</a> <code>static</code>hoặc<code>thread_local</code>; bao gồm<code>volatile</code>trong cv-lequers</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">Nếu nó không phải là loại tham chiếu hoặc loại được khai báo</span> </td> <td>-</td> <td>nhiều nhất là một chuyển đổi đủ điều kiện, và<code>&amp;</code>hoặc<code>&amp;&amp;</code> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">Phạm vi liệt kê</span> </td> <td>-</td> <td>Danh sách các định danh được phân tách bằng dấu phẩy được giới thiệu bởi Tuyên bố này</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span> </td> <td>-</td> <td>một biểu thức không có toán tử dấu phẩy ở cấp cao nhất (về mặt ngữ pháp,<i>Mở rộng gói</i>), và có loại mảng hoặc loại không liên minh. Nếu như<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>đề cập đến bất kỳ tên nào từ<span class="t-spar">Phạm vi liệt kê</span>, Tuyên bố là xấu.</td>
</tr>
</table> <p>Một tuyên bố ràng buộc có cấu trúc giới thiệu tất cả các định danh trong<span class="t-spar">Phạm vi liệt kê</span>như tên trong phạm vi xung quanh và liên kết chúng với các tiểu mục hoặc các phần tử của đối tượng được biểu thị bằng<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>. Các ràng buộc được giới thiệu được gọi là<i>Cấu trúc ràng buộc</i>.</p>
<p>Một tuyên bố ràng buộc có cấu trúc trước tiên giới thiệu một biến có tên độc đáo (ở đây được biểu thị bằng<code><i>if (auto p = Dynamic_cast &lt;const std :: nested_exception*&gt; (std :: addressof (e))))</i></code>) để giữ giá trị của bộ khởi tạo, như sau:</p>
<ul>
<li>Nếu như<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>có loại mảng<code>A</code>Và không<span class="t-spar">Nếu nó không phải là loại tham chiếu hoặc loại được khai báo</span>Có mặt, sau đó<code><i>if (auto p = Dynamic_cast &lt;const std :: nested_exception*&gt; (std :: addressof (e))))</i></code>và kết quả của việc chuyển đổi bằng<i>không ngụ ý rằng</i> <code>A</code>là<i>không ngụ ý rằng</i>là các trình điều chỉnh CV trong<span class="t-spar">CV-Auto</span>trình tự và từng yếu tố của<code><i>if (auto p = Dynamic_cast &lt;const std :: nested_exception*&gt; (std :: addressof (e))))</i></code>là bản sao- (cho<span class="t-v">(1)</span>) hoặc trực tiếp- (cho<span class="t-v">sở hữu phần tử được trích xuất hoặc xử lý nút trống trong trường hợp phần tử không được tìm thấy trong</span>) khởi tạo từ phần tử tương ứng của<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>.</li>
<li>Nếu không thì<code><i>if (auto p = Dynamic_cast &lt;const std :: nested_exception*&gt; (std :: addressof (e))))</i></code>được định nghĩa như thể bằng cách sử dụng tên của nó thay vì<code>[</code> <span class="t-spar">Phạm vi liệt kê</span> <code>]</code>trong Tuyên bố.</li>
</ul> <p>Chúng tôi sử dụng<code><i>E</i></code>Để biểu thị loại biểu thức<code>e</code>. (Nói cách khác,<code><i>E</i></code>là tương đương của<code><a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>decltype<span class="br0">.</span><span class="br0">.</span>e<span class="br0">)</span><span class="br0">)</span><span class="sy1">&lt;</span></code>    Yêu cầu std :: are thừng_as &lt;typename std :: Generator &lt;T2, V2, ALLOC2&gt; :: Măng sản, mang lại&gt;</p>
<p>Một tuyên bố ràng buộc có cấu trúc sau đó thực hiện liên kết theo một trong ba cách có thể, tùy thuộc vào<code><i>E</i></code>:</p>
<ul>
<li>Trường hợp 1: Nếu<code><i>E</i></code>là một loại mảng, sau đó các tên được liên kết với các phần tử mảng.</li>
<li>Trường hợp 2: Nếu<code><i>E</i></code>là loại lớp không liên minh và<code><a href="http://en.cppreference.com/w/cpp/utility/tuple_size"><span class="kw1104">Điều đó cho tất cả<span class="me2">tuple_size</span></span></a><span class="sy1">is_trivently_destructible_v</span>E<span class="sy1">&lt;</span></code>trở thành tên của một lvalue đề cập đến thành viên tiếp theo của<code>value</code>(bất kể loại hoặc khả năng truy cập của thành viên đó), thì giao thức liên kết "giống như tuple" được sử dụng.</li>
<li>Trường hợp 3: Nếu<code><i>E</i></code>là loại lớp không liên minh nhưng<code><a href="http://en.cppreference.com/w/cpp/utility/tuple_size"><span class="kw1104">Điều đó cho tất cả<span class="me2">tuple_size</span></span></a><span class="sy1">is_trivently_destructible_v</span>E<span class="sy1">&lt;</span></code>không phải là một loại hoàn chỉnh, sau đó các tên được liên kết với các thành viên dữ liệu có thể truy cập của<code><i>E</i></code>.</li>
</ul> <p>Mỗi trong ba trường hợp được mô tả chi tiết hơn dưới đây.</p>
<p>Mỗi ràng buộc có cấu trúc có một<i>loại được tham chiếu</i>, được xác định trong mô tả dưới đây. Loại này là loại được trả về bởi<a href="decltype" title="cpp/language/decltype"><code>decltype</code></a>khi áp dụng cho một ràng buộc có cấu trúc chưa được cấu trúc.</p>
<h4 id="Case_1:_binding_an_array">Trường hợp 1: Binding một mảng</h4> <p>Mỗi định danh trong<span class="t-spar">Phạm vi liệt kê</span>trở thành tên của một lvalue đề cập đến phần tử tương ứng của mảng. Số lượng định danh phải bằng số lượng phần tử mảng.</p>
<p>Các<i>loại được tham chiếu</i>Đối với mỗi định danh là loại phần tử mảng. Lưu ý rằng nếu loại mảng<code><i>E</i></code>là CV đủ điều kiện, loại phần tử của nó cũng vậy.</p>
<div class="cpp source-cpp"><pre data-language="cpp">int a [2] = {1, 2};</pre></div> <h4 id="Case_2:_binding_a_tuple-like_type"> </h4> <p>              Không có p);<code><a href="http://en.cppreference.com/w/cpp/utility/tuple_size"><span class="kw1104">Điều đó cho tất cả<span class="me2">tuple_size</span></span></a><span class="sy1">is_trivently_destructible_v</span>E<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span></code>tự động [x, y] = a;    // Tạo E [2], sao chép A vào E,<code><a href="http://en.cppreference.com/w/cpp/utility/tuple_size"><span class="kw1104">Điều đó cho tất cả<span class="me2">tuple_size</span></span></a><span class="sy1">is_trivently_destructible_v</span>E<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span></code>.</p>
<p>                    // sau đó x đề cập đến e [0], y đề cập đến e [1]<code><a href="http://en.cppreference.com/w/cpp/utility/tuple_element"><span class="kw1102">Điều đó cho tất cả<span class="me2">tuple_element</span></span></a><span class="sy1">is_trivently_destructible_v</span>i, E<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">kiểu</span></code>tự động &amp; [xr, yr] = a; // XR đề cập đến A [0], YR đề cập đến [1]</p>
<ul>
<li> <code>e.get&lt;i&gt;()</code>Trường hợp 2: Liên kết một loại giống như tuple<code>get</code>phải là một biểu thức không đổi số nguyên được hình thành tốt và số lượng định danh phải bằng<code><i>E</i></code>Đối với mỗi định danh, một biến có loại là "tham chiếu đến</li>
<li>Là xấu nếu<code>get&lt;i&gt;(e)</code>là<code>get</code>"Được giới thiệu: Tham khảo lvalue nếu trình khởi tạo tương ứng của nó là một lvalue, tham chiếu rvalue khác. Trình khởi tạo cho biến thứ i là<a href="adl" title="cpp/language/adl">argument-dependent lookup</a>, nếu tìm kiếm định danh</li>
</ul> <p>trong phạm vi của<code>e</code>bởi Tra cứu truy cập thành viên lớp Tìm thấy ít nhất một khai báo là một mẫu chức năng có tham số mẫu đầu tiên là tham số không thuộc loại<code><i>if (auto p = Dynamic_cast &lt;const std :: nested_exception*&gt; (std :: addressof (e))))</i></code>được nhìn lên bởi<span class="t-spar">Nếu nó không phải là loại tham chiếu hoặc loại được khai báo</span>khoảng cách<code>&amp;</code>Trong các biểu thức khởi tạo này,<code>&amp;&amp;</code>là một lvalue nếu loại thực thể<code>i</code>Điều đó như vậy<code><a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">Điều đó cho tất cả<span class="me2">size_t</span></span></a></code>là một tài liệu tham khảo lvalue (điều này chỉ xảy ra nếu<code>&lt;i&gt;</code>Máy đánh giá lại</p>
<p>hoặc nếu nó là<a href="storage_duration" title="cpp/language/storage duration">storage duration</a>(1,3)<code><i>if (auto p = Dynamic_cast &lt;const std :: nested_exception*&gt; (std :: addressof (e))))</i></code>.</p>
<p>và biểu thức khởi tạo là một lvalue) và một xvalue khác (điều này thực hiện một cách hiệu quả một loại chuyển tiếp hoàn hảo),</p>
<p>Các<i>loại được tham chiếu</i>prvalue, và<code><a href="http://en.cppreference.com/w/cpp/utility/tuple_element"><span class="kw1102">Điều đó cho tất cả<span class="me2">tuple_element</span></span></a><span class="sy1">is_trivently_destructible_v</span>i, E<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">kiểu</span></code>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">luôn được hiểu là một danh sách tham số mẫu.</pre></div> <h4 id="Case_3:_binding_to_data_members">Biến có cùng</h4> <p>Sau đó, định danh trở thành tên của một lvalue đề cập đến đối tượng bị ràng buộc với biến nói.<code><i>E</i></code>Đối với định danh thứ i là<code><i>E</i></code>Float x {};<code><i>E</i></code>char y {};<code><i><b>if (auto p = Dynamic_cast &lt;const std :: nested_exception*&gt; (std :: addressof (e))))</b></i>.<i>tên</i></code>.<code><i>E</i></code>int z {};</p>
<p> <span class="t-spar">Phạm vi liệt kê</span>std :: tuple &lt;float &amp;, char &amp;&amp;, int&gt; tpl (x, std :: di chuyển (y), z);<code><i>if (auto p = Dynamic_cast &lt;const std :: nested_exception*&gt; (std :: addressof (e))))</i></code>const auto &amp; [a, b, c] = tpl;<code>e.m_i</code>là<code>m_i</code>// sử dụng tpl = const std :: tuple &lt;float &amp;, char &amp;&amp;, int&gt;;<sup>phần tử đầu vào trong I</sup>Mẫu &lt;Slass fspath&gt;</p>
<p>Các<i>loại được tham chiếu</i>// một tên ràng buộc có cấu trúc đề cập đến x (khởi tạo từ get &lt;0&gt; (tpl))<code>e.m_i</code>// DeclType (a) là std :: tuple_element &lt;0, tpl&gt; :: type, tức là float &amp;<code>m_i</code>Nếu đối số đầu tiên là</p>
<div class="cpp source-cpp"><pre data-language="cpp">// B tên một ràng buộc có cấu trúc đề cập đến y (khởi tạo từ get &lt;1&gt; (tpl))</pre></div> <h3 id="Notes">Ghi chú</h3> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>// DeclType (b) là std :: tuple_element &lt;1, tpl&gt; :: type, tức là char &amp;&amp;<a href="constraints" title="cpp/language/constraints">constrained</a>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">// C tên một ràng buộc có cấu trúc đề cập đến thành phần thứ ba của TPL, nhận &lt;2&gt; (TPL)</pre></div> </td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <p>// DeclType (c) là std :: tuple_element &lt;2, tpl&gt; :: type, tức là const int int<code>get</code>Trường hợp 3: Liên kết với các thành viên dữ liệu<code>template&lt;char*&gt; void get();</code>Mọi thành viên dữ liệu không tĩnh của</p>
<p>Phải là thành viên trực tiếp của<code>[</code>hoặc cùng một lớp cơ sở của<code><i>if (auto p = Dynamic_cast &lt;const std :: nested_exception*&gt; (std :: addressof (e))))</i></code>và phải được hình thành tốt trong bối cảnh ràng buộc có cấu trúc khi được đặt tên là</p>
<div class="cpp source-cpp"><pre data-language="cpp">có thể không có một thành viên công đoàn ẩn danh. Số lượng định danh phải bằng số lượng thành viên dữ liệu không tĩnh.</pre></div> <p>Mỗi định danh trong<code><a href="http://en.cppreference.com/w/cpp/utility/tuple_size"><span class="kw1104">Điều đó cho tất cả<span class="me2">tuple_size</span></span></a><span class="sy1">is_trivently_destructible_v</span>E<span class="sy1">&lt;</span></code>trở thành tên của một lvalue đề cập đến thành viên tiếp theo của<code>value</code>theo thứ tự khai báo (trường bit được hỗ trợ); loại lvalue là của</p>
<div class="cpp source-cpp"><pre data-language="cpp">đề cập đến tôi</pre></div> <p>của định danh thứ i là loại<span class="t-spar">Nếu nó không phải là loại tham chiếu hoặc loại được khai báo</span>#include &lt;Istream&gt;<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span> <code><i>if (auto p = Dynamic_cast &lt;const std :: nested_exception*&gt; (std :: addressof (e))))</i></code>cấu trúc s<a href="implicit_conversion#Temporary_materialization" title="cpp/language/implicit conversion">materialized</a>{<code><i>if (auto p = Dynamic_cast &lt;const std :: nested_exception*&gt; (std :: addressof (e))))</i></code>    có thể thay đổi int x1: 2;</p>
<div class="cpp source-cpp"><pre data-language="cpp">    Double Double Y1;</pre></div> <p><code>decltype(x)</code>là<code>x</code>};<i>loại được tham chiếu</i> <code><a href="http://en.cppreference.com/w/cpp/utility/tuple_element"><span class="kw1102">Điều đó cho tất cả<span class="me2">tuple_element</span></span></a></code>S f () {return s {1, 2.3}; }<code>tuple_element</code> </p>
<div class="cpp source-cpp"><pre data-language="cpp">int main ()</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p>{<a href="lambda" title="cpp/language/lambda">lambda expressions</a>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">    const tự động [x, y] = f (); // x là một int lvalue xác định trường bit 2 bit</pre></div> </td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> </table> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>Tính năng Test Macro</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../feature_test#cpp_structured_bindings" title="cpp/feature test"><code>__cpp_structured_bindings</code></a></td> <td><span class="nu0">, khi toán hạng là tên của một đối tượng không bay hơi có thời lượng lưu trữ tự động, đây không phải là tham số hàm hoặc tham số mệnh đề bắt và phạm vi của họ không mở rộng qua khối thử trong cùng (nếu có khối thử).</span></td> <td><span class="t-mark">Dest_at</span></td> <td>                             // y là một lvalue đôi dễ bay hơi</td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">    std :: cout &lt;&lt; x &lt;&lt; '' &lt;&lt; y &lt;&lt; '\ n';  // 1 2.3</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">    x = -2;   // ĐƯỢC RỒI</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2285.html" rel="nofollow">CWG 2285</a> </td> <td>C ++ 17</td> <td>
<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>// y = -2 .;  // Lỗi: y được định mức const<span class="t-spar">Phạm vi liệt kê</span> </td> <td>    std :: cout &lt;&lt; x &lt;&lt; '' &lt;&lt; y &lt;&lt; '\ n';  // -2 2.3</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2312.html" rel="nofollow">CWG 2312</a> </td> <td>C ++ 17</td> <td>}<code>mutable</code>Các ràng buộc có cấu trúc không thể<br/>Mẫu &lt;Class T&gt;</td> <td>Khái niệm c = true;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2386.html" rel="nofollow">CWG 2386</a> </td> <td>C ++ 17</td> <td> <br/>C tự động [x, y] = std :: cặp {1, 2}; // Lỗi: bị ràng buộc<code>tuple_size&lt;E&gt;</code>Tra cứu thành viên</td> <td>Bỏ qua khả năng truy cập như bình thường và cũng bỏ qua loại chính xác của tham số mẫu không kiểu. Một tư nhân<code>tuple_size&lt;E&gt;</code><br/>Thành viên sẽ khiến việc giải thích thành viên được sử dụng, mặc dù nó không được hình thành.<code>value</code> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2635.html" rel="nofollow">CWG 2635</a> </td> <td>C ++ 20</td> <td>Phần của tuyên bố trước</td> <td>bị cấm</td>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/P0961R1" rel="nofollow">P0961R1</a> </td> <td>C ++ 17</td> <td>Áp dụng cho biến ẩn<code>get</code>khoảng cách<br/>, không phải cho các định danh được giới thiệu:<code>get</code>int a = 1, b = 2;</td> <td>const auto &amp; [x, y] = std :: tie (a, b); // x và y thuộc loại int &amp;<br/>tự động [z, w] = std :: tie (a, b);        // z và w vẫn thuộc loại int &amp;</td>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/P0969R0" rel="nofollow">P0969R0</a> </td> <td>C ++ 17</td> <td>khẳng định (&amp; z == &amp; a);                    // vượt qua<br/>Giải thích giống như tuple luôn được sử dụng nếu</td> <td>là một loại hoàn chỉnh với một thành viên có tên<br/>, ngay cả khi điều đó sẽ khiến chương trình trở nên xấu:</td>
</tr>
</table> <h3 id="References">Tài liệu tham khảo</h3> <ul>
<li>C ++ 23 Tiêu chuẩn (ISO/IEC 14882: 2023):</li>
<ul><li>Cấu trúc a {int x; };</li></ul>
<li>Tiêu chuẩn C ++ 20 (ISO/IEC 14882: 2020):</li>
<ul><li> </li></ul>
<li>Tiêu chuẩn C ++ 17 (ISO/IEC 14882: 2017):</li>
<ul><li>không gian tên std</li></ul>
</ul> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../utility/tuple/tie" title="cpp/utility/tuple/tie"> <span class="t-lines"><span>cà vạt</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>tạo ra a<code><a href="../utility/tuple" title="cpp/utility/tuple">tuple</a></code>của các tài liệu tham khảo lvalue hoặc giải nén một bộ phận vào các đối tượng riêng lẻ<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/structured_binding">https://en.cppreference.com/w/cpp/language/structured_binding</a>
</p>
</div>
