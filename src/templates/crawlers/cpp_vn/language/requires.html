 <h1 class="firstHeading" id="firstHeading">Yêu cầu biểu hiện<span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span>
</h1> <p>Mang lại một biểu thức prvalue của loại<span class="kw4">bool</span>Điều đó mô tả các ràng buộc.</p>
<h3 id="Syntax">Cú pháp</h3> <table class="t-sdsc-begin"> <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <code>requires</code> <code>{</code> <span class="t-spar">biểu thức mà</span> <code>}</code> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <code>requires</code> <code>(</code> <span class="t-spar">danh sách tham số</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <code>)</code> <code>{</code> <span class="t-spar">biểu thức mà</span> <code>}</code> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">danh sách tham số</span> </td> <td>-</td> <td>Một danh sách các tham số được phân tách bằng dấu phẩy như trong khai báo hàm, ngoại trừ các đối số mặc định không được phép và nó không thể kết thúc bằng dấu chấm lửng (trừ một biểu thị việc mở rộng gói). Các tham số này không có lưu trữ, liên kết hoặc tuổi thọ và chỉ được sử dụng để hỗ trợ chỉ định các yêu cầu. Các tham số này nằm trong phạm vi cho đến khi đóng<code>}</code>của<span class="t-spar">biểu thức mà</span>.</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">biểu thức mà</span> </td> <td>-</td> <td>Constexpr Phạm vi :: Subrange &lt;i&gt;<i>yêu cầu</i>, mỗi yêu cầu là một trong những điều sau đây:<ul>
<li>Yêu cầu đơn giản</li>
<li>Loại yêu cầu</li>
<li>Yêu cầu ghép</li>
<li>yêu cầu lồng nhau</li>
</ul> </td>
</tr>
</table> <h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3> <p>Các yêu cầu có thể đề cập đến các tham số mẫu nằm trong phạm vi, cho các tham số cục bộ được giới thiệu trong<span class="t-spar">danh sách tham số</span>và đối với bất kỳ tuyên bố nào khác có thể nhìn thấy từ bối cảnh kèm theo.</p>
<p>Sự thay thế của các đối số mẫu thành một biểu hiện yêu cầu được sử dụng trong một tuyên bố<a href="templates#Templated_entity" title="cpp/language/templates">templated entity</a>có thể dẫn đến việc hình thành các loại hoặc biểu thức không hợp lệ trong các yêu cầu của nó hoặc vi phạm các ràng buộc ngữ nghĩa của các yêu cầu đó. Trong những trường hợp như vậy, yêu cầu biểu hiện<code>false</code>và không làm cho chương trình không được hình thành. Việc thay thế và kiểm tra hạn chế ngữ nghĩa tiến hành theo thứ tự từ vựng và dừng lại khi một điều kiện xác định kết quả của biểu hiện yêu cầu. Nếu thay thế (nếu có) và kiểm tra hạn chế ngữ nghĩa thành công, thì yêu cầu biểu hiện<code>true</code>.</p>
<p>Nếu một lỗi thay thế sẽ xảy ra trong một biểu hiện yêu cầu cho mọi đối số mẫu có thể, chương trình sẽ không được hình thành, không cần chẩn đoán:</p>
<div class="cpp source-cpp"><pre data-language="cpp">Mẫu &lt;Class T&gt;</pre></div> <p>Khái niệm C = Yêu cầu<a href="templates#Templated_entity" title="cpp/language/templates">templated entity</a>{</p>
<h3 id="Simple_requirements">    int [-(int) sizeof (t)]; // không hợp lệ cho mọi t: không được hình thành, không cần chẩn đoán</h3> <p>};<code>requires</code>Nếu một biểu hiện yêu cầu có chứa các loại hoặc biểu thức không hợp lệ trong các yêu cầu của nó và nó không xuất hiện trong Tuyên bố của một</p>
<div class="cpp source-cpp"><pre data-language="cpp">, sau đó chương trình là xấu.</pre></div> <p>Yêu cầu đơn giản<code>requires</code>Một yêu cầu đơn giản là một câu lệnh biểu thức tùy ý không bắt đầu với từ khóa</p>
<h3 id="Type_requirements">Chữ ký của hàm phải tương đương với các điều sau:</h3> <p>. Nó khẳng định rằng biểu thức là hợp lệ. Biểu thức là một toán hạng không được đánh giá; Chỉ có tính chính xác ngôn ngữ được kiểm tra.<a href="../keyword/typename" title="cpp/keyword/typename"><code>typename</code></a>Mẫu &lt;Typename T&gt;</p>
<div class="cpp source-cpp"><pre data-language="cpp">Khái niệm có thể bổ sung = Yêu cầu (T a, T B)</pre></div> <h3 id="Compound_requirements">{</h3> <p>    a + b; // "Biểu thức A+B là một biểu thức hợp lệ sẽ biên dịch"</p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <code>{</code> <span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span> <code>}</code> <code>noexcept</code><span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">luôn được hiểu là một yêu cầu lồng nhau. Do đó, một yêu cầu đơn giản không thể bắt đầu với một biểu hiện yêu cầu không được yêu cầu.</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <code>;</code> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">luôn được hiểu là một yêu cầu lồng nhau. Do đó, một yêu cầu đơn giản không thể bắt đầu với một biểu hiện yêu cầu không được yêu cầu.</span> </td> <td>-</td> <td> <code>-&gt;</code> <span class="t-spar">Loại hạn chế</span> </td>
</tr>
</table> <p>Mẫu &lt;class t, class u = t&gt;</p>
<div class="t-li1">
<span class="t-li">1)</span>Khái niệm Swappable = Yêu cầu (T &amp;&amp; T, U &amp;&amp; U)<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>Số lượng các yếu tố để sao chép</div> <div class="t-li1">
<span class="t-li">2)</span>Nếu như<code>noexcept</code>{<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>    Hoán đổi (std :: Chuyển tiếp &lt;t&gt; (t), std :: Chuyển tiếp &lt;u&gt; (u));<a href="noexcept" title="cpp/language/noexcept">potentially throwing</a>Số lượng các yếu tố để sao chép</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Nếu như<span class="t-spar">luôn được hiểu là một yêu cầu lồng nhau. Do đó, một yêu cầu đơn giản không thể bắt đầu với một biểu hiện yêu cầu không được yêu cầu.</span>};</div> <div class="t-li2">
<span class="t-li">}</span>Một yêu cầu bắt đầu với từ khóa<span class="t-spar">luôn được hiểu là một yêu cầu lồng nhau. Do đó, một yêu cầu đơn giản không thể bắt đầu với một biểu hiện yêu cầu không được yêu cầu.</span>Số lượng các yếu tố để sao chép</div> <div class="t-li2">
<span class="t-li">{</span> <code>decltype((expression))</code>Yêu cầu loại là từ khóa<span class="t-spar">Loại hạn chế</span>theo sau là một tên loại, tùy chọn đủ điều kiện. Yêu cầu là loại được đặt tên là hợp lệ: điều này có thể được sử dụng để xác minh rằng một loại lồng nhau có tên nào đó tồn tại hoặc một chuyên ngành mẫu lớp tên một loại hoặc một chuyên ngành mẫu bí danh đặt tên cho một loại. Một yêu cầu loại đặt tên một chuyên môn mẫu lớp không yêu cầu loại phải hoàn thành.<code>false</code>.</div> <div class="cpp source-cpp"><pre data-language="cpp">Mẫu &lt;Typename T&gt;</pre></div> <h3 id="Nested_requirements">sử dụng ref = t &amp;;</h3> <p> </p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <code>requires</code> <span class="t-spar">    {std :: Hash &lt;t&gt; {} (a)} -&gt; std :: mctionble_to &lt;std :: size_t&gt;;</span> <code>;</code> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <p>Mẫu &lt;Typename T&gt;<span class="t-spar">    {std :: Hash &lt;t&gt; {} (a)} -&gt; std :: mctionble_to &lt;std :: size_t&gt;;</span>Khái niệm C = Yêu cầu<span class="t-spar">    {std :: Hash &lt;t&gt; {} (a)} -&gt; std :: mctionble_to &lt;std :: size_t&gt;;</span>{<span class="t-spar">    {std :: Hash &lt;t&gt; {} (a)} -&gt; std :: mctionble_to &lt;std :: size_t&gt;;</span>    Tên T :: Nội; // Tên thành viên được yêu cầu</p>
<div class="cpp source-cpp"><pre data-language="cpp">    Tên s &lt;t&gt;;     // Chuyên môn hóa mẫu cần thiết</pre></div> <h3 id="Note">điều đó làm cho phạm vi đó bằng phạm vi</h3> <p>Biểu thức ràng buộc được giới thiệu cho từng tham số với ràng buộc<a href="../keyword/requires" title="cpp/keyword/requires"><code>requires</code></a>    Typename ref &lt;t&gt;;   // Thay thế mẫu bí danh cần thiết<a href="constraints#Requires_clauses" title="cpp/language/constraints">requires clauses</a>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">};</pre></div> <h3 id="Keywords">không định nghĩa macro như vậy. Tuy nhiên, nó xác định hằng số macro</h3> <p><a href="../keyword/requires" title="cpp/keyword/requires"><code>requires</code></a></p>
<h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <a href="constraints" title="cpp/language/constraints"> Constraints and concepts</a><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span> </td> <td> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/requires">https://en.cppreference.com/w/cpp/language/requires</a>
</p>
</div>
