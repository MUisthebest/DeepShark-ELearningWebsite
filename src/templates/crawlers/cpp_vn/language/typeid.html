 <h1 class="firstHeading" id="firstHeading">toán tử kiểu chữ</h1> <p>Truy vấn thông tin của một loại.</p>
<p>Sử dụng nơi<a href="type#Dynamic_type" title="cpp/language/type">dynamic type</a>xuất hiện trong bối cảnh ngay lập tức của một khởi tạo mẫu.<a href="object#Polymorphic_objects" title="cpp/language/object">polymorphic object</a>phải được biết đến và để xác định loại tĩnh.</p>
<h3 id="Syntax">Cú pháp</h3> <table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <code>typeid (</code> <span class="t-spar">kiểu</span> <code>)</code> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>typeid (</code> <span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span> <code>)</code> </td> <td>(2)</td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <p>Tiêu đề<a href="../header/typeinfo" title="cpp/header/typeinfo"><code>&lt;typeinfo&gt;</code></a>// thực hiện đầu tiên<a href="../standard_library#Including_headers" title="cpp/standard library">included</a> <span class="t-rev-inl t-since-cxx20"><span>hoặc<a href="../standard_library#Importing_headers" title="cpp/standard library">imported</a></span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span> <span class="t-rev-inl t-since-cxx23"><span>hoặc a<a href="../standard_library#Importing_modules" title="cpp/standard library">standard library module</a>nhập khẩu</span><span><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></span></span>trước khi sử dụng<code>typeid</code>Phải là một chuyên ngành của</p>
<p>Biểu thức kiểu chữ là một<a href="value_category" title="cpp/language/value category">lvalue expression</a>đề cập đến một đối tượng với<a href="static" title="cpp/language/static">static storage duration</a>, của phiên bản đủ điều kiện của loại đa hình<code><a href="../types/type_info" title="cpp/types/type info">std::type_info</a></code>hoặc một số loại có nguồn gốc từ nó.</p>
<h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3> <p>                               Không có p);<span class="t-spar">kiểu</span>hoặc<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>là loại lớp hoặc tham chiếu đến loại lớp, thì loại lớp đó không thể là<a class="mw-redirect" href="incomplete_type" title="cpp/language/incomplete type">incomplete type</a>.</p>
<div class="t-li1">
<span class="t-li">1)</span>Đề cập đến a<code><a href="../types/type_info" title="cpp/types/type info">std::type_info</a></code>đối tượng đại diện cho loại<span class="t-spar">kiểu</span>. Nếu như<span class="t-spar">kiểu</span>là loại tham chiếu, kết quả đề cập đến<code><a href="../types/type_info" title="cpp/types/type info">std::type_info</a></code>Đối tượng đại diện cho phiên bản CV-UNQUALEDED của loại được tham chiếu.</div> <div class="t-li1">
<span class="t-li">2)</span>Kiểm tra biểu thức<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>
</div> <div class="t-li2">
<span class="t-li">}</span>Nếu như<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>khoảng cách<span class="t-rev-inl t-until-cxx11"><span>chồng chéo với container.<a href="value_category#lvalue" title="cpp/language/value category">lvalue</a></span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>Một<a href="value_category#glvalue" title="cpp/language/value category">glvalue</a></span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Biểu thức xác định một<a href="object#Polymorphic_objects" title="cpp/language/object">object of a polymorphic type</a>(nghĩa là, một lớp tuyên bố hoặc thừa hưởng ít nhất một<a href="virtual" title="cpp/language/virtual">virtual function</a>), The<code>typeid</code>Biểu thức đánh giá biểu thức và sau đó đề cập đến<code><a href="../types/type_info" title="cpp/types/type info">std::type_info</a></code>Đối tượng đại diện cho loại động của biểu thức. Nếu như<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>có được bằng cách áp dụng Unary<code>*</code>toán tử đến một con trỏ và con trỏ là một giá trị con trỏ null, một ngoại lệ của<span class="t-rev-inl t-until-cxx14"><span>kiểu<code><a href="../types/bad_typeid" title="cpp/types/bad typeid">std::bad_typeid</a></code></span><span><span class="t-mark-rev t-until-cxx14">Constexpr std :: cặp &lt;const t &amp;, const t &amp;&gt; minmax (const t &amp; a, const t &amp; b,</span></span></span><span class="t-rev-inl t-since-cxx14"><span>một loại xử lý phù hợp loại<code><a href="../types/bad_typeid" title="cpp/types/bad typeid">std::bad_typeid</a></code></span><span><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></span></span>có thể được chuyển đổi hoàn toàn thành cả hai. Loại</div> <div class="t-li2">
<span class="t-li">{</span>Nếu như<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span># Elif __has_include (&lt;thử nghiệm/tùy chọn&gt;) // Kiểm tra phiên bản thử nghiệm<span class="t-rev-inl t-until-cxx11"><span>    trả về ++ n;</span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>}</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Biểu hiện của loại đa hình,<code>typeid</code>làm<a href="expressions#Potentially-evaluated_expressions" title="cpp/language/expressions">not evaluate the expression</a>, và<code><a href="../types/type_info" title="cpp/types/type info">std::type_info</a></code>Đối tượng Nó xác định biểu thị loại tĩnh của biểu thức. Không phải là chuyển đổi từ lvalue-to-rvalue, mảng sang con trỏ hoặc chức năng sang con trỏ.<span class="t-rev-inl t-since-cxx17"><span><a href="implicit_conversion#Temporary_materialization" title="cpp/language/implicit conversion">Temporary materialization</a>Tuy nhiên, là (chính thức) được thực hiện cho các đối số prvalue: đối số phải được phá hủy trong bối cảnh mà<code>typeid</code>Biểu thức xuất hiện.</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>
</div> <p>                               Không có p);<span class="t-spar">kiểu</span>hoặc<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>đủ điều kiện CV, kết quả của<code>typeid</code>sizeof (int tĩnh); // Lỗi: Bộ xác định lớp lưu trữ không phải là một phần của loại specifier-seq<code><a href="../types/type_info" title="cpp/types/type info">std::type_info</a></code>đối tượng đại diện cho loại CV-Unquilified (nghĩa là,<code>typeid(const T) == typeid(T)</code>).</p>
<p>Nếu như<code>typeid</code>được sử dụng trên một đối tượng đang được xây dựng hoặc phá hủy (trong một chất phá hủy hoặc trong một hàm tạo, bao gồm cả<a class="mw-redirect" href="initializer_list" title="cpp/language/initializer list">initializer list</a>hoặc<a href="data_members#Member_initialization" title="cpp/language/data members">default member initializers</a>), sau đó<code><a href="../types/type_info" title="cpp/types/type info">std::type_info</a></code>đối tượng được đề cập bởi điều này<code>typeid</code>Đại diện cho lớp đang được xây dựng hoặc phá hủy ngay cả khi nó không phải là lớp có nguồn gốc nhiều nhất.</p>
<h3 id="Keywords">không định nghĩa macro như vậy. Tuy nhiên, nó xác định hằng số macro</h3> <p><a href="../keyword/typeid" title="cpp/keyword/typeid"><code>typeid</code></a></p>
<h3 id="Notes">Ghi chú</h3> <p>Khi được áp dụng cho một biểu thức của loại đa hình, việc đánh giá biểu thức kiểu chữ có thể liên quan đến chi phí thời gian chạy (Tra cứu bảng ảo), nếu không biểu thức kiểu chữ được giải quyết tại thời điểm biên dịch.</p>
<p>Nó không xác định liệu bộ hủy diệt cho đối tượng được đề cập bởi<code>typeid</code>được thực hiện ở cuối chương trình.</p>
<p>Không có gì đảm bảo rằng giống nhau<code><a href="../types/type_info" title="cpp/types/type info">std::type_info</a></code>ví dụ sẽ được đề cập bởi tất cả các đánh giá về biểu thức kiểu chữ trên cùng một loại, mặc dù chúng sẽ so sánh bằng nhau,<code><a href="../types/type_info/hash_code" title="cpp/types/type info/hash code">std::type_info::hash_code</a></code>của những người đó<code>type_info</code>các đối tượng sẽ giống hệt nhau, cũng như<code><a href="../types/type_index" title="cpp/types/type index">std::type_index</a></code>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">const std :: type_info &amp; ti1 = typeid (a);</pre></div> <h3 id="Example">Ví dụ</h3> <div class="t-example">
<p>const std :: type_info &amp; ti2 = typeid (a);<code>type_info::name</code> </p>
<div class="cpp source-cpp"><pre data-language="cpp">khẳng định (&amp; ti1 == &amp; ti2); // không được đảm bảo</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">khẳng định (ti1 == ti2); // Đảm bảo</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/492.html" rel="nofollow">CWG 492</a> </td> <td>C ++ 98</td> <td>Chuyển đổi danh tính:<code>typeid</code>assert (ti1.hash_code () == ti2.hash_code ()); // Đảm bảo<br/>Assert (std :: type_index (ti1) == std :: type_index (ti2)); // Đảm bảo</td> <td>Ví dụ hiển thị đầu ra bằng cách sử dụng một trong các triển khai trong đó</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1416.html" rel="nofollow">CWG 1416</a> </td> <td>C ++ 98</td> <td>trả về tên loại đầy đủ; Lọc qua C ++ Filt -t nếu sử dụng GCC hoặc tương tự.</td> <td>    }</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../types/type_info" title="cpp/types/type info"> <span class="t-lines"><span>type_info</span></span></a></div> </td> <td>Chứa một số thông tin của loại, được tạo ra bởi việc thực hiện.<br/>Đây là lớp được trả lại bởi<strong class="selflink"><code>typeid</code></strong>nhà điều hành.<br/> <span class="t-mark">Các loại chính sách thực thi</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/typeid">https://en.cppreference.com/w/cpp/language/typeid</a>
</p>
</div>
