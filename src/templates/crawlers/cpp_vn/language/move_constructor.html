 <h1 class="firstHeading" id="firstHeading">Di chuyển các nhà xây dựng</h1> <p>Một hàm tạo di chuyển là một<a href="constructor" title="cpp/language/constructor">constructor</a>có thể được gọi với một đối số của cùng loại lớp và sao chép nội dung của đối số, có thể biến đổi đối số.</p>
<h3 id="Syntax">Cú pháp</h3> <table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <span class="t-spar">tên lớp</span>﻿<code>(</code><span class="t-spar">danh sách tham số</span>﻿<code>);</code> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">tên lớp</span>﻿<code>(</code><span class="t-spar">danh sách tham số</span>﻿<code>)</code> <span class="t-spar">cơ thể chức năng</span> </td> <td>(2)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">tên lớp</span>﻿<code>(</code><span class="t-spar">Danh sách đơn tham số</span>﻿<code>) = default;</code> </td> <td>(3)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">tên lớp</span>﻿<code>(</code><span class="t-spar">danh sách tham số</span>﻿<code>) = delete;</code> </td> <td>(4)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">tên lớp</span>﻿<code>::</code><span class="t-spar">tên lớp</span>﻿<code>(</code><span class="t-spar">danh sách tham số</span>﻿<code>)</code> <span class="t-spar">cơ thể chức năng</span> </td> <td>             Không có p);</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">tên lớp</span>﻿<code>::</code><span class="t-spar">tên lớp</span>﻿<code>(</code><span class="t-spar">Danh sách đơn tham số</span>﻿<code>) = default;</code> </td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">tên lớp</span> </td> <td>-</td> <td>lớp có hàm tạo di chuyển đang được khai báo</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">danh sách tham số</span> </td> <td>-</td> <td>không trống<a href="function#Parameter_list" title="cpp/language/function">parameter list</a>thỏa mãn tất cả các điều kiện sau:<ul>
<li>đưa ra loại lớp là<code>T</code>, tham số đầu tiên là loại T<span class="sy3">. Trong các cuộc gọi có hiệu lực</span>Thì<span class="kw4">hằng số</span>T<span class="sy3">. Trong các cuộc gọi có hiệu lực</span>Thì<span class="kw4">bay hơi</span>T<span class="sy3">. Trong các cuộc gọi có hiệu lực</span>hoặc<span class="kw4">hằng số</span> <span class="kw4">bay hơi</span>T<span class="sy3">. Trong các cuộc gọi có hiệu lực</span>, Và</li>
<li>hoặc không có tham số khác hoặc tất cả các tham số khác có<a href="default_arguments" title="cpp/language/default arguments">default arguments</a> </li>
</ul> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">Danh sách đơn tham số</span> </td> <td>-</td> <td>Một<a href="function#Parameter_list" title="cpp/language/function">parameter list</a>chỉ trong một tham số, loại T<span class="sy3">. Trong các cuộc gọi có hiệu lực</span>Thì<span class="kw4">hằng số</span>T<span class="sy3">. Trong các cuộc gọi có hiệu lực</span>Thì<span class="kw4">bay hơi</span>T<span class="sy3">. Trong các cuộc gọi có hiệu lực</span>hoặc<span class="kw4">hằng số</span> <span class="kw4">bay hơi</span>T<span class="sy3">. Trong các cuộc gọi có hiệu lực</span>và không có đối số mặc định</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">cơ thể chức năng</span> </td> <td>-</td> <td>các<a href="constructor" title="cpp/language/constructor">function body</a>của hàm tạo di chuyển</td>
</tr>
</table> <h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3> <div class="t-li1">
<span class="t-li">1)</span>Tuyên bố của một hàm tạo di chuyển bên trong định nghĩa lớp.</div> <div class="t-li1">
<span class="t-li">    const std :: chrono :: giây* offset;     // Chỉ giải thích</span>Định nghĩa của một hàm tạo di chuyển bên trong định nghĩa lớp.</div> <div class="t-li2">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Trình xây dựng di chuyển được mặc định rõ ràng.</div> <div class="t-li2">
<span class="t-li">là trong</span>Trình xây dựng di chuyển bị xóa.</div> <div class="t-li1">
<span class="t-li">    trả về std :: find_if_not (đầu tiên, cuối cùng, p) == cuối cùng;</span>Định nghĩa của một hàm tạo di chuyển bên ngoài định nghĩa lớp (lớp phải chứa một khai báo<span class="t-v">(1)</span>).</div> <div class="t-li2">
<span class="t-li">từ_sys</span>Trình xây dựng di chuyển được mặc định rõ ràng.</div> <div class="cpp source-cpp"><pre data-language="cpp">Cấu trúc x</pre></div> <p>{<a href="initialization" title="cpp/language/initialization">initialized</a>    X (x &amp; khác); // Sao chép hàm tạo<a href="direct_initialization" title="cpp/language/direct initialization">direct-initialization</a>hoặc<a href="copy_initialization" title="cpp/language/copy initialization">copy-initialization</a>    X (x &amp;&amp; khác); // Di chuyển hàm tạo<span class="t-rev-inl t-until-cxx17"><span><a href="value_category#rvalue" title="cpp/language/value category">rvalue</a>// x (x Khác);   // Lỗi: Loại tham số không chính xác</span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span><span class="t-rev-inl t-since-cxx17"><span>XVALUE</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>};</p>
<ul>
<li>Liên minh y<code>T a = std::move(b);</code>hoặc<code>T a(std::move(b));</code>là<code>b</code>{<code>T</code>Số lượng các yếu tố để sao chép</li>
<li>{<code>f(std::move(a));</code>là<code>a</code>{<code>T</code>Và<code>f</code>khoảng cách<code>void f(T t)</code>Số lượng các yếu tố để sao chép</li>
<li>    Y (y &amp; other, int num = 1); // Sao chép hàm tạo với nhiều tham số<code>return a;</code>// y (y &amp; other, int num);     // Lỗi: `num` không có đối số mặc định<code>T f()</code>là<code>a</code>{<code>T</code> </li>
</ul> <p>Liên minh y<span class="t-rev-inl t-until-cxx17"><span>{</span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span><span class="t-rev-inl t-since-cxx17"><span>    Y (y &amp;&amp; khác, int num = 1); // Di chuyển hàm tạo với nhiều tham số</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>, nhìn thấy<a href="copy_elision" title="cpp/language/copy elision">copy elision</a>.</p>
<p>// y (y &amp;&amp; khác, int num);     // Lỗi: `num` không có đối số mặc định<code><a href="../string/basic_string" title="cpp/string/basic string">std::string</a></code>};<code><a href="../container/vector" title="cpp/container/vector">std::vector</a></code>};<code><a href="../memory/unique_ptr" title="cpp/memory/unique ptr">std::unique_ptr</a></code>Hàm tạo di chuyển thường được gọi khi một đối tượng là</p>
<h3 id="Implicitly-declared_move_constructor">) từ</h3> <p>(xValue hoặc prvalue)</p>
<ul>
<li>    // và không viloate các hạn chế được liệt kê ở trên<a href="copy_constructor" title="cpp/language/copy constructor">copy constructors</a>Số lượng các yếu tố để sao chép</li>
<li>    // và không viloate các hạn chế được liệt kê ở trên<a href="copy_assignment" title="cpp/language/copy assignment">copy assignment operators</a>Số lượng các yếu tố để sao chép</li>
<li>    // và không viloate các hạn chế được liệt kê ở trên<a href="move_assignment" title="cpp/language/move assignment">move assignment operators</a>Số lượng các yếu tố để sao chép</li>
<li>    Toán tử tự động = (y &amp;&amp; khác) -&gt; y &amp;;       // OK: Loại trả về theo dõi<a href="destructor" title="cpp/language/destructor">destructor</a>.</li>
</ul> <p>cùng loại, bao gồm cả<a href="explicit" title="cpp/language/explicit">explicit</a> <span class="kw1">};</span> <span class="kw1"> </span>// y &amp; toán tử = (y &amp;&amp;, int num = 1);        // Lỗi: có các tham số không đối tượng khác<code>T::T(T&amp;&amp;)</code>.</p>
<p>trong đó có một hàm tạo di chuyển.<code>T::T(const T&amp;&amp;)</code>Và<code>T::T(T&amp;&amp;)</code>Khi bộ khởi tạo là một prvalue, cuộc gọi của hàm tạo di chuyển là<span class="kw1">#include &lt;Istream&gt;</span>.</p>
<p>thường được tối ưu hóa ra<span class="t-rev-inl t-until-cxx17"><span><a href="except_spec" title="cpp/language/except spec">dynamic exception specification</a></span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span><span class="t-rev-inl t-since-cxx17"><span><a href="noexcept_spec" title="cpp/language/noexcept spec">noexcept specification</a></span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>.</p>
<h3 id="Implicitly-defined_move_constructor">Không bao giờ được thực hiện</h3> <p>Di chuyển các hàm tạo thường "đánh cắp" các tài nguyên do đối số nắm giữ (ví dụ: con trỏ đến các đối tượng được phân bổ động, mô tả tệp, ổ cắm TCP, luồng I/O, chạy các luồng, v.v.) thay vì tạo các bản sao của chúng và để lại đối số trong một số trạng thái hợp lệ nhưng khác. Ví dụ, di chuyển từ một<a href="definition#ODR-use" title="cpp/language/definition">odr-used</a>hoặc<a href="constant_expression#Functions_and_variables_needed_for_constant_evaluation" title="cpp/language/constant expression">needed for constant evaluation</a>có thể dẫn đến cuộc tranh luận bị bỏ trống. Tuy nhiên, hành vi này không nên dựa vào. Đối với một số loại, chẳng hạn như<code><a href="../string/byte/memmove" title="cpp/string/byte/memmove">std::memmove</a></code>, trạng thái di chuyển-từ được chỉ định đầy đủ.<a href="value_category#xvalue" title="cpp/language/value category">xvalue</a>lý lẽ.</p>
<p>thuộc loại lớp hoặc mảng loại lớp có hàm tạo bản sao có tham số thuộc loại<span class="t-rev-inl t-until-cxx23"><span><a href="constexpr#constexpr_constructor" title="cpp/language/constexpr">constexpr constructor</a></span><span><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></span></span><span class="t-rev-inl t-since-cxx23"><span><a href="constexpr#constructor_function" title="cpp/language/constexpr">constructor function</a></span><span><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></span></span>Trình xây dựng di chuyển được tuyên bố ngầm<span class="kw4">constexpr</span>.</p>
<h3 id="Deleted_move_constructor">Nếu không có bộ xây dựng di chuyển do người dùng xác định nào được cung cấp cho loại lớp và tất cả các điều sau đây là đúng:</h3> <p>Sau đó trình biên dịch sẽ khai báo một hàm tạo di chuyển dưới dạng không<code>T</code>(c)<code>T</code>Toán tử gán bản sao được xác định ngầm cho một lớp<a href="object#Potentially_constructed_subobject" title="cpp/language/object">potentially constructed subobject</a>Toán tử gán được chọn để sao chép từng tiểu đơn lớp cơ sở trực tiếp là hàm constexpr và<code>M</code>. Đối với các loại liên minh, hàm tạo bản sao được xác định ngầm sẽ sao chép biểu diễn đối tượng (như bởi</p>
<ul>
<li> <code>M</code>Một lớp có thể có nhiều hàm tạo di chuyển, ví dụ: cả hai</li>
<li>Việc tạo ra hàm tạo bản sao được xác định ngầm được xác định<code>M</code>. Nếu có một số hàm tạo di chuyển do người dùng xác định</li>
<ul>
<li>Toán tử gán bản sao được xác định ngầm cho một lớp</li>
<li>Việc tạo ra toán tử gán bản sao được xác định ngầm được xác định<a href="union#Union-like_classes" title="cpp/language/union">variant member</a>có một hàm tạo phân hủy người dùng hoặc trình xây dựng bản sao phát hành của người dùng.</li>
</ul>
</ul> <p>Trình xây dựng di chuyển di chuyển được khai báo ngầm (hoặc mặc định trên khai báo đầu tiên) có một đặc tả ngoại lệ như được mô tả trong<a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a>Trẻ xây dựng di chuyển được xác định ngầm</p>
<h3 id="Trivial_move_constructor">Nếu hàm tạo di chuyển được tuyên bố ngầm không bị xóa cũng không tầm thường, thì nó được xác định (nghĩa là cơ thể chức năng được tạo và biên dịch) bởi trình biên dịch nếu</h3> <p>. Đối với các loại liên minh, hàm tạo di chuyển được xác định ngầm sẽ sao chép biểu diễn đối tượng (như bởi<code>T</code>Sao chép toán tử gán cho lớp</p>
<ul>
<li>được định nghĩa là xóa</li>
<li> <code>T</code>Nếu bất kỳ điều kiện nào sau đây được thỏa mãn:</li>
<li> <code>T</code>có một thành viên dữ liệu không tĩnh thuộc loại không có đủ điều kiện const (hoặc có thể là mảng đa chiều của chúng).</li>
<li>). Đối với các loại lớp không liên kết, hàm tạo di chuyển thực hiện di chuyển toàn bộ thành viên của các cơ sở của đối tượng và các thành viên không tĩnh, theo thứ tự khởi tạo của họ, sử dụng khởi tạo trực tiếp với<code>T</code>có a</li>
<li>, hàm tạo di chuyển được tạo là<code>T</code>(hoặc có thể là mảng đa chiều của chúng) sao cho độ phân giải quá tải được áp dụng để tìm</li>
</ul> <p>Đã xóa Trình xây dựng di chuyển<code><a href="../string/byte/memmove" title="cpp/string/byte/memmove">std::memmove</a></code>Trình xây dựng di chuyển bị xử lý rõ ràng hoặc được khai báo rõ ràng cho lớp</p>
<h3 id="Eligible_move_constructor">có chất phá hủy bị xóa hoặc không thể truy cập khỏi hàm tạo sao chép hoặc</h3> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p>Trình xây dựng di chuyển</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p>Một hàm tạo di chuyển đã bị xóa bị bỏ qua bởi</p>
<ul>
<li>Toán tử gán bản sao cho lớp</li>
<li>Để cho một số đối tượng máy phát<a href="constraints" title="cpp/language/constraints">associated constraints</a>là tầm thường nếu tất cả những điều sau đây là đúng:</li>
<li>(Nếu không, nó sẽ ngăn chặn sự khởi tạo sao chép từ rvalue).<a href="constraints#Partial_ordering_of_constraints" title="cpp/language/constraints">more constrained</a>không có chức năng thành viên ảo;</li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <p>Nhà xây dựng di chuyển tầm thường<a href="lifetime#Implicit-lifetime_types" title="cpp/language/lifetime">implicit-lifetime type</a>Trình xây dựng bản sao được chọn cho mọi loại thành viên loại (hoặc mảng thuộc loại lớp) của<a href="../named_req/triviallycopyable" title="cpp/named req/TriviallyCopyable">trivially copyable type</a>.</p>
<h3 id="Notes">Ghi chú</h3> <p>Trình xây dựng di chuyển cho lớp<a href="exceptions#Exception_safety" title="cpp/language/exceptions">strong exception guarantee</a>hàm tạo di chuyển được chọn cho mọi cơ sở trực tiếp của<code><a href="../container/vector" title="cpp/container/vector">std::vector</a></code>Trình xây dựng di chuyển được chọn cho mọi loại thành viên loại (hoặc mảng thuộc loại lớp) của<code><a href="../utility/move_if_noexcept" title="cpp/utility/move if noexcept">std::move_if_noexcept</a></code>Một hàm tạo di chuyển tầm thường là một hàm tạo thực hiện hành động tương tự như hàm tạo bản sao tầm thường, nghĩa là tạo ra một bản sao của biểu diễn đối tượng như thể</p>
<p>. Tất cả các loại dữ liệu tương thích với ngôn ngữ C (loại POD) đều có thể di chuyển tầm thường.<a href="value_category" title="cpp/language/value category">rvalue</a>Trình xây dựng di chuyển đủ điều kiện<a href="value_category" title="cpp/language/value category">xvalue</a>là tầm thường.<code>std::move</code><span class="t-rev-inl t-until-cxx17"><span>hoặc a<a href="value_category" title="cpp/language/value category">prvalue</a>Một hàm tạo di chuyển đủ điều kiện nếu nó không bị xóa.</span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span>Một hàm tạo di chuyển đủ điều kiện nếu<a href="value_category" title="cpp/language/value category">lvalue</a>Không có hàm tạo di chuyển nào với cùng loại tham số đầu tiên là</p>
<p>Tầm thường của các nhà xây dựng di chuyển đủ điều kiện xác định xem lớp có phải là một<i>dựa vào</i>Có thể, các nhà xây dựng di chuyển do người dùng xác định không nên ném ngoại lệ. Ví dụ,<i>dựa vào</i>Để lựa chọn giữa di chuyển và sao chép khi các yếu tố cần được di dời.<span class="kw4">hằng số</span>T<span class="sy3">. Trong các cuộc gọi có hiệu lực</span>).</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Nếu cả hai hàm tạo sao chép và di chuyển được cung cấp và không có hàm tạo nào khác là khả thi, độ phân giải quá tải sẽ chọn hàm tạo di chuyển nếu đối số là một</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">cùng loại (một</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1353.html" rel="nofollow">CWG 1353</a> </td> <td>C ++ 11</td> <td>chẳng hạn như tạm thời không tên<br/> </td> <td>Không có toán tử gán bản sao với cùng loại tham số đầu tiên và cùng một cv/ref-aperifers (nếu có)</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1402.html" rel="nofollow">CWG 1402</a> </td> <td>C ++ 11</td> <td>) và chọn hàm tạo bản sao nếu đối số là<br/>(đối tượng được đặt tên hoặc một hàm/toán tử trả về tham chiếu Lvalue). Nếu chỉ có hàm tạo bản sao được cung cấp, tất cả các loại đối số chọn nó (miễn là nó có một tham chiếu đến const, vì các rvalues ​​có thể liên kết với các tham chiếu của const), điều này khiến việc sao chép dự phòng để di chuyển, khi di chuyển không có sẵn.<br/>Một hàm tạo được gọi là một<br/>Di chuyển hàm tạo</td> <td>Khi nó lấy một tham chiếu rvalue làm tham số. Nó không bắt buộc phải di chuyển bất cứ điều gì, lớp không bắt buộc phải có một tài nguyên phải được di chuyển và<br/>Di chuyển hàm tạo<br/>    C C1, C2;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1491.html" rel="nofollow">CWG 1491</a> </td> <td>C ++ 11</td> <td>Có thể không thể di chuyển một tài nguyên như trong trường hợp cho phép (nhưng có thể không hợp lý) trong đó tham số là tham chiếu RVALUE const (<br/>#include &lt;iomanip&gt;</td> <td>#include &lt;Istream&gt;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2094.html" rel="nofollow">CWG 2094</a> </td> <td>C ++ 11</td> <td>#include &lt;chuỗi&gt;<br/>#include &lt;Tiện ích&gt;<a class="external text" href="https://cplusplus.github.io/CWG/issues/496.html" rel="nofollow">CWG 496</a>)</td> <td>Nếu cả hai toán tử gán bản sao và di chuyển được cung cấp, độ phân giải quá tải sẽ chọn gán di chuyển nếu đối số là một</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <ul>
<li> <a href="converting_constructor" title="cpp/language/converting constructor">converting constructor</a> </li>
<li> <a href="copy_assignment" title="cpp/language/copy assignment">copy assignment</a> </li>
<li> <a href="copy_constructor" title="cpp/language/copy constructor">copy constructor</a> </li>
<li> <a href="copy_elision" title="cpp/language/copy elision">copy elision</a> </li>
<li> <a href="default_constructor" title="cpp/language/default constructor">default constructor</a> </li>
<li> <a href="destructor" title="cpp/language/destructor">destructor</a> </li>
<li> <a href="explicit" title="cpp/language/explicit"><code>explicit</code></a> </li>
<li> <a href="initialization" title="cpp/language/initialization">initialization</a> <ul>
<li> <a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate initialization</a> </li>
<li> <a href="constant_initialization" title="cpp/language/constant initialization">constant initialization</a> </li>
<li> <a href="copy_initialization" title="cpp/language/copy initialization">copy initialization</a> </li>
<li> <a href="default_initialization" title="cpp/language/default initialization">default initialization</a> </li>
<li> <a href="direct_initialization" title="cpp/language/direct initialization">direct initialization</a> </li>
<li> <a class="mw-redirect" href="initializer_list" title="cpp/language/initializer list">initializer list</a> </li>
<li> <a href="list_initialization" title="cpp/language/list initialization">list initialization</a> </li>
<li> <a href="reference_initialization" title="cpp/language/reference initialization">reference initialization</a> </li>
<li> <a href="value_initialization" title="cpp/language/value initialization">value initialization</a> </li>
<li> <a href="zero_initialization" title="cpp/language/zero initialization">zero initialization</a> </li>
</ul> </li>
<li> <a href="move_assignment" title="cpp/language/move assignment">move assignment</a> </li>
<li> <a href="new" title="cpp/language/new"><code>new</code></a> </li>
</ul> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/move_constructor">https://en.cppreference.com/w/cpp/language/move_constructor</a>
</p>
</div>
