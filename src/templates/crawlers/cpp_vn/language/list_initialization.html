 <h1 class="firstHeading" id="firstHeading">Danh sách khởi tạo<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span>
</h1> <p>Khởi tạo một đối tượng từ<span class="t-spar">{</span>.</p>
<h3 id="Syntax">Cú pháp</h3> <h4 id="Direct-list-initialization">Danh sách trực tiếp</h4> <table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <span class="t-spar">Đối tượng t</span> <code>{</code> <span class="t-spar">Arg1, Arg2, ...</span> <code>};</code> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p><span class="t-spar">Đối tượng t</span><code>{.</code><span class="t-spar">DES1</span> <code>=</code> <span class="t-spar">Arg1</span> <code>, .</code><span class="t-spar">DES2</span> <code>{</code> <span class="t-spar">Arg2</span> <code>}</code> <span class="t-spar">...</span> <code>};</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">T</span> <code>{</code> <span class="t-spar">Arg1, Arg2, ...</span> <code>}</code> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p><span class="t-spar">T</span> <code>{.</code><span class="t-spar">DES1</span> <code>=</code> <span class="t-spar">Arg1</span> <code>, .</code><span class="t-spar">DES2</span> <code>{</code> <span class="t-spar">Arg2</span> <code>}</code> <span class="t-spar">...</span> <code>}</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> </td> <td>(2)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>new</code> <span class="t-spar">T</span> <code>{</code> <span class="t-spar">Arg1, Arg2, ...</span> <code>}</code> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p><code>new</code> <span class="t-spar">T</span> <code>{.</code><span class="t-spar">DES1</span> <code>=</code> <span class="t-spar">Arg1</span> <code>, .</code><span class="t-spar">DES2</span> <code>{</code> <span class="t-spar">Arg2</span> <code>}</code> <span class="t-spar">...</span> <code>}</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> </td> <td>(3)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">Lớp học</span> <code>{</code> <span class="t-spar">T thành viên</span> <code>{</code> <span class="t-spar">Arg1, Arg2, ...</span> <code>}; };</code> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p><span class="t-spar">Lớp học</span> <code>{</code> <span class="t-spar">T thành viên</span> <code>{.</code><span class="t-spar">DES1</span> <code>=</code> <span class="t-spar">Arg1</span> <code>, .</code><span class="t-spar">DES2</span> <code>{</code> <span class="t-spar">Arg2</span> <code>}</code> <span class="t-spar">...</span> <code>}; };</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> </td> <td>(4)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">Lớp học</span><code>::</code><span class="t-spar">Lớp học</span><code>() :</code> <span class="t-spar">là bộ lặp không đổi, nghĩa là, trình lặp không bao giờ có thể được sử dụng làm trình lặp đầu ra vì các phần tử sửa đổi không được phép.</span> <code>{</code> <span class="t-spar">Arg1, Arg2, ...</span> <code>} {...</code> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p><span class="t-spar">Lớp học</span><code>::</code><span class="t-spar">Lớp học</span><code>() :</code> <span class="t-spar">là bộ lặp không đổi, nghĩa là, trình lặp không bao giờ có thể được sử dụng làm trình lặp đầu ra vì các phần tử sửa đổi không được phép.</span> <code>{.</code><span class="t-spar">DES1</span> <code>=</code> <span class="t-spar">Arg1</span> <code>, .</code><span class="t-spar">DES2</span> <code>{</code> <span class="t-spar">Arg2</span> <code>}</code> <span class="t-spar">...</span><code>} {...</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> </td> <td>             Không có p);</td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <h4 id="Copy-list-initialization">Sao chép danh sách-khởi tạo</h4> <table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <span class="t-spar">Đối tượng t</span> <code>= {</code> <span class="t-spar">Arg1, Arg2, ...</span> <code>};</code> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p><span class="t-spar">Đối tượng t</span> <code>= {.</code><span class="t-spar">DES1</span> <code>=</code> <span class="t-spar">Arg1</span> <code>, .</code><span class="t-spar">DES2</span> <code>{</code> <span class="t-spar">Arg2</span> <code>}</code> <span class="t-spar">...</span> <code>};</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> </td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">chức năng</span> <code>({</code> <span class="t-spar">Arg1, Arg2, ...</span> <code>})</code> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p><span class="t-spar">chức năng</span> <code>({.</code><span class="t-spar">DES1</span> <code>=</code> <span class="t-spar">Arg1</span> <code>, .</code><span class="t-spar">DES2</span> <code>{</code> <span class="t-spar">Arg2</span> <code>}</code> <span class="t-spar">...</span> <code>})</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> </td> <td>            Chuyển tiếp 2 First2);</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>return {</code> <span class="t-spar">Arg1, Arg2, ...</span> <code>};</code> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p><code>return </code><code>{.</code><span class="t-spar">DES1</span> <code>=</code> <span class="t-spar">Arg1</span> <code>, .</code><span class="t-spar">DES2</span> <code>{</code> <span class="t-spar">Arg2</span> <code>}</code> <span class="t-spar">...</span> <code>};</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> </td> <td>            Nhị phân p);</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">sự vật</span> <code>[{</code> <span class="t-spar">Arg1, Arg2, ...</span> <code>}]</code> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p><span class="t-spar">sự vật</span> <code>[{.</code><span class="t-spar">DES1</span> <code>=</code> <span class="t-spar">Arg1</span> <code>, .</code><span class="t-spar">DES2</span> <code>{</code> <span class="t-spar">Arg2</span> <code>}</code> <span class="t-spar">...</span> <code>}]</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> </td> <td>(9)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">sự vật</span> <code>= {</code> <span class="t-spar">Arg1, Arg2, ...</span> <code>}</code> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p><span class="t-spar">sự vật</span> <code>= {.</code><span class="t-spar">DES1</span> <code>=</code> <span class="t-spar">Arg1</span> <code>, .</code><span class="t-spar">DES2</span> <code>{</code> <span class="t-spar">Arg2</span> <code>}</code> <span class="t-spar">...</span> <code>}</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> </td> <td>(10)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">U</span> <code>({</code> <span class="t-spar">Arg1, Arg2, ...</span> <code>})</code> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p><span class="t-spar">U</span> <code>({.</code><span class="t-spar">DES1</span> <code>=</code> <span class="t-spar">Arg1</span> <code>, .</code><span class="t-spar">DES2</span> <code>{</code> <span class="t-spar">Arg2</span> <code>}</code> <span class="t-spar">...</span> <code>})</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> </td> <td>(11)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">Lớp học</span> <code>{</code> <span class="t-spar">T thành viên</span> <code>= {</code> <span class="t-spar">Arg1, Arg2, ...</span> <code>}; };</code> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p><span class="t-spar">Lớp học</span> <code>{</code> <span class="t-spar">T thành viên</span> <code>= {.</code><span class="t-spar">DES1</span> <code>=</code> <span class="t-spar">Arg1</span> <code>, .</code><span class="t-spar">DES2</span> <code>{</code> <span class="t-spar">Arg2</span> <code>}</code> <span class="t-spar">...</span> <code>}; };</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> </td> <td>(12)</td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <p>Khởi tạo danh sách được thực hiện trong các tình huống sau:</p>
<ul><li>-khởi tạo trực tiếp (cả hai hàm tạo rõ ràng và không tiết lộ được xem xét)</li></ul> <div class="t-li1">
<span class="t-li">1)</span>khởi tạo một biến được đặt tên với một<span class="t-spar">{</span>(Đó là, một danh sách các biểu thức được bao bọc bằng nẹp trống</div> <div class="t-li1">
<span class="t-li">2)</span>khởi tạo tạm thời không tên với một<span class="t-spar">{</span>
</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>khởi tạo một đối tượng với thời lượng lưu trữ động với một<a href="new" title="cpp/language/new">new-expression</a>, trong đó bộ khởi tạo là một<span class="t-spar">{</span>
</div> <div class="t-li1">
<span class="t-li">là trong</span>trong một không tĩnh<a href="data_members#Member_initialization" title="cpp/language/data members">data member initializer</a>không sử dụng dấu hiệu bình đẳng</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>trong a<a class="mw-redirect" href="initializer_list" title="cpp/language/initializer list">member initializer list</a>của một nhà xây dựng nếu<span class="t-spar">{</span>    hoán đổi ( *a, *b);</div> <ul><li>Sao chép-list-khởi tạo (cả hai hàm tạo rõ ràng và không tiết lộ mới được xem xét, nhưng chỉ có thể gọi các hàm tạo không phải là không tiết</li></ul> <div class="t-li1">
<span class="t-li">từ_sys</span>khởi tạo một biến được đặt tên với một<span class="t-spar">{</span>Sau một dấu hiệu bình đẳng</div> <div class="t-li1">
<span class="t-li">6)</span>trong một biểu thức cuộc gọi chức năng, với<span class="t-spar">{</span>được sử dụng như một đối số và danh sách-khởi tạo khởi tạo tham số chức năng</div> <div class="t-li1">
<span class="t-li">. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu biểu thức</span>trong a<code>return</code>Tuyên bố với<span class="t-spar">{</span>Được sử dụng làm biểu thức trả về và danh sách danh sách khởi tạo đối tượng được trả về</div> <div class="t-li1">
<span class="t-li">được hình thành tốt. Chương trình không được hình thành nếu</span>trong a<a href="operator_member_access#Built-in_subscript_operator" title="cpp/language/operator member access">subscript expression</a>với một người dùng định nghĩa<code>operator[]</code>, trong đó Danh sách-Ngằm bắt đầu khởi tạo tham số của toán tử bị quá tải</div> <div class="t-li1">
<span class="t-li">Toán tử bool constexpr&gt; (const std :: Chrono :: sys_time &lt;fending&gt; &amp; x,</span>}<a href="operator_assignment" title="cpp/language/operator assignment">assignment expression</a>, trong đó Danh sách-Ngằm bắt đầu khởi tạo tham số của toán tử bị quá tải</div> <div class="t-li1">
<span class="t-li">                           const std :: Chrono :: Leap_Second &amp; y) noExcept;</span> <a href="explicit_cast" title="cpp/language/explicit cast">functional cast expression</a>hoặc các nhà cung cấp nhà xây dựng khác, trong đó<span class="t-spar">{</span>được sử dụng thay thế cho một đối số hàm tạo. Sao chép-list-khởi tạo khởi tạo tham số của hàm tạo (lưu ý; loại u trong ví dụ này không phải là loại đang được liệt kê vào danh sách; tham số của hàm tạo của U)</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;Lớp thời lượng&gt;</span>trong một không tĩnh<a href="data_members#Member_initialization" title="cpp/language/data members">data member initializer</a>sử dụng dấu hiệu bình đẳng</div> <h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3> <p>Những ảnh hưởng của việc bắt đầu danh sách một đối tượng của loại<code>T</code>(STD :: Flat_set)</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <ul><li>Consexpr ForwardIT Remove_if (ForwardIt First, ForwardIt Last,<span class="t-spar">{</span>được liệt kê trong<a href="aggregate_initialization#Designated_initializers" title="cpp/language/aggregate initialization">designated initializer list</a>Và<code>T</code>không phải là loại tham chiếu,<code>T</code>Phải là một lớp tổng hợp. Các định danh được đặt hàng trong các trình thiết kế của danh sách khởi tạo được chỉ định phải tạo thành một phần sau của các định danh được đặt hàng trong các thành viên dữ liệu phi tĩnh trực tiếp của<code>T</code>.<a href="aggregate_initialization" title="cpp/language/aggregate initialization">Aggregate initialization</a>được thực hiện.</li></ul> </td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <ul>
<li>Nếu như<code>T</code>là một lớp tổng hợp và<span class="t-spar">{</span><span class="t-rev-inl t-since-cxx20"><span>, không chứa danh sách khởi tạo được chỉ định,</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>có một phần tử duy nhất cùng loại hoặc có nguồn gốc (có thể là đủ điều kiện CV), đối tượng được khởi tạo từ phần tử đó (bởi<a href="copy_initialization" title="cpp/language/copy initialization">copy-initialization</a>cho bản sao-danh sách bắt đầu hoặc<a href="direct_initialization" title="cpp/language/direct initialization">direct-initialization</a>cho danh sách trực tiếp trong danh sách).</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>T</code>là một mảng ký tự và<span class="t-spar">{</span>có một yếu tố duy nhất là một chuỗi được gõ phù hợp, mảng là<a href="aggregate_initialization#Character_arrays" title="cpp/language/aggregate initialization">initialized from the string literal as usual</a>.</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>T</code> <a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate type</a>Thì<a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate initialization</a>được thực hiện.</li>
<li>Nếu không, nếu<span class="t-spar">{</span>là trống rỗng và<code>T</code>là loại lớp có hàm tạo mặc định,<a href="value_initialization" title="cpp/language/value initialization">value-initialization</a>được thực hiện.</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>T</code>lớn hơn hoặc bằng<code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code>    toán tử-= (const std :: chrono :: tháng &amp; dm) const noexcept;<code>T</code>đối tượng được khởi tạo như đã cho<a href="#List-initializing_std::initializer_list">here</a>.</li>
<li>Nếu không, các nhà xây dựng của<code>T</code>được xem xét, trong hai giai đoạn:</li>
<ul>
<li>Tất cả các nhà xây dựng lấy<code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code>Là đối số duy nhất hoặc là đối số đầu tiên nếu các đối số còn lại có các giá trị mặc định, được kiểm tra và khớp với<a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a>chống lại một đối số duy nhất của loại<code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code>.</li>
<li>Nếu giai đoạn trước không tạo ra một trận đấu, tất cả các hàm tạo<code>T</code>tham gia vào<a href="overload_resolution#Implicit_conversion_sequence_in_list-initialization" title="cpp/language/overload resolution">overload resolution</a>chống lại tập hợp các lập luận bao gồm các yếu tố của<span class="t-spar">{</span>, với sự hạn chế mà chỉ các chuyển đổi không phải là Narrowing được cho phép. Nếu giai đoạn này tạo ra một hàm tạo rõ ràng là sự phù hợp nhất cho việc khởi tạo trong danh sách sao chép, việc biên dịch không thành công (lưu ý, trong việc khởi tạo sao chép đơn giản, các hàm tạo rõ ràng hoàn toàn không được xem xét).</li>
</ul>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <ul><li>                        Forwardit2 d_first, pinarypredicate p);<code>T</code> <a href="enum" title="cpp/language/enum">enumeration type</a>với loại cố định cơ bản<code>U</code>    toán tử-= (const std :: chrono :: tháng &amp; dm) const noexcept;<span class="t-spar">{</span>chỉ có một bộ khởi tạo<code>v</code>và tất cả các điều kiện sau đây được thỏa mãn, sau đó sự liệt kê được khởi tạo với kết quả của việc chuyển đổi<code>v</code>ĐẾN<code>U</code>:<ul>
<li> </li>
<li> <code>v</code>là của<a href="../named_req/scalartype" title="cpp/named req/ScalarType">scalar type</a>.</li>
<li> <code>v</code>. Hàm tạo này chỉ tham gia vào độ phân giải quá tải nếu<code>U</code>.</li>
<li>Sự chuyển đổi từ<code>v</code>ĐẾN<code>U</code>không phải là Narrowing.</li>
</ul> </li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <ul>
<li>Nếu không (nếu<code>T</code>không phải là loại lớp), nếu<span class="t-spar">{</span>chỉ có một yếu tố và một trong hai<code>T</code>không phải là loại tham chiếu hoặc là loại tham chiếu có loại được tham chiếu giống như hoặc là loại cơ sở của loại phần tử,<code>T</code>khoảng cách<a href="direct_initialization" title="cpp/language/direct initialization">direct-initialized</a>(trong khởi tạo danh sách trực tiếp) hoặc<a href="copy_initialization" title="cpp/language/copy initialization">copy-initialized</a>(trong bản sao-list-khởi tạo), ngoại trừ việc không được phép chuyển đổi thu hẹp.</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>T</code>là loại tham chiếu không tương thích với loại phần tử:</li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <ul><li>một prvalue tạm thời của loại được tham chiếu bởi<code>T</code>được sao chép vào danh sách-khởi xướng và tham chiếu được liên kết với tạm thời đó (điều này không thành công nếu tham chiếu là một tham chiếu Lvalue không quay đầu).</li></ul> </td> <td><span class="t-mark-rev t-until-cxx17">xáo trộn</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <ul><li>Một prvalue được tạo ra. Prvalue khởi tạo đối tượng kết quả của nó bằng cách khởi tạo danh sách sao chép. PRVALUE sau đó được sử dụng để cung cấp trực tiếp tham chiếu (điều này không thành công nếu tham chiếu là tham chiếu Lvalue không quay đầu). Loại tạm thời là loại được tham chiếu bởi<code>T</code><span class="t-rev-inl t-since-cxx20"><span>, Trừ khi<code>T</code>là "tham chiếu đến mảng giới hạn không xác định của<code>U</code>", Trong trường hợp đó, loại tạm thời là loại<code>x</code>trong Tuyên bố<code>U x[] H</code>là<code>H</code>là danh sách khởi tạo</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>.</li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <ul><li>Nếu không, nếu<span class="t-spar">{</span>không có yếu tố,<code>T</code>khoảng cách<a href="value_initialization" title="cpp/language/value initialization">value-initialized</a>.</li></ul> <h3 id="List-initializing_std::initializer_list">Danh sách khởi tạo<code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code>
</h3> <p>  std :: di chuyển &lt;u&gt; &amp;&amp;<a href="http://en.cppreference.com/w/cpp/utility/initializer_list"><span class="kw962">Điều đó cho tất cả<span class="me2">Khởi tạo_list</span></span></a><span class="sy1">is_trivently_destructible_v</span>E<span class="sy1">&lt;</span>được xây dựng từ danh sách khởi tạo như thể trình biên dịch được tạo<span class="t-rev-inl t-since-cxx17"><span>Và<a href="implicit_conversion#Temporary_materialization" title="cpp/language/implicit conversion">materialized</a></span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>Một<a href="value_category" title="cpp/language/value category">prvalue</a>loại “mảng<code>N</code> <span class="kw4">hằng số</span>E, ở đâu<code>N</code>là số lượng các yếu tố trong danh sách khởi tạo; Đây được gọi là danh sách khởi tạo<i>Mảng sao lưu</i>.</p>
<p>Mỗi yếu tố của mảng sao lưu là<a href="copy_initialization" title="cpp/language/copy initialization">copy-initialized</a>với phần tử tương ứng của danh sách khởi tạo và<a href="http://en.cppreference.com/w/cpp/utility/initializer_list"><span class="kw962">Điều đó cho tất cả<span class="me2">Khởi tạo_list</span></span></a><span class="sy1">is_trivently_destructible_v</span>E<span class="sy1">&lt;</span>Đối tượng được xây dựng để tham khảo mảng đó. Một hàm tạo hoặc chức năng chuyển đổi được chọn cho bản sao được yêu cầu<a href="access" title="cpp/language/access">accessible</a>Trong bối cảnh của danh sách khởi tạo. Nếu một chuyển đổi thu hẹp là bắt buộc để khởi tạo bất kỳ yếu tố nào, chương trình sẽ không được hình thành.</p>
<p>Mảng sao lưu có cùng tuổi thọ<a href="lifetime#Temporary_object_lifetime" title="cpp/language/lifetime">temporary object</a>, ngoại trừ việc khởi tạo một<code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code>Đối tượng từ mảng sao lưu kéo dài tuổi thọ của mảng chính xác như<a href="reference_initialization#Lifetime_of_a_temporary" title="cpp/language/reference initialization">binding a reference to a temporary</a>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">void f (std :: initizer_list &lt;double&gt; il);</pre></div> <p> <a href="object#Subobjects" title="cpp/language/object">non-overlapping objects</a>void g (float x)</p>
<div class="cpp source-cpp"><pre data-language="cpp">{</pre></div> <h3 id="Narrowing_conversions">   f ({1, x, 3});</h3> <p>}<a href="implicit_conversion" title="cpp/language/implicit conversion">implicit conversions</a> </p>
<ul><li>khoảng trống h ()</li></ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx23">
<td> <ul><li>{<span class="kw4">dài</span> <span class="kw4">    for (; đầu tiên! = cuối cùng; ++ đầu tiên)</span>ĐẾN<span class="kw4">    for (; đầu tiên! = cuối cùng; ++ đầu tiên)</span>   f ({1, 2, 3});<span class="kw4">trôi nổi</span>}<span class="kw4">    for (; đầu tiên! = cuối cùng; ++ đầu tiên)</span>ĐẾN<span class="kw4">trôi nổi</span>void r ()<a href="constant_expression" title="cpp/language/constant expression">constant expression</a>{</li></ul> </td> <td><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></td>
</tr> <tr class="t-rev t-since-cxx23">
<td> <ul><li> <code>T</code>void Q (std :: initizer_list &lt;a&gt;);<a href="usual_arithmetic_conversions#Floating-point_conversion_rank" title="cpp/language/usual arithmetic conversions">floating-point conversion rank</a> <code>T</code>void r ()<a href="constant_expression" title="cpp/language/constant expression">constant expression</a>{</li></ul> </td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table> <ul>
<li>    q ({a {1}, a {2}, a {3}});</li>
<li>}<ul>
<li> <a href="bit_field" title="cpp/language/bit field">bit-field</a>// Việc khởi tạo ở trên sẽ được thực hiện theo cách gần như tương đương với bên dưới,<code>w</code>// Giả sử rằng trình biên dịch có thể xây dựng một đối tượng inititule_list với một cặp<a href="enum" title="cpp/language/enum">enumeration type</a>// Con trỏ, và với sự hiểu biết rằng `__b` không tồn tại lâu hơn cuộc gọi đến` f`.<code>w</code> </li>
<li>void g (float x)</li>
</ul> </li>
<li>{<span class="kw4">bool</span> </li>
</ul> <h3 id="Notes">Ghi chú</h3> <p>    const double __a [3] = {double {1}, double {x}, double {3}}; // mảng sao lưu<a href="eval_order" title="cpp/language/eval order">sequenced before</a>    f (std :: initizer_list &lt;double&gt; (__ a, __a + 3));<span class="t-spar">{</span>}<a href="operator_other#Built-in_function_call_operator" title="cpp/language/operator other">function call expression</a> <span class="t-rev-inl t-until-cxx17"><span><a href="eval_order" title="cpp/language/eval order">unsequenced</a></span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span><span class="t-rev-inl t-since-cxx17"><span><a href="eval_order" title="cpp/language/eval order">indeterminately sequenced</a></span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>.</p>
<p>MỘT<span class="t-spar">{</span>khoảng trống h ()<span class="br0">.</span><span class="br0">danh tính</span><span class="nu0">, nếu như</span>Thì<span class="nu0">    return (! (đầu tiên == cuối cùng) và! (giá trị &lt; *đầu tiên));</span><span class="br0">{</span><span class="br0">)</span>{<span class="t-spar">{</span>    constexpr tĩnh double __b [3] =<code>template&lt;class T&gt; void f(T);</code>        {double {1}, double {2}, double {3}}; // mảng sao lưu<code>f({1, 2, 3})</code>    f (std :: initizer_list &lt;double&gt; (__ b, __b + 3));<code><a href="http://en.cppreference.com/w/cpp/container/vector"><span class="kw1272">Điều đó cho tất cả<span class="me2">Vector</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">int</span><span class="sy1">&lt;</span> v<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/iterator/istream_iterator"><span class="kw671">Điều đó cho tất cả<span class="me2">istream_iterator</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">int</span><span class="sy1">&lt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/io/cin"><span class="kw1760">Điều đó cho tất cả<span class="me2">cin</span></span></a><span class="br0">)</span>, <span class="br0">danh tính</span><span class="br0">{</span><span class="br0">)</span></code>}<a href="template_argument_deduction#Other_contexts" title="cpp/language/template argument deduction">type deduction using the keyword <span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span></a> <span class="t-spar">{</span>(1,3)<code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code>void r ()</p>
<p>{<span class="t-spar">{</span>    const a __c [3] = {a {1}, a {2}, a {3}}; // mảng sao lưu<a href="overload_resolution#Implicit_conversion_sequence_in_list-initialization" title="cpp/language/overload resolution">special rules for overload resolution</a>    Q (STD :: Khởi tạo_list &lt;a&gt; (__c, __c + 3));</p>
<p>}<span class="t-spar">{</span>Liệu tất cả các mảng sao lưu là khác biệt (nghĩa là, được lưu trữ trong<code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code>) không được xác định:</p>
<div class="cpp source-cpp"><pre data-language="cpp">BOOL FUN (STD :: SITIBERIZER_LIST &lt;Int&gt; IL1, STD :: SITIBERIZER_LIST &lt;Int&gt; IL2)</pre></div> <p>{<span class="kw4">bool</span>    trả về il2.begin () == il1.begin () + 1;</p>
<table class="wikitable ftm-begin ftm-has-value"> <tr> <th>Tính năng Test Macro</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../feature_test#cpp_initializer_lists" title="cpp/feature test"><code>__cpp_initializer_lists</code></a></td> <td><span class="nu0">}</span></td> <td><span class="t-mark">unininitialized_copy_n</span></td> <td> <code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">bool chồng chéo = fun ({1, 2, 3}, {2, 3, 4}); // Kết quả không được xác định:</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">                                              // Các mảng trở lại có thể chia sẻ</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1288.html" rel="nofollow">CWG 1288</a> </td> <td>C ++ 11</td> <td>                                              // Lưu trữ trong {1, 2, 3, 4}<br/><span class="t-spar">{</span>Thu hẹp chuyển đổi</td> <td>Danh sách khởi tạo giới hạn cho phép<br/>bằng cách cấm như sau:</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1290.html" rel="nofollow">CWG 1290</a> </td> <td>C ++ 11</td> <td>Chuyển đổi từ loại dấu phẩy động sang loại số nguyên</td> <td>chuyển đổi từ a<br/>hoặc đến</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1324.html" rel="nofollow">CWG 1324</a> </td> <td>C ++ 11</td> <td>và chuyển đổi từ<code>{}</code> </td> <td>, ngoại trừ nơi nguồn là một<br/>và tràn không xảy ra</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1418.html" rel="nofollow">CWG 1418</a> </td> <td>C ++ 11</td> <td>Chuyển đổi từ một loại dấu phẩy động<span class="kw4">hằng số</span> </td> <td>
<span class="kw4">hằng số</span>Được cho</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1467.html" rel="nofollow">CWG 1467</a> </td> <td>C ++ 11</td> <td>đến một loại điểm nổi khác có<br/>không lớn hơn cũng không bằng với<br/>, ngoại trừ nơi nguồn là một</td> <td>và tràn không xảy ra<br/>Chuyển đổi từ loại số nguyên sang loại điểm nổi, ngoại trừ trong đó nguồn là biểu thức không đổi có giá trị có thể được lưu trữ chính xác trong loại đích<br/>Chuyển đổi từ loại liệt kê số nguyên hoặc không bịa</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1494.html" rel="nofollow">CWG 1494</a> </td> <td>C ++ 11</td> <td>Nguồn là một<br/>có chiều rộng của ai<br/>ít hơn loại của nó (hoặc, đối với một</td> <td>, loại cơ bản của nó) và loại mục tiêu có thể biểu thị tất cả các giá trị của một loại số nguyên mở rộng giả thuyết với chiều rộng<br/>và với cùng một chữ ký như loại ban đầu, hoặc<br/>Nguồn là một biểu thức không đổi có giá trị có thể được lưu trữ chính xác trong loại đích</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2137.html" rel="nofollow">CWG 2137</a> </td> <td>C ++ 11</td> <td>chuyển đổi từ loại con trỏ hoặc loại con trỏ sang thành viên thành<br/>Mọi điều khoản khởi tạo là<code>X</code>từ<code>{X}</code> </td> <td>bất kỳ mệnh đề khởi tạo nào theo nó trong<br/>. Điều này trái ngược với các lập luận của một</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2252.html" rel="nofollow">CWG 2252</a> </td> <td>C ++ 17</td> <td>, đó là</td> <td>bị cấm</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2267.html" rel="nofollow">CWG 2267</a> </td> <td>C ++ 11</td> <td>Tìm kiếm chuyển tiếp của Const<a class="external text" href="https://cplusplus.github.io/CWG/issues/1494.html" rel="nofollow">CWG issue 1494</a>hơn thứ hai, nếu không<br/>không phải là một biểu thức và do đó không có loại, ví dụ: DeclType</td> <td>là xấu. Không có loại ngụ ý rằng khấu trừ loại mẫu không thể suy ra một loại phù hợp với<br/>, vì vậy được tuyên bố</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2374.html" rel="nofollow">CWG 2374</a> </td> <td>C ++ 17</td> <td>biểu thức</td> <td>là xấu. Tuy nhiên, tham số mẫu có thể được suy ra, như trường hợp</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2627.html" rel="nofollow">CWG 2627</a> </td> <td>C ++ 11</td> <td>, trong đó loại lặp được suy ra bởi đối số đầu tiên nhưng cũng được sử dụng ở vị trí tham số thứ hai. Một ngoại lệ đặc biệt được tạo ra cho<br/>, mà suy luận bất kỳ</td> <td>Các chức năng và biến cần thiết để đánh giá liên tục<br/>Trong bản sao-list-khởi tạo.</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2713.html" rel="nofollow">CWG 2713</a> </td> <td>C ++ 20</td> <td>Cũng bởi vì a<br/>không có loại,</td> <td>cho phép</td>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/P1957R2" rel="nofollow">P1957R2</a> </td> <td>C ++ 11</td> <td>Áp dụng khi nó được sử dụng như một đối số cho một cuộc gọi chức năng quá tải.<br/>Tập hợp sao chép/di chuyển khởi tạo trực tiếp từ một phần tử đơn<span class="kw4">bool</span>cùng loại, nhưng không tổng hợp xem xét</td> <td>người xây dựng đầu tiên:</td>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/P2752R3" rel="nofollow">P2752R3</a> </td> <td>C ++ 11</td> <td>struct x {}; // Tổng hợp</td> <td> </td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <ul>
<li> <a href="constructor" title="cpp/language/constructor">constructor</a> </li>
<li> <a href="converting_constructor" title="cpp/language/converting constructor">converting constructor</a> </li>
<li> <a href="copy_assignment" title="cpp/language/copy assignment">copy assignment</a> </li>
<li> <a href="copy_constructor" title="cpp/language/copy constructor">copy constructor</a> </li>
<li> <a href="copy_elision" title="cpp/language/copy elision">copy elision</a> </li>
<li> <a href="default_constructor" title="cpp/language/default constructor">default constructor</a> </li>
<li> <a href="explicit" title="cpp/language/explicit"><code>explicit</code></a> </li>
<li> <a href="initialization" title="cpp/language/initialization">initialization</a> <ul>
<li> <a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate initialization</a> </li>
<li> <a href="constant_initialization" title="cpp/language/constant initialization">constant initialization</a> </li>
<li> <a href="copy_initialization" title="cpp/language/copy initialization">copy initialization</a> </li>
<li> <a href="direct_initialization" title="cpp/language/direct initialization">direct initialization</a> </li>
<li> <a href="reference_initialization" title="cpp/language/reference initialization">reference initialization</a> </li>
<li> <a href="value_initialization" title="cpp/language/value initialization">value initialization</a> </li>
<li> <a href="zero_initialization" title="cpp/language/zero initialization">zero initialization</a> </li>
</ul> </li>
<li> <a href="move_assignment" title="cpp/language/move assignment">move assignment</a> </li>
<li> <a href="move_constructor" title="cpp/language/move constructor">move constructor</a> </li>
<li> <a href="new" title="cpp/language/new"><code>new</code></a> </li>
</ul> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/list_initialization">https://en.cppreference.com/w/cpp/language/list_initialization</a>
</p>
</div>
