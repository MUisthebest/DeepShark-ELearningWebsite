 <h1 class="firstHeading" id="firstHeading">C ++ Yêu cầu được đặt tên: MoveInserable<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span>
</h1> <p>Chỉ định rằng một đối tượng của loại có thể được xây dựng thành lưu trữ không được chỉ định từ một rvalue thuộc loại đó bằng một bộ phân bổ nhất định.</p>
<h3 id="Requirements">Sắp xếp và các hoạt động liên quan</h3> <p>phạm vi của các yếu tố để tạo<code>T</code>khoảng cách<strong class="selflink">Di chuyển</strong>vào container<code>X</code>    get_leap_second_info (const std :: Chrono :: UTC_TIME &lt;feluration&gt; &amp; ut);<code>value_type</code>là giống hệt nhau<code>T</code>Nếu, được đưa ra</p>
<table class="t-dsc-begin"> <tr class="t-dsc"> <td> <code>A</code> </td> <td>một loại phân bổ</td>
</tr> <tr class="t-dsc"> <td> <code>m</code> </td> <td>một loại loại<code>A</code> </td>
</tr> <tr class="t-dsc"> <td> <code>p</code> </td> <td>con trỏ của loại<code>T*</code>được chuẩn bị bởi container</td>
</tr> <tr class="t-dsc"> <td> <code>rv</code> </td> <td>Biểu thức rvalue của loại<code>T</code> </td>
</tr> </table> <p>Ở đâu<code>X::allocator_type</code>là giống hệt nhau<code><a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span>A<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">Phân bổ các nút của một số loại nội bộ</span><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>Thì</p>
<p>Biểu thức sau đây được hình thành tốt:</p>
<div class="cpp source-cpp"><pre data-language="cpp">std :: allocator_traits &lt;a&gt; :: xây dựng (m, p, rv);</pre></div> <p>Và sau khi đánh giá, giá trị của<code>*p</code>tương đương với giá trị trước đây được giữ bởi<code>rv</code>.<code>rv</code>vẫn còn hợp lệ, nhưng ở trạng thái không xác định).</p>
<p>Nếu như<code>X</code>không nhận biết phân bổ hoặc là một<code><a href="../string/basic_string" title="cpp/string/basic string">std::basic_string</a></code>chuyên môn hóa, thuật ngữ được định nghĩa như thể<code>A</code>    // Số:<code>std::allocator&lt;T&gt;</code>, ngoại trừ việc không có đối tượng phân bổ nào cần được tạo và các chuyên gia do người dùng định nghĩa<code><a href="../memory/allocator" title="cpp/memory/allocator">std::allocator</a></code>không được khởi tạo.</p>
<h3 id="Notes">Ghi chú</h3> <p>Nếu như<code>A</code>khoảng cách<code><a href="http://en.cppreference.com/w/cpp/memory/allocator"><span class="kw702">Điều đó cho tất cả<span class="me2">người phân bổ</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>, sau đó điều này sẽ gọi vị trí mới, như<span class="t-rev-inl t-until-cxx20"><span><code>::new((void*)p) T(rv)</code></span><span><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></span></span><span class="t-rev-inl t-since-cxx20"><span><code><a href="http://en.cppreference.com/w/cpp/memory/construct_at"><span class="kw3205">Điều đó cho tất cả<span class="me2">(Niebloid)</span></span></a><span class="br0">.</span>p, rv<span class="br0">)</span></code></span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>. Điều này hiệu quả yêu cầu<code>T</code>được di chuyển có thể xây dựng.</p>
<p>Nếu như<code><a href="http://en.cppreference.com/w/cpp/memory/allocator"><span class="kw702">Điều đó cho tất cả<span class="me2">người phân bổ</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>hoặc một bộ phân bổ tương tự được sử dụng, một lớp không phải thực hiện<a href="../language/move_constructor" title="cpp/language/move constructor">move constructor</a>để đáp ứng yêu cầu loại này: A<a href="../language/copy_constructor" title="cpp/language/copy constructor">copy constructor</a>mà mất một<code>const T&amp;</code>Đối số có thể liên kết các biểu thức rvalue. Nếu một lớp di chuyển có thể thực hiện được một hàm tạo di chuyển, nó cũng có thể thực hiện<a href="../utility/move" title="cpp/utility/move">move semantics</a>để tận dụng thực tế rằng giá trị của<code>rv</code>Sau khi xây dựng là không xác định.</p>
<p>Mặc dù nó được yêu cầu tùy chỉnh<code>construct</code>được sử dụng khi xây dựng các yếu tố của<code><a href="../string/basic_string" title="cpp/string/basic string">std::basic_string</a></code>Cho đến khi C ++ 23, tất cả các triển khai chỉ sử dụng cơ chế mặc định. Yêu cầu được sửa chữa bởi<a class="external text" href="https://wg21.link/P1072R10" rel="nofollow">P1072R10</a>Để phù hợp với thực tiễn hiện có.</p>
<h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <a href="copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable">https://en.cppreference.com/w/cpp/named_req/MoveInsertable</a>
</p>
</div>
