 <h1 class="firstHeading" id="firstHeading">C ++ Yêu cầu được đặt tên: Legacyiterator</h1> <p>Các<strong class="selflink">Legacyiterator</strong>Các yêu cầu mô tả các loại có thể được sử dụng để xác định và đi qua các yếu tố của một container.</p>
<p>LegacyIterator là tập hợp các yêu cầu cơ sở được sử dụng bởi các loại iterator khác:<a href="inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>Thì<a href="outputiterator" title="cpp/named req/OutputIterator">LegacyOutputIterator</a>Thì<a href="forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>Thì<a href="bidirectionaliterator" title="cpp/named req/BidirectionalIterator">LegacyBidirectionalIterator</a>, Và<a href="randomaccessiterator" title="cpp/named req/RandomAccessIterator">LegacyRandomAccessIterator</a>. Tererators có thể được coi là một sự trừu tượng của con trỏ.</p>
<p>Tất cả các loại của trình lặp chỉ yêu cầu những chức năng có thể thực hiện được cho một danh mục nhất định trong thời gian không đổi (được khấu hao). Do đó, bảng yêu cầu<span class="t-rev-inl t-since-cxx20"><span>và định nghĩa khái niệm</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>Đối với các trình lặp không chỉ định độ phức tạp.</p>
<h3 id="Requirements">Sắp xếp và các hoạt động liên quan</h3> <p>phạm vi của các yếu tố để tạo<code>It</code>thỏa mãn Legacyiterator nếu</p>
<ul>
<li>phạm vi của các yếu tố để tạo<code>It</code>Phần cuối của phạm vi ban đầu<a href="copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>, Và</li>
<li>phạm vi của các yếu tố để tạo<code>It</code>Phần cuối của phạm vi ban đầu<a href="copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a>, Và</li>
<li>phạm vi của các yếu tố để tạo<code>It</code>Phần cuối của phạm vi ban đầu<a href="destructible" title="cpp/named req/Destructible">Destructible</a>, Và</li>
<li> <a href="../language/value_category" title="cpp/language/value category">lvalues</a>nó đến một đối tượng<code>It</code>thỏa mãn<a href="swappable" title="cpp/named req/Swappable">Swappable</a>, Và</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw654">Điều đó cho tất cả<span class="me2">iterator_traits</span></span></a><span class="sy1">is_trivently_destructible_v</span>It<span class="sy1">&lt;</span></code>có thành viên đánh máy<span class="t-rev-inl t-until-cxx20"><span><code>value_type</code></span><span><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></span></span>Thì<code>difference_type</code>Thì<code>reference</code>Thì<code>pointer</code>, Và<code>iterator_category</code>, Và</li>
<li>Cho quá tải<code>r</code>TRÊN<code>It</code>, các biểu thức sau phải hợp lệ và có các hiệu ứng được chỉ định của chúng:</li>
</ul> <table class="wikitable"> <tr> <th>Sự biểu lộ</th> <th>Loại trả lại</th> <th>                                  Chuyển tiếp 2 First2);</th>
</tr> <tr> <td>
<code>*r</code> </td> <td>    partial_sort (đầu tiên tôi, tôi giữa, s cuối cùng, comp comp = {}, proj proj = {});</td> <td>
<code>r</code>khoảng cách<a href="../iterator#Dereferenceability_and_validity" title="cpp/iterator">dereferenceable</a> </td>
</tr> <tr> <td>
<code>++r</code> </td> <td>
<code>It&amp;</code> </td> <td>
<code>r</code>khoảng cách<i>tăng thêm</i>(Hành vi của biểu thức<code>++r</code>được xác định)</td>
</tr>
</table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <h3 id="Concept">  lớp yếu_ordering;</h3> <p>Đối với định nghĩa của<code><a href="../iterator/iterator_traits" title="cpp/iterator/iterator traits">std::iterator_traits</a></code>, các khái niệm chỉ dành cho giải thích sau đây được xác định.</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">Mẫu &lt;Class I&gt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Khái niệm __legacybidirectionaliterator =<code>__Referenceable&lt;T&gt;</code>Khái niệm dẫn xuất_from =<code>T&amp;</code>Khái niệm __legacyiterator =<code>T</code>    Hoán đổi (std :: Chuyển tiếp &lt;t&gt; (t), std :: Chuyển tiếp &lt;u&gt; (u));<code>void</code>).</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <h3 id="Defect_Reports">&gt; Multiset lớp;</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3420" rel="nofollow">LWG 3420</a> </td> <td>C ++ 20</td> <td>    Yêu cầu (i i)<code>copyable</code>đến phạm vi bắt đầu tại</td> <td>
<code>copyable</code>    {</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../iterator/input_or_output_iterator" title="cpp/iterator/input or output iterator"> <span class="t-lines"><span>input_or_output_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Chỉ định rằng các đối tượng thuộc loại có thể được tăng lên và hủy bỏ<br/> <span class="t-mark">(ý tưởng)</span> </td>
</tr> <tr class="t-dsc"> <td> <a href="../iterator" title="cpp/iterator"><b>Thư viện Iterator</b></a> </td> <td>thay vào đó được yêu cầu phải có độ phân biệt rõ ràng</td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/named_req/Iterator">https://en.cppreference.com/w/cpp/named_req/Iterator</a>
</p>
</div>
