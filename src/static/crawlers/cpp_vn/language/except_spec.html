 <h1 class="firstHeading" id="firstHeading">Đặc điểm kỹ thuật ngoại lệ động<span class="t-mark-rev t-until-cxx17">xáo trộn</span>
</h1> <p>Liệt kê các ngoại lệ mà một hàm có thể trực tiếp hoặc gián tiếp ném.</p>
<h3 id="Syntax">Cú pháp</h3> <table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <code>throw(</code><span class="t-spar">Danh sách ID loại</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span><code>)</code> </td> <td>(1)</td> <td> <span class="t-mark-rev t-deprecated-cxx11">(không dùng nữa trong C ++ 11)</span><br/><span class="t-mark-rev t-until-cxx17">(Đã xóa trong C ++ 17)</span> </td>
</tr>
</table> <div class="t-li1">
<span class="t-li">1)</span>Đặc điểm kỹ thuật ngoại lệ động rõ ràng.</div> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">Danh sách ID loại</span> </td> <td>-</td> <td>Danh sách phân tách dấu phẩy của<a href="type#Type_naming" title="cpp/language/type">type-ids</a><span class="t-rev-inl t-since-cxx11"><span>, một ID loại đại diện cho một<a href="parameter_pack#Pack_expansion" title="cpp/language/parameter pack">pack expansion</a>được theo sau bởi một dấu chấm lửng (...)</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span> </td>
</tr>
</table> <p>Một đặc tả ngoại lệ động rõ ràng sẽ chỉ xuất hiện trên trình khai báo hàm cho loại hàm, con trỏ đến loại chức năng, tham chiếu đến loại chức năng hoặc loại chức năng con trỏ đến thành viên là loại Tuyên bố hoặc định nghĩa cấp cao nhất hoặc trên một loại đó xuất hiện dưới dạng tham số hoặc loại trả về trong một trình khai báo hàm.</p>
<div class="cpp source-cpp"><pre data-language="cpp">void f () ném (int);            // OK: Tuyên bố chức năng</pre></div> <h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3> <p>void (*pf) () ném (int);       // ok: con trỏ để khai báo chức năng<code>T</code>void g (void pfa () ném (int));  // ok: khai báo tham số con trỏ tới hàm</p>
<p><a class="mw-redirect" href="incomplete_type" title="cpp/language/incomplete type">Incomplete types</a>typedef int (*pf) () ném (int); // Lỗi: Tuyên bố Typedef<code>void*</code><span class="t-rev-inl t-since-cxx11"><span>Nếu một hàm được khai báo với loại</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Được liệt kê trong đặc tả ngoại lệ động của nó, hàm có thể đưa ra các ngoại lệ của loại đó hoặc một loại có nguồn gốc từ nó.<span class="t-rev-inl t-since-cxx11"><span><a href="parameter_pack" title="cpp/language/parameter pack">parameter packs</a>, Con trỏ hoặc tham chiếu đến các loại không đầy đủ khác ngoài CV</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>.</p>
<p>và các loại tham chiếu rvalue<span class="t-rev-inl t-since-cxx11"><span>không được phép trong đặc tả ngoại lệ. Các loại mảng và chức năng, nếu được sử dụng, được điều chỉnh theo các loại con trỏ tương ứng, các cấp độ CV cấp cao nhất cũng bị loại bỏ.</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>được phép</p>
<p>Một đặc điểm kỹ thuật ngoại lệ động có tập hợp các loại điều chỉnh trống</p>
<p>(sau khi bất kỳ gói nào được mở rộng)<code><a href="../error/unexpected" title="cpp/error/unexpected">std::unexpected</a></code>không ném. Một chức năng với một đặc tả ngoại lệ động không ném không cho phép bất kỳ ngoại lệ nào.<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>Một đặc tả ngoại lệ động không được coi là một phần của loại chức năng.<code><a href="../error/set_unexpected" title="cpp/error/set unexpected">std::set_unexpected</a></code>Nếu hàm ném một ngoại lệ của loại không được liệt kê trong đặc tả ngoại lệ của nó, thì chức năng<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>được gọi. Các cuộc gọi chức năng mặc định<code><a href="../error/unexpected" title="cpp/error/unexpected">std::unexpected</a></code>, nhưng nó có thể được thay thế bằng một chức năng do người dùng cung cấp (thông qua<code><a href="../error/bad_exception" title="cpp/error/bad exception">std::bad_exception</a></code>) có thể gọi<code><a href="../error/bad_exception" title="cpp/error/bad exception">std::bad_exception</a></code>hoặc ném một ngoại lệ. Nếu ngoại lệ được ném từ<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>Chuỗi để giữ tên viết tắt múi giờ hoặc tên tương ứng với</p>
<h4 id="Instantiation">được chấp nhận bởi đặc điểm kỹ thuật ngoại lệ, ngăn xếp việc tháo gỡ tiếp tục như bình thường. Nếu nó không, nhưng</h4> <p>được cho phép bởi đặc tả ngoại lệ,<i>, nhưng chưa được khởi tạo, các tên phụ thuộc được tra cứu và bất kỳ mẫu nào được sử dụng trong</i>Khởi tạo</p>
<p>Đặc điểm kỹ thuật ngoại lệ động của chuyên môn mẫu chức năng không được khởi tạo cùng với khai báo chức năng; nó chỉ được khởi tạo khi</p>
<p>cần thiết<i>, nhưng chưa được khởi tạo, các tên phụ thuộc được tra cứu và bất kỳ mẫu nào được sử dụng trong</i>Thông số ngoại lệ động của hàm thành viên đặc biệt được tuyên bố ngầm cũng chỉ được đánh giá khi cần thiết (đặc biệt, việc khai báo ẩn hàm thành viên của một lớp dẫn xuất không yêu cầu xác định đặc tính ngoại lệ của chức năng thành viên cơ sở phải được khởi tạo).<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>Khi đặc tả ngoại lệ động của chuyên môn mẫu chức năng là</p>
<p>cần thiết<i>, nhưng chưa được khởi tạo, các tên phụ thuộc được tra cứu và bất kỳ mẫu nào được sử dụng trong</i>được khởi tạo như thể để tuyên bố chuyên môn hóa.</p>
<ul>
<li>Một đặc điểm ngoại lệ động của một hàm được coi là</li>
<li>cần thiết<a href="definition#ODR-use" title="cpp/language/definition">odr-used</a> </li>
<li>Trong các bối cảnh sau:</li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">Trong một biểu thức, trong đó hàm được chọn bởi độ phân giải quá tải</pre></div> <ul>
<li>Hàm là</li>
<li>chức năng sẽ được sử dụng ODR nhưng xuất hiện trong một toán hạng không được đánh giá</li>
<li>Mẫu &lt;Class T&gt;</li>
</ul> <h3 id="Potential_exceptions">T f () ném (std :: mảng &lt;char, sizeof (t)&gt;);</h3> <p> <code>f</code>int main ()<code>pf</code>{<code>pmf</code>Toán tử gán bản sao được xác định ngầm cho một lớp<i>Nếu tuyên bố của</i>                            // lỗi vì khởi tạo đặc tả ngoại lệ</p>
<div class="t-li1">
<span class="t-li">1)</span>                            // Tính toán sizeof (void)<code>f</code>Thì<code>pf</code>, hoặc<code>pmf</code>}<span class="t-rev-inl t-until-cxx11"><span>Thông số kỹ thuật là cần thiết để so sánh với một khai báo chức năng khác (ví dụ: trên trình ghi đè chức năng ảo hoặc trên một chuyên môn hóa rõ ràng của mẫu chức năng)</span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span>Trong một định nghĩa chức năng</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <span class="t-li">2)</span>Đặc điểm kỹ thuật là cần thiết vì một chức năng thành viên đặc biệt mặc định cần kiểm tra nó để quyết định đặc tả ngoại lệ của riêng mình (điều này chỉ diễn ra khi cần có đặc điểm kỹ thuật của chức năng thành viên đặc biệt mặc định là chính nó, chính là cần thiết).<code>f</code>Thì<code>pf</code>, hoặc<code>pmf</code>Sử dụng<a href="noexcept" title="cpp/language/noexcept"><code>noexcept(true)</code></a>Ngoại lệ tiềm năng</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Mỗi chức năng</div> <p>, Con trỏ tới chức năng<span class="t-rev-inl t-since-cxx11"><span>và chức năng con trỏ tới thành viên</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>tập hợp các ngoại lệ tiềm năng</p>
<p>, bao gồm các loại có thể được ném. Tập hợp tất cả các loại chỉ ra rằng bất kỳ ngoại lệ nào cũng có thể được ném. Bộ này được định nghĩa như sau:<code>e</code>Toán tử gán bản sao được xác định ngầm cho một lớp<i>Nếu tuyên bố của</i>Sử dụng một đặc điểm kỹ thuật ngoại lệ động<code>e</code>Điều đó như vậy<a href="constant_expression" title="cpp/language/constant expression">core constant expression</a>điều đó không cho phép tất cả các ngoại lệ<code>e</code>- có thể sửa đổi giá trị được tham chiếu thông qua<a href="default_arguments" title="cpp/language/default arguments">default argument expressions</a>, tập hợp bao gồm các loại được liệt kê trong đặc điểm kỹ thuật đó.<code>e</code> </p>
<div class="t-li1">
<span class="t-li">1)</span>Nếu như<code>e</code>Nếu không, nếu tuyên bố của<code>g</code>, bộ trống.<ul><li>, tập hợp các trường hợp ngoại lệ tiềm năng là sự kết hợp của các bộ ngoại lệ tiềm năng của mọi thứ họ sẽ gọi: Trình cấu trúc/toán tử chuyển nhượng/người phá hủy của các thành viên dữ liệu phi tĩnh không biến đổi, cơ sở trực tiếp và, khi thích hợp, các cơ sở ảo (bao gồm các biểu thức đối số mặc định, như mọi khi).<code>g</code>Lưu ý: Đối với các chức năng thành viên đặc biệt được tuyên bố ngầm (người xây dựng, toán tử chuyển nhượng và bộ hủy)<code>g</code>và cho các nhà xây dựng kế thừa</li></ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li>, tập hợp các trường hợp ngoại lệ tiềm năng là sự kết hợp của các bộ ngoại lệ tiềm năng của mọi thứ họ sẽ gọi: Trình cấu trúc/toán tử chuyển nhượng/người phá hủy của các thành viên dữ liệu phi tĩnh không biến đổi, cơ sở trực tiếp và, khi thích hợp, các cơ sở ảo (bao gồm các biểu thức đối số mặc định, như mọi khi).<code>g</code>Sử dụng<a href="noexcept" title="cpp/language/noexcept"><code>noexcept(true)</code></a>Mỗi biểu thức</li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <ul><li>tập hợp các ngoại lệ tiềm năng</li></ul>
</div> <div class="t-li1">
<span class="t-li">2)</span>Nếu như<code>e</code>. Bộ trống nếu<a href="new" title="cpp/language/new">new-expression</a>, nếu không, đó là sự kết hợp của các bộ ngoại lệ tiềm năng của tất cả các biểu hiện phụ ngay lập tức của</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Nếu như<code>e</code>Điều đó như vậy<a href="throw" title="cpp/language/throw">throw-expression</a>), kết hợp với một tập hợp khác phụ thuộc vào hình thức</div> <div class="t-li1">
<span class="t-li">là trong</span>Nếu như<code>e</code>Điều đó như vậy<a href="dynamic_cast" title="cpp/language/dynamic cast"><code>dynamic_cast</code></a>là một biểu thức cuộc gọi chức năng, hãy để<code><a href="../types/bad_cast" title="cpp/types/bad cast">std::bad_cast</a></code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Nếu như<code>e</code>Điều đó như vậy<a href="typeid" title="cpp/language/typeid"><code>typeid</code></a>biểu thị hàm, con trỏ hàm hoặc chức năng con trỏ đến thành viên được gọi, sau đó<code><a href="../types/bad_typeid" title="cpp/types/bad typeid">std::bad_typeid</a></code>.</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <span class="t-li">từ_sys</span>Nếu như<code>e</code>Điều đó như vậy<a href="new" title="cpp/language/new">new-expression</a>Nếu tuyên bố của<code><a href="../memory/new/bad_array_new_length" title="cpp/memory/new/bad array new length">std::bad_array_new_length</a></code>.</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <div class="cpp source-cpp"><pre data-language="cpp">sử dụng một đặc tả ngoại lệ động, tập hợp các ngoại lệ tiềm năng của</pre></div> <p>được thêm vào tập hợp;<span class="t-rev-inl t-since-cxx11"><span>Nếu tuyên bố của</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>, tập hợp trống rỗng;</p>
<ul>
<li>Nếu không, tập hợp là tập hợp của tất cả các loại.<span class="t-rev-inl t-until-cxx11"><span>gọi một chức năng ngầm (đó là biểu thức toán tử và toán tử bị quá tải, đó là một</span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>khoảng cách<code>noexcept(false)</code></span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>.</li>
<li>và chức năng phân bổ bị quá tải, hoặc nó là một biểu thức đầy đủ và bộ hủy của một tạm thời được gọi là), thì tập hợp là tập hợp của hàm đó.</li>
<li>, tập hợp là ngoại lệ sẽ được khởi tạo bởi toán hạng của nó hoặc tập hợp tất cả các loại cho biểu hiện ném lại (không có toán hạng).<span class="t-rev-inl t-until-cxx11"><span><code>throw()</code></span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span><code>noexcept(true)</code></span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>.</li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">Để tham khảo một loại đa hình, tập hợp bao gồm</pre></div> <h3 id="Notes">Ghi chú</h3> <p>áp dụng cho một con trỏ được thu hút vào một loại đa hình, tập hợp bao gồm<a class="external text" href="https://cplusplus.github.io/CWG/issues/1330.html" rel="nofollow">CWG1330</a>, nhìn thấy<a class="external text" href="https://github.com/llvm/llvm-project/issues/56439" rel="nofollow">LLVM #56349</a>.</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example">
<p>Với kích thước mảng không liên tục và chức năng phân bổ được chọn có một tập hợp các ngoại lệ tiềm năng không trống, tập hợp bao gồm</p>
<div class="cpp source-cpp"><pre data-language="cpp">void f () ném (int); // f () set của mình là "int"</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">void g ();            // bộ của G () là tập hợp tất cả các loại</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/25.html" rel="nofollow">CWG 25</a> </td> <td>C ++ 98</td> <td> <br/>Cấu trúc a {a (); };                  // "Bộ" mới "là tập hợp tất cả các loại<br/>struct b {b () noExcept; };         // "B ()" "Bộ</td> <td>struct d () {d () ném (gấp đôi); }; // Bộ D mới là tập hợp tất cả các loại<br/>Tất cả các chức năng thành viên được tuyên bố ngầm<br/>và kế thừa các nhà xây dựng</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/973.html" rel="nofollow">CWG 973</a> </td> <td>C ++ 98</td> <td>Có thông số kỹ thuật ngoại lệ, được chọn như sau:<br/>Nếu tập hợp các ngoại lệ tiềm năng là tập hợp của tất cả các loại, thì đặc tả ngoại lệ ngầm</td> <td>Mẫu &lt;class inputit, class outputit&gt;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1330.html" rel="nofollow">CWG 1330</a> </td> <td>C ++ 98</td> <td>Cho phép tất cả các ngoại lệ (đặc điểm kỹ thuật ngoại lệ được coi là hiện tại, mặc dù nó không thể diễn tả được trong mã và hoạt động như thể không có thông số kỹ thuật ngoại lệ)</td> <td>Mặt khác, nếu tập hợp các ngoại lệ tiềm năng không trống, đặc điểm kỹ thuật ngoại lệ ngầm liệt kê mọi loại từ tập hợp.</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1267.html" rel="nofollow">CWG 1267</a> </td> <td>C ++ 11</td> <td>Nếu không, đặc tả ngoại lệ ngầm là</td> <td>không được phép</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1351.html" rel="nofollow">CWG 1351</a> </td> <td>C ++ 98<br/>C ++ 11</td> <td>Cấu trúc a<br/>{</td> <td>    A (int = (a (5), 0)) noExcept;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1777.html" rel="nofollow">CWG 1777</a> </td> <td>C ++ 11</td> <td>
<code>throw(T...)</code>    A (const a &amp;) ném ();<br/>    A (a &amp;&amp;) ném ();<code>T</code>    ~ A () ném (x);</td> <td>};<br/> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2191.html" rel="nofollow">CWG 2191</a> </td> <td>C ++ 98</td> <td>cấu trúc b<code>typeid</code>  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }<br/>{<code>bad_typeid</code>    B () ném ();</td> <td>                           Forwardit2 first2, forwardit2 last2,<code>bad_typeid</code><br/>    B (const b &amp;) = mặc định; // Đặc điểm kỹ thuật ngoại lệ là "noExcept (true)"</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <a href="noexcept_spec" title="cpp/language/noexcept spec"> <code>noexcept</code> specifier</a><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span> </td> <td>    B (b &amp;&amp;, int = (ném y (), 0)) noExcept;</td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/except_spec">https://en.cppreference.com/w/cpp/language/except_spec</a>
</p>
</div>
