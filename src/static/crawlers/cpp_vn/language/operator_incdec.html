 <h1 class="firstHeading" id="firstHeading">}</h1> <p>Các toán tử tăng/giảm tăng hoặc giảm giá trị của đối tượng.</p>
<table class="wikitable"> <tr> <th rowspan="2">Tên nhà điều hành</th> <th rowspan="2">Cú pháp</th> <th rowspan="2">
<a href="operators" title="cpp/language/operators">Over​load​able</a> </th> <th colspan="2">Ví dụ nguyên mẫu (cho<code>class T</code>)</th>
</tr> <tr> <th>Định nghĩa lớp bên trong</th> <th>Định nghĩa lớp bên ngoài</th>
</tr> <tr> <td>    int n1 = 1;</td> <td>
<code>++a</code> </td> <td class="table-yes">Đúng</td> <td>
<code>T&amp; T::operator++();</code> </td> <td>
<code>T&amp; operator++(T&amp; a);</code> </td>
</tr> <tr> <td>    int n2 = ++ n1;</td> <td>
<code>--a</code> </td> <td class="table-yes">Đúng</td> <td>
<code>T&amp; T::operator--();</code> </td> <td>
<code>T&amp; operator--(T&amp; a);</code> </td>
</tr> <tr> <td>hậu kỳ</td> <td>
<code>a++</code> </td> <td class="table-yes">Đúng</td> <td>
<code>T T::operator++(int);</code> </td> <td>
<code>T operator++(T&amp; a, int);</code> </td>
</tr> <tr> <td>sự suy thoái sau</td> <td>
<code>a--</code> </td> <td class="table-yes">Đúng</td> <td>
<code>T T::operator--(int);</code> </td> <td>
<code>T operator--(T&amp; a, int);</code> </td>
</tr> <tr> <td colspan="5"> <b>Ghi chú</b><br/> <ul>
<li>Các phiên bản tiền tố của các toán tử tích hợp trở lại<i>Tài liệu tham khảo</i>và các phiên bản Postfix trở lại<i>giá trị</i>, và điển hình<a href="operators" title="cpp/language/operators">user-defined overloads</a>Thực hiện theo mẫu để các toán tử do người dùng xác định có thể được sử dụng theo cách tương tự như các bản dựng. Tuy nhiên, trong quá tải toán tử do người dùng xác định<code>void</code>).</li>
<li>Các<code>int</code>Tham số là một tham số giả được sử dụng để phân biệt giữa các phiên bản tiền tố và postfix của các toán tử. Khi toán tử postfix do người dùng xác định được gọi, giá trị được truyền trong tham số đó luôn bằng không, mặc dù nó có thể được thay đổi bằng cách gọi toán tử sử dụng ký hiệu cuộc gọi chức năng (ví dụ:<code>a.operator++(2)</code>hoặc<code>operator++(a, 2)</code>).</li>
</ul> </td>
</tr>
</table> <h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3> <p><i>Trước khi tăng</i>Và<i>    int n2 = ++ n1;</i>Người vận hành tăng hoặc giảm giá trị của đối tượng và trả về tham chiếu đến kết quả.</p>
<p><i>Hậu kỳ</i>Và<i>sự suy thoái sau</i>Tạo một bản sao của đối tượng, tăng hoặc giảm giá trị của đối tượng và trả về bản sao từ trước khi tăng hoặc giảm.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>Sử dụng một lvalue thuộc loại không có đủ điều kiện dễ bay hơi làm toán hạng của phiên bản tích hợp của các toán tử này không được chấp nhận.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <h4 id="Built-in_prefix_operators">Các nhà khai thác tiền tố tích hợp</h4> <p>Các biểu thức tăng và biểu thức giảm tiền tố có biểu mẫu</p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <code>++</code> <span class="t-spar">struct {int c [3]; } s1, s2 = {3, 4, 5};</span> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <code>--</code> <span class="t-spar">struct {int c [3]; } s1, s2 = {3, 4, 5};</span> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <div class="t-li1">
<span class="t-li">1)</span>Tăng tiền tố (trước khi tăng)</div> <div class="t-li1">
<span class="t-li">2)</span>Tiền tố giảm (khai báo trước)</div> <p>Toán tử<span class="t-spar">struct {int c [3]; } s1, s2 = {3, 4, 5};</span>của một toán tử tăng tiền tố tích hợp hoặc toán tử giảm phải có thể sửa đổi (không phải con quay)<a href="value_category" title="cpp/language/value category">lvalue</a>của<span class="t-rev-inl t-since-cxx17"><span>không phải là Boolean</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>loại số học hoặc con trỏ tới hoàn toàn được xác định<a href="type" title="cpp/language/type">object type</a>là một biểu hiện ID không đủ tiêu chuẩn được chuẩn bị bởi một toán tử phân giải phạm vi<code>++x</code>hoàn toàn tương đương với<code>x += 1</code><span class="t-rev-inl t-until-cxx17"><span>Đối với các hoạt động không phải là Boolean</span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span>và biểu thức<code>--x</code>hoàn toàn tương đương với<code>x -= 1</code>, nghĩa là, mức tăng hoặc giảm tiền tố là một biểu thức lvalue xác định toán hạng đã được sửa đổi. Tất cả các quy tắc chuyển đổi số học và quy tắc số học được xác định cho<a href="operator_arithmetic" title="cpp/language/operator arithmetic">arithmetic operators</a>Áp dụng và xác định chuyển đổi ngầm (nếu có) được áp dụng cho toán hạng cũng như loại trả về của biểu thức.</p>
<p><span class="t-rev-inl t-until-cxx17"><span>Nếu toán hạng của toán tử trước là loại<code>bool</code>, nó được đặt thành<code>true</code> <span class="t-mark">(không dùng nữa)</span>.</span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span></p>
<p>TRONG<a href="overload_resolution#Call_to_an_overloaded_operator" title="cpp/language/overload resolution">overload resolution against user-defined operators</a>, cho mọi loại số học có trình độ dễ bay hơi tùy chọn<code>A</code>REALLOCATION thường là các hoạt động tốn kém về mặt hiệu suất. Các<code>bool</code>và cho mọi con trỏ đủ điều kiện dễ bay hơi tùy ý<code>P</code>Để tùy chọn loại đối tượng có trình độ CV, chữ ký chức năng sau tham gia vào độ phân giải quá tải:</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">A &amp; Toán tử ++ (A &amp;)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Bool &amp; Toán tử ++ (Bool &amp;)</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark">(không dùng nữa)</span><span class="t-mark-rev t-until-cxx17">xáo trộn</span> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">P &amp; Toán tử ++ (P &amp;)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">A &amp; Toán tử-(A &amp;)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">P &amp; Toán tử-(P &amp;)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <h4 id="Built-in_postfix_operators">Các nhà khai thác postfix tích hợp</h4> <p>Các biểu thức gia tăng và giảm dần Postfix có biểu mẫu</p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <span class="t-spar">struct {int c [3]; } s1, s2 = {3, 4, 5};</span> <code>++</code> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <span class="t-spar">struct {int c [3]; } s1, s2 = {3, 4, 5};</span> <code>--</code> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <div class="t-li1">
<span class="t-li">1)</span>Postfix tăng (sau khi tăng)</div> <div class="t-li1">
<span class="t-li">2)</span>Postfix giảm (sau suy thoái)</div> <p>Toán tử<span class="t-spar">struct {int c [3]; } s1, s2 = {3, 4, 5};</span>của một toán tử gia tăng hoặc vận hành giảm tích hợp phải là một người có thể sửa đổi (không phải là con quay)<a href="value_category" title="cpp/language/value category">lvalue</a>của<span class="t-rev-inl t-since-cxx17"><span>không phải là Boolean</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>loại số học hoặc con trỏ tới hoàn toàn được xác định<a href="type" title="cpp/language/type">object type</a>. Kết quả là<a href="value_category" title="cpp/language/value category">prvalue</a>Bản sao giá trị ban đầu của toán hạng. Như một tác dụng phụ, biểu hiện<code>x++</code>sửa đổi giá trị của toán hạng của nó như thể bằng cách đánh giá<code>x += 1</code><span class="t-rev-inl t-until-cxx17"><span>Đối với các hoạt động không phải là Boolean</span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span>và biểu thức<code>x--</code>sửa đổi giá trị của toán hạng của nó như thể bằng cách đánh giá<code>x -= 1</code>. Tất cả các quy tắc chuyển đổi số học và quy tắc số học được xác định cho<a href="operator_arithmetic" title="cpp/language/operator arithmetic">arithmetic operators</a>Áp dụng và xác định chuyển đổi ngầm (nếu có) được áp dụng cho toán hạng cũng như loại trả về của biểu thức.</p>
<p><span class="t-rev-inl t-until-cxx17"><span>Nếu hoạt động của toán tử sau khi đầu tiên thuộc loại<code>bool</code>, nó được đặt thành<code>true</code> <span class="t-mark">(không dùng nữa)</span>.</span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span></p>
<p>TRONG<a href="overload_resolution#Call_to_an_overloaded_operator" title="cpp/language/overload resolution">overload resolution against user-defined operators</a>, cho mọi loại số học có trình độ dễ bay hơi tùy chọn<code>A</code>REALLOCATION thường là các hoạt động tốn kém về mặt hiệu suất. Các<code>bool</code>và cho mọi con trỏ đủ điều kiện dễ bay hơi tùy ý<code>P</code>Để tùy chọn loại đối tượng có trình độ CV, chữ ký chức năng sau tham gia vào độ phân giải quá tải:</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">Người vận hành ++ (A &amp;, Int)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Toán tử bool ++ (Bool &amp;, int)</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark">(không dùng nữa)</span><span class="t-mark-rev t-until-cxx17">xáo trộn</span> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">Nhà điều hành P ++ (P &amp;, Int)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">Một nhà điều hành-(A &amp;, int)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">Nhà điều hành P-(P &amp;, int)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <h4 id="Example">Ví dụ</h4> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;Istream&gt;</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c"> </pre></div> </div> <h3 id="Notes">Ghi chú</h3> <p>int main ()<a href="eval_order" title="cpp/language/eval order">sequencing rules</a>.</p>
<p>{<i>    int n1 = 1;</i>hoặc<i>    int n2 = ++ n1;</i>    int n3 = ++ ++ n1;</p>
<h3 id="Standard_library">Mẫu &lt;Class I2&gt;</h3> <p>    int n4 = n1 ++;<a href="../named_req/iterator" title="cpp/named req/Iterator">LegacyIterator</a>// int n5 = n1 ++ ++;   // lỗi<a href="../named_req/bidirectionaliterator" title="cpp/named req/BidirectionalIterator">LegacyBidirectionalIterator</a>// int n6 = n1 +++ n1; // Hành vi không xác định</p>
<table class="t-dsc-begin"> <tr> <td colspan="2"> <h5 id="overloads_for_arithmetic_types">    std :: cout &lt;&lt; "n1 =" &lt;&lt; n1 &lt;&lt; '\ n'</h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../atomic/atomic/operator_arith" title="cpp/atomic/atomic/operator arith"> <span class="t-lines"><span>fetch_or</span><span>fetch_or<span class="t-dsc-small">toán tử ++</span></span><span>thực hiện nguyên tử Bitwise XOR giữa đối số và giá trị của đối tượng nguyên tử và có được giá trị được giữ trước đó</span><span>thực hiện nguyên tử Bitwise XOR giữa đối số và giá trị của đối tượng nguyên tử và có được giá trị được giữ trước đó<span class="t-dsc-small">toán tử ++</span></span></span></a></div> </td> <td>toán tử ++<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::atomic&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/duration/operator_arith2" title="cpp/chrono/duration/operator arith2"> <span class="t-lines"><span>fetch_or</span><span>fetch_or<span class="t-dsc-small">toán tử ++</span></span><span>thực hiện nguyên tử Bitwise XOR giữa đối số và giá trị của đối tượng nguyên tử và có được giá trị được giữ trước đó</span><span>thực hiện nguyên tử Bitwise XOR giữa đối số và giá trị của đối tượng nguyên tử và có được giá trị được giữ trước đó<span class="t-dsc-small">toán tử ++</span></span></span></a></div> </td> <td>Trả về giá trị thời lượng đặc biệt tối đa<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::chrono::duration&lt;Rep,Period&gt;</code>)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="overloads_for_iterator_types">              &lt;&lt; "N2 =" &lt;&lt; N2 &lt;&lt; '\ n'</h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/raw_storage_iterator/operator_arith" title="cpp/memory/raw storage iterator/operator arith"> <span class="t-lines"><span>fetch_or</span><span>fetch_or<span class="t-dsc-small">toán tử ++</span></span></span></a></div> </td> <td>tiến bộ của iterator<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::raw_storage_iterator&lt;OutputIt,T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/reverse_iterator/operator_arith" title="cpp/iterator/reverse iterator/operator arith"> <span class="t-lines"><span>fetch_or</span><span>fetch_or<span class="t-dsc-small">toán tử ++</span></span><span>(int)</span><span>toán tử+</span><span>thực hiện nguyên tử Bitwise XOR giữa đối số và giá trị của đối tượng nguyên tử và có được giá trị được giữ trước đó</span><span>thực hiện nguyên tử Bitwise XOR giữa đối số và giá trị của đối tượng nguyên tử và có được giá trị được giữ trước đó<span class="t-dsc-small">toán tử ++</span></span><span>nhà điều hành--</span><span>người vận hành-</span></span></a></div> </td> <td>Truy cập một phần tử theo chỉ mục<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::reverse_iterator&lt;Iter&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/move_iterator/operator_arith" title="cpp/iterator/move iterator/operator arith"> <span class="t-lines"><span>fetch_or</span><span>fetch_or<span class="t-dsc-small">toán tử ++</span></span><span>(int)</span><span>toán tử+</span><span>thực hiện nguyên tử Bitwise XOR giữa đối số và giá trị của đối tượng nguyên tử và có được giá trị được giữ trước đó</span><span>thực hiện nguyên tử Bitwise XOR giữa đối số và giá trị của đối tượng nguyên tử và có được giá trị được giữ trước đó<span class="t-dsc-small">toán tử ++</span></span><span>nhà điều hành--</span><span>người vận hành-</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>Truy cập một phần tử theo chỉ mục<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::move_iterator&lt;Iter&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/front_insert_iterator/operator_plus__plus_" title="cpp/iterator/front insert iterator/operator++"> <span class="t-lines"><span>fetch_or</span><span>fetch_or<span class="t-dsc-small">toán tử ++</span></span></span></a></div> </td> <td>không có op<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::front_insert_iterator&lt;Container&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/back_insert_iterator/operator_plus__plus_" title="cpp/iterator/back insert iterator/operator++"> <span class="t-lines"><span>fetch_or</span><span>fetch_or<span class="t-dsc-small">toán tử ++</span></span></span></a></div> </td> <td>không có op<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::back_insert_iterator&lt;Container&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/insert_iterator/operator_plus__plus_" title="cpp/iterator/insert iterator/operator++"> <span class="t-lines"><span>fetch_or</span><span>fetch_or<span class="t-dsc-small">toán tử ++</span></span></span></a></div> </td> <td>không có op<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::insert_iterator&lt;Container&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/istream_iterator/operator_arith" title="cpp/iterator/istream iterator/operator arith"> <span class="t-lines"><span>fetch_or</span><span>fetch_or<span class="t-dsc-small">toán tử ++</span></span></span></a></div> </td> <td>tiến bộ của iterator<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::istream_iterator&lt;T,CharT,Traits,Distance&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/ostream_iterator/operator_arith" title="cpp/iterator/ostream iterator/operator arith"> <span class="t-lines"><span>fetch_or</span><span>fetch_or<span class="t-dsc-small">toán tử ++</span></span></span></a></div> </td> <td>không có op<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::ostream_iterator&lt;T,CharT,Traits&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/istreambuf_iterator/operator_arith" title="cpp/iterator/istreambuf iterator/operator arith"> <span class="t-lines"><span>fetch_or</span><span>fetch_or<span class="t-dsc-small">toán tử ++</span></span></span></a></div> </td> <td>tiến bộ của iterator<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::istreambuf_iterator&lt;CharT,Traits&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/ostreambuf_iterator/operator_arith" title="cpp/iterator/ostreambuf iterator/operator arith"> <span class="t-lines"><span>fetch_or</span><span>fetch_or<span class="t-dsc-small">toán tử ++</span></span></span></a></div> </td> <td>không có op<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::ostreambuf_iterator&lt;CharT,Traits&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../regex/regex_iterator/operator_arith" title="cpp/regex/regex iterator/operator arith"> <span class="t-lines"><span>fetch_or</span><span>fetch_or<span class="t-dsc-small">toán tử ++</span></span></span></a></div> </td> <td>              &lt;&lt; "N3 =" &lt;&lt; N3 &lt;&lt; '\ n'<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::regex_iterator&lt;BidirIt,CharT,Traits&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../regex/regex_token_iterator/operator_arith" title="cpp/regex/regex token iterator/operator arith"> <span class="t-lines"><span>fetch_or</span><span>fetch_or<span class="t-dsc-small">toán tử ++</span></span></span></a></div> </td> <td>              &lt;&lt; "n4 =" &lt;&lt; n4 &lt;&lt; '\ n';<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::regex_token_iterator&lt;BidirIt,CharT,Traits&gt;</code>)</span> </td>
</tr> </table> <h3 id="See_also">(chức năng)</h3> <p><a href="operator_precedence" title="cpp/language/operator precedence">Operator precedence</a></p>
<p><a href="operators" title="cpp/language/operators">Operator overloading</a></p>
<table class="wikitable"> <tr style="text-align:center"> <th colspan="7">Các nhà khai thác chung</th>
</tr> <tr style="text-align:center"> <td>
<a href="operator_assignment" title="cpp/language/operator assignment">assignment</a> </td> <td>
<strong class="selflink">sự gia tăng<br/>giảm dần</strong> </td> <td>
<a href="operator_arithmetic" title="cpp/language/operator arithmetic">arithmetic</a> </td> <td>
<a href="operator_logical" title="cpp/language/operator logical">logical</a> </td> <td>
<a href="operator_comparison" title="cpp/language/operator comparison">comparison</a> </td> <td>
<a href="operator_member_access" title="cpp/language/operator member access">member<br/>access</a> </td> <td>
<a href="operator_other" title="cpp/language/operator other">other</a> </td>
</tr> <tr style="text-align:center"> <td rowspan="6"> <p><code>a = b a += b a -= b a *= b a /= b a %= b a &amp;= b a |= b a ^= b a &lt;&lt;= b a &gt;&gt;= b</code></p>
</td> <td rowspan="6"> <p><code>++a --a a++ a--</code></p>
</td> <td rowspan="6"> <p><code>+a -a a + b a - b a * b a / b a % b ~a a &amp; b a | b a ^ b a &lt;&lt; b a &gt;&gt; b</code></p>
</td> <td rowspan="6"> <p><code>!a a &amp;&amp; b a || b</code></p>
</td> <td rowspan="6"> <p><code>a == b a != b a &lt; b a &gt; b a &lt;= b a &gt;= b a &lt;=&gt; b</code></p>
</td> <td rowspan="6"> <p><code>a[...] *a &amp;a a-&gt;b a.b a-&gt;*b a.*b</code></p>
</td> <td>Gọi chức năng</td>
</tr> <tr style="text-align:center"> <td>
<code>a(...)</code> </td>
</tr> <tr style="text-align:center"> <td>dấu phẩy</td>
</tr> <tr style="text-align:center"> <td>
<code>a, b</code> </td>
</tr> <tr style="text-align:center"> <td>có điều kiện</td>
</tr> <tr style="text-align:center"> <td>
<code>a ? b : c</code> </td>
</tr> <tr> <th colspan="7">Các nhà khai thác đặc biệt</th>
</tr> <tr> <td colspan="7"> <p><a href="static_cast" title="cpp/language/static cast"><code>static_cast</code></a>Chuyển đổi một loại thành loại liên quan khác<br/> <a href="dynamic_cast" title="cpp/language/dynamic cast"><code>dynamic_cast</code></a>Chuyển đổi trong hệ thống phân cấp thừa kế<br/> <a href="const_cast" title="cpp/language/const cast"><code>const_cast</code></a>thêm hoặc loại bỏ<a href="cv" title="cpp/language/cv">cv</a>-Qualifiers<br/> <a href="reinterpret_cast" title="cpp/language/reinterpret cast"><code>reinterpret_cast</code></a>Chuyển đổi loại thành loại không liên quan<br/> <a href="explicit_cast" title="cpp/language/explicit cast">C-style cast</a>Chuyển đổi loại này sang loại khác bằng cách kết hợp<code>static_cast</code>Thì<code>const_cast</code>, Và<code>reinterpret_cast</code> <br/> <a href="new" title="cpp/language/new"><code>new</code></a>Tạo các đối tượng có thời lượng lưu trữ động<br/> <a href="delete" title="cpp/language/delete"><code>delete</code></a>Các đối tượng phá hủy được tạo trước đây bởi biểu thức và bản phát hành mới thu được vùng bộ nhớ<br/> <a href="sizeof" title="cpp/language/sizeof"><code>sizeof</code></a>truy vấn kích thước của một loại<br/> <a href="sizeof..." title="cpp/language/sizeof..."><code>sizeof...</code></a>truy vấn kích thước của một<a href="parameter_pack" title="cpp/language/parameter pack">parameter pack</a> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span><br/> <a href="typeid" title="cpp/language/typeid"><code>typeid</code></a>truy vấn thông tin loại của một loại<br/> <a href="noexcept" title="cpp/language/noexcept"><code>noexcept</code></a>kiểm tra xem một biểu thức có thể ném một ngoại lệ<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span><br/> <a href="alignof" title="cpp/language/alignof"><code>alignof</code></a>// (thường là 4):<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></p>
</td>
</tr>
</table> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/operator_incdec" title="c/language/operator incdec">C documentation</a></span>vì<span class=""><span>}</span></span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/operator_incdec">https://en.cppreference.com/w/cpp/language/operator_incdec</a>
</p>
</div>
