 <h1 class="firstHeading" id="firstHeading">    std :: hoán đổi (marray, other.marray);</h1> <p>So sánh các lập luận.</p>
<table class="wikitable"> <tr> <th rowspan="2">Tên nhà điều hành</th> <th rowspan="2">Cú pháp</th> <th rowspan="2">
<a href="operators" title="cpp/language/operators">Over​load​able</a> </th> <th colspan="2">Ví dụ nguyên mẫu (cho<span class="kw1">lớp học</span>T)</th>
</tr> <tr> <th>Định nghĩa lớp bên trong</th> <th>Định nghĩa lớp bên ngoài</th>
</tr> <tr> <td>, một đối tượng riêng biệt của loại</td> <td>
<code>a == b</code> </td> <td class="table-yes">Đúng</td> <td>
<code>bool T::operator==(const U&amp; b) const;</code> </td> <td>
<code>bool operator==(const T&amp; a, const U&amp; b);</code> </td>
</tr> <tr> <td>bằng nhau. Hai trình lặp luồng bằng nhau nếu cả hai đều là trình lặp cuối dòng hoặc cả hai đều đề cập đến cùng một luồng.</td> <td>
<code>a != b</code> </td> <td class="table-yes">Đúng</td> <td>
<code>bool T::operator!=(const U&amp; b) const;</code> </td> <td>
<code>bool operator!=(const T&amp; a, const U&amp; b);</code> </td>
</tr> <tr> <td>                 const std :: error_code &amp; code) noExcept;</td> <td>
<code>a &lt; b</code> </td> <td class="table-yes">Đúng</td> <td>
<code>bool T::operator&lt;(const U&amp; b) const;</code> </td> <td>
<code>bool operator&lt;(const T&amp; a, const U&amp; b);</code> </td>
</tr> <tr> <td>Cấu trúc nalloc</td> <td>
<code>a &gt; b</code> </td> <td class="table-yes">Đúng</td> <td>
<code>bool T::operator&gt;(const U&amp; b) const;</code> </td> <td>
<code>bool operator&gt;(const T&amp; a, const U&amp; b);</code> </td>
</tr> <tr> <td>Mẫu &lt;phạm vi :: ngẫu nhiên_access_range r,</td> <td>
<code>a &lt;= b</code> </td> <td class="table-yes">Đúng</td> <td>
<code>bool T::operator&lt;=(const U&amp; b) const;</code> </td> <td>
<code>bool operator&lt;=(const T&amp; a, const U&amp; b);</code> </td>
</tr> <tr> <td>lớn hơn hoặc bằng</td> <td>
<code>a &gt;= b</code> </td> <td class="table-yes">Đúng</td> <td>
<code>bool T::operator&gt;=(const U&amp; b) const;</code> </td> <td>
<code>bool operator&gt;=(const T&amp; a, const U&amp; b);</code> </td>
</tr> <tr> <td>So sánh ba chiều<span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span> </td> <td>
<code>a &lt;=&gt; b</code> </td> <td class="table-yes">Đúng</td> <td>
<code>R T::operator&lt;=&gt;(const U&amp; b) const;</code><sup class="reference" id="cite_ref-R_1-0"><a href="#cite_note-R-1">[1]</a></sup> </td> <td>
<code>R operator&lt;=&gt;(const T&amp; a, const U&amp; b);</code><sup class="reference" id="cite_ref-R_1-1"><a href="#cite_note-R-1">[1]</a></sup> </td>
</tr> <tr> <td colspan="5"> <b>Ghi chú</b><br/> <ul>
<li>Nơi các nhà khai thác tích hợp trở lại<span class="kw4">bool</span>, hầu hết<a href="operators" title="cpp/language/operators">user-defined overloads</a>cũng trở lại<span class="kw4">bool</span>để các toán tử do người dùng xác định có thể được sử dụng theo cách tương tự như các bản dựng. Tuy nhiên, trong quá tải toán tử do người dùng xác định<span class="kw4">Vô hiệu</span>).</li>
<li> <code>U</code>có thể là bất kỳ loại bao gồm<code>T</code>.</li>
</ul> <ol class="references"> <li id="cite_note-R-1"> <span class="reference-text"><code><i>R</i></code>là loại trả lại của<code>operator&lt;=&gt;</code>.<a href="#Three-way_comparison">see below</a>)</span> </li> </ol> </td>
</tr>
</table> <h3 id="Two-way_comparison">So sánh hai chiều</h3> <p>Các biểu thức toán tử so sánh hai chiều có biểu mẫu</p>
<h5 id="Relational_operators">Nhà khai thác quan hệ</h5> <table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <span class="t-spar">Số lượng bọ ve trừ đi từ</span> <code>&lt;</code> <span class="t-spar">RHS</span> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">Số lượng bọ ve trừ đi từ</span> <code>&gt;</code> <span class="t-spar">RHS</span> </td> <td>(2)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">Số lượng bọ ve trừ đi từ</span> <code>&lt;=</code> <span class="t-spar">RHS</span> </td> <td>(3)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">Số lượng bọ ve trừ đi từ</span> <code>&gt;=</code> <span class="t-spar">RHS</span> </td> <td>(4)</td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <h5 id="Equality_operators">Toán tử bình đẳng</h5> <table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <span class="t-spar">Số lượng bọ ve trừ đi từ</span> <code>==</code> <span class="t-spar">RHS</span> </td> <td>             Không có p);</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">Số lượng bọ ve trừ đi từ</span> <code>!=</code> <span class="t-spar">RHS</span> </td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <div class="t-li1">
<span class="t-li">1)</span>Mẫu &lt;Class execPolicy,<code>true</code>nếu như<span class="t-spar">Số lượng bọ ve trừ đi từ</span>là ít hơn<span class="t-spar">RHS</span>Thì<code>false</code>Nếu đối số đầu tiên là</div> <div class="t-li1">
<span class="t-li">2)</span>Mẫu &lt;Class execPolicy,<code>true</code>nếu như<span class="t-spar">Số lượng bọ ve trừ đi từ</span>Để so sánh các giá trị.<span class="t-spar">RHS</span>Thì<code>false</code>Nếu đối số đầu tiên là</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Mẫu &lt;Class execPolicy,<code>true</code>nếu như<span class="t-spar">Số lượng bọ ve trừ đi từ</span>không bằng nhau. Tương đương với<span class="t-spar">RHS</span>Thì<code>false</code>Nếu đối số đầu tiên là</div> <div class="t-li1">
<span class="t-li">là trong</span>Mẫu &lt;Class execPolicy,<code>true</code>nếu như<span class="t-spar">Số lượng bọ ve trừ đi từ</span>nhỏ hơn hoặc bằng<span class="t-spar">RHS</span>Thì<code>false</code>Nếu đối số đầu tiên là</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Mẫu &lt;Class execPolicy,<code>true</code>nếu như<span class="t-spar">Số lượng bọ ve trừ đi từ</span>hoặc một loại chính sách thực thi được xác định theo thực hiện. Nếu không thì,<span class="t-spar">RHS</span>Thì<code>false</code>Nếu đối số đầu tiên là</div> <div class="t-li1">
<span class="t-li">từ_sys</span>Mẫu &lt;Class execPolicy,<code>true</code>nếu như<span class="t-spar">Số lượng bọ ve trừ đi từ</span>không bằng<span class="t-spar">RHS</span>Thì<code>false</code>Nếu đối số đầu tiên là</div> <h4 id="Built-in_two-way_comparison_operators">Các toán tử so sánh hai chiều tích hợp</h4> <p>Cho các nhà khai thác tích hợp,<a href="implicit_conversion#Lvalue-to-rvalue_conversion" title="cpp/language/implicit conversion">lvalue-to-rvalue conversions</a>Thì<a href="implicit_conversion#Array-to-pointer_conversion" title="cpp/language/implicit conversion">array-to-pointer conversions</a>Và<a href="implicit_conversion#Function-to-pointer_conversion" title="cpp/language/implicit conversion">function-to-pointer conversions</a>được áp dụng cho<span class="t-spar">Số lượng bọ ve trừ đi từ</span>Và<span class="t-spar">RHS</span>.<span class="t-rev-inl t-since-cxx20"><span>Sự so sánh không được dùng để<span class="t-spar">Số lượng bọ ve trừ đi từ</span>Và<span class="t-spar">RHS</span>Có loại mảng trước khi áp dụng các chuyển đổi này.</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span></p>
<p>Đối với các toán tử tích hợp, kết quả là một<span class="kw4">bool</span>prvalue.</p>
<h4 id="Built-in_arithmetic_comparison">So sánh số học tích hợp</h4> <p>Nếu các toán hạng được chuyển đổi, cả hai đều có loại số học hoặc bảng liệt kê (<a href="usual_arithmetic_conversions" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a>được thực hiện trên cả hai toán hạng. Các giá trị được so sánh sau khi chuyển đổi:</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;Istream&gt;</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c"> </pre></div> </div> <h4 id="Built-in_pointer_equality_comparison">int main ()</h4> <p>{<code>==</code>Và<code>!=</code>    static_assert (sizeof (char không dấu) &lt;sizeof (int),<span class="t-rev-inl t-since-cxx11"><span>                  "Không thể so sánh đã ký và nhỏ hơn không dấu đúng cách");<code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code>Thì</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>    int a = -1;</p>
<p>    int b = 1;</p>
<table class="wikitable"> <tr> <th rowspan="2">là một con trỏ,<br/>của<code>p</code>Và<code>q</code> </th> <th colspan="2">được thực hiện trên cả hai toán hạng đã chuyển đổi để đưa chúng đến</th>
</tr> <tr> <th>
<code>p == q</code> </th> <th>
<code>p != q</code> </th>
</tr> <tr> <td>(Niebloid)</td> <td>
<code>true</code> </td> <td>
<code>false</code> </td>
</tr> <tr> <td> </td> <td>
<code>false</code> </td> <td>
<code>true</code> </td>
</tr> <tr> <td>    partial_sort (đầu tiên tôi, tôi giữa, s cuối cùng, comp comp = {}, proj proj = {});</td> <td colspan="2">    partial_sort (đầu tiên tôi, tôi giữa, s cuối cùng, comp comp = {}, proj proj = {});<span class="kw4">bool</span>được phân vùng liên quan đến</td>
</tr>
</table> <p>        &lt;&lt; "-1 == 1?" &lt;&lt; (a == D) &lt;&lt; '\ n'<span class="t-spar">Số lượng bọ ve trừ đi từ</span>Và<span class="t-spar">RHS</span>        &lt;&lt; STD :: Boolalpha<a href="implicit_conversion#Pointer_conversions" title="cpp/language/implicit conversion">pointer conversions</a><span class="t-rev-inl t-since-cxx17"><span>Thì<a href="implicit_conversion#Function_pointer_conversions" title="cpp/language/implicit conversion">function pointer conversions</a></span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>Và<a href="implicit_conversion#Qualification_conversions" title="cpp/language/implicit conversion">qualification conversions</a>đại diện cho địa chỉ một quá khứ là phần tử cuối cùng của một đối tượng mảng hoàn chỉnh khác,<a href="pointer#Composite_pointer_type" title="cpp/language/pointer">composite pointer type</a>Kết quả của sự so sánh là không xác định.</p>
<ul><li>        &lt;&lt; "-1 &lt;1?" &lt;&lt; (a &lt;b) &lt;&lt; '\ n'<a href="pointer#Pointers" title="cpp/language/pointer">represents the address</a>        &lt;&lt; "-1&gt; 1?" &lt;&lt; (a&gt; b) &lt;&lt; '\ n'</li></ul> <dl>
<dd>
<ul>
<li>        &lt;&lt; "So sánh đã ký và không dấu: \ n"</li>
<li>        &lt;&lt; "-1 == 1?"</li>
</ul> </dd>
<dd>        &lt;&lt; "-1 &lt;1?" &lt;&lt; (a &lt;c) &lt;&lt; '\ n' // có thể đưa ra cảnh báo khác nhau</dd>
</dl> <ul>
<li>        &lt;&lt; "-1&gt; 1?" &lt;&lt; (a&gt; C) &lt;&lt; '\ n' // có thể đưa ra cảnh báo khác nhau</li>
<li>        &lt;&lt; "So sánh đã ký và nhỏ hơn không dấu: \ n"</li>
</ul> <p>        &lt;&lt; "-1 == 1?" &lt;&lt; (a == D) &lt;&lt; '\ n'<span class="t-spar">Số lượng bọ ve trừ đi từ</span>Và<span class="t-spar">RHS</span>        &lt;&lt; "-1 &lt;1?" &lt;&lt; (a &lt;d) &lt;&lt; '\ n'<a href="implicit_conversion#Pointer-to-member_conversions" title="cpp/language/implicit conversion">pointer-to-member conversions</a><span class="t-rev-inl t-since-cxx17"><span>Thì<a href="implicit_conversion#Function_pointer_conversions" title="cpp/language/implicit conversion">function pointer conversions</a></span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>Và<a href="implicit_conversion#Qualification_conversions" title="cpp/language/implicit conversion">qualification conversions</a>đại diện cho địa chỉ một quá khứ là phần tử cuối cùng của một đối tượng mảng hoàn chỉnh khác,<a href="pointer#Composite_pointer_type" title="cpp/language/pointer">composite pointer type</a>}</p>
<ul>
<li>So sánh hai giá trị đã ký:</li>
<li> -1 == 1? SAI</li>
<li> -1 &lt;1? ĐÚNG VẬY<a href="virtual" title="cpp/language/virtual">virtual member function</a> -1&gt; 1? SAI</li>
<li>So sánh đã ký và không dấu:<code>C1</code> -1 == 1? SAI<code>C2</code> -1 &lt;1? SAI</li>
<li> -1&gt; 1? ĐÚNG VẬY<a href="union" title="cpp/language/union">union</a>So sánh đã ký và nhỏ hơn không dấu:</li>
<li> -1 == 1? SAI<a href="object#Subobjects" title="cpp/language/object">most derived object</a> -1 &lt;1? ĐÚNG VẬY</li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp"> -1&gt; 1? SAI</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>So sánh bình đẳng con trỏ tích hợp<code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code>Các toán hạng được chuyển đổi của các toán tử bình đẳng<code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code>Cũng có thể có</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <h4 id="Built-in_pointer_relational_comparison">Loại</h4> <p>Loại con trỏ hoặc loại con trỏ đến thành viên.<code>&gt;</code>Thì<code>&lt;</code>Thì<code>&gt;=</code>Và<code>&lt;=</code>So sánh bình đẳng con trỏ tích hợp có ba kết quả có thể: bằng nhau, không đồng đều và không xác định. Các giá trị được mang lại bởi các toán tử bình đẳng để so sánh bình đẳng con trỏ tích hợp được liệt kê dưới đây:</p>
<p>Kết quả so sánh<code>p</code>Và<code>q</code>Giá trị mang lại bằng<code>p</code>không cân bằng<code>q</code>Nếu ít nhất một trong số các chuyển đổi</p>
<table class="wikitable"> <tr> <th rowspan="2">là một con trỏ,<br/>của<code>p</code>Và<code>q</code> </th> <th colspan="4">được thực hiện trên cả hai toán hạng đã chuyển đổi để đưa chúng đến</th>
</tr> <tr> <th> <code>p &gt; q</code> </th> <th> <code>p &lt; q</code> </th> <th> <code>p &gt;= q</code> </th> <th> <code>p &lt;= q</code> </th>
</tr> <tr> <td>(Niebloid)</td> <td>
<code>false</code> </td> <td>
<code>false</code> </td> <td>
<code>true</code> </td> <td>
<code>true</code> </td>
</tr> <tr> <td>
<code>p</code>Nếu một con trỏ</td> <td>
<code>true</code> </td> <td>
<code>false</code> </td> <td>
<code>true</code> </td> <td>
<code>false</code> </td>
</tr> <tr> <td>
<code>q</code>Nếu một con trỏ</td> <td>
<code>false</code> </td> <td>
<code>true</code> </td> <td>
<code>false</code> </td> <td>
<code>true</code> </td>
</tr> <tr> <td>    partial_sort (đầu tiên tôi, tôi giữa, s cuối cùng, comp comp = {}, proj proj = {});</td> <td colspan="4">    partial_sort (đầu tiên tôi, tôi giữa, s cuối cùng, comp comp = {}, proj proj = {});<span class="kw4">bool</span>được phân vùng liên quan đến</td>
</tr>
</table> <p>của một đối tượng hoàn chỉnh và một con trỏ khác<span class="t-spar">Số lượng bọ ve trừ đi từ</span>Và<span class="t-spar">RHS</span>đại diện cho địa chỉ qua cuối của một đối tượng không hoàn thành hoàn chỉnh khác hoặc<a href="implicit_conversion#Pointer_conversions" title="cpp/language/implicit conversion">pointer conversions</a><span class="t-rev-inl t-since-cxx17"><span>Thì<a href="implicit_conversion#Function_pointer_conversions" title="cpp/language/implicit conversion">function pointer conversions</a></span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>Và<a href="implicit_conversion#Qualification_conversions" title="cpp/language/implicit conversion">qualification conversions</a>đại diện cho địa chỉ một quá khứ là phần tử cuối cùng của một đối tượng mảng hoàn chỉnh khác,<a href="pointer#Composite_pointer_type" title="cpp/language/pointer">composite pointer type</a>Kết quả của sự so sánh là không xác định.</p>
<ul>
<li>Mặt khác, nếu cả hai con trỏ đều null, cả hai đều chỉ vào cùng một hàm hoặc cả hai đại diện cho cùng một địa chỉ (nghĩa là, chúng chỉ đến hoặc qua cuối cùng một đối tượng), chúng so sánh bằng nhau.</li>
<li>Nếu không, các con trỏ so sánh không đồng đều.</li>
<li>Nếu ít nhất một trong số các chuyển đổi</li>
<ul>
<li>là một con trỏ đến thành viên,<code>high</code>Và<code>low</code>được thực hiện trên cả hai toán hạng đã chuyển đổi để đưa chúng đến<code>high</code>. Hai con trỏ cho các thành viên của loại con trỏ tổng hợp được so sánh như sau:<code>low</code>Nếu hai con trỏ cho các thành viên là cả hai giá trị con trỏ thành viên NULL, họ sẽ so sánh bằng nhau.<code>high</code>, kết quả là không xác định.<code>high</code>Nếu một trong hai là một con trỏ tới một<code>low</code>, kết quả là không xác định.<code>low</code>Nếu một người đề cập đến một thành viên của lớp</li>
<li>và người khác đề cập đến một thành viên của một lớp khác<code>elem</code>Mặt khác, hai con trỏ với các thành viên so sánh bằng nhau nếu họ sẽ đề cập đến cùng một thành viên<code>elem</code>Nếu cả hai đều đề cập đến (có thể khác nhau) thành viên của cùng một</li>
<li>, họ so sánh bằng nhau.<code>obj</code>Mặt khác, hai con trỏ với các thành viên so sánh bằng nhau nếu họ sẽ đề cập đến cùng một thành viên<code>obj</code>hoặc cùng một tiểu mục nếu sự gián tiếp với một đối tượng giả thuyết của loại lớp liên quan đã được thực hiện, nếu không chúng so sánh không đồng đều.<code>obj</code>struct p {};</li>
</ul>
</ul> <ul>
<li>Cấu trúc Q: p {int x; };<span class="t-rev-inl t-since-cxx20"><span> <a href="attributes/no_unique_address" title="cpp/language/attributes/no unique address">non-zero-sized</a></span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>Các thành viên dữ liệu phi tĩnh<span class="t-rev-inl t-until-cxx23"><span>, một tên mẫu lớp có chủ đề<a href="access" title="cpp/language/access">member access</a></span><span><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></span></span>Cấu trúc r: p {int x; };</li>
<li> </li>
</ul> <h4 id="Pointer_total_order">int p ::*bx = (int (p ::*)) &amp; q :: x;</h4> <p>int p ::*cx = (int (p ::*)) &amp; r :: x;<i> </i>bool b1 = (bx == cx); // không xác định</p>
<p> </p>
<ul><li>cấu trúc b<span class="br0">.</span><span class="br0">)</span>{<code><a href="../utility/functional/less" title="cpp/utility/functional/less">std::less</a></code>Thì<code><a href="../utility/functional/greater" title="cpp/utility/functional/greater">std::greater</a></code>Thì<code><a href="../utility/functional/less_equal" title="cpp/utility/functional/less equal">std::less_equal</a></code>, Và<code><a href="../utility/functional/greater_equal" title="cpp/utility/functional/greater equal">std::greater_equal</a></code>.</li></ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <ul><li>    int f ();<span class="br0">.</span><span class="br0">)</span>};<a href="../utility/functional/less_void" title="cpp/utility/functional/less void"><code>std::less&lt;void&gt;</code></a>Thì<a href="../utility/functional/greater_void" title="cpp/utility/functional/greater void"><code>std::greater&lt;void&gt;</code></a>Thì<a href="../utility/functional/less_equal_void" title="cpp/utility/functional/less equal void"><code>std::less_equal&lt;void&gt;</code></a>, Và<a href="../utility/functional/greater_equal_void" title="cpp/utility/functional/greater equal void"><code>std::greater_equal&lt;void&gt;</code></a>.</li></ul> </td> <td><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <ul>
<li>int (b ::*pb) () = &amp; b :: f;<span class="sy1">&lt;=&gt;</span>int (l ::*pl) () = pb;<span class="br0">.</span><span class="br0">)</span>của<code><a href="../utility/compare/compare_three_way" title="cpp/utility/compare/compare three way">std::compare_three_way</a></code>.</li>
<li>int (b ::*pb) () = &amp; b :: f;<span class="sy1">==</span>int (l ::*pl) () = pb;<span class="br0">.</span><span class="br0">)</span>của<a href="../utility/functional/ranges/equal_to" title="cpp/utility/functional/ranges/equal to"><code>std::ranges::equal_to</code></a>Và<a href="../utility/functional/ranges/not_equal_to" title="cpp/utility/functional/ranges/not equal to"><code>std::ranges::not_equal_to</code></a>.</li>
<li>int (b ::*pb) () = &amp; b :: f;<span class="sy1">is_trivently_destructible_v</span>int (l ::*pl) () = pb;<span class="br0">.</span><span class="br0">)</span>của<a href="../utility/functional/ranges/less" title="cpp/utility/functional/ranges/less"><code>std::ranges::less</code></a>Thì<a href="../utility/functional/ranges/greater" title="cpp/utility/functional/ranges/greater"><code>std::ranges::greater</code></a>Thì<a href="../utility/functional/ranges/less_equal" title="cpp/utility/functional/ranges/less equal"><code>std::ranges::less_equal</code></a>, Và<a href="../utility/functional/ranges/greater_equal" title="cpp/utility/functional/ranges/greater equal"><code>std::ranges::greater_equal</code></a>.</li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <h4 id="Overloads">(Constexpr kể từ C ++ 14)</h4> <p>TRONG<a href="overload_resolution#Call_to_an_overloaded_operator" title="cpp/language/overload resolution">overload resolution against user-defined operators</a> <code>L</code>Và<code>R</code>int (r ::*pr) () = pb;</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">int (d ::*pdl) () = pl;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">int (d ::*pdr) () = pr;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp"> </pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool x = (pdl == pdr); // SAI</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool y = (pb == pl);   // ĐÚNG VẬY</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">Hai toán hạng</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>là lớn hơn và không xác định. Các giá trị được mang lại bởi các toán tử quan hệ để so sánh quan hệ con trỏ tích hợp được liệt kê dưới đây:<code>P</code>và cái khác là một con trỏ null hằng số so sánh bằng nhau.</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">So sánh quan hệ con trỏ tích hợp</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">Các toán hạng được chuyển đổi của các toán tử quan hệ</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">Cũng có thể có loại con trỏ.</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">So sánh quan hệ con trỏ tích hợp trên các gợi ý không đồng đều</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">có ba kết quả có thể:</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">là lớn hơn,</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>là lớn hơn và không xác định. Các giá trị được mang lại bởi các toán tử quan hệ để so sánh quan hệ con trỏ tích hợp được liệt kê dưới đây:<code>MP</code>Kết quả so sánh<span class="t-rev-inl t-since-cxx11"><span>hoặc<code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code></span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Tất cả các toán tử logic bitwise khác đều có thấp hơn</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">Giá trị mang lại bằng</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">là lớn hơn</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">là lớn hơn</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Nếu được chuyển đổi</pre></div> </div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <h3 id="Three-way_comparison">So sánh ba chiều</h3> <p>Cả hai là con trỏ,</p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <span class="t-spar">Một</span> <code>&lt;=&gt;</code> <span class="t-spar">Hành vi là không xác định nếu</span> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <p>được thực hiện trên cả hai toán hạng đã chuyển đổi để đưa chúng đến</p>
<ul>
<li> <code>(a &lt;=&gt; b) &lt; 0</code>nếu như<code>a &lt; b</code>Thì</li>
<li> <code>(a &lt;=&gt; b) &gt; 0</code>nếu như<code>a &gt; b</code>Thì</li>
<li> <code>(a &lt;=&gt; b) == 0</code>nếu như<code>a</code>Và<code>b</code>. Hai con trỏ của loại con trỏ tổng hợp được so sánh như sau:</li>
</ul> <p>Nếu các con trỏ so sánh kết quả so sánh bằng nhau hoặc kết quả so sánh bình đẳng là không xác định, kết quả so sánh quan hệ rơi vào cùng một loại.<span class="kw4">bool</span>Mặt khác (các con trỏ so sánh không đồng đều), nếu bất kỳ con trỏ nào không phải là một con trỏ đối tượng, kết quả không được xác định.</p>
<p>Mặt khác (cả hai gợi ý đều chỉ ra các đối tượng), kết quả được xác định theo thứ tự một phần phù hợp với các quy tắc sau:</p>
<ul>
<li>Đưa ra hai yếu tố khác nhau</li>
<li>của một mảng như vậy<a href="../utility/compare/strong_ordering" title="cpp/utility/compare/strong ordering"><code>std::strong_ordering</code></a>:</li>
<ul>
<li> <code>std::strong_ordering::equal</code>có chỉ số cao hơn</li>
<li> <code>std::strong_ordering::less</code>, nếu một con trỏ chỉ vào</li>
<li> <code>std::strong_ordering::greater</code>Nếu đối số đầu tiên là</li>
</ul>
<li>(hoặc một tiểu mục của<a href="../utility/compare/partial_ordering" title="cpp/utility/compare/partial ordering"><code>std::partial_ordering</code></a>là một biểu hiện ID không đủ tiêu chuẩn được chuẩn bị bởi một toán tử phân giải phạm vi<code>a &lt;=&gt; b</code>        std :: Common_Reference_T &lt;</li>
<ul>
<li> <code>std::partial_ordering::less</code>nếu như<code>a</code>là ít hơn<code>b</code>Thì</li>
<li> <code>std::partial_ordering::greater</code>nếu như<code>a</code>Để so sánh các giá trị.<code>b</code>Thì</li>
<li> <code>std::partial_ordering::equivalent</code>nếu như<code>a</code>Mẫu &lt;class T, class so sánh&gt;<code>b</code>.<code>-0 &lt;=&gt; +0</code>) và các con trỏ khác chỉ ra</li>
<li> <code>std::partial_ordering::unordered</code>.<code>NaN &lt;=&gt; anything</code>(hoặc một tiểu mục của</li>
</ul>
</ul> <p>), cái trước so sánh lớn hơn so với cái sau.<code>E</code>Nếu một con trỏ trỏ đến một phần tử<code>&lt;=&gt;</code>(hoặc cho một tiểu mục của</p>
<p>) của một mảng và con trỏ khác đã qua cuối cùng một mảng, con trỏ quá khứ so sánh lớn hơn con trỏ khác.<a href="implicit_conversion#Array-to-pointer_conversion" title="cpp/language/implicit conversion">array-to-pointer conversions</a>Thì<a href="implicit_conversion#Pointer_conversions" title="cpp/language/implicit conversion">pointer conversions</a>Và<a href="implicit_conversion#Qualification_conversions" title="cpp/language/implicit conversion">qualification conversions</a>Nếu một con trỏ trỏ đến một đối tượng hoàn chỉnh, tiểu mục lớp cơ sở hoặc tiểu đơn thành viên<a href="pointer#Composite_pointer_type" title="cpp/language/pointer">composite pointer type</a>.</p>
<p>(hoặc cho một tiểu mục của<code>p</code>Và<code>q</code>Thì<code>p &lt;=&gt; q</code>), và con trỏ khác đã qua kết thúc<a href="../utility/compare/strong_ordering" title="cpp/utility/compare/strong ordering"><code>std::strong_ordering</code></a>:</p>
<ul>
<li> <code>std::strong_ordering::equal</code>, con trỏ quá khứ so sánh lớn hơn con trỏ khác.<a href="#Built-in_pointer_equality_comparison">compare equal</a>Thì</li>
<li> <code>std::strong_ordering::less</code>nếu như<code>q</code> <a href="#Built-in_pointer_relational_comparison">compares greater than</a> <code>p</code>Thì</li>
<li> <code>std::strong_ordering::greater</code>nếu như<code>p</code>Nếu con trỏ chỉ ra sự khác biệt<code>q</code>Thì</li>
<li>của cùng một đối tượng của một loại lớp không liên kết hoặc các tiểu mục của các thành viên đó, đệ quy, con trỏ đến thành viên được tuyên bố sau này so sánh lớn hơn con trỏ khác.</li>
</ul> <p>Nếu không, phần tử là</p>
<h4 id="Overloads_2">(Constexpr kể từ C ++ 14)</h4> <p>TRONG<a href="overload_resolution#Call_to_an_overloaded_operator" title="cpp/language/overload resolution">overload resolution against user-defined operators</a>Nếu không, kết quả là không xác định.<code>T</code>Con trỏ tổng số đơn đặt hàng</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">Tồn tại một</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Ở đâu<code>R</code>thực hiện tổng số đơn đặt hàng nghiêm ngặt được xác định</p>
<div class="cpp source-cpp"><pre data-language="cpp">trong mỗi chương trình. Tổng số đơn đặt hàng nghiêm ngặt phù hợp với thứ tự một phần được mô tả ở trên: kết quả không xác định trở thành được xác định bằng cách thực hiện, trong khi các kết quả khác vẫn giữ nguyên.</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">So sánh con trỏ với tổng số đơn đặt hàng nghiêm ngặt được áp dụng trong các trường hợp sau:</pre></div> </td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <h3 id="Notes">Ghi chú</h3> <p>Gọi cho người vận hành<code>a &lt; b &lt; c</code>của các chuyên ngành loại con trỏ của<code>(a &lt; b) &lt; c</code>Gọi các toán tử tích hợp so sánh các con trỏ từ nhà điều hành<code>a &lt; (b &lt; c)</code>hoặc<code>(a &lt; b) &amp;&amp; (b &lt; c)</code>.</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">của các chuyên ngành</pre></div> </div> <p>Gọi toán tử tích hợp<a href="operators#Comparison_operators" title="cpp/language/operators">user-defined operator&lt;</a>khoảng cách<a class="extiw" href="https://en.wikipedia.org/wiki/Strict_weak_ordering" title="enwiki:Strict weak ordering">strict weak ordering</a>So sánh các con trỏ từ nhà điều hành<a href="../named_req/compare" title="cpp/named req/Compare">Compare</a>Gọi toán tử tích hợp<code><a href="../algorithm/sort" title="cpp/algorithm/sort">std::sort</a></code>Thì<code><a href="../algorithm/max_element" title="cpp/algorithm/max element">std::max_element</a></code>Thì<code><a href="../container/map" title="cpp/container/map">std::map</a></code>, vân vân.</p>
<p>Các<a href="#Member_layout">comparison result</a>So sánh các con trỏ từ nhà điều hành<span class="t-rev-inl t-until-cxx23"><span>Gọi toán tử tích hợp<a href="access" title="cpp/language/access">member access modes</a></span><span><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></span></span>So sánh các con trỏ từ nhà điều hành</p>
<p>, bao gồm các loại liệt kê, chữ ký chức năng sau đây tham gia vào độ phân giải quá tải:<a class="extiw" href="https://en.wikipedia.org/wiki/Total_order#Strict_total_order" title="enwiki:Total order">strict total ordering</a>toán tử bool &lt;(l, r);<code><a href="../utility/functional/less" title="cpp/utility/functional/less">std::less</a></code>toán tử bool&gt; (l, r);<code><a href="../container/set" title="cpp/container/set">std::set</a></code>hoặc<code><a href="../container/map" title="cpp/container/map">std::map</a></code>.</p>
<p>toán tử bool &lt;= (l, r);<a href="../named_req/equalitycomparable" title="cpp/named req/EqualityComparable">EqualityComparable</a>Và<a href="../named_req/lessthancomparable" title="cpp/named req/LessThanComparable">LessThanComparable</a>toán tử bool&gt; = (l, r);<i>toán tử bool == (l, r);</i>đó là con trỏ tới đối tượng hoặc con trỏ tới chức năng, chữ ký chức năng sau tham gia vào độ phân giải quá tải:<code>a == b</code>Và<i>Cho mọi loại</i>đó là con trỏ tới đối tượng hoặc con trỏ tới chức năng, chữ ký chức năng sau tham gia vào độ phân giải quá tải:<code>!(a &lt; b) &amp;&amp; !(b &lt; a)</code>.</p>
<p>toán tử bool &lt;(p, p);<a class="external text" href="https://cplusplus.github.io/CWG/issues/583.html" rel="nofollow">CWG issue 583</a>toán tử bool&gt; (p, p);<a class="external text" href="https://wg21.link/N3624" rel="nofollow">N3624</a>:</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">toán tử bool &lt;= (p, p);</pre></div> </div> <p>toán tử bool&gt; = (p, p);<a href="default_comparisons" title="cpp/language/default comparisons">default comparisons</a>.</p>
<p>toán tử bool == (p, p);</p>
<div class="cpp source-cpp"><pre data-language="cpp">toán tử bool! = (p, p);</pre></div> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../feature_test#cpp_impl_three_way_comparison" title="cpp/feature test"><code>__cpp_impl_three_way_comparison</code></a></td> <td><span class="nu0">201907L</span></td> <td><span class="t-mark">Phạm vi :: Construct_at</span></td> <td>Cho mọi loại</td>
</tr> <tr> <td><a href="../feature_test#cpp_lib_three_way_comparison" title="cpp/feature test"><code>__cpp_lib_three_way_comparison</code></a></td> <td><span class="nu0">201907L</span></td> <td><span class="t-mark">Phạm vi :: Construct_at</span></td> <td>Đó là một con trỏ đến đối tượng thành viên hoặc chức năng con trỏ đến thành viên</td>
</tr>
</table> <h3 id="Standard_library">Mẫu &lt;Class I2&gt;</h3> <p>toán tử bool == (MP, MP);</p>
<table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../types/type_info/operator_cmp" title="cpp/types/type info/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span></span></div> </td> <td>toán tử bool! = (MP, MP);<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::type_info</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../error/error_code/operator_cmp" title="cpp/error/error code/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>so sánh hai<code>error_code</code>S<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../error/error_condition/operator_cmp" title="cpp/error/error condition/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>so sánh<code>error_condition</code>cát<code>error_code</code>S<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/pair/operator_cmp" title="cpp/utility/pair/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>so sánh về mặt từ vựng các giá trị trong cặp<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/tuple/operator_cmp" title="cpp/utility/tuple/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>về mặt từ vựng so sánh các giá trị trong tuple<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/bitset/operator_cmp" title="cpp/utility/bitset/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span></span></div> </td> <td>#include &lt;Istream&gt;<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::bitset&lt;N&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/allocator/operator_cmp" title="cpp/memory/allocator/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span></span></div> </td> <td> <br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::allocator&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/unique_ptr/operator_cmp" title="cpp/memory/unique ptr/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>So sánh với người khác<code>unique_ptr</code>là một Symlink hiện có, bản thân nó bị xóa, không phải là mục tiêu của nó.<code>nullptr</code> <br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/operator_cmp" title="cpp/memory/shared ptr/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>So sánh với người khác<code>shared_ptr</code>là một Symlink hiện có, bản thân nó bị xóa, không phải là mục tiêu của nó.<code>nullptr</code> <br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/function/operator_cmp" title="cpp/utility/functional/function/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span></span></div> </td> <td>so sánh a<code><a href="../utility/functional/function" title="cpp/utility/functional/function">std::function</a></code>với<code>nullptr</code> <br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/duration/operator_cmp" title="cpp/chrono/duration/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>% người vận hành%<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/time_point/operator_cmp" title="cpp/chrono/time point/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Trả về điểm thời gian tương ứng với thời lượng nhỏ nhất<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/scoped_allocator_adaptor/operator_cmp" title="cpp/memory/scoped allocator adaptor/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span></span></div> </td> <td>So sánh hai phiên bản scoped_allocator_adaptor<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../types/type_index/operator_cmp" title="cpp/types/type index/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Cấu trúc foo<code><a href="../types/type_info" title="cpp/types/type info">std::type_info</a></code>Đối tượng<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::type_index</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/operator_cmp" title="cpp/string/basic string/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử&gt;</span><span>toán tử &lt;=</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>về mặt từ vựng so sánh hai chuỗi<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../locale/locale/operator_cmp" title="cpp/locale/locale/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span></span></div> </td> <td>{<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::locale</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/array/operator_cmp" title="cpp/container/array/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Hoạt động<code>arrays</code> <br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/deque/operator_cmp" title="cpp/container/deque/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Hoạt động<code>deques</code> <br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/forward_list/operator_cmp" title="cpp/container/forward list/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Hoạt động<code>forward_lists</code> <br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/list/operator_cmp" title="cpp/container/list/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Hoạt động<code>lists</code> <br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/vector/operator_cmp" title="cpp/container/vector/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Hoạt động<code>vectors</code> <br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/map/operator_cmp" title="cpp/container/map/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Hoạt động<code>maps</code> <br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/multimap/operator_cmp" title="cpp/container/multimap/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Hoạt động<code>multimaps</code> <br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/set/operator_cmp" title="cpp/container/set/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Hoạt động<code>sets</code> <br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/multiset/operator_cmp" title="cpp/container/multiset/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Hoạt động<code>multisets</code> <br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/unordered_map/operator_cmp" title="cpp/container/unordered map/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span></span></div> </td> <td>xô<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/unordered_multimap/operator_cmp" title="cpp/container/unordered multimap/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span></span></div> </td> <td>        khóa lớp,<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/unordered_set/operator_cmp" title="cpp/container/unordered set/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span></span></div> </td> <td>        khóa lớp,<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/unordered_multiset/operator_cmp" title="cpp/container/unordered multiset/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span></span></div> </td> <td>    Class Allocator = std :: Allocator &lt;Key&gt;<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/queue/operator_cmp" title="cpp/container/queue/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Hoạt động<code>queues</code> <br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/stack/operator_cmp" title="cpp/container/stack/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Hoạt động<code>stacks</code> <br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/reverse_iterator/operator_cmp" title="cpp/iterator/reverse iterator/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>so sánh các trình lặp cơ bản<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/move_iterator/operator_cmp" title="cpp/iterator/move iterator/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>so sánh các trình lặp cơ bản<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/istream_iterator/operator_cmp" title="cpp/iterator/istream iterator/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span></span></div> </td> <td>so sánh hai<code>istream_iterator</code>S<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/istreambuf_iterator/operator_cmp" title="cpp/iterator/istreambuf iterator/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span></span></div> </td> <td>so sánh hai<code>istreambuf_iterator</code>S<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/complex/operator_cmp" title="cpp/numeric/complex/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span></span></div> </td> <td>so sánh hai số phức hoặc một phức tạp và vô hướng<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/valarray/operator_cmp" title="cpp/numeric/valarray/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span></span></a></div> </td> <td>so sánh hai valarrays hoặc valarray với giá trị<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/random/linear_congruential_engine/operator_cmp" title="cpp/numeric/random/linear congruential engine/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span></span></div> </td> <td>    int n1;<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/random/poisson_distribution/operator_cmp" title="cpp/numeric/random/poisson distribution/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span></span></div> </td> <td>    int n2;<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../regex/sub_match/operator_cmp" title="cpp/regex/sub match/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>so sánh a<code>sub_match</code>với người khác<code>sub_match</code>, một chuỗi hoặc một ký tự<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../regex/match_results/operator_cmp" title="cpp/regex/match results/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span></span></div> </td> <td>về mặt từ vựng so sánh các giá trị trong hai kết quả trận đấu<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../regex/regex_iterator/operator_cmp" title="cpp/regex/regex iterator/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span></span></div> </td> <td>so sánh hai<code>regex_iterator</code>S<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::regex_iterator&lt;BidirIt,CharT,Traits&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../regex/regex_token_iterator/operator_cmp" title="cpp/regex/regex token iterator/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span></span></div> </td> <td>so sánh hai<code>regex_token_iterator</code>S<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::regex_token_iterator&lt;BidirIt,CharT,Traits&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../thread/thread/id/operator_cmp" title="cpp/thread/thread/id/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>so sánh hai<code>thread::id</code>Đối tượng<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> </table> <p>Không gian tên<a href="../utility/rel_ops/operator_cmp" title="cpp/utility/rel ops/operator cmp"><code>std::rel_ops</code></a>};<code>!=</code>Thì<code>&gt;</code>Thì<code>&lt;=</code>, Và<code>&gt;=</code>:</p>
<table class="t-dsc-begin"> <tr class="t-dsc-header"> <th colspan="2">C Thư viện<code><a href="../header/utility" title="cpp/header/utility">&lt;utility&gt;</a></code> </th>
</tr> <tr class="t-dsc-header"> <th colspan="2">(không thay đổi)<code>std::rel_ops</code> </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/rel_ops/operator_cmp" title="cpp/utility/rel ops/operator cmp"> <span class="t-lines"><span>toán tử! =</span><span>toán tử&gt;</span><span>toán tử &lt;=</span><span>toán tử&gt; =</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(Không dùng nữa trong C ++ 20)</span></span></span></div> </td> <td>Tự động tạo các toán tử so sánh dựa trên người dùng do người dùng xác định<code>operator==</code>Và<code>operator&lt;</code> <br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/583.html" rel="nofollow">CWG 583</a><br/>.<a class="external text" href="https://wg21.link/N3624" rel="nofollow">N3624</a>)</td> <td>C ++ 98</td> <td> <br/>Liên minh</td> <td>{</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/661.html" rel="nofollow">CWG 661</a> </td> <td>C ++ 98</td> <td>    int n;<br/>liệu<code>1 &lt; 2</code>        std :: Common_Reference_T &lt;<code>true</code>hoặc<code>false</code>    gấp đôi d;</td> <td>Mẫu &lt;int i&gt;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/879.html" rel="nofollow">CWG 879</a> </td> <td>C ++ 98</td> <td>};<br/>ĐẾN<span class="kw4">Vô hiệu</span> </td> <td>int main ()<br/>{</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1596.html" rel="nofollow">CWG 1596</a> </td> <td>C ++ 98</td> <td>    std :: cout &lt;&lt; std :: boolalpha;<br/> </td> <td>    char a [4] = "abc";<br/>    char* p1 = &amp; a [1];</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1598.html" rel="nofollow">CWG 1598</a> </td> <td>C ++ 98</td> <td>    char* p2 = &amp; a [2];<br/>    std :: cout &lt;&lt; "Con trỏ vào các phần tử mảng: \ n"<br/>              &lt;&lt; "P1 == P2?" &lt;&lt; (p1 == p2) &lt;&lt; '\ n'</td> <td>              &lt;&lt; "p1 &lt;p2?" &lt;&lt; (p1 &lt;p2) &lt;&lt; '\ n';<br/>    partial_sort (đầu tiên tôi, tôi giữa, s cuối cùng, comp comp = {}, proj proj = {});<br/>                     Forwardit2 s_first, forwardit2 s_last,</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1858.html" rel="nofollow">CWG 1858</a> </td> <td>C ++ 98</td> <td> <br/>    Foo f;<br/>    int* p3 = &amp; f.n1;</td> <td>    int* p4 = &amp; f.n2;<br/>    std :: cout &lt;&lt; "Con trỏ cho các thành viên của một lớp: \ n"</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2419.html" rel="nofollow">CWG 2419</a> </td> <td>C ++ 98</td> <td>    std :: uint32_t x2 = x0 &amp; ~ mặt nạ;<br/>    std :: uint32_t x3 = x0 &amp; mặt nạ;<br/>              &lt;&lt; "P3 == P4?" &lt;&lt; (p3 == p4) &lt;&lt; '\ n'<code>&amp;</code> </td> <td>    std :: uint32_t x5 = ~ x0;<br/>    sử dụng bin16 = std :: bitset &lt;16&gt;;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2526.html" rel="nofollow">CWG 2526</a> </td> <td>C ++ 98</td> <td>              &lt;&lt; "p3 &lt;p4?" &lt;&lt; (p3 &lt;p4) &lt;&lt; '\ n';<code>&gt;</code>Thì<code>&gt;=</code>Thì<code>&lt;</code>Và<code>&lt;=</code> <br/>    Liên minh u;<span class="kw4">Vô hiệu</span>    int* p5 = &amp; U.N;<a class="external text" href="https://wg21.link/N3624" rel="nofollow">N3624</a> </td> <td>    hệ điều hành &lt;&lt; '!';</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <ul>
<li> <a href="operator_precedence" title="cpp/language/operator precedence">Operator precedence</a> </li>
<li> <a href="operators" title="cpp/language/operators">Operator overloading</a> </li>
<li> <a href="../named_req/compare" title="cpp/named req/Compare">Compare</a>    gấp đôi* p6 = &amp; U.D;</li>
</ul> <table class="wikitable"> <tr style="text-align:center"> <th colspan="7">Các nhà khai thác chung</th>
</tr> <tr style="text-align:center"> <td>
<a href="operator_assignment" title="cpp/language/operator assignment">assignment</a> </td> <td>
<a href="operator_incdec" title="cpp/language/operator incdec">increment<br/>decrement</a> </td> <td>
<a href="operator_arithmetic" title="cpp/language/operator arithmetic">arithmetic</a> </td> <td>
<a href="operator_logical" title="cpp/language/operator logical">logical</a> </td> <td>
<strong class="selflink">    std :: cout &lt;&lt; "Con trỏ cho các thành viên của một liên minh: \ n"</strong> </td> <td>
<a href="operator_member_access" title="cpp/language/operator member access">member<br/>access</a> </td> <td>
<a href="operator_other" title="cpp/language/operator other">other</a> </td>
</tr> <tr style="text-align:center"> <td rowspan="6"> <p><code>a = b a += b a -= b a *= b a /= b a %= b a &amp;= b a |= b a ^= b a &lt;&lt;= b a &gt;&gt;= b</code></p>
</td> <td rowspan="6"> <p><code>++a --a a++ a--</code></p>
</td> <td rowspan="6"> <p><code>+a -a a + b a - b a * b a / b a % b ~a a &amp; b a | b a ^ b a &lt;&lt; b a &gt;&gt; b</code></p>
</td> <td rowspan="6"> <p><code>!a a &amp;&amp; b a || b</code></p>
</td> <td rowspan="6"> <p><code>a == b a != b a &lt; b a &gt; b a &lt;= b a &gt;= b a &lt;=&gt; b</code></p>
</td> <td rowspan="6"> <p><code>a[...] *a &amp;a a-&gt;b a.b a-&gt;*b a.*b</code></p>
</td> <td>Gọi chức năng</td>
</tr> <tr style="text-align:center"> <td>
<code>a(...)</code> </td>
</tr> <tr style="text-align:center"> <td>dấu phẩy</td>
</tr> <tr style="text-align:center"> <td>
<code>a, b</code> </td>
</tr> <tr style="text-align:center"> <td>có điều kiện</td>
</tr> <tr style="text-align:center"> <td>
<code>a ? b : c</code> </td>
</tr> <tr> <th colspan="7">Các nhà khai thác đặc biệt</th>
</tr> <tr> <td colspan="7"> <p><a href="static_cast" title="cpp/language/static cast"><code>static_cast</code></a>Chuyển đổi một loại thành loại liên quan khác<br/> <a href="dynamic_cast" title="cpp/language/dynamic cast"><code>dynamic_cast</code></a>Chuyển đổi trong hệ thống phân cấp thừa kế<br/> <a href="const_cast" title="cpp/language/const cast"><code>const_cast</code></a>thêm hoặc loại bỏ<a href="cv" title="cpp/language/cv">cv</a>-Qualifiers<br/> <a href="reinterpret_cast" title="cpp/language/reinterpret cast"><code>reinterpret_cast</code></a>Chuyển đổi loại thành loại không liên quan<br/> <a href="explicit_cast" title="cpp/language/explicit cast">C-style cast</a>Chuyển đổi loại này sang loại khác bằng cách kết hợp<code>static_cast</code>Thì<code>const_cast</code>, Và<code>reinterpret_cast</code> <br/> <a href="new" title="cpp/language/new"><code>new</code></a>Tạo các đối tượng có thời lượng lưu trữ động<br/> <a href="delete" title="cpp/language/delete"><code>delete</code></a>Các đối tượng phá hủy được tạo trước đây bởi biểu thức và bản phát hành mới thu được vùng bộ nhớ<br/> <a href="sizeof" title="cpp/language/sizeof"><code>sizeof</code></a>truy vấn kích thước của một loại<br/> <a href="sizeof..." title="cpp/language/sizeof..."><code>sizeof...</code></a>truy vấn kích thước của một<a href="parameter_pack" title="cpp/language/parameter pack">parameter pack</a> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span><br/> <a href="typeid" title="cpp/language/typeid"><code>typeid</code></a>truy vấn thông tin loại của một loại<br/> <a href="noexcept" title="cpp/language/noexcept"><code>noexcept</code></a>kiểm tra xem một biểu thức có thể ném một ngoại lệ<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span><br/> <a href="alignof" title="cpp/language/alignof"><code>alignof</code></a>// (thường là 4):<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></p>
</td>
</tr>
</table> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/operator_comparison" title="c/language/operator comparison">C documentation</a></span>vì<span class=""><span>    std :: hoán đổi (marray, other.marray);</span></span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/operator_comparison">https://en.cppreference.com/w/cpp/language/operator_comparison</a>
</p>
</div>
