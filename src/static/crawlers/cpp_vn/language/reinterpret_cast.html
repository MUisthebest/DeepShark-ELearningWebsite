 <h1 class="firstHeading" id="firstHeading">
<code>reinterpret_cast</code>chuyển đổi</h1> <p>Chuyển đổi giữa các loại bằng cách giải thích lại mẫu bit cơ bản.</p>
<h3 id="Syntax">Cú pháp</h3> <table class="t-sdsc-begin"> <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <code>reinterpret_cast&lt;</code> <span class="t-spar">Loại mục tiêu</span> <code>&gt;(</code> <span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span> <code>)</code> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <p>Trả về một giá trị của loại<span class="t-spar">Loại mục tiêu</span>.</p>
<h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3> <p>Không gian tên std :: Phạm vi<span class="kw1">Mẫu &lt;Biểu đồ lớp, Đặc điểm lớp, Alloc Class, Class Parsable&gt;</span>, nhưng thích<span class="kw1">thu được như thể bằng cách</span>    toán tử-= (const std :: chrono :: tháng &amp; dm) const noexcept;<span class="kw1">is_const_v</span>Biểu thức không biên dịch với bất kỳ hướng dẫn CPU nào (ngoại trừ khi chuyển đổi giữa số nguyên và con trỏ, hoặc giữa các con trỏ về các kiến ​​trúc tối nghĩa nơi biểu diễn con trỏ phụ thuộc vào loại của nó). Nó chủ yếu là một chỉ thị thời gian biên dịch hướng dẫn trình biên dịch<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>như thể nó có loại<span class="t-spar">Loại mục tiêu</span>.</p>
<p>Chỉ có thể thực hiện các chuyển đổi sau đây với<span class="kw1">is_const_v</span>, ngoại trừ khi nào các chuyển đổi như vậy sẽ<a href="const_cast#Casting_away_constness" title="cpp/language/const cast">cast away constness</a>(hoặc biến động).</p>
<div class="t-li1">
<span class="t-li">1)</span>Một biểu thức của tích phân, liệt kê, con trỏ hoặc loại con trỏ đến thành viên có thể được chuyển đổi thành loại riêng của nó. Giá trị kết quả giống như giá trị của<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>.</div> <div class="t-li1">
<span class="t-li">2)</span>Một con trỏ có thể được chuyển đổi thành bất kỳ loại tích phân nào đủ lớn để giữ tất cả các giá trị thuộc loại của nó (ví dụ:<code><a href="../types/integer" title="cpp/types/integer">std::uintptr_t</a></code>).</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Giá trị của bất kỳ loại tích phân hoặc loại liệt kê có thể được chuyển đổi thành loại con trỏ. Một con trỏ được chuyển đổi thành một số nguyên có kích thước đủ và trở lại cùng loại con trỏ được đảm bảo có giá trị ban đầu của nó, nếu không, con trỏ kết quả không thể được giải thích một cách an toàn (chuyển đổi đường tròn theo hướng ngược lại không được đảm bảo;<code><a href="../types/null" title="cpp/types/NULL">NULL</a></code>hoặc số nguyên không được đảm bảo để mang lại giá trị con trỏ null của loại mục tiêu;<a href="static_cast" title="cpp/language/static cast"><code>static_cast</code></a>hoặc<a class="mw-redirect" href="implicit_cast" title="cpp/language/implicit cast">implicit conversion</a>nên được sử dụng cho mục đích này.</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <span class="t-li">là trong</span>Bất kỳ giá trị nào của loại<code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code>, bao gồm<code>nullptr</code>có thể được chuyển đổi thành bất kỳ loại tích phân nào như thể nó<code>(void*)0</code>, nhưng không có giá trị, thậm chí không<code>nullptr</code>Khi thực hiện chuyển đổi mảng thành con trỏ (xem ở trên) hoặc<code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code>:<span class="kw1">Mẫu &lt;Biểu đồ lớp, Đặc điểm lớp, Alloc Class, Class Parsable&gt;</span>nên được sử dụng cho mục đích đó.</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Bất kỳ loại con trỏ đối tượng nào<code>T1*</code>có thể được chuyển đổi thành loại con trỏ đối tượng khác<code><i>không ngụ ý rằng</i> T2*</code>. Điều này hoàn toàn tương đương với<code>static_cast&lt;cv T2*&gt;(static_cast&lt;cv void*&gt;(expression))</code>(điều đó ngụ ý rằng nếu<code>T2</code>Yêu cầu liên kết không nghiêm ngặt hơn<code>T1</code>'s, giá trị của con trỏ không thay đổi và chuyển đổi con trỏ kết quả trở lại loại ban đầu mang lại giá trị ban đầu). Trong mọi trường hợp, con trỏ kết quả chỉ có thể được kiểm tra an toàn nếu được phép<i>loại bí danh</i>Quy tắc (xem bên dưới).</div> <div class="t-li1">
<span class="t-li">từ_sys</span>MỘT<span class="t-rev-inl t-until-cxx11"><span><a href="value_category#lvalue" title="cpp/language/value category">lvalue</a></span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span><a href="value_category#glvalue" title="cpp/language/value category">glvalue</a></span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Biểu hiện của loại<code>T1</code>có thể được chuyển đổi thành tham chiếu sang loại khác<code>T2</code>. Kết quả là của<code>*reinterpret_cast&lt;T2*&gt;(p)</code>là<code>p</code>là một con trỏ của loại con trỏ<code>T1</code>"Đối tượng được chỉ định bởi<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>. Không có tạm thời được tạo, không có bản sao nào được thực hiện, không có hàm tạo hoặc chức năng chuyển đổi được gọi. Tham chiếu kết quả chỉ có thể được truy cập một cách an toàn nếu được phép bởi<i>loại bí danh</i>Quy tắc (xem bên dưới).</div> <div class="t-li1">
<span class="t-li">6)</span>Bất kỳ con trỏ đến chức năng nào cũng có thể được chuyển đổi thành một con trỏ sang loại chức năng khác. Gọi hàm thông qua một con trỏ sang loại chức năng khác không được xác định, nhưng việc chuyển đổi con trỏ như vậy trở lại con trỏ sang loại hàm gốc mang lại con trỏ sang hàm gốc.</div> <div class="t-li1">
<span class="t-li">. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu biểu thức</span>Về một số triển khai (đặc biệt, trên bất kỳ hệ thống tương thích POSIX nào theo yêu cầu của<a class="external text" href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/dlsym.html" rel="nofollow"><code>dlsym</code></a>), một con trỏ hàm có thể được chuyển đổi thành<code>void*</code>hoặc bất kỳ con trỏ đối tượng khác, hoặc ngược lại. Nếu việc triển khai hỗ trợ chuyển đổi theo cả hai hướng, chuyển đổi thành loại ban đầu sẽ mang lại giá trị ban đầu, nếu không, con trỏ kết quả không thể bị hủy bỏ hoặc được gọi một cách an toàn.</div> <div class="t-li1">
<span class="t-li">được hình thành tốt. Chương trình không được hình thành nếu</span>Giá trị con trỏ null của bất kỳ loại con trỏ nào cũng có thể được chuyển đổi thành bất kỳ loại con trỏ nào khác, dẫn đến giá trị con trỏ null của loại đó. Lưu ý rằng hằng số con trỏ null<code>nullptr</code>hoặc bất kỳ giá trị nào khác của loại<code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code>không thể được chuyển đổi thành một con trỏ với<code>reinterpret_cast</code>: chuyển đổi ngầm hoặc<code>static_cast</code>nên được sử dụng cho mục đích này.</div> <div class="t-li1">
<span class="t-li">Toán tử bool constexpr&gt; (const std :: Chrono :: sys_time &lt;fending&gt; &amp; x,</span>Một hàm con trỏ sang thành viên có thể được chuyển đổi thành con trỏ sang một hàm thành viên khác của một loại khác. Chuyển đổi trở lại loại ban đầu mang lại giá trị ban đầu, nếu không, con trỏ kết quả không thể được sử dụng an toàn.</div> <div class="t-li1">
<span class="t-li">                           const std :: Chrono :: Leap_Second &amp; y) noExcept;</span>Một con trỏ tới đối tượng thành viên của một số lớp<code>T1</code>có thể được chuyển đổi thành một con trỏ sang đối tượng thành viên khác của lớp khác<code>T2</code>. Nếu như<code>T2</code>Sự liên kết của không nghiêm ngặt hơn<code>T1</code>'S, chuyển đổi trở lại loại ban đầu<code>T1</code>mang lại giá trị ban đầu, nếu không, con trỏ kết quả không thể được sử dụng một cách an toàn.</div> <p>T2</p>
<ul><li>Tham chiếu kết quả đề cập đến đối tượng ban đầu.<span class="t-spar">Loại mục tiêu</span>Giá trị con trỏ null có thể được chuyển đổi thành giá trị con trỏ null của<span class="t-rev-inl t-since-cxx11"><span>Loại mục tiêu</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Số lượng các yếu tố để sao chép</li></ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li>. Giá trị con trỏ thành viên null có thể được chuyển đổi thành giá trị con trỏ thành viên null của<span class="t-spar">Loại mục tiêu</span>Như với tất cả các biểu thức diễn viên, kết quả là:</li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <ul><li>một lvalue nếu</li></ul> <h3 id="Keywords">không định nghĩa macro như vậy. Tuy nhiên, nó xác định hằng số macro</h3> <p><a href="../keyword/reinterpret_cast" title="cpp/keyword/reinterpret cast"><code>reinterpret_cast</code></a></p>
<h3 id="Type_aliasing">Loại bí danh</h3> <p>Bất cứ khi nào một nỗ lực được thực hiện để đọc hoặc sửa đổi giá trị được lưu trữ của một đối tượng thuộc loại<code>DynamicType</code>thông qua một glvalue loại<code>AliasedType</code>, hành vi không được xác định trừ khi một trong những điều sau đây là đúng:</p>
<ul>
<li> <code>AliasedType</code>Và<code>DynamicType</code>&gt;<a href="implicit_conversion#Similar_types" title="cpp/language/implicit conversion">similar</a>.</li>
<li> <code>AliasedType</code>là (có thể<a href="cv" title="cpp/language/cv">cv</a>-qualified) đã ký hoặc biến thể không dấu của<code>DynamicType</code>.</li>
<li> <code>AliasedType</code>khoảng cách<span class="t-rev-inl t-since-cxx17"><span><a href="../types/byte" title="cpp/types/byte"><code>std::byte</code></a>Thì</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span> <span class="kw4">char</span>, hoặc<span class="kw4">STD</span> <span class="kw4">char</span>: Điều này cho phép kiểm tra<a href="object#Object_representation_and_value_representation" title="cpp/language/object">object representation</a>của bất kỳ đối tượng như một mảng của byte.</li>
</ul> <p>Quy tắc này cho phép phân tích bí danh dựa trên loại, trong đó trình biên dịch giả định rằng giá trị đọc qua một glvalue thuộc một loại không được sửa đổi bằng cách ghi vào một glvalue thuộc loại khác (tùy thuộc vào các ngoại lệ được ghi nhận ở trên).</p>
<p>Lưu ý rằng nhiều trình biên dịch C ++ thư giãn quy tắc này, dưới dạng mở rộng ngôn ngữ không chuẩn, để cho phép truy cập loại sai thông qua thành viên không hoạt động của<a href="union" title="cpp/language/union">union</a>(Truy cập như vậy không được xác định trong C).</p>
<h3 id="Notes">Ghi chú</h3> <p>Giả sử rằng các yêu cầu liên kết được đáp ứng, một<span class="kw1">is_const_v</span>không thay đổi<a href="pointer#Pointers" title="cpp/language/pointer">value of a pointer</a>ngoài một vài trường hợp hạn chế liên quan đến<a href="static_cast#pointer-interconvertible" title="cpp/language/static cast"><i>Con trỏ-interConvertible</i></a>Đối tượng:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct s1 {int a; } S1;</pre></div> <p>struct s2 {int a; Riêng tư: int B; } S2; // không phải là tiêu chuẩn<span class="kw1">is_const_v</span>Union u {int a; kép b; } u = {0};</p>
<div class="cpp source-cpp"><pre data-language="cpp">int mảng [2];</pre></div> <p> </p>
<p>int* p1 = reinterpret_cast &lt;int*&gt; (&amp; s1); // Giá trị của p1 là "con trỏ tới s1.a" vì<span class="kw4">int</span><span class="sy2">*</span>và a<span class="kw4">trôi nổi</span><span class="sy2">*</span>                                       // s1.a và s1 là con trỏ-interconbartable<a class="external text" href="https://web.archive.org/web/20201128194944/http://www.open-std.org/pipermail/ub/2016-February/000565.html" rel="nofollow">this email on SG12 reflector</a> </p>
<p>int* p2 = reinterpret_cast &lt;int*&gt; (&amp; s2); // Giá trị của P2 không thay đổi bởi reinterpret_cast<code><a href="../string/byte/memcpy" title="cpp/string/byte/memcpy">std::memcpy</a></code> <span class="t-rev-inl t-since-cxx20"><span>hoặc<a href="../numeric/bit_cast" title="cpp/numeric/bit cast"><code>std::bit_cast</code></a></span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>                                       // và là "con trỏ tới S2". </p>
<div class="cpp source-cpp"><pre data-language="cpp"> </pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>int* p3 = reinterpret_cast &lt;int*&gt; (&amp; u);  // Giá trị của P3 là "Con trỏ tới U.A":<code><a href="../types/integer" title="cpp/types/integer">std::intptr_t</a></code>và/hoặc<code><a href="../types/integer" title="cpp/types/integer">std::uintptr_t</a></code>                                       // u.a và u là con trỏ-interconbartable<i>không ngụ ý rằng</i> <span class="kw4">Vô hiệu</span> </p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <p>gấp đôi* p4 = reinterpret_cast &lt;double*&gt; (p3); // Giá trị của P4 là "con trỏ tới U.B": U.A và</p>
<ul>
<li> <code>AliasedType</code> <a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate type</a>hoặc a<a href="union" title="cpp/language/union">union</a>                                            // U.B là con trỏ-interConverible vì</li>
<li> <code>AliasedType</code>                                            // cả hai đều là con trỏ-interConverible với u<a href="cv" title="cpp/language/cv">cv</a>    int* p = &amp; a [2];<a href="derived_class" title="cpp/language/derived class">base class</a>của<code>DynamicType</code>.</li>
</ul> <p> <span class="kw4">STD</span> <span class="kw4">char</span>int* p5 = reinterpret_cast &lt;int*&gt; (&amp; mảng); // Giá trị của p5 không thay đổi bởi reinterpret_cast<a class="external text" href="https://cplusplus.github.io/CWG/issues/2051.html" rel="nofollow">CWG issue 2051</a>.</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example">
<p>                                        // và là "con trỏ tới mảng"<span class="kw1">is_const_v</span>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">Thực hiện quyền truy cập thành viên lớp chỉ định thành viên dữ liệu không tĩnh hoặc chức năng thành viên không tĩnh trên GlValue không thực sự chỉ định một đối tượng thuộc loại thích hợp-chẳng hạn như một đối tượng có</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">- Kết quả trong hành vi không xác định:</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/195.html" rel="nofollow">CWG 195</a> </td> <td>C ++ 98</td> <td>struct s {int x; };<br/>struct t {int x; int f (); };</td> <td>Hành vi sử dụng các chỉ thị không được xác định không theo tiêu chuẩn không rõ ràng</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/658.html" rel="nofollow">CWG 658</a> </td> <td>C ++ 98</td> <td>struct s1: s {};    // Layout tiêu chuẩn<br/>struct st: s, t {}; // không phải là tiêu chuẩn</td> <td> <br/>S s = {};<br/>Auto p = reinterpret_cast &lt;t*&gt; (&amp; s); // Giá trị của P là "Con trỏ tới S"</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/799.html" rel="nofollow">CWG 799</a> </td> <td>C ++ 98</td> <td>Tự động I = p-&gt; x; // Biểu thức truy cập thành viên lớp là hành vi không xác định;<br/>               // s không phải là đối tượng T<span class="kw1">is_const_v</span> </td> <td>hơn thứ hai, nếu không</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1268.html" rel="nofollow">CWG 1268</a> </td> <td>C ++ 11</td> <td>
<span class="kw1">is_const_v</span>p-&gt; x = 1; // Hành vi không xác định</td> <td>p-&gt; f ();   // Hành vi không xác định</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <a href="const_cast" title="cpp/language/const cast"> <code>const_cast</code> conversion </a> </td> <td>Sự mơ hồ ở trên cũng có thể xảy ra trong bối cảnh của một tuyên bố. Trong bối cảnh đó, sự lựa chọn là giữa một khai báo đối tượng với kiểu diễn viên theo kiểu chức năng là trình khởi tạo và khai báo liên quan đến một trình khai báo chức năng với một khoảng dấu ngoặc đơn xung quanh một tên tham số. Độ phân giải cũng là để xem xét bất kỳ cấu trúc nào, chẳng hạn như khai báo tham số tiềm năng, có thể là một tuyên bố là một tuyên bố:</td>
</tr> <tr class="t-dsc"> <td> <a href="static_cast" title="cpp/language/static cast"> <code>static_cast</code> conversion </a> </td> <td>cấu trúc s</td>
</tr> <tr class="t-dsc"> <td> <a href="dynamic_cast" title="cpp/language/dynamic cast"> <code>dynamic_cast</code> conversion </a> </td> <td>{</td>
</tr> <tr class="t-dsc"> <td> <a href="explicit_cast" title="cpp/language/explicit cast"> explicit casts </a> </td> <td> </td>
</tr> <tr class="t-dsc"> <td> <a class="mw-redirect" href="implicit_cast" title="cpp/language/implicit cast"> standard conversions </a> </td> <td>};</td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/bit_cast" title="cpp/numeric/bit cast"> <span class="t-lines"><span>BIT_CAST</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>diễn giải lại biểu diễn đối tượng của một loại là của một loại khác<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/reinterpret_cast">https://en.cppreference.com/w/cpp/language/reinterpret_cast</a>
</p>
</div>
