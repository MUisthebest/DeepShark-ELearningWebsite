 <h1 class="firstHeading" id="firstHeading"> </h1> <p>Truy cập một thành viên của toán hạng của nó.</p>
<table class="wikitable"> <tr> <th rowspan="2">Tên nhà điều hành</th> <th rowspan="2">Cú pháp</th> <th rowspan="2">
<a href="operators" title="cpp/language/operators">Over​load​able</a> </th> <th colspan="2">Ví dụ nguyên mẫu (cho<span class="kw1">lớp học</span>T)</th>
</tr> <tr> <th>Định nghĩa lớp bên trong</th> <th>Định nghĩa lớp bên ngoài</th>
</tr> <tr> <td>Đăng ký</td> <td>Một<span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span>Hành vi là không xác định nếu<span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span><table class="t-rev-begin"> <tr class="t-rev t-since-cxx23">
<td> <p>Một<span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span>...<span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span></p>
</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table> </td> <td class="table-yes">Đúng</td> <td>R<span class="sy3">Không có giá trị</span>T<span class="sy4">::</span><span class="me2">nhà điều hành</span><span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span><span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span><span class="br0">.</span>S b<span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span><table class="t-rev-begin"> <tr class="t-rev t-since-cxx23">
<td> <p>R<span class="sy3">Không có giá trị</span>T<span class="sy4">::</span><span class="me2">nhà điều hành</span><span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span><span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span><span class="br0">.</span>...<span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></p>
</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table> </td> <td class="table-na"> <small>N/a</small> </td>
</tr> <tr> <td>không định hướng</td> <td>
<span class="sy2">*</span>Một</td> <td class="table-yes">Đúng</td> <td>R<span class="sy3">Không có giá trị</span>T<span class="sy4">::</span><span class="me2">nhà điều hành</span><span class="sy2">*</span><span class="br0">.</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span> </td> <td>R<span class="sy3">Không có giá trị</span>nhà điều hành<span class="sy2">*</span><span class="br0">.</span>T a<span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span> </td>
</tr> <tr> <td>địa chỉ của</td> <td>
<span class="sy3">Không có giá trị</span>Một</td> <td class="table-yes">Đúng</td> <td>R<span class="sy2">*</span>T<span class="sy4">::</span><span class="me2">nhà điều hành</span><span class="sy3">Không có giá trị</span><span class="br0">.</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span> </td> <td>R<span class="sy2">*</span>nhà điều hành<span class="sy3">Không có giá trị</span><span class="br0">.</span>T a<span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span> </td>
</tr> <tr> <td>thành viên của đối tượng</td> <td>Một.<span class="me1">Hành vi là không xác định nếu</span> </td> <td class="table-no">KHÔNG</td> <td class="table-na"> <small>N/a</small> </td> <td class="table-na"> <small>N/a</small> </td>
</tr> <tr> <td>Thành viên của con trỏ</td> <td>Một<span class="sy2">-</span><span class="sy1">&lt;</span>Hành vi là không xác định nếu</td> <td class="table-yes">Đúng</td> <td>R<span class="sy2">*</span>T<span class="sy4">::</span><span class="me2">nhà điều hành</span><span class="sy2">-</span><span class="sy1">&lt;</span><span class="br0">.</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span> </td> <td class="table-na"> <small>N/a</small> </td>
</tr> <tr> <td>Con trỏ tới thành viên của đối tượng</td> <td>Một.<span class="sy2">*</span>Hành vi là không xác định nếu</td> <td class="table-no">KHÔNG</td> <td class="table-na"> <small>N/a</small> </td> <td class="table-na"> <small>N/a</small> </td>
</tr> <tr> <td>Con trỏ tới thành viên của con trỏ</td> <td>Một<span class="sy2">-</span><span class="sy1">&lt;</span><span class="sy2">*</span>Hành vi là không xác định nếu</td> <td class="table-yes">Đúng</td> <td>R<span class="sy3">Không có giá trị</span>T<span class="sy4">::</span><span class="me2">nhà điều hành</span><span class="sy2">-</span><span class="sy1">&lt;</span><span class="sy2">*</span><span class="br0">.</span>S b<span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span> </td> <td>R<span class="sy3">Không có giá trị</span>nhà điều hành<span class="sy2">-</span><span class="sy1">&lt;</span><span class="sy2">*</span><span class="br0">.</span>T a, s b<span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span> </td>
</tr> <tr> <td colspan="5"> <b>Ghi chú</b><br/> <ul><li>Như với hầu hết các quá tải do người dùng xác định, các loại trả về sẽ khớp với các loại trả về được cung cấp bởi các toán tử tích hợp để<a href="operators" title="cpp/language/operators">the user-defined operators</a>có thể được sử dụng theo cách tương tự như các bản dựng. Tuy nhiên, trong quá tải toán tử do người dùng xác định<span class="kw4">Vô hiệu</span>). Một ngoại lệ là toán tử<span class="sy2">-</span><span class="sy1">&lt;</span>, phải trả về một con trỏ hoặc lớp khác với toán tử quá tải<span class="sy2">-</span><span class="sy1">&lt;</span>có thể sử dụng thực tế.</li></ul> </td>
</tr>
</table> <h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3> <p>{<i>Đăng ký</i>toán tử cung cấp quyền truy cập vào một đối tượng được trỏ đến bởi<a href="pointer" title="cpp/language/pointer">pointer</a>hoặc<a href="array" title="cpp/language/array">array</a>Thoại.</p>
<p>{<i>không định hướng</i>Toán tử cung cấp quyền truy cập vào một đối tượng hoặc chức năng được chỉ ra bởi toán hạng con trỏ.</p>
<p>{<i>địa chỉ của</i>Toán tử tạo ra một con trỏ trỏ đến toán hạng đối tượng hoặc chức năng.</p>
<p><i>Thành viên của đối tượng</i>Và<i>Con trỏ tới thành viên của đối tượng</i>Các nhà khai thác cung cấp quyền truy cập vào một thành viên dữ liệu hoặc chức năng thành viên của toán hạng đối tượng.</p>
<p>{<i>Thành viên của con trỏ</i>Và<i>Con trỏ tới thành viên của con trỏ</i>Các nhà khai thác cung cấp quyền truy cập vào một thành viên dữ liệu hoặc chức năng thành viên của lớp được chỉ ra bởi toán hạng con trỏ.</p>
<h4 id="Built-in_subscript_operator">Toán tử giám sát tích hợp</h4> <p>Các biểu thức toán tử giám sát có biểu mẫu</p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <span class="t-spar">expr1</span>﻿<code>[</code><span class="t-spar">expr2</span>﻿<code>]</code> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">expr1</span>﻿<code>[{</code><span class="t-spar">struct {int c [3]; } s1, s2 = {3, 4, 5};</span>﻿<code>, ...</code><code>}]</code> </td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">expr1</span>﻿<code>[</code><span class="t-spar">expr2</span>﻿<code>,</code> <span class="t-spar">struct {int c [3]; } s1, s2 = {3, 4, 5};</span>﻿<code>, ...</code><code>]</code> </td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td>
</tr>
</table> <div class="t-li1">
<span class="t-li">1)</span>Đối với toán tử tích hợp, một trong những biểu thức (hoặc<span class="t-spar">expr1</span>hoặc<span class="t-spar">expr2</span>) phải là một glvalue của loại "mảng<code>T</code>"Hoặc một prvalue của loại con trỏ"<code>T</code>", Trong khi biểu thức khác (<span class="t-spar">expr2</span>hoặc<span class="t-spar">expr1</span>, tương ứng) phải là một prvalue của bảng liệt kê hoặc loại tích phân. Kết quả của biểu thức này có loại<code>T</code>.<span class="t-rev-inl t-since-cxx23"><span><span class="t-spar">expr2</span>không thể là một<a href="operator_other#Built-in_comma_operator" title="cpp/language/operator other">comma expression</a>.</span><span><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></span></span>
</div> <div class="t-li1">
<span class="t-li">2)</span>Biểu mẫu có danh sách được bao bọc trong các dấu ngoặc vuông chỉ được sử dụng để gọi quá tải<code>operator[]</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Biểu mẫu có danh sách biểu thức được phân tách bằng dấu phẩy bên trong dấu ngoặc vuông chỉ được sử dụng để gọi quá tải<code>operator[]</code>.</div> <p>Biểu thức chỉ số tích hợp<code>E1[E2]</code>hoàn toàn giống hệt với biểu thức<code>*(E1 + E2)</code>Ngoại trừ danh mục giá trị của nó (xem bên dưới)<span class="t-rev-inl t-since-cxx17"><span>Và<a href="eval_order" title="cpp/language/eval order">evaluation order</a></span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>: Toán tử con trỏ (có thể là kết quả của chuyển đổi mảng thành con trỏ và phải trỏ đến một phần tử của một số mảng hoặc một quá khứ<a href="operator_arithmetic" title="cpp/language/operator arithmetic">pointer arithmetic</a>, và sau đó bị thu hút.</p>
<p>Khi được áp dụng cho một mảng, biểu thức đăng ký là<a href="value_category" title="cpp/language/value category">lvalue</a><span class="t-rev-inl t-since-cxx11"><span>Nếu mảng là một lvalue và<a href="value_category" title="cpp/language/value category">xvalue</a>Nếu nó không</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>.</p>
<p>Khi được áp dụng cho một con trỏ, biểu thức phụ luôn là một lvalue.</p>
<p>phạm vi của các yếu tố để tạo<code>T</code>không được phép là một<a class="mw-redirect" href="incomplete_type" title="cpp/language/incomplete type">incomplete type</a>, ngay cả khi kích thước hoặc cấu trúc bên trong của<code>T</code>không bao giờ được sử dụng, như trong<code>&amp;x[0]</code>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20 t-until-cxx23">
<td> <p>Sử dụng một cái không bao gồm<a href="operator_other#Built-in_comma_operator" title="cpp/language/operator other">comma expression</a>Như đối số thứ hai (phải) của toán tử giám sát được không dùng nữa.</p>
<p>Ví dụ,<code>a[b, c]</code>được không dùng nữa và<code>a[(b, c)]</code>Toán tử Auto Auto của Const</p>
</td> <td>
<span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span><br/><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span>
</td>
</tr> <tr class="t-rev t-since-cxx23">
<td> <p>Một chưa được khám phá<a href="operator_other#Built-in_comma_operator" title="cpp/language/operator other">comma expression</a>Không thể là đối số thứ hai (bên phải) của toán tử giám sát. Ví dụ,<code>a[b, c]</code>là xấu hoặc tương đương với<code>a.operator[](b, c)</code>.</p>
<p>Dấu ngoặc đơn là cần thiết để sử dụng biểu thức dấu phẩy làm chỉ số, ví dụ:<code>a[(b, c)]</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table> <p>TRONG<a href="overload_resolution#Call_to_an_overloaded_operator" title="cpp/language/overload resolution">overload resolution against user-defined operators</a>, cho mọi loại đối tượng<code>T</code>.</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">T &amp; toán tử [] (t*, std :: ptrdiff_t);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">T &amp; toán tử [] (std :: ptrdiff_t, t*);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;Istream&gt;</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">#include &lt;Map&gt;</pre></div> </div> <h4 id="Built-in_indirection_operator">#include &lt;chuỗi&gt;</h4> <p> </p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <code>*</code><span class="t-spar">struct {int c [3]; } s1, s2 = {3, 4, 5};</span> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <p>int main ()<span class="t-spar">struct {int c [3]; } s1, s2 = {3, 4, 5};</span>{</p>
<p>    int a [4] = {1, 2, 3, 4};<a href="cv" title="cpp/language/cv">cv</a>    int* p = &amp; a [2];<span class="kw4">Vô hiệu</span>    std :: cout &lt;&lt; p [1] &lt;&lt; p [-1] &lt;&lt; 1 [p] &lt;&lt; (-1) [p] &lt;&lt; '\ n';</p>
<p>TRONG<a href="overload_resolution#Call_to_an_overloaded_operator" title="cpp/language/overload resolution">overload resolution against user-defined operators</a>, cho mọi loại<code>T</code> </p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">    std :: map &lt;std :: cặp &lt;int, int&gt;, std :: chuỗi&gt; m;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">    m [{1, 2}] = "ABC"; // sử dụng phiên bản [{...}]</pre></div> </div> <h4 id="Built-in_address-of_operator">}</h4> <p>4242</p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <code>&amp;</code><span class="t-spar">struct {int c [3]; } s1, s2 = {3, 4, 5};</span> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>&amp;</code><span class="t-spar">lớp học</span>﻿<code>::</code><span class="t-spar">là bộ lặp không đổi, nghĩa là, trình lặp không bao giờ có thể được sử dụng làm trình lặp đầu ra vì các phần tử sửa đổi không được phép.</span> </td> <td>(2)</td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <div class="t-li1">
<span class="t-li">1)</span>Toán tử liên tục tích hợp<code>T</code>Thì<code>operator&amp;</code>Các biểu thức toán tử gián tiếp có biểu mẫu<code>T*</code>Toán tử của toán tử liên tục tích hợp phải là con trỏ tới đối tượng hoặc một con trỏ để hoạt động và kết quả là lvalue đề cập đến đối tượng hoặc chức năng mà<code>operator&amp;</code>điểm.<code>operator&amp;</code>Thì<code><a href="../memory/addressof" title="cpp/memory/addressof">std::addressof</a></code>Một con trỏ tới (có thể<code>operator&amp;</code>-đạt tiêu chuẩn)<code>operator*</code>.</div> <div class="t-li1">không thể bị thu hẹp. Con trỏ đến các loại không hoàn chỉnh khác có thể được bỏ qua, nhưng lvalue thu được chỉ có thể được sử dụng trong các bối cảnh cho phép một loại không hoàn chỉnh, ví dụ: Khi khởi tạo một tài liệu tham khảo.<a href="overloaded_address" title="cpp/language/overloaded address">Address of an overloaded function</a> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx23">
<td> <p>Nếu như<span class="t-spar">struct {int c [3]; } s1, s2 = {3, 4, 5};</span>Đó là loại đối tượng (có thể có thể điều chỉnh CV) hoặc loại chức năng (không phải là const hoặc ref-đủ điều kiện), chữ ký chức năng sau đây tham gia vào độ phân giải quá tải:<a href="member_functions" title="cpp/language/member functions">explicit object member function</a>Thì<span class="t-spar">struct {int c [3]; } s1, s2 = {3, 4, 5};</span>T &amp; toán tử*(t*);<a href="identifiers#Qualified_identifiers" title="cpp/language/identifiers">qualified identifier</a>#include &lt;Istream&gt;<code>&amp;</code> </p>
</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table>
</div> <div class="t-li1">
<span class="t-li">2)</span>int f () {return 42; }<a href="union#Union-like_classes" title="cpp/language/union">variant</a>là bộ lặp không đổi, nghĩa là, trình lặp không bao giờ có thể được sử dụng làm trình lặp đầu ra vì các phần tử sửa đổi không được phép.<span class="t-rev-inl t-since-cxx23"><span> <a href="member_functions" title="cpp/language/member functions">explicit object member function</a></span><span><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></span></span>, ví dụ.<code>&amp;C::member</code>int main ()<a href="pointer#Pointers_to_member_functions" title="cpp/language/pointer">pointer to member function</a>hoặc<a href="pointer#Pointers_to_data_members" title="cpp/language/pointer">pointer to data member</a>nó đến một đối tượng<code>T</code>có thể được chuyển đổi thành một<code>C</code>{<code>&amp;member</code>constexpr outputit độc đáo_copy (đầu vào đầu tiên, đầu vào cuối cùng,<code>C::member</code>    int n = 1;<code>&amp;(C::member)</code>    int* pn = &amp; n;</div> <p>TRONG<a href="overload_resolution#Call_to_an_overloaded_operator" title="cpp/language/overload resolution">overload resolution against user-defined operators</a> <span class="sy3">Không có giá trị</span>Loại phần tử phải là<a href="overload_resolution#Viable_functions" title="cpp/language/overload resolution">viable function</a>.</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">    int &amp; r = *pn; // lvalue có thể bị ràng buộc với một tham chiếu</pre></div> </div> <h4 id="Built-in_member_access_operators">    int m = *pn;  // Indirection + lvalue sang rvalue chuyển đổi</h4> <p> </p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <span class="t-spar">struct {int c [3]; } s1, s2 = {3, 4, 5};</span>﻿<code>.template</code><span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">, với cùng một trình độ CV, đó là chỉ vào đối tượng hoặc chức năng được chỉ định bởi toán hạng. Nếu toán hạng có loại không đầy đủ, con trỏ có thể được hình thành, nhưng nếu loại không hoàn chỉnh đó là một lớp xác định</span> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">struct {int c [3]; } s1, s2 = {3, 4, 5};</span>﻿<code>-&gt;template</code><span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">, với cùng một trình độ CV, đó là chỉ vào đối tượng hoặc chức năng được chỉ định bởi toán hạng. Nếu toán hạng có loại không đầy đủ, con trỏ có thể được hình thành, nhưng nếu loại không hoàn chỉnh đó là một lớp xác định</span> </td> <td>(2)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">struct {int c [3]; } s1, s2 = {3, 4, 5};</span>﻿<code>.</code><span class="t-spar">    [] (...) {} (r, m, fr); // xóa cảnh báo "biến không sử dụng" có thể</span> </td> <td>(3)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">struct {int c [3]; } s1, s2 = {3, 4, 5};</span>﻿<code>-&gt;</code><span class="t-spar">    [] (...) {} (r, m, fr); // xóa cảnh báo "biến không sử dụng" có thể</span> </td> <td>(4)</td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <div class="t-li1">
<span class="t-li">1)</span>Các<span class="t-spar">struct {int c [3]; } s1, s2 = {3, 4, 5};</span>}<a class="mw-redirect" href="incomplete_type" title="cpp/language/incomplete type">complete</a>Địa chỉ tích hợp của nhà điều hành<code>T</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>Các<span class="t-spar">struct {int c [3]; } s1, s2 = {3, 4, 5};</span>Các biểu thức địa chỉ của toán tử có biểu mẫu<code>T*</code>.</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>Các<span class="t-spar">struct {int c [3]; } s1, s2 = {3, 4, 5};</span>Nếu toán hạng là biểu thức lvalue của một số đối tượng hoặc loại chức năng</div> <p><span class="t-spar">struct {int c [3]; } s1, s2 = {3, 4, 5};</span>tạo và trả về một loại prvalue</p>
<p><span class="t-spar">, với cùng một trình độ CV, đó là chỉ vào đối tượng hoặc chức năng được chỉ định bởi toán hạng. Nếu toán hạng có loại không đầy đủ, con trỏ có thể được hình thành, nhưng nếu loại không hoàn chỉnh đó là một lớp xác định</span>, nó không được xác định cho dù quá tải hoặc quá tải được sử dụng. Đối với các toán hạng của loại với người dùng do người dùng định nghĩa<a href="identifiers#In_expressions" title="cpp/language/identifiers">id-expression</a>có thể được sử dụng để có được con trỏ thực sự. Lưu ý rằng, không giống như các phiên bản C99 và sau C, không có trường hợp đặc biệt nào cho Unary<code>T</code>áp dụng cho kết quả của Unary<code>B</code>của<code>T</code>(ví dụ.<code>E1.E2</code>hoặc<code>E1-&gt;E2</code>Nếu toán hạng là tên của hàm quá tải, địa chỉ chỉ có thể được lấy nếu quá tải có thể được giải quyết do bối cảnh. Nhìn thấy<a href="identifiers#Qualified_identifiers" title="cpp/language/identifiers">qualified</a>(ví dụ.<code>E1.B::E2</code>hoặc<code>E1-&gt;B::E2</code>Đặt tên cho một<a href="dependent_name#template_disambiguator" title="cpp/language/dependent name"><span class="kw1">             STD :: mui trần_to &lt;const alloc &amp;, allocator&gt;</span> disambiguator</a>(ví dụ.<code>E1.template E2</code>hoặc<code>E1-&gt;template E2</code>).</p>
<p>phải là a<span class="sy2">-</span><span class="sy1">&lt;</span>. Áp dụng<span class="sy2">-</span><span class="sy1">&lt;</span>Để định danh không đủ tiêu chuẩn đặt tên một hàm thành viên đối tượng rõ ràng là không được hình thành.<span class="sy2">-</span><span class="sy1">&lt;</span>Nếu toán hạng là tên đủ điều kiện của một người không tĩnh hoặc</p>
<p>              Không có p);<code>E1-&gt;E2</code>hoàn toàn tương đương với<code>(*E1).E2</code>được đánh giá và loại bỏ trong cả hai trường hợp;<code>E1.E2</code>.</p>
<p>là loại tham chiếu<code>E1.E2</code>:</p>
<span class="t-li">1)</span>nếu như<code>E2</code>Điều đó như vậy<a href="static" title="cpp/language/static">static data member</a>:<ul>
<li>nếu như<code>E2</code>struct b {void f (); };<code>T&amp;</code> <span class="t-rev-inl t-since-cxx11"><span>hoặc<code>T&amp;&amp;</code></span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span> <code>T</code>có thể được sử dụng để khởi tạo một con trỏ đến thành viên.</li>
<li>, toán tử này không giới thiệu bất kỳ chữ ký chức năng bổ sung nào: địa chỉ tích hợp của toán tử không áp dụng nếu có tồn tại một toán tử quá tải<code>E2</code>(1,3)<code>T</code> <code>T</code>void f (double) {}</li>
</ul> <code>E1</code>Cấu trúc a {int i; };<span class="t-li">2)</span>nếu như<code>E2</code>Điều đó như vậy<a href="data_members" title="cpp/language/data members">non-static data member</a>:<ul>
<li>nếu như<code>E2</code>struct b {void f (); };<code>T&amp;</code> <span class="t-rev-inl t-since-cxx11"><span>hoặc<code>T&amp;&amp;</code></span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span> <code>T</code>int main ()<code>E1</code>{</li>
<li>    int n = 1;<code>E1</code>    int* pn = &amp; n;    // Con trỏ<code>E1</code>Thì</li>
<li>bị ràng buộc,<code>E1</code> <span class="t-rev-inl t-until-cxx17"><span>rvalue</span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span><span class="t-rev-inl t-since-cxx17"><span>Nếu không, nếu<a href="implicit_conversion#Temporary_materialization" title="cpp/language/implicit conversion">materialized</a>là một lvalue, kết quả là một lvalue chỉ định rằng thành viên dữ liệu không tĩnh của</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>Nếu không (nếu<span class="t-rev-inl t-until-cxx11"><span>rvalue</span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>XVALUE</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span> <code>E1</code>.</li>
</ul>Nếu như<code>E2</code>Cụ thể,<a href="cv#mutable_specifier" title="cpp/language/cv">mutable</a>    void (*pf) (int) = &amp; f; // Độ phân giải quá tải do bối cảnh khởi tạo<a href="cv" title="cpp/language/cv">cv-qualification</a>// tự động pf2 = &amp; f; // Lỗi: Loại chức năng quá tải mơ hồ<code>E1</code>Và<code>E2</code>    tự động pf2 = static_cast &lt;void (*) (int)&gt; (&amp; f); // Độ phân giải quá tải do diễn viên<code>E2</code>}<code>E1</code>Và<code>E2</code>Số lượng các yếu tố để sao chép<div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>nếu như<code>E2</code>Điều đó như vậy<a href="static" title="cpp/language/static">static member function</a>Các nhà khai thác truy cập thành viên tích hợp<code>E1</code>Các biểu thức toán tử truy cập thành viên có biểu mẫu</div> <div class="t-li1">
<span class="t-li">là trong</span>nếu như<code>E2</code>Điều đó như vậy<a href="member_functions" title="cpp/language/member functions">non-static member function</a>id-Expr<a href="destructor" title="cpp/language/destructor">destructor</a>id-Expr<code>E1</code>Pseudo-Destructor</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>nếu như<code>E2</code>Pseudo-Destructor<code>E2</code>(1,3)<code>T</code>, kết quả của sự so sánh là<span class="t-rev-inl t-until-cxx11"><span>một rvalue</span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>một prvalue</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>nó đến một đối tượng<code>T</code>Phải là một biểu hiện của</div> <div class="t-li1">
<span class="t-li">từ_sys</span>nếu như<code>E2</code>Điều đó như vậy<a class="mw-redirect" href="nested_classes" title="cpp/language/nested classes">nested type</a>Loại lớp</div> <div class="t-li1">
<span class="t-li">6)</span>nếu như<code>E1</code>Toán tử gán bản sao được xác định ngầm cho một lớp<a href="../named_req/scalartype" title="cpp/named req/ScalarType">ScalarType</a>Và<code>E2</code>Điều đó như vậy<code>~</code>theo sau là<a href="type#Type_naming" title="cpp/language/type">type name</a>hoặc<a href="decltype" title="cpp/language/decltype">decltype specifier</a>Phải là một biểu thức của con trỏ để hoàn thành loại lớp<a href="identifiers#Qualified_identifiers" title="cpp/language/identifiers">qualified</a>Phải là một biểu thức của loại vô hướng (xem bên dưới).<i>được đánh giá ngay cả khi không cần thiết (ví dụ: khi toán hạng thứ hai đặt tên cho thành viên tĩnh).</i>id-Expr<code>E1</code>là một tên của (chính thức, một<code>operator.</code>tên đó) một thành viên dữ liệu hoặc chức năng thành viên của</div> <p>hoặc của một lớp cơ sở rõ ràng và dễ tiếp cận<code>operator-&gt;</code>), tùy chọn<a href="overload_resolution#Call_to_an_overloaded_operator" title="cpp/language/overload resolution">overload resolution against user-defined operators</a>), tùy chọn sử dụng<span class="sy2">-</span><span class="sy1">&lt;</span>Nếu một nhà điều hành do người dùng xác định<span class="sy2">-</span><span class="sy1">&lt;</span>Loại phần tử phải là<a href="overload_resolution#Viable_functions" title="cpp/language/overload resolution">viable function</a>.</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">được gọi, toán tử</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">được gọi lại trên giá trị kết quả, đệ quy, cho đến khi người vận hành</pre></div> </div> <p>Nếu như<code>E2</code>đạt được mà trả về một con trỏ đơn giản. Sau đó, ngữ nghĩa tích hợp được áp dụng cho con trỏ đó.<code>E1</code>cho các loại tích hợp; Đó là lý do tại sao các quy tắc sau chỉ giải quyết<a href="implicit_conversion#Similar_types" title="cpp/language/implicit conversion">similar</a>, nếu không (nếu<code>E1</code>được thêm hoặc trừ như sau:</p>
<div class="cpp source-cpp"><pre data-language="cpp">là loại tham chiếu</pre></div> <h4 id="Built-in_pointer-to-member_access_operators">, kết quả là một loại loại</h4> <p>chỉ định đối tượng hoặc chức năng mà tham chiếu bị ràng buộc,</p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <span class="t-spar">Số lượng bọ ve trừ đi từ</span>﻿<code>.*</code><span class="t-spar">RHS</span> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">Số lượng bọ ve trừ đi từ</span>﻿<code>-&gt;*</code><span class="t-spar">RHS</span> </td> <td>(2)</td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <div class="t-li1">
<span class="t-li">1)</span> <span class="t-spar">Số lượng bọ ve trừ đi từ</span>nếu không, với loại<code>T</code>.</div> <div class="t-li1">
<span class="t-li">2)</span> <span class="t-spar">Số lượng bọ ve trừ đi từ</span>, kết quả là một loại loại<code>T*</code>.</div> <p><span class="t-spar">RHS</span>chỉ định thành viên dữ liệu tĩnh đó.<a href="pointer#Pointers_to_data_members" title="cpp/language/pointer">data</a>hoặc<a href="pointer#Pointers_to_member_functions" title="cpp/language/pointer">function</a> <code>T</code>Thiết yếu,<code>B</code>của<code>T</code>.</p>
<p>              Không có p);<code>E1-&gt;*E2</code>hoàn toàn tương đương với<code>(*E1).*E2</code>được đánh giá và loại bỏ trong cả hai trường hợp;<code>E1.*E2</code>.</p>
<p>là loại tham chiếu<code>E1.*E2</code>:</p>
<span class="t-li">1)</span>nếu như<code>E2</code>, kết quả là một loại loại<ul>
<li>nếu như<code>E1</code>chỉ định đối tượng hoặc chức năng mà thành viên tham chiếu tương ứng của</li>
<li>bị ràng buộc,<code>E1</code> <span class="t-rev-inl t-until-cxx17"><span>rvalue</span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span><span class="t-rev-inl t-since-cxx17"><span>Nếu không, nếu<a href="implicit_conversion#Temporary_materialization" title="cpp/language/implicit conversion">materialized</a>là một lvalue, kết quả là một lvalue chỉ định rằng thành viên dữ liệu không tĩnh của</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>Nếu không (nếu<span class="t-rev-inl t-until-cxx11"><span>rvalue</span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>XVALUE</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>xValue (có thể</li>
</ul> <div class="t-li1">
<span class="t-li">2)</span>nếu như<code>E2</code>từ prvalue)</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>), kết quả là một</div> <div class="t-li1">
<span class="t-li">là trong</span>nếu như<code>E2</code>chỉ định thành viên dữ liệu không tĩnh của</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Thành viên, The<code>E1</code>kết quả là sự kết hợp của các trình độ CV của<a href="implicit_conversion#Similar_types" title="cpp/language/implicit conversion">similar</a>, nếu không (nếu<code>E1</code>là một thành viên có thể thay đổi), đó là sự kết hợp của các cấp độ dễ bay hơi của<a href="object#Subobjects" title="cpp/language/object">most derived object</a>, kết quả là một lvalue chỉ định chức năng thành viên tĩnh đó. Thiết yếu,<code>E2</code>được đánh giá và loại bỏ trong trường hợp này;</div> <div class="t-li1">
<span class="t-li">từ_sys</span>nếu như<code>E1</code>bao gồm a<code>E2</code>, chương trình là xấu;<code>&amp;</code>chỉ có thể được sử dụng làm toán hạng bên trái của toán tử gọi chức năng thành viên và không có mục đích nào khác;<span class="t-rev-inl t-since-cxx20"><span>là một người liệt kê thành viên, với loại<code>const</code>Constexpr Iterator chèn (const_iterator pos,<code>volatile</code></span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>Số lượng các yếu tố để sao chép</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <span class="t-li">6)</span>nếu như<code>E1</code>có giá trị là giá trị của người liệt kê;<code>E2</code>, chương trình là xấu;<code>&amp;&amp;</code>, chương trình là xấu.</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <p>TRONG<a href="overload_resolution#Call_to_an_overloaded_operator" title="cpp/language/overload resolution">overload resolution against user-defined operators</a>chỉ định cùng loại (trừ CV-Sprice), tùy chọn<code>D</code>Thì<code>B</code>Thì<code>R</code>, kết quả là một loại prvalue đặc biệt chỉ có thể được sử dụng làm toán hạng bên trái của toán tử gọi chức năng và không có mục đích nào khác. Biểu thức cuộc gọi chức năng kết quả được gọi<code>B</code>Gọi phá hủy giả<code>D</code>. Nó không có đối số, trả về khoảng trống, đánh giá<code>D</code>, Và<code>R</code>và kết thúc tuổi thọ của đối tượng kết quả của nó. Đây là trường hợp duy nhất mà hoạt động bên trái của</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">có loại không lớp. Cho phép cuộc gọi phá hủy giả làm cho nó có thể viết mã mà không phải biết liệu một chất phá hủy có tồn tại cho một loại nhất định hay không.</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>nhà điều hành. không thể bị quá tải và cho</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">, TRONG</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">, toán tử tích hợp không giới thiệu bất kỳ chữ ký chức năng bổ sung nào: toán tử tích hợp</pre></div> </div> <h3 id="Standard_library">Mẫu &lt;Class I2&gt;</h3> <p>không áp dụng nếu tồn tại một toán tử quá tải</p>
<table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../utility/bitset/operator_at" title="cpp/utility/bitset/operator at"> <span class="t-lines"><span>nhà điều hành []</span></span></a></div> </td> <td>#include &lt;Cassert&gt;<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::bitset&lt;N&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/unique_ptr/operator_at" title="cpp/memory/unique ptr/operator at"> <span class="t-lines"><span>nhà điều hành []</span></span></a></div> </td> <td>#include &lt;Istream&gt;<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::unique_ptr&lt;T,Deleter&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/operator_at" title="cpp/string/basic string/operator at"> <span class="t-lines"><span>nhà điều hành []</span></span></a></div> </td> <td>#include &lt;nhớ&gt;<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::basic_string&lt;CharT,Traits,Allocator&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/array/operator_at" title="cpp/container/array/operator at"> <span class="t-lines"><span>nhà điều hành []</span></span></a></div> </td> <td>ghi đè mọi phần tử của mảng với phần tử tương ứng của một mảng khác<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::array&lt;T,N&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/deque/operator_at" title="cpp/container/deque/operator at"> <span class="t-lines"><span>nhà điều hành []</span></span></a></div> </td> <td>ghi đè mọi phần tử của mảng với phần tử tương ứng của một mảng khác<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::deque&lt;T,Allocator&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/vector/operator_at" title="cpp/container/vector/operator at"> <span class="t-lines"><span>nhà điều hành []</span></span></a></div> </td> <td>ghi đè mọi phần tử của mảng với phần tử tương ứng của một mảng khác<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::vector&lt;T,Allocator&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/map/operator_at" title="cpp/container/map/operator at"> <span class="t-lines"><span>nhà điều hành []</span></span></a></div> </td> <td>lặp theo thứ tự tăng dần của các khóa, trong đó tăng dần được xác định bằng cách so sánh được sử dụng để xây dựng. Đó là, được đưa ra<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::map&lt;Key,T,Compare,Allocator&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/unordered_map/operator_at" title="cpp/container/unordered map/operator at"> <span class="t-lines"><span>nhà điều hành []</span></span></a></div> </td> <td>lặp theo thứ tự tăng dần của các khóa, trong đó tăng dần được xác định bằng cách so sánh được sử dụng để xây dựng. Đó là, được đưa ra<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::unordered_map&lt;Key,T,Hash,KeyEqual,Allocator&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/reverse_iterator/operator_at" title="cpp/iterator/reverse iterator/operator at"> <span class="t-lines"><span>nhà điều hành []</span></span></a></div> </td> <td>Truy cập phần tử pointed-to<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::reverse_iterator&lt;Iter&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/move_iterator/operator_at" title="cpp/iterator/move iterator/operator at"> <span class="t-lines"><span>nhà điều hành []</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>Truy cập phần tử pointed-to<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::move_iterator&lt;Iter&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/valarray/operator_at" title="cpp/numeric/valarray/operator at"> <span class="t-lines"><span>nhà điều hành []</span></span></a></div> </td> <td> <br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::valarray&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../regex/match_results/operator_at" title="cpp/regex/match results/operator at"> <span class="t-lines"><span>nhà điều hành []</span></span></a></div> </td> <td>Cấu trúc p<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::match_results&lt;BidirIt,Alloc&gt;</code>)</span> </td>
</tr> </table> <p>{</p>
<table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../memory/unique_ptr/operator*" title="cpp/memory/unique ptr/operator*"> <span class="t-lines"><span>toán tử/=</span><span>toán tử-&gt;</span></span></a></div> </td> <td>    Mẫu &lt;Typename T&gt;<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::unique_ptr&lt;T,Deleter&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/operator*" title="cpp/memory/shared ptr/operator*"> <span class="t-lines"><span>toán tử/=</span><span>toán tử-&gt;</span></span></a></div> </td> <td>    tĩnh t* ptr () {trả về mới t; }<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::shared_ptr&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/auto_ptr/operator*" title="cpp/memory/auto ptr/operator*"> <span class="t-lines"><span>toán tử/=</span><span>toán tử-&gt;</span></span></a></div> </td> <td>};<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::auto_ptr&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/raw_storage_iterator/operator*" title="cpp/memory/raw storage iterator/operator*"> <span class="t-lines"><span>toán tử/=</span></span></a></div> </td> <td> <br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::raw_storage_iterator&lt;OutputIt,T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/reverse_iterator/operator*" title="cpp/iterator/reverse iterator/operator*"> <span class="t-lines"><span>toán tử/=</span><span>toán tử-&gt;</span></span></a></div> </td> <td>Mẫu &lt;Typename T&gt;<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::reverse_iterator&lt;Iter&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/back_insert_iterator/operator*" title="cpp/iterator/back insert iterator/operator*"> <span class="t-lines"><span>toán tử/=</span></span></a></div> </td> <td>không có op<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::back_insert_iterator&lt;Container&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/front_insert_iterator/operator*" title="cpp/iterator/front insert iterator/operator*"> <span class="t-lines"><span>toán tử/=</span></span></a></div> </td> <td>không có op<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::front_insert_iterator&lt;Container&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/insert_iterator/operator*" title="cpp/iterator/insert iterator/operator*"> <span class="t-lines"><span>toán tử/=</span></span></a></div> </td> <td>không có op<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::insert_iterator&lt;Container&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/move_iterator/operator*" title="cpp/iterator/move iterator/operator*"> <span class="t-lines"><span>toán tử/=</span><span>toán tử-&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span><span class="t-mark-rev t-deprecated-cxx20">(Không dùng nữa trong C ++ 20)</span></span></span></div> </td> <td>Truy cập trình lặp cơ bản<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::move_iterator&lt;Iter&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/istream_iterator/operator*" title="cpp/iterator/istream iterator/operator*"> <span class="t-lines"><span>toán tử/=</span><span>toán tử-&gt;</span></span></a></div> </td> <td>đối tượng được xây dựng, bằng cách gọi toán tử thích hợp<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::istream_iterator&lt;T,CharT,Traits,Distance&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/ostream_iterator/operator*" title="cpp/iterator/ostream iterator/operator*"> <span class="t-lines"><span>toán tử/=</span></span></a></div> </td> <td>không có op<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::ostream_iterator&lt;T,CharT,Traits&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/istreambuf_iterator/operator*" title="cpp/iterator/istreambuf iterator/operator*"> <span class="t-lines"><span>toán tử/=</span></span></a></div> </td> <td>off_type<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::istreambuf_iterator&lt;CharT,Traits&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/ostreambuf_iterator/operator*" title="cpp/iterator/ostreambuf iterator/operator*"> <span class="t-lines"><span>toán tử/=</span></span></a></div> </td> <td>không có op<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::ostreambuf_iterator&lt;CharT,Traits&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../regex/regex_iterator/operator*" title="cpp/regex/regex iterator/operator*"> <span class="t-lines"><span>toán tử/=</span><span>toán tử-&gt;</span></span></a></div> </td> <td>Cấu trúc a<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::regex_iterator&lt;BidirIt,CharT,Traits&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../regex/regex_token_iterator/operator*" title="cpp/regex/regex token iterator/operator*"> <span class="t-lines"><span>toán tử/=</span><span>toán tử-&gt;</span></span></a></div> </td> <td>{<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::regex_token_iterator&lt;BidirIt,CharT,Traits&gt;</code>)</span> </td>
</tr> </table> <p> <span class="sy3">Không có giá trị</span> <span class="sy3">Không có giá trị</span>    int n;<a class="external text" href="https://msdn.microsoft.com/en-us/library/31k6d0k7(v=vs.100).aspx" rel="nofollow"><code>CComPtr</code></a>    tĩnh int sn;<a class="external text" href="https://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/reference/operator/and_predicate.html" rel="nofollow">boost.spirit</a>.</p>
<p> <span class="sy2">-</span><span class="sy1">&lt;</span><span class="sy2">*</span>    int f () {return 10 + n; }<a class="external text" href="https://www.aristeia.com/Papers/DDJ_Oct_1999.pdf" rel="nofollow">smart pointer interface</a>) được gọi với một đối số số nguyên<a class="external text" href="https://www.boost.org/doc/libs/release/libs/phoenix/doc/html/phoenix/modules/operator.html#phoenix.modules.operator.member_pointer_operator" rel="nofollow">boost.phoenix</a>    tĩnh int sf () {return 4; }<a class="external text" href="https://github.com/schlangster/cpp.react/blob/master/include/react/Signal.h#L557" rel="nofollow">cpp.react</a>.</p>
<h3 id="Notes">Ghi chú</h3> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>Tính năng Test Macro</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../feature_test#cpp_multidimensional_subscript" title="cpp/feature test"><code>__cpp_multidimensional_subscript</code></a></td> <td><span class="nu0">3)</span></td> <td><span class="t-mark">Phạm vi :: IOTA</span></td> <td>
<a href="operators#Array_subscript_operator" title="cpp/language/operators">Multidimensional subscript operator</a> </td>
</tr>
</table> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1213.html" rel="nofollow">CWG 1213</a> </td> <td>C ++ 11</td> <td> </td> <td>    lớp B {};</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1458.html" rel="nofollow">CWG 1458</a> </td> <td>C ++ 98</td> <td>    enum e {red = 1, blue = 2};<code>&amp;</code> <br/>tuyên bố<code>operator&amp;</code>    void g ()</td> <td>    {<br/>              &lt;&lt; (Thành công? "Thành công \ n": "thất bại \ n");<code>&amp;</code>    hoán đổi ( *a, *b);</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1642.html" rel="nofollow">CWG 1642</a> </td> <td>C ++ 98</td> <td>các<span class="t-spar">RHS</span>        typedef int u;</td> <td> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1800.html" rel="nofollow">CWG 1800</a> </td> <td>C ++ 98</td> <td>        // Mẫu từ khóa cần thiết cho một thành viên mẫu phụ thuộc<code>&amp;</code>        int* p = t (). Mẫu ptr &lt;u&gt; ();<br/>        p-&gt; ~ u (); // u là int, gọi cho kẻ phá hủy giả của int<br/>        Xóa p;</td> <td>    }<br/>};<br/> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2614.html" rel="nofollow">CWG 2614</a> </td> <td>C ++ 98</td> <td>(Nói cách khác, việc thêm một khai báo chức năng mới sau khi định nghĩa mẫu không hiển thị nó, ngoại trừ thông qua ADL).<code>E1.E2</code>Mẫu &lt;&gt;<code>E2</code>int a &lt;p&gt; :: sn = 2;</td> <td>hơn thứ hai, nếu không</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <p><a href="operator_precedence" title="cpp/language/operator precedence">Operator precedence</a></p>
<p><a href="operators" title="cpp/language/operators">Operator overloading</a></p>
<table class="wikitable"> <tr style="text-align:center"> <th colspan="7">Các nhà khai thác chung</th>
</tr> <tr style="text-align:center"> <td>
<a href="operator_assignment" title="cpp/language/operator assignment">assignment</a> </td> <td>
<a href="operator_incdec" title="cpp/language/operator incdec">increment<br/>decrement</a> </td> <td>
<a href="operator_arithmetic" title="cpp/language/operator arithmetic">arithmetic</a> </td> <td>
<a href="operator_logical" title="cpp/language/operator logical">logical</a> </td> <td>
<a href="operator_comparison" title="cpp/language/operator comparison">comparison</a> </td> <td>
<strong class="selflink">là bộ lặp không đổi, nghĩa là, trình lặp không bao giờ có thể được sử dụng làm trình lặp đầu ra vì các phần tử sửa đổi không được phép.<br/>truy cập</strong> </td> <td>
<a href="operator_other" title="cpp/language/operator other">other</a> </td>
</tr> <tr style="text-align:center"> <td rowspan="6"> <p><code>a = b a += b a -= b a *= b a /= b a %= b a &amp;= b a |= b a ^= b a &lt;&lt;= b a &gt;&gt;= b</code></p>
</td> <td rowspan="6"> <p><code>++a --a a++ a--</code></p>
</td> <td rowspan="6"> <p><code>+a -a a + b a - b a * b a / b a % b ~a a &amp; b a | b a ^ b a &lt;&lt; b a &gt;&gt; b</code></p>
</td> <td rowspan="6"> <p><code>!a a &amp;&amp; b a || b</code></p>
</td> <td rowspan="6"> <p><code>a == b a != b a &lt; b a &gt; b a &lt;= b a &gt;= b a &lt;=&gt; b</code></p>
</td> <td rowspan="6"> <p><code>a[...] *a &amp;a a-&gt;b a.b a-&gt;*b a.*b</code></p>
</td> <td>Gọi chức năng</td>
</tr> <tr style="text-align:center"> <td>
<code>a(...)</code> </td>
</tr> <tr style="text-align:center"> <td>dấu phẩy</td>
</tr> <tr style="text-align:center"> <td>
<code>a, b</code> </td>
</tr> <tr style="text-align:center"> <td>có điều kiện</td>
</tr> <tr style="text-align:center"> <td>
<code>a ? b : c</code> </td>
</tr> <tr> <th colspan="7">Các nhà khai thác đặc biệt</th>
</tr> <tr> <td colspan="7"> <p><a href="static_cast" title="cpp/language/static cast"><code>static_cast</code></a>Chuyển đổi một loại thành loại liên quan khác<br/> <a href="dynamic_cast" title="cpp/language/dynamic cast"><code>dynamic_cast</code></a>Chuyển đổi trong hệ thống phân cấp thừa kế<br/> <a href="const_cast" title="cpp/language/const cast"><code>const_cast</code></a>thêm hoặc loại bỏ<a href="cv" title="cpp/language/cv">cv</a>-Qualifiers<br/> <a href="reinterpret_cast" title="cpp/language/reinterpret cast"><code>reinterpret_cast</code></a>Chuyển đổi loại thành loại không liên quan<br/> <a href="explicit_cast" title="cpp/language/explicit cast">C-style cast</a>Chuyển đổi loại này sang loại khác bằng cách kết hợp<code>static_cast</code>Thì<code>const_cast</code>, Và<code>reinterpret_cast</code> <br/> <a href="new" title="cpp/language/new"><code>new</code></a>Tạo các đối tượng có thời lượng lưu trữ động<br/> <a href="delete" title="cpp/language/delete"><code>delete</code></a>Các đối tượng phá hủy được tạo trước đây bởi biểu thức và bản phát hành mới thu được vùng bộ nhớ<br/> <a href="sizeof" title="cpp/language/sizeof"><code>sizeof</code></a>truy vấn kích thước của một loại<br/> <a href="sizeof..." title="cpp/language/sizeof..."><code>sizeof...</code></a>truy vấn kích thước của một<a href="parameter_pack" title="cpp/language/parameter pack">parameter pack</a> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span><br/> <a href="typeid" title="cpp/language/typeid"><code>typeid</code></a>truy vấn thông tin loại của một loại<br/> <a href="noexcept" title="cpp/language/noexcept"><code>noexcept</code></a>kiểm tra xem một biểu thức có thể ném một ngoại lệ<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span><br/> <a href="alignof" title="cpp/language/alignof"><code>alignof</code></a>// (thường là 4):<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></p>
</td>
</tr>
</table> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/operator_member_access" title="c/language/operator member access">C documentation</a></span>vì<span class=""><span> </span></span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/operator_member_access">https://en.cppreference.com/w/cpp/language/operator_member_access</a>
</p>
</div>
