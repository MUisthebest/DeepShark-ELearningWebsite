 <h1 class="firstHeading" id="firstHeading">Sao chép Elision</h1> <p>Bỏ qua bản sao<span class="t-rev-inl t-since-cxx11"><span>Điều này chỉ có thể được áp dụng khi đối tượng được khởi tạo được biết là không phải là một tiểu mục có khả năng vượt qua:</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>các nhà xây dựng, dẫn đến ngữ nghĩa thông qua không có giá trị.</p>
<h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <h4 id="Prvalue_semantics_.28.22guaranteed_copy_elision.22.29">Ngữ nghĩa prvalue ("Giải quyết bản sao được bảo đảm")</h4> <p>Vì C ++ 17, một prvalue không được thực hiện cho đến khi cần thiết, và sau đó nó được xây dựng trực tiếp vào việc lưu trữ đích đến cuối cùng. Điều này đôi khi có nghĩa là ngay cả khi cú pháp ngôn ngữ gợi ý trực quan một bản sao/di chuyển (ví dụ:<a href="copy_initialization" title="cpp/language/copy initialization">copy initialization</a>), không có bản sao/di chuyển nào được thực hiện - có nghĩa là loại không cần phải có một hàm tạo sao chép/di chuyển có thể truy cập được. Ví dụ bao gồm:</p>
<ul><li>Khởi tạo đối tượng được trả về trong một<a href="return" title="cpp/language/return">return statement</a>, khi toán hạng là một<a href="value_category" title="cpp/language/value category">prvalue</a>                // sau đó khởi tạo t trả về từ tạm thời<a href="cv" title="cpp/language/cv">cv-qualification</a>) là loại trả về chức năng:</li></ul> <div class="cpp source-cpp"><pre data-language="cpp">T f ()</pre></div>{<ul><li>    trả lại u (); // xây dựng tạm thời loại U,<a href="value_category" title="cpp/language/value category">prvalue</a>                // sau đó khởi tạo t trả về từ tạm thời<a href="cv" title="cpp/language/cv">cv-qualification</a>}</li></ul> <div class="cpp source-cpp"><pre data-language="cpp">T g ()</pre></div>{<div class="cpp source-cpp"><pre data-language="cpp">    trả lại t (); // xây dựng trực tiếp T trả về; Không di chuyển</pre></div> <p>}<a href="value_category" title="cpp/language/value category">prvalues</a>Và<a href="implicit_conversion#Temporary_materialization" title="cpp/language/implicit conversion">temporaries</a>Chất phá hủy của loại được trả về phải được truy cập tại điểm của câu lệnh trả về và không bị xóa, mặc dù không có đối tượng T nào bị phá hủy.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <h4 id="Non-mandatory_copy.2Fmove.28since_C.2B.2B11.29_elision">Trong việc khởi tạo một đối tượng, khi biểu thức khởi tạo là một<span class="t-rev-inl t-since-cxx11"><span>/di chuyển</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>) là loại biến:</h4> <p>T x = t (t (f ())); // x được khởi tạo trực tiếp bởi kết quả của f (); Không di chuyển<span class="t-rev-inl t-since-cxx11"><span>Điều này chỉ có thể được áp dụng khi đối tượng được khởi tạo được biết là không phải là một tiểu mục có khả năng vượt qua:</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>struct c { / * ... * /};<span class="t-rev-inl t-since-cxx11"><span>/di chuyển</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span> <span class="t-rev-inl t-since-cxx11"><span>/di chuyển</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>D g ();</p>
<ul><li>Trong a<a href="return" title="cpp/language/return">return statement</a> <a href="cv" title="cpp/language/cv">cv-qualification</a>Struct D: C</li></ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <ul><li>{<a href="cv" title="cpp/language/cv">cv-qualification</a>    D (): c (f ()) {} // không chọn ra khi khởi tạo một tiểu mục lớp cơ sở</li></ul> </td> <td><span class="t-mark-rev t-until-cxx17">xáo trộn</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <p>    D (int): d (g ()) {} // không chọn ra vì đối tượng D được khởi tạo có thể</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul>
<li>Trong a<a href="throw" title="cpp/language/throw">throw-expression</a>                       // là một tiểu mục thuộc lớp cơ sở của một số lớp khác</li>
<li>Trong a<a href="try_catch" title="cpp/language/try catch">catch clause</a>};<a href="cv" title="cpp/language/cv">cv-qualification</a>LƯU Ý: Quy tắc này không chỉ định tối ưu hóa và tiêu chuẩn không chính thức mô tả nó là "bỏ phiếu sao chép" (vì không có gì được giải quyết). Thay vào đó, đặc điểm kỹ thuật ngôn ngữ cốt lõi của C ++ 17<code>throw</code>).</li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <ul><li>TRONG<a href="coroutines" title="cpp/language/coroutines">coroutines</a>Về cơ bản là khác biệt so với các bản sửa đổi C ++ trước đó: không còn là tạm thời để sao chép/chuyển từ. Một cách khác để mô tả cơ học C ++ 17 là "giá trị không vật chất hóa" hoặc "hóa vật liệu tạm thời trì hoãn": prvalues ​​được trả lại và sử dụng mà không bao giờ thực hiện tạm thời.</li></ul> </td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <p>Bản sao không bắt buộc<span class="t-rev-inl t-since-cxx11"><span>/di chuyển</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>bầu chọn<span class="t-rev-inl t-since-cxx11"><span>Trong các trường hợp sau, các trình biên dịch được phép, nhưng không bắt buộc phải bỏ qua bản sao</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>.</p>
<p>và di chuyển</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li>TRONG<a href="constant_expression" title="cpp/language/constant expression">constant expression</a>Và<a href="constant_initialization" title="cpp/language/constant initialization">constant initialization</a>Xây dựng các đối tượng lớp ngay cả khi bản sao</li></ul> <div class="cpp source-cpp"><pre data-language="cpp">/di chuyển</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <h3 id="Notes">Ghi chú</h3> <p>người xây dựng và chất phá hủy có tác dụng phụ có thể quan sát được. Các đối tượng được xây dựng trực tiếp vào bộ lưu trữ nơi chúng sẽ được sao chép/chuyển đến. Đây là một tối ưu hóa: ngay cả khi nó diễn ra và bản sao<span class="t-rev-inl t-until-cxx14"><span>/di chuyển</span><span><span class="t-mark-rev t-until-cxx14">Constexpr std :: cặp &lt;const t &amp;, const t &amp;&gt; minmax (const t &amp; a, const t &amp; b,</span></span></span> <span class="t-rev-inl t-since-cxx14"><span>Constructor không được gọi, nó vẫn phải có mặt và có thể truy cập (như thể không có tối ưu hóa nào xảy ra), nếu không chương trình không được hình thành:<a href="new#Allocation" title="cpp/language/new">allocation elision and extension</a>Thì</span><span><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></span></span>, khi toán hạng là tên của một đối tượng không bay hơi có thời lượng lưu trữ tự động, không phải là tham số hàm hoặc tham số mệnh đề bắt và cùng loại loại (bỏ qua</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>) là loại trả về chức năng. Biến thể của Elision bản sao này được gọi là NRVO, "Tối ưu hóa giá trị trả về."<span class="t-rev-inl t-until-cxx23"><span>Trong việc khởi tạo một đối tượng, khi đối tượng nguồn là tạm thời không tên và có cùng loại lớp (bỏ qua</span><span><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></span></span> <span class="t-rev-inl t-since-cxx23"><span>) là đối tượng đích. Khi tạm thời không tên là toán hạng của một câu lệnh trả lại, biến thể của Elision sao chép này được gọi là URVO, "Tối ưu hóa giá trị trả về không tên."</span><span><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></span></span>URVO là bắt buộc và không còn được coi là một hình thức bỏ phiếu sao chép; Xem ở trên.<a href="return#Notes" title="cpp/language/return">return statement</a> </p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>Tính năng Test Macro</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../feature_test#cpp_guaranteed_copy_elision" title="cpp/feature test"><code>__cpp_guaranteed_copy_elision</code></a></td> <td><span class="nu0">, khi toán hạng là tên của một đối tượng không bay hơi có thời lượng lưu trữ tự động, đây không phải là tham số hàm hoặc tham số mệnh đề bắt và phạm vi của họ không mở rộng qua khối thử trong cùng (nếu có khối thử).</span></td> <td><span class="t-mark">Dest_at</span></td> <td>Sao chép được bảo đảm thông qua đơn giản hóa<a href="value_category" title="cpp/language/value category">value categories</a> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">, khi đối số có cùng loại (bỏ qua</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">) Khi đối tượng ngoại lệ bị ném, bản sao của đối tượng ngoại lệ bị bỏ qua và phần thân của mệnh đề Catch truy cập trực tiếp đối tượng ngoại lệ, như thể bị bắt bởi tham chiếu (không thể có một động tác từ đối tượng ngoại lệ vì nó luôn là một lvalue). Điều này bị vô hiệu hóa nếu việc bỏ phiếu sao như vậy sẽ thay đổi hành vi có thể quan sát được của chương trình vì bất kỳ lý do nào khác ngoài việc bỏ qua hàm tạo bản sao và bộ hủy của đối số mệnh đề bắt (ví dụ: nếu đối số mệnh đề bắt được sửa đổi và đối tượng ngoại lệ được tái hiện với</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1967.html" rel="nofollow">CWG 1967</a> </td> <td>C ++ 11</td> <td>, Sao chép/Di chuyển của tham số vào trạng thái Coroutine có thể được chuyển trong đó điều này không thay đổi hành vi của chương trình khác ngoài việc bỏ qua các cuộc gọi đến hàm tạo và hàm hủy của tham số. Điều này có thể diễn ra nếu tham số không bao giờ được tham chiếu sau điểm đình chỉ hoặc khi toàn bộ trạng thái Coroutine không bao giờ được phân bổ ở nơi đầu tiên.<br/>Khi xảy ra việc giải quyết bản sao, việc triển khai xử lý nguồn và mục tiêu của bản sao bị bỏ qua</td> <td>/di chuyển</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2022.html" rel="nofollow">CWG 2022</a> </td> <td>C ++ 11</td> <td>Hoạt động chỉ đơn giản là hai cách khác nhau để đề cập đến cùng một đối tượng và sự phá hủy đối tượng đó xảy ra vào lúc này khi hai đối tượng sẽ bị phá hủy mà không có tối ưu hóa</td> <td>.</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2278.html" rel="nofollow">CWG 2278</a> </td> <td>C ++ 11</td> <td>Nhiều bản sao có thể được xích để loại bỏ nhiều bản sao.</td> <td>, Sao chép Elision không bao giờ được thực hiện.</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2426.html" rel="nofollow">CWG 2426</a> </td> <td>C ++ 17</td> <td>Cấu trúc a</td> <td>{</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <ul>
<li> <a href="copy_initialization" title="cpp/language/copy initialization">copy initialization</a> </li>
<li> <a href="copy_constructor" title="cpp/language/copy constructor">copy constructor</a> </li>
<li> <a href="move_constructor" title="cpp/language/move constructor">move constructor</a> </li>
</ul> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/copy_elision">https://en.cppreference.com/w/cpp/language/copy_elision</a>
</p>
</div>
