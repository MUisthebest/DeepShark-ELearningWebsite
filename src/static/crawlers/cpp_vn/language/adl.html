 <h1 class="firstHeading" id="firstHeading">Tra cứu phụ thuộc vào đối số</h1> <p>Tra cứu phụ thuộc vào đối số, còn được gọi là Tra cứu ADL hoặc Koenig<sup class="reference" id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup>, là tập hợp các quy tắc để tìm kiếm các tên hàm không đủ tiêu chuẩn trong<a href="operator_other" title="cpp/language/operator other">function-call expressions</a>, bao gồm các cuộc gọi chức năng ngầm đến<a href="operators" title="cpp/language/operators">overloaded operators</a>. Các tên chức năng này được tra cứu trong các không gian tên của các đối số của chúng ngoài phạm vi và không gian tên được xem xét bởi thông thường<a href="lookup" title="cpp/language/lookup">unqualified name lookup</a>.</p>
<div class="t-example">
<p>Tra cứu phụ thuộc vào đối số cho phép sử dụng các toán tử được xác định trong một không gian tên khác. Ví dụ:</p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;Istream&gt;</pre></div> </div> <h3 id="Details"> </h3> <p>int main ()<a href="lookup" title="cpp/language/lookup">unqualified lookup</a>{</p>
<div class="t-li1">
<span class="t-li">1)</span>    std :: cout &lt;&lt; "test \ n"; // Không có toán tử &lt;&lt; trong không gian tên toàn cầu, nhưng ADL</div> <div class="t-li1">
<span class="t-li">2)</span>                           // kiểm tra không gian tên STD vì đối số bên trái nằm trong<a href="namespace#Using-declarations" title="cpp/language/namespace">using-declaration</a>).</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>                           // std và tìm std :: nhà điều hành &lt;&lt; (std :: ostream &amp;, const char*)</div> <p>    toán tử &lt;&lt; (std :: cout, "test \ n"); // Tương tự, sử dụng ký hiệu cuộc gọi chức năng<i> </i>    // Tuy nhiên,</p>
<div class="t-li1">
<span class="t-li">1)</span>    std :: cout &lt;&lt; endl; // Lỗi: 'Endl' không được khai báo trong không gian tên này.</div> <div class="t-li1">
<span class="t-li">2)</span>                       // Đây không phải là một lệnh gọi hàm đến endl (), vì vậy ADL không áp dụng</div> <div class="t-li2">
<span class="t-li">}</span> </div> <div class="t-li2">
<span class="t-li">{</span>    endl (std :: cout); // OK: Đây là một cuộc gọi chức năng: ADL kiểm tra không gian tên STD</div> <div class="t-li2">
<span class="t-li">}</span>                     // Vì đối số của endl đang ở STD và tìm thấy std :: endl<a href="nested_types" title="cpp/language/nested types">member of another class</a> </div> <div class="t-li2">
<span class="t-li">tải trong luồng B.</span>    (endl) (std :: cout); // Lỗi: 'Endl' không được khai báo trong không gian tên này.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>                       // biểu hiện phụ (ENDL) không phải là ID không đủ tiêu chuẩn<a href="class_template" title="cpp/language/class template">class template</a>}</div> <div class="t-li2">
<span class="t-li">}</span>Chi tiết</div> <div class="t-li2">
<span class="t-li">{</span>Đầu tiên, việc tra cứu phụ thuộc vào đối số không được xem xét nếu bộ tra cứu được tạo ra bởi thông thường</div> <div class="t-li2">
<span class="t-li">}</span>Chứa bất kỳ điều nào sau đây:</div> <div class="t-li1">
<span class="t-li">là trong</span>Một tuyên bố của một thành viên lớp.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Tuyên bố về một hàm ở phạm vi khối (đó không phải là</div> <div class="t-li1">
<span class="t-li">từ_sys</span>Bất kỳ tuyên bố nào không phải là một hàm hoặc mẫu chức năng (ví dụ: đối tượng hàm hoặc biến khác có tên xung đột với tên của hàm đang được tra cứu).</div> <div class="t-li1">
<span class="t-li">6)</span>Mặt khác, đối với mọi đối số trong biểu thức cuộc gọi hàm, loại của nó được kiểm tra để xác định</div> <div class="t-li1">
<span class="t-li">. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu biểu thức</span>tập hợp các không gian tên và lớp học liên kết</div> <div class="t-li1">
<span class="t-li">được hình thành tốt. Chương trình không được hình thành nếu</span>rằng nó sẽ thêm vào tra cứu.<a href="overloaded_address" title="cpp/language/overloaded address">address-of expression for a set of overloaded functions</a>Đối với các đối số thuộc loại cơ bản, tập hợp các không gian tên và lớp liên quan là trống.<ul><li>Đối với các đối số thuộc loại lớp (bao gồm cả liên minh), bộ bao gồm:<a href="templates#template-id" title="cpp/language/templates">template-id</a>Bản thân lớp.</li></ul>
</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>Tất cả các lớp cơ sở trực tiếp và gián tiếp của nó.<a href="namespace" title="cpp/language/namespace">inline namespace</a>Nếu lớp là một</p>
<p>, lớp mà nó là một thành viên.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <p>Các không gian tên kèm theo bên trong của các lớp được thêm vào tập hợp.</p>
<p>Đối với các đối số có loại là một<a href="lookup" title="cpp/language/lookup">unqualified lookup</a>Chuyên môn hóa, ngoài các quy tắc của lớp, các loại sau được kiểm tra và các lớp và không gian tên liên quan của chúng được thêm vào tập hợp.</p>
<div class="t-li1">
<span class="t-li">1)</span> <a href="namespace#Using-directives" title="cpp/language/namespace">using-directives</a>Các loại của tất cả các đối số mẫu được cung cấp cho các tham số mẫu loại (bỏ qua các tham số mẫu không kiểu và bỏ qua các tham số mẫu mẫu).</div> <div class="t-li1">
<span class="t-li">2)</span>Các không gian tên trong đó bất kỳ đối số mẫu nào là thành viên.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Các lớp trong đó bất kỳ đối số mẫu nào là thành viên (nếu chúng là mẫu thành viên lớp).</div> <h3 id="Notes">Ghi chú</h3> <p>Đối với các đối số của loại liệt kê, không gian tên kèm theo bên trong của Tuyên bố loại bảng liệt kê được xác định được thêm vào tập hợp. Nếu loại liệt kê là thành viên của một lớp, lớp đó được thêm vào tập hợp.<sup class="reference" id="cite_ref-2"><a href="#cite_note-2">[2]</a></sup>Đối với các đối số của loại con trỏ tới T hoặc con trỏ tới một mảng T, loại T được kiểm tra và tập hợp các lớp và không gian tên liên quan của nó được thêm vào tập hợp.</p>
<div class="cpp source-cpp"><pre data-language="cpp">Đối với các đối số của loại chức năng, các loại tham số chức năng và loại trả về hàm được kiểm tra và tập hợp các lớp và không gian tên liên quan của chúng được thêm vào tập hợp.</pre></div>Đối với các đối số của loại con trỏ đến hàm thành viên F của lớp X, các loại tham số hàm, loại trả về hàm và lớp X được kiểm tra và tập hợp các lớp và không gian tên liên quan của chúng được thêm vào tập hợp.<code><a href="http://en.cppreference.com/w/cpp/algorithm/swap"><span class="kw1603">Điều đó cho tất cả<span class="me2">Được xác định trong tiêu đề</span></span></a><span class="br0">.</span>obj1, obj2<span class="br0">)</span></code>Đối với các đối số của loại con trỏ đến thành viên dữ liệu t của lớp X, loại thành viên và loại X đều được kiểm tra và tập hợp các lớp và không gian tên liên quan của chúng được thêm vào tập hợp.<code>swap(obj1, obj2)</code>Nếu đối số là tên hoặc<code><a href="../algorithm/iter_swap" title="cpp/algorithm/iter swap">std::iter_swap</a></code>(hoặc các mẫu chức năng), mọi hàm trong tập hợp quá tải đều được kiểm tra và tập hợp các lớp và không gian tên liên quan của nó được thêm vào tập hợp.<a href="../named_req/swappable" title="cpp/named req/Swappable">Swappable</a>loại.<p>Ngoài ra, nếu tập hợp quá tải được đặt tên bởi một<code>operator&gt;&gt;</code>hoặc<code>operator+</code>vì<code><a href="../container/vector" title="cpp/container/vector">std::vector</a></code>, tất cả các đối số mẫu và đối số mẫu mẫu của nó (nhưng không phải đối số mẫu không thuộc loại) được kiểm tra và tập hợp các lớp và không gian tên liên quan của chúng được thêm vào tập hợp.<code><a href="../utility/pair" title="cpp/utility/pair">std::pair</a></code>Nếu bất kỳ không gian tên nào trong tập hợp các lớp và không gian tên liên quan là<a href="dependent_name" title="cpp/language/dependent name">dependent names</a>, không gian tên kèm theo của nó cũng được thêm vào tập hợp.</p>
<p>Nếu bất kỳ không gian tên nào trong tập hợp các lớp và không gian tên được liên kết trực tiếp chứa một không gian tên nội tuyến, thì không gian tên nội tuyến đó được thêm vào tập hợp.<a href="friend" title="cpp/language/friend">friend function</a>Sau khi tập hợp các lớp và không gian tên liên quan được xác định, tất cả các khai báo được tìm thấy trong các lớp của tập hợp này sẽ bị loại bỏ cho mục đích xử lý ADL tiếp theo, ngoại trừ các hàm và mẫu chức năng của Friend Scoped Face, như đã nêu ở điểm 2 dưới đây.</p>
<div class="cpp source-cpp"><pre data-language="cpp">Tập hợp các tuyên bố được tìm thấy bởi thông thường</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p>và tập hợp các khai báo được tìm thấy trong tất cả các yếu tố của tập hợp được tạo ra bởi ADL, được hợp nhất, với các quy tắc đặc biệt sau:<a href="function_template" title="cpp/language/function template">function template</a>Trong các không gian tên liên quan bị bỏ qua.</p>
<div class="cpp source-cpp"><pre data-language="cpp">Các chức năng bạn bè bao gồm không gian tên (và các mẫu chức năng) được khai báo trong một lớp liên quan có thể nhìn thấy thông qua ADL ngay cả khi chúng không thể nhìn thấy thông qua tra cứu thông thường.</pre></div> </td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> </table> <p>Tất cả các tên ngoại trừ các hàm và mẫu chức năng đều bị bỏ qua (không va chạm với các biến).</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li>Do tra cứu phụ thuộc vào đối số, các chức năng không phải thành viên và các toán tử không phải thành viên được xác định trong cùng một không gian tên như một lớp được coi là một phần của giao diện công cộng của lớp đó (nếu chúng được tìm thấy thông qua ADL)<code>begin</code>Và<code>end</code>.  ADL là lý do đằng sau thành ngữ đã được thiết lập để hoán đổi hai đối tượng theo mã chung:<a href="range-for" title="cpp/language/range-for">range-for</a>sử dụng std :: hoán đổi;</li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <ul><li>các<a href="dependent_name#Lookup_rules" title="cpp/language/dependent name">dependent name lookup</a>hoán đổi (obj1, obj2);</li></ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <ul><li>Vì gọi điện<code>get</code>trực tiếp sẽ không xem xét các hàm hoán đổi do người dùng xác định<a href="structured_binding" title="cpp/language/structured binding">structured binding declaration</a>Sẽ không gọi gì nếu không có quá tải do người dùng xác định. Đặc biệt,</li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <h3 id="Examples">, không còn là một phần của cây phụ thuộc.</h3> <div class="t-example">
<p>và tất cả các thuật toán thư viện tiêu chuẩn khác đều sử dụng phương pháp này khi xử lý<a class="external free" href="http://www.gotw.ca/gotw/030.htm" rel="nofollow">http://www.gotw.ca/gotw/030.htm</a></p>
<div class="cpp source-cpp"><pre data-language="cpp">Quy tắc tra cứu tên làm cho việc khai báo các toán tử trong không gian tên toàn cầu hoặc do người dùng xác định hoạt động trên các loại từ không gian tên STD, ví dụ: một tùy chỉnh</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/33.html" rel="nofollow">CWG 33</a> </td> <td>C ++ 98</td> <td>hoặc cho<br/>(Trừ khi các loại phần tử của vectơ/cặp là loại do người dùng xác định, sẽ thêm không gian tên của chúng vào ADL). Các nhà khai thác như vậy sẽ không được tra cứu từ các bản khởi tạo mẫu, chẳng hạn như thuật toán thư viện tiêu chuẩn. Nhìn thấy</td> <td>Mẫu &lt;class inputit, class outputit&gt;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/90.html" rel="nofollow">CWG 90</a> </td> <td>C ++ 98</td> <td>Để biết thêm chi tiết.<br/>ADL có thể tìm thấy một</td> <td>(thông thường, một toán tử quá tải) được xác định hoàn toàn trong một mẫu lớp hoặc lớp, ngay cả khi nó không bao giờ được khai báo ở cấp không gian tên.</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/239.html" rel="nofollow">CWG 239</a> </td> <td>C ++ 98</td> <td>Mẫu &lt;Typename T&gt;<br/>Số cấu trúc</td> <td>{<br/>    số (int);</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/997.html" rel="nofollow">CWG 997</a> </td> <td>C ++ 98</td> <td>    Số bạn gcd (số x, số y) {return 0; }; // Định nghĩa bên trong<br/>                                                         // Mẫu lớp</td> <td>};</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1690.html" rel="nofollow">CWG 1690</a> </td> <td>C ++ 98<br/>C ++ 11</td> <td> <br/>// trừ khi một tuyên bố phù hợp được cung cấp GCD là</td> <td>// Một thành viên vô hình (ngoại trừ thông qua ADL) của không gian tên này</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1691.html" rel="nofollow">CWG 1691</a> </td> <td>C ++ 11</td> <td>void g ()</td> <td>Đã sửa</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1692.html" rel="nofollow">CWG 1692</a> </td> <td>C ++ 98</td> <td>{<br/>    số &lt;double&gt; a (3), b (4);</td> <td>    a = gcd (a, b); // Tìm GCD vì số &lt;double&gt; là một lớp liên kết,<br/>                   // Làm cho GCD hiển thị trong không gian tên của nó (phạm vi toàn cầu)<br/>// b = gcd (3, 4); // Lỗi; GCD không hiển thị</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <ul>
<li> <a href="lookup" title="cpp/language/lookup">Name lookup</a> </li>
<li> <a href="function_template" title="cpp/language/function template">Template argument deduction</a> </li>
<li> <a href="overload_resolution" title="cpp/language/overload resolution">Overload resolution</a> </li>
</ul> <h3 id="External_links">Liên kết bên ngoài</h3> <table> <tr style="vertical-align:top;"> <td> </td> <td>
<ol class="references"> <li id="cite_note-1"> <span class="reference-text">}<a class="external text" href="https://www.drdobbs.com/cpp/a-personal-note-about-argument-dependent/232901443" rel="nofollow">"A Personal Note About Argument-Dependent Lookup"</a></span> </li> <li id="cite_note-2"> <span class="reference-text">Mặc dù một cuộc gọi chức năng có thể được giải quyết thông qua ADL ngay cả khi Tra cứu thông thường không tìm thấy gì, một cuộc gọi chức năng đến<a class="external text" href="http://www.gotw.ca/publications/mill02.htm" rel="nofollow">"What's In a Class? - The Interface Principle"</a>Với các đối số mẫu được chỉ định rõ ràng yêu cầu có một khai báo mẫu được tìm thấy bằng cách tra cứu thông thường (nếu không, đó là một lỗi cú pháp để gặp một tên không xác định theo sau là một ký tự ít hơn).</span> </li> </ol> </td>
</tr>
</table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/adl">https://en.cppreference.com/w/cpp/language/adl</a>
</p>
</div>
