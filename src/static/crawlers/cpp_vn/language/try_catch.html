 <h1 class="firstHeading" id="firstHeading">cố gắng chặn</h1> <p>Các cộng sự một hoặc nhiều trình xử lý ngoại lệ (bắt giữ) với một câu lệnh ghép.</p>
<h3 id="Syntax">Cú pháp</h3> <table class="t-sdsc-begin"> <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <code>try</code> <span class="t-spar">Tệp hỗn hợp</span> <span class="t-spar">{</span> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <p>Ở đâu<span class="t-spar">{</span>là một chuỗi của một hoặc nhiều<span class="t-spar">người xử lý</span>s, có cú pháp sau:</p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <code>catch</code> <code>(</code> <span class="t-spar">attr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">Loại Specifier-seq</span> <span class="t-spar">người khai báo</span> <code>)</code> <span class="t-spar">Tệp hỗn hợp</span> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>catch</code> <code>(</code> <span class="t-spar">attr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">Loại Specifier-seq</span> <span class="t-spar">TÓM TẮT KIẾN TRÚC</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <code>)</code> <span class="t-spar">Tệp hỗn hợp</span> </td> <td>(2)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>catch</code> <code>(</code> <code>...</code> <code>)</code> <span class="t-spar">Tệp hỗn hợp</span> </td> <td>(3)</td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">Tệp hỗn hợp</span> </td> <td>-</td> <td>Ống niềng răng<a href="statements#Compound_statements" title="cpp/language/statements">sequence of statements</a> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">attr</span> </td> <td>-</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span>bất kỳ số lượng của<a href="attributes" title="cpp/language/attributes">attributes</a>, áp dụng cho tham số chính thức</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">Loại Specifier-seq</span> </td> <td>-</td> <td>một phần của khai báo tham số chính thức, giống như trong một<a href="function" title="cpp/language/function">function</a>Danh sách tham số</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">người khai báo</span> </td> <td>-</td> <td>một phần của khai báo tham số chính thức, giống như trong một<a href="function" title="cpp/language/function">function</a>Danh sách tham số</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">TÓM TẮT KIẾN TRÚC</span> </td> <td>-</td> <td>một phần của khai báo tham số chính thức không tên, giống như trong<a href="function" title="cpp/language/function">function</a>Danh sách tham số</td>
</tr>
</table> <div class="t-li1">
<span class="t-li">1)</span>Điều khoản bắt được tuyên bố một tham số chính thức được đặt tên<div class="cpp source-cpp"><pre data-language="cpp">thử { / * * /} Catch (const std :: excent &amp; e) { / * * /}</pre></div>
</div> <div class="t-li1">
<span class="t-li">2)</span>Điều khoản bắt được tuyên bố một tham số không tên<div class="cpp source-cpp"><pre data-language="cpp">thử { / * * /} Catch (const std :: Exception &amp;) { / * * /}</pre></div>
</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Catch-all Handler, được kích hoạt cho bất kỳ ngoại lệ nào<div class="cpp source-cpp"><pre data-language="cpp">thử { / * * /} Catch (...) { / * * /}</pre></div>
</div> <h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3>(Raco).<a href="throw" title="cpp/language/throw">throw exceptions</a>Để biết thêm thông tin về biểu hiện ném<p>Một khối thử là một<a href="statements" title="cpp/language/statements">statement</a>và như vậy, có thể xuất hiện bất cứ nơi nào một câu lệnh có thể xuất hiện (nghĩa là, là một trong những tuyên bố trong một tuyên bố ghép, bao gồm cả tuyên bố hợp chất cơ thể chức năng). Nhìn thấy<a href="function-try-block" title="cpp/language/function-try-block">function-try-block</a>Đối với các khối thử xung quanh các cơ thể chức năng. Mô tả sau đây áp dụng cho cả bucks thử và<a href="function-try-block" title="cpp/language/function-try-block">function-try-blocks</a>.</p>
<p>Tham số chính thức của mệnh đề bắt (<span class="t-spar">Loại Specifier-seq</span>Và<span class="t-spar">người khai báo</span>hoặc<span class="t-spar">Loại Specifier-seq</span>Và<span class="t-spar">TÓM TẮT KIẾN TRÚC</span>) Xác định loại ngoại lệ nào gây ra điều khoản bắt này được nhập. Nó không thể là một<a class="mw-redirect" href="incomplete_type" title="cpp/language/incomplete type">incomplete type</a>Thì<a href="abstract_class" title="cpp/language/abstract class">abstract class</a>kiểu,<span class="t-rev-inl t-since-cxx11"><span> <a href="reference" title="cpp/language/reference">rvalue reference</a>kiểu,</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>hoặc con trỏ đến loại không hoàn chỉnh (ngoại trừ con trỏ đến (có thể<a href="cv" title="cpp/language/cv">cv</a>    int* p = &amp; a [2];<code>void</code>được cho phép). Nếu loại tham số chính thức là loại mảng hoặc loại chức năng, nó được coi là loại con trỏ tương ứng (tương tự như a<a href="function" title="cpp/language/function">function declaration</a>).</p>
<p>Khi một ngoại lệ được ném bởi bất kỳ tuyên bố nào trong<span class="t-spar">Tệp hỗn hợp</span>    toán tử-= (const std :: chrono :: tháng &amp; dm) const noexcept;<a href="throw#The_exception_object" title="cpp/language/throw">exception object</a>nó đến một đối tượng<code>E</code>được khớp với các loại tham số chính thức<code>T</code>của mỗi điều khoản bắt trong<span class="t-spar">}</span>, theo thứ tự các mệnh đề bắt được liệt kê. Ngoại lệ là một trận đấu nếu bất kỳ điều nào sau đây là đúng:</p>
<ul>
<li> <code>E</code>Và<code>T</code>là cùng một loại (bỏ qua các trình điều chỉnh CV cấp cao nhất trên<code>T</code>)</li>
<li> <code>T</code>là một tham chiếu lvalue (có thể là đủ điều kiện CV)<code>E</code> </li>
<li> <code>T</code>là một lớp cơ sở công cộng rõ ràng của<code>E</code> </li>
<li> <code>T</code>là một tham chiếu đến một lớp cơ sở công cộng rõ ràng của<code>E</code> </li>
<li> <code>T</code>Chuyển đổi tiêu chuẩn được áp dụng để chuyển đổi biểu thức thành prvalue.<code>U</code>hoặc<code>const U&amp;</code>, Và<code>U</code>là một con trỏ hoặc con trỏ đến loại thành viên và<code>E</code>cũng là một con trỏ hoặc con trỏ đến loại thành viên có thể chuyển đổi hoàn toàn<code>U</code>bởi một hoặc nhiều</li>
<ul>
<li>một tiêu chuẩn<a href="implicit_conversion#Pointer_conversions" title="cpp/language/implicit conversion">pointer conversion</a>khác với một lớp cơ sở riêng tư, được bảo vệ hoặc mơ hồ</li>
<li>Một<a href="implicit_conversion#Qualification_conversions" title="cpp/language/implicit conversion">qualification conversion</a> </li>
</ul>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <ul><li>Một<a href="implicit_conversion#Function_pointer_conversions" title="cpp/language/implicit conversion">function pointer conversion</a> </li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li> <code>T</code>Chuyển đổi tiêu chuẩn được áp dụng để chuyển đổi biểu thức thành prvalue.<code>U</code>hoặc<code>const U&amp;</code>là<code>U</code>là một con trỏ hoặc một con trỏ đến loại thành viên và<code>E</code>khoảng cách<code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code>.</li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <div class="cpp source-cpp"><pre data-language="cpp">thử</pre></div> <p>{<code>catch (...)</code>    f ();<span class="t-spar">}</span>Catch (const std :: overflow_error &amp; e))<a href="exceptions" title="cpp/language/exceptions">nothrow exception guarantee</a>.</p>
<p>{} // Điều này thực thi nếu f () ném std :: overflow_error (cùng loại quy tắc)<a href="throw" title="cpp/language/throw">throw-expression</a>Catch (const std :: runtime_error &amp; e))<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>{} // Điều này thực thi nếu f () ném std :: underflow_error (quy tắc lớp cơ sở)</p>
<p>Catch (const std :: Exception &amp; E)<a href="copy_initialization" title="cpp/language/copy initialization">copy-initialized</a>{} // Điều này thực thi nếu f () ném std :: logic_error (quy tắc lớp cơ sở)<a href="copy_elision" title="cpp/language/copy elision">copy elision</a>).</p>
<div class="cpp source-cpp"><pre data-language="cpp">nắm lấy (...)</pre></div> <p>{} // Điều này thực thi nếu f () ném std :: chuỗi hoặc int hoặc bất kỳ loại không liên quan nào khác<code>throw;</code>Các điều khoản bắt tất cả</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>phù hợp với ngoại lệ của bất kỳ loại. Nếu có mặt, nó phải là điều khoản bắt cuối cùng trong<code><a href="../error/current_exception" title="cpp/error/current exception">std::current_exception</a></code>Handler-seq<code><a href="../error/exception_ptr" title="cpp/error/exception ptr">std::exception_ptr</a></code>, Và<code><a href="../error/throw_with_nested" title="cpp/error/throw with nested">std::throw_with_nested</a></code>. Khối bắt tất cả có thể được sử dụng để đảm bảo rằng không có trường hợp ngoại lệ nào có thể thoát khỏi một chức năng cung cấp</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <p>MỘT<a href="goto" title="cpp/language/goto">goto</a>hoặc<a href="switch" title="cpp/language/switch">switch</a>Nếu không có trận đấu nào được tìm thấy sau khi tất cả các loại bắt được kiểm tra</p>
<p>. Nếu không còn chứa khối thử,<a href="function-try-block" title="cpp/language/function-try-block">function-try-block</a>được thực hiện (trong trường hợp này, nó được xác định bằng cách thực hiện liệu có bất kỳ ngăn xếp nào xảy ra: ném một ngoại lệ không được phép được phép chấm dứt chương trình mà không cần gọi bất kỳ chất phá hủy nào).<a href="return" title="cpp/language/return">return</a>Thì<a href="continue" title="cpp/language/continue">continue</a>Thì<a href="break" title="cpp/language/break">break</a>Thì<a href="goto" title="cpp/language/goto">goto</a>Khi nhập mệnh đề bắt, nếu tham số chính thức của nó là một lớp cơ sở thuộc loại ngoại lệ, thì đó là<span class="t-spar">Tệp hỗn hợp</span>Từ tiểu mục cơ sở của đối tượng ngoại lệ. Mặt khác, nó được sao chép sao chép từ đối tượng ngoại lệ (bản sao này có thể xảy ra<code><a href="../error/exception_ptr" title="cpp/error/exception ptr">std::exception_ptr</a></code>thử</p>
<h3 id="Notes">Ghi chú</h3> <p>{<code><span class="kw1">    std :: ifstream f ("không tồn tại");</span> <a href="http://en.cppreference.com/w/cpp/types/NULL"><span class="kw110">VÔ GIÁ TRỊ</span></a><span class="sy4">Số lượng các yếu tố để sao chép</span></code>    std :: chuỗi ("ABC"). Subrtr (10); // Ném std :: length_error<code>int</code>Đếm các yếu tố mà vị ngữ<code>throw nullptr;</code>}</p>
<p>// Catch (std :: Except</p>
<div class="cpp source-cpp"><pre data-language="cpp">// {</pre></div> <p>Nếu như<a href="goto" title="cpp/language/goto">goto</a>// std :: cout &lt;&lt; e.what (); // thông tin từ length_error bị mất<code>goto</code>//}</p>
<div class="cpp source-cpp"><pre data-language="cpp">Catch (const std :: Exception &amp; e) // tham chiếu đến cơ sở của một đối tượng đa hình</pre></div> <p>{<a class="external text" href="https://cplusplus.github.io/CWG/issues/388.html" rel="nofollow">CWG388</a>    std :: cout &lt;&lt; e.what (); // thông tin từ inm_error in</p>
<div class="cpp source-cpp"><pre data-language="cpp">}</pre></div> <h3 id="Keywords">không định nghĩa macro như vậy. Tuy nhiên, nó xác định hằng số macro</h3> <p><a href="../keyword/try" title="cpp/keyword/try"><code>try</code></a>Thì<a href="../keyword/catch" title="cpp/keyword/catch"><code>catch</code></a>Thì<a href="../keyword/throw" title="cpp/keyword/throw"><code>throw</code></a></p>
<h3 id="Example">Ví dụ</h3> <div class="t-example">
<p>Nếu tham số của mệnh đề bắt là loại tham chiếu, bất kỳ thay đổi nào được thực hiện đối với nó được phản ánh trong đối tượng ngoại lệ và có thể được quan sát bởi một trình xử lý khác nếu ngoại lệ được đánh giá lại với<code>try-catch</code>khối</p>
<div class="cpp source-cpp"><pre data-language="cpp">. Nếu tham số không phải là một tài liệu tham khảo, bất kỳ thay đổi nào được thực hiện đối với nó là cục bộ và suốt đời của nó kết thúc khi trình xử lý thoát ra.</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">Trong một điều khoản bắt,</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/98.html" rel="nofollow">CWG 98</a> </td> <td>C ++ 98</td> <td>có thể được sử dụng để nắm bắt ngoại lệ trong một<br/>có thể được sử dụng để xây dựng các ngoại lệ lồng nhau.</td> <td>bị cấm</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/210.html" rel="nofollow">CWG 210</a> </td> <td>C ++ 98</td> <td>Tuyên bố sẽ không được sử dụng để chuyển kiểm soát vào một khối thử hoặc vào một người xử lý.</td> <td>Khác với bằng cách ném hoặc phát triển lại ngoại lệ, điều khoản bắt sau một khối thử thường xuyên (không<br/>) có thể thoát ra với một</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/388.html" rel="nofollow">CWG 388</a> </td> <td>C ++ 98</td> <td>, hoặc bằng cách đi đến cuối của nó<br/>. Trong mọi trường hợp, điều này phá hủy đối tượng ngoại lệ (trừ khi một ví dụ của</td> <td>tồn tại mà đề cập đến nó).</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1166.html" rel="nofollow">CWG 1166</a> </td> <td>C ++ 98</td> <td>Biểu hiện ném<br/>không được đảm bảo để phù hợp với mệnh đề bắt con trỏ, bởi vì loại đối tượng ngoại lệ có thể là</td> <td>được chắc chắn kết hợp bởi bất kỳ con trỏ hoặc điều khoản bắt đường con trỏ đến thành viên nào.<br/>Nếu một mệnh đề bắt cho một lớp dẫn xuất được đặt sau mệnh đề bắt cho một lớp cơ sở, mệnh đề bắt có nguồn gốc sẽ không bao giờ được thực thi:</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1769.html" rel="nofollow">CWG 1769</a> </td> <td>C ++ 98</td> <td>thử<br/>{<br/>    f ();</td> <td>}<br/>Catch (const std :: Exception &amp; E)<br/>{} // sẽ được thực thi nếu f () ném std :: runtime_error</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2093.html" rel="nofollow">CWG 2093</a> </td> <td>C ++ 98</td> <td>Catch (const std :: runtime_error &amp; e))<br/>{} // Mã chết!</td> <td>cho phép</td>
</tr>
</table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/try_catch">https://en.cppreference.com/w/cpp/language/try_catch</a>
</p>
</div>
