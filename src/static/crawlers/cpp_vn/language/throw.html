 <h1 class="firstHeading" id="firstHeading">
<code>throw</code>  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</h1> <p>Báo hiệu một điều kiện sai lầm và thực hiện một trình xử lý lỗi.</p>
<h3 id="Syntax">Cú pháp</h3> <table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <code>throw</code> <span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>throw</code> </td> <td>(2)</td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3>(Raco).<a href="try_catch" title="cpp/language/try catch">try-catch block</a>Để biết thêm thông tin về<span class="kw1">    i = 0;</span>Và<span class="kw1">#include &lt;Istream&gt;</span><i>(Bộ xử lý ngoại lệ) Khối</i> <span class="t-li">1)</span>{<a href="copy_initialization" title="cpp/language/copy initialization">copy-initializes</a>các<i>đối tượng ngoại lệ</i>từ<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li>Điều này có thể gọi hàm tạo di chuyển cho biểu thức rvalue. Ngay cả khi việc khởi tạo bản sao, chọn hàm xây dựng di chuyển, việc sao chép khởi tạo từ lvalue phải được hình thành tốt và bộ hủy phải có thể truy cập được</li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <ul><li>Điều này cũng có thể gọi hàm tạo di chuyển cho các biểu thức đặt tên cho các biến hoặc hàm cục bộ hoặc chức năng hoặc<span class="kw1">#include &lt;Istream&gt;</span>Các tham số mệnh đề có phạm vi không kéo dài qua bên trong bên trong<span class="kw1">    i = 0;</span>khối (nếu có), theo cùng một độ phân giải quá tải như trong<a href="return" title="cpp/language/return">return statement</a> </li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <ul><li>Bản sao<span class="t-rev-inl t-since-cxx11"><span>/di chuyển</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>có thể phải chịu<a href="copy_elision" title="cpp/language/copy elision">copy elision</a>
</li></ul>sau đó chuyển quyền kiểm soát sang<a href="try_catch" title="cpp/language/try catch">exception handler</a>với loại phù hợp mà câu lệnh ghép hoặc danh sách khởi tạo thành viên theo từ khóa<span class="kw1">    i = 0;</span>được nhập gần đây nhất và không bị thoát khỏi chủ đề thực thi này.<div class="t-li1">
<span class="t-li">2)</span>Rethrows ngoại lệ hiện đang xử lý. Từ bỏ việc thực hiện hiện tại<code>catch</code>chặn và chuyển điều khiển cho trình xử lý ngoại lệ phù hợp tiếp theo (nhưng không phải cho một người khác<code>catch</code>mệnh đề sau cùng<code>try</code>BLOCK: Triển lãm hỗn hợp của nó được coi là đã 'thoát'), tái sử dụng đối tượng ngoại lệ hiện có: không có đối tượng mới nào được thực hiện. Mẫu này chỉ được phép khi một ngoại lệ hiện đang được xử lý (nó gọi<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>nếu được sử dụng khác). Các<code>catch</code>mệnh đề liên quan đến một<a href="function-try-block" title="cpp/language/function-try-block">function <span class="kw1">    i = 0;</span> block</a>Phải thoát qua rethrowing nếu được sử dụng trên một hàm tạo.</div> <p>(Raco).<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code><span class="t-rev-inl t-until-cxx17"><span>Và<code><a href="../error/unexpected" title="cpp/error/unexpected">std::unexpected</a></code></span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span>Đối với việc xử lý các lỗi phát sinh trong quá trình xử lý ngoại lệ.</p>
<h3 id="The_exception_object">Đối tượng ngoại lệ</h3> <p>Các<i>đối tượng ngoại lệ</i>là một đối tượng tạm thời trong bộ nhớ không xác định được xây dựng bởi<span class="kw1">    std :: ifstream f ("không tồn tại");</span>}</p>
<p>Các<a href="implicit_conversion#Array-to-pointer_conversion" title="cpp/language/implicit conversion">array-to-pointer</a>Và<a href="implicit_conversion#Function-to-pointer_conversion" title="cpp/language/implicit conversion">function-to-pointer</a>Chuyển đổi được thực hiện trên<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>. Loại đối tượng ngoại lệ được xác định bằng cách xóa bất kỳ cấp cao nào<a href="cv" title="cpp/language/cv">cv-qualifiers</a>từ loại<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>(có thể sau khi chuyển đổi) và đối tượng ngoại lệ là<a href="copy_initialization" title="cpp/language/copy initialization">copy-initialized</a>từ<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>(có thể sau khi chuyển đổi).</p>
<p>Nếu loại đối tượng ngoại lệ sẽ là<a class="mw-redirect" href="incomplete_type" title="cpp/language/incomplete type">incomplete type</a>, đầu vào được coi là mã hóa rộng bản địa (do đó không có sự chuyển đổi nào diễn ra trên Windows).<a href="abstract_class" title="cpp/language/abstract class">abstract class</a>Loại, hoặc con trỏ đến loại không đầy đủ khác với con trỏ tới (có thể là đủ điều kiện CV)<span class="kw4">Vô hiệu</span>, chương trình là xấu.</p>
<p>                               Không có p);<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span>là loại lớp, bản sao của nó<span class="t-rev-inl t-since-cxx11"><span>/di chuyển</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>người xây dựng và phá hủy phải có thể truy cập được ngay cả khi<a href="copy_elision" title="cpp/language/copy elision">copy elision</a>) trong đó một trong các toán hạng là một mảng, kết quả tiềm năng của toán hạng đó được bao gồm trong tập hợp.</p>
<p>Không giống như các đối tượng tạm thời khác, đối tượng ngoại lệ được coi là đối số lvalue khi khởi tạo<span class="kw1">#include &lt;Istream&gt;</span>Các tham số mệnh đề, do đó nó có thể được bắt bởi tham chiếu Lvalue, sửa đổi và rethrown.</p>
<p>Đối tượng ngoại lệ vẫn tồn tại cho đến khi cuối cùng<span class="kw1">#include &lt;Istream&gt;</span>Điều khoản thoát ra ngoài việc tái hiện<span class="kw1">#include &lt;Istream&gt;</span>tham số của mệnh đề) hoặc cho đến khi cuối cùng<code><a href="../error/exception_ptr" title="cpp/error/exception ptr">std::exception_ptr</a></code>rằng tham chiếu đối tượng này bị phá hủy (trong trường hợp đó, đối tượng ngoại lệ bị phá hủy ngay trước khi phá hủy<code><a href="../error/exception_ptr" title="cpp/error/exception ptr">std::exception_ptr</a></code>trả lại.</p>
<h3 id="Stack_unwinding">Xếp chồng thư giãn</h3> <p>Khi đối tượng ngoại lệ được xây dựng, luồng điều khiển hoạt động ngược (lên ngăn xếp cuộc gọi) cho đến khi nó bắt đầu<a href="try_catch" title="cpp/language/try catch"><span class="kw1">    i = 0;</span> block</a>, tại thời điểm đó các tham số của tất cả các liên quan<span class="kw1">#include &lt;Istream&gt;</span>Các khối được so sánh, theo thứ tự xuất hiện, với loại đối tượng ngoại lệ để tìm một trận đấu (xem<a href="try_catch" title="cpp/language/try catch"><span class="kw1">    i = 0;</span>-<span class="kw1">#include &lt;Istream&gt;</span> block</a>Để biết chi tiết về quy trình này). Nếu không tìm thấy trận đấu nào, luồng điều khiển tiếp tục thư giãn ngăn xếp cho đến khi tiếp theo<span class="kw1">    i = 0;</span>Khối, và như vậy. Nếu một trận đấu được tìm thấy, dòng điều khiển sẽ nhảy vào trận đấu<span class="kw1">#include &lt;Istream&gt;</span>Mô -đun được đặt tên</p>
<p>Khi luồng điều khiển di chuyển lên ngăn xếp cuộc gọi, các bộ hủy được gọi cho tất cả các đối tượng với<a href="storage_duration" title="cpp/language/storage duration">automatic storage duration</a>được xây dựng, nhưng chưa bị phá hủy, vì tương ứng<span class="kw1">    i = 0;</span>Khối đã được nhập, theo thứ tự ngược lại hoàn thành các hàm tạo của chúng. Nếu một ngoại lệ được ném từ một chất hủy diệt của một biến cục bộ hoặc của một<a href="return" title="cpp/language/return">return</a>Tuyên bố, bộ hủy diệt cho đối tượng được trả về từ hàm cũng được gọi.</p>
<p>Nếu một ngoại lệ được ném từ một hàm tạo hoặc (hiếm) từ một chất phá hủy một vật thể (bất kể thời lượng lưu trữ của đối tượng), các chất phá hủy được gọi cho tất cả các thành viên không biến đổi không biến đổi và các lớp cơ sở, theo thứ tự hoàn thành các hàm tạo của chúng. Thành viên biến thể của<a href="union#Union-like_classes" title="cpp/language/union">union-like classes</a>chỉ bị phá hủy trong trường hợp tháo gỡ từ hàm tạo và nếu thành viên tích cực thay đổi giữa khởi tạo và phá hủy, hành vi không được xác định.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>Nếu một nhà xây dựng ủy thác thoát ra với một ngoại lệ sau khi nhà xây dựng không phải là hoàn thành thành công, bộ hủy diệt cho đối tượng này được gọi.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <p>Nếu ngoại lệ được ném từ một hàm tạo được gọi bởi một<a href="new" title="cpp/language/new">new-expression</a>, phù hợp<a href="../memory/new/operator_delete" title="cpp/memory/new/operator delete">deallocation function</a>được gọi, nếu có.</p>
<p>Quá trình này được gọi là<i>xếp chồng thư giãn</i>.</p>
<p>Nếu bất kỳ chức năng nào được gọi trực tiếp bởi cơ chế tháo gỡ ngăn xếp, sau khi khởi tạo đối tượng ngoại lệ và trước khi bắt đầu bộ xử lý ngoại lệ, hãy thoát ra ngoài ngoại lệ,<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>được gọi. Các chức năng như vậy bao gồm<a href="destructor" title="cpp/language/destructor">destructors</a>của các đối tượng có thời lượng lưu trữ tự động có phạm vi bị thoát và hàm tạo bản sao của đối tượng ngoại lệ được gọi là (nếu không<a href="copy_elision" title="cpp/language/copy elision">elided</a>) để khởi tạo các đối số bắt giữ.</p>
<p>Nếu một ngoại lệ bị ném và không bị bắt, bao gồm các ngoại lệ thoát khỏi chức năng ban đầu của<code><a href="../thread/thread" title="cpp/thread/thread">std::thread</a></code>, hàm chính và hàm tạo hoặc hàm hủy của bất kỳ đối tượng tĩnh hoặc địa điểm nào, sau đó<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>được gọi. Đó là việc thực hiện được xác định cho dù có bất kỳ ngăn xếp ngăn xếp nào diễn ra cho các trường hợp ngoại lệ không.</p>
<h3 id="Notes">Ghi chú</h3> <p>Khi tái hiện các ngoại lệ, biểu mẫu thứ hai phải được sử dụng để tránh cắt đối tượng trong trường hợp (điển hình) trong đó các đối tượng ngoại lệ sử dụng kế thừa:</p>
<div class="cpp source-cpp"><pre data-language="cpp">thử</pre></div> <p>Các<span class="kw1">    std :: ifstream f ("không tồn tại");</span>{<a href="value_category" title="cpp/language/value category">prvalue expression</a>nó đến một đối tượng<span class="kw4">Vô hiệu</span>    std :: chuỗi ("ABC"). Subrtr (10); // Ném std :: out_of_range<a href="operator_other#Conditional_operator" title="cpp/language/operator other">conditional operator</a>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">}</pre></div> <h3 id="Keywords">không định nghĩa macro như vậy. Tuy nhiên, nó xác định hằng số macro</h3> <p><a href="../keyword/throw" title="cpp/keyword/throw"><code>throw</code></a></p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Catch (const std :: Exception &amp; E)</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">{</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/499.html" rel="nofollow">CWG 499</a> </td> <td>C ++ 98</td> <td>    std :: cout &lt;&lt; e.what () &lt;&lt; '\ n';<br/>// Ném e; // sao chép-khởi tạo một đối tượng ngoại lệ mới của loại std :: ngoại lệ<br/>    ném;   // rethrows đối tượng ngoại lệ của loại std :: out_of_range</td> <td>}<br/>-Expression được phân loại là<br/>. Giống như bất kỳ biểu thức nào khác, nó có thể là biểu hiện phụ trong một biểu thức khác, phổ biến nhất là trong</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/668.html" rel="nofollow">CWG 668</a> </td> <td>C ++ 98</td> <td>
<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>Double F (Double D)<br/>{</td> <td>gọi <code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code><br/>                     Forwardit2 s_first, forwardit2 s_last,</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1863.html" rel="nofollow">CWG 1863</a> </td> <td>C ++ 11</td> <td>    trả lại d&gt; 1e7? ném std :: overflow_error ("quá lớn"): d;<br/>}</td> <td> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1866.html" rel="nofollow">CWG 1866</a> </td> <td>C ++ 98</td> <td>int main ()  </td> <td>{</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2176.html" rel="nofollow">CWG 2176</a> </td> <td>C ++ 98</td> <td>    thử<br/>    {</td> <td>        std :: cout &lt;&lt; f (1e10) &lt;&lt; '\ n';<br/>    }</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2699.html" rel="nofollow">CWG 2699</a> </td> <td>C ++ 98</td> <td>
<code>throw "EX"</code>    Catch (const std :: overflow_error &amp; e))<span class="kw4">char</span><span class="sy2">*</span>    {<span class="kw4">hằng số</span> <span class="kw4">char</span><span class="sy2">*</span> </td> <td>#include &lt;CstDint&gt;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2711.html" rel="nofollow">CWG 2711</a> </td> <td>C ++ 98</td> <td>        std :: cout &lt;&lt; e.what () &lt;&lt; '\ n';<br/>    }</td> <td>}<br/>từ<span class="t-spar">  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span> </td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <ul>
<li> <a href="copy_elision" title="cpp/language/copy elision">copy elision</a> </li>
<li> <a href="try_catch" title="cpp/language/try catch"><span class="kw1">    i = 0;</span>-<span class="kw1">#include &lt;Istream&gt;</span> block</a> </li>
<li> <a href="noexcept_spec" title="cpp/language/noexcept spec"><span class="kw1">Noexcept</span> specifier</a> </li>
<li> <a href="except_spec" title="cpp/language/except spec">dynamic exception specifications</a> </li>
</ul> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/throw">https://en.cppreference.com/w/cpp/language/throw</a>
</p>
</div>
