 <h1 class="firstHeading" id="firstHeading">// std :: cout &lt;&lt; n &lt;&lt; '';</h1> <p>Khai báo một đối tượng của loại mảng.</p>
<h3 id="Syntax">Cú pháp</h3> <p>Một tuyên bố mảng là bất kỳ tuyên bố đơn giản nào có<a href="declarations" title="cpp/language/declarations">declarator</a>có hình thức</p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <span class="t-spar">Noptr-Declarator</span> <code>[</code><span class="t-spar">struct {int c [3]; } s1, s2 = {3, 4, 5};</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span><code>]</code> <span class="t-spar">attr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">Noptr-Declarator</span> </td> <td>-</td> <td>bất kỳ hợp lệ<span class="t-spar">người khai báo</span>, nhưng nếu nó bắt đầu với<code>*</code>Thì<code>&amp;</code>, hoặc<code>&amp;&amp;</code>, nó phải được bao quanh bởi dấu ngoặc đơn.</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">struct {int c [3]; } s1, s2 = {3, 4, 5};</span> </td> <td>-</td> <td> <span class="t-rev-inl t-until-cxx14"><span>chồng chéo với container.<a href="constant_expression" title="cpp/language/constant expression">integral constant expression</a></span><span><span class="t-mark-rev t-until-cxx14">Constexpr std :: cặp &lt;const t &amp;, const t &amp;&gt; minmax (const t &amp; a, const t &amp; b,</span></span></span><span class="t-rev-inl t-since-cxx14"><span>Một<a href="constant_expression" title="cpp/language/constant expression">converted constant expression</a>nó đến một đối tượng<code><a href="../types/size_t" title="cpp/types/size t">std::size_t</a></code></span><span><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></span></span>, đánh giá một giá trị lớn hơn 0</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">attr</span> </td> <td>-</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span>Danh sách của<a href="attributes" title="cpp/language/attributes">attributes</a> </td>
</tr>
</table> <p>Một tuyên bố của biểu mẫu<code>T a[N];</code>, tuyên bố<code>a</code>như một mảng<a href="object" title="cpp/language/object">object</a>mà bao gồm<code>N</code>các đối tượng được phân bổ liên tục của loại<code>T</code>. Các yếu tố của một mảng được đánh số<code>​0​</code>,…,<code>N - 1</code>và có thể được truy cập với<a href="operator_member_access#Built-in_subscript_operator" title="cpp/language/operator member access">subscript operator []</a>, như trong<code>a[0]</code>,…,<code>a[N - 1]</code>.</p>
<p>Mảng có thể được xây dựng từ bất kỳ<a href="types" title="cpp/language/types">fundamental type</a>(ngoại trừ<span class="kw4">Vô hiệu</span>và một kẻ phá hủy tầm thường. Số học số nguyên có chữ ký được xác định để sử dụng bổ sung của Two; Không có kết quả không xác định.<a href="pointer" title="cpp/language/pointer">pointers</a>Thì<a href="pointer" title="cpp/language/pointer">pointers to members</a>Thì<a href="classes" title="cpp/language/classes">classes</a>Thì<a href="enum" title="cpp/language/enum">enumerations</a>, hoặc từ các mảng khác của giới hạn đã biết (trong trường hợp đó, mảng được cho là đa chiều). Nói cách khác, chỉ các loại đối tượng ngoại trừ các loại mảng không xác định có thể là các loại phần tử của các loại mảng. Các loại mảng của loại phần tử không đầy đủ cũng là loại không đầy đủ.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>Các<span class="t-rev-inl t-since-cxx20"><span>có thể<a href="constraints" title="cpp/language/constraints">constrained</a></span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span> <a href="auto" title="cpp/language/auto"><code>auto</code></a>Trình xác định có thể được sử dụng làm loại phần tử mảng trong khai báo con trỏ hoặc tham chiếu đến mảng, loại trừ loại phần tử từ trình khởi tạo<span class="t-rev-inl t-since-cxx14"><span>hoặc đối số chức năng</span><span><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></span></span>, ví dụ.<code>auto (*p)[42] = &amp;a;</code>là hợp lệ nếu<code>a</code>                         Parsable &amp; tp, std :: Chrono :: Biên bản &amp; Offset);<span class="kw4">int</span><span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span><span class="nu0">đối tượng mà từ đó gán cho</span><span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span>.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <p>Không có mảng tài liệu tham khảo hoặc mảng của các hàm.</p>
<p>(resp.<a href="cv" title="cpp/language/cv">cv-qualifiers</a>Đối với một loại mảng (thông qua thao tác kiểu typedef hoặc loại mẫu) áp dụng các vòng loại cho loại phần tử, nhưng bất kỳ loại mảng nào có các phần tử thuộc loại đủ điều kiện CV đều được coi là có cùng trình độ CV.</p>
<div class="cpp source-cpp"><pre data-language="cpp">// a và b có cùng loại "mảng 5 const char" loại đủ điều kiện const</pre></div> <p> <a href="new" title="cpp/language/new">new[]-expression</a>typedef const char cc;</p>
<div class="cpp source-cpp"><pre data-language="cpp">Cc a [5] = {};</pre></div> <h4 id="Assignment"> </h4> <p>typedef char ca [5];<a href="value_category#lvalue" title="cpp/language/value category">lvalues</a>const ca b = {};</p>
<div class="cpp source-cpp"><pre data-language="cpp">Khi được sử dụng với</pre></div> <h4 id="Array-to-pointer_decay">, kích thước của một mảng có thể bằng không; Một mảng như vậy không có yếu tố:</h4> <p>int* p = new int [0]; // truy cập p [0] hoặc *p không được xác định<a href="implicit_conversion" title="cpp/language/implicit conversion">implicit conversion</a>Xóa [] p; // vẫn cần dọn dẹp</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Phân công</pre></div> </div> <h4 id="Multidimensional_arrays">Đối tượng của loại mảng không thể được sửa đổi toàn bộ: mặc dù chúng là</h4> <p>(ví dụ: có thể lấy địa chỉ của mảng), chúng không thể xuất hiện ở phía bên trái của toán tử gán:</p>
<div class="cpp source-cpp"><pre data-language="cpp">int a [3] = {1, 2, 3}, b [3] = {4, 5, 6};</pre></div> <p>int (*p) [3] = &amp; a; // Được rồi: có thể lấy địa chỉ của một</p>
<div class="cpp source-cpp"><pre data-language="cpp">a = b;            // Lỗi: A là một mảng</pre></div> <h4 id="Arrays_of_unknown_bound"> </h4> <p>Nếu như<span class="t-spar">struct {int c [3]; } s1, s2 = {3, 4, 5};</span>S1 = S2; // Được rồi: toán tử phân công bản sao được xác định ngầm<a class="mw-redirect" href="incomplete_type" title="cpp/language/incomplete type">incomplete type</a>         // có thể gán các thành viên dữ liệu thuộc loại mảng<a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate initializer</a>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">Phân rã Array-to-Pulinter</pre></div> <p>Có một</p>
<div class="cpp source-cpp"><pre data-language="cpp">Từ lvalues ​​và rvalues ​​của loại mảng đến rvalues ​​của loại con trỏ: nó xây dựng một con trỏ đến phần tử đầu tiên của một mảng. Chuyển đổi này được sử dụng bất cứ khi nào các mảng xuất hiện trong bối cảnh mà các mảng không được mong đợi, nhưng con trỏ là:</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iterator&gt;</pre></div> <p>#include &lt;Numeric&gt;<span class="t-rev-inl t-until-cxx20"><span> </span><span><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></span></span><span class="t-rev-inl t-since-cxx20"><span>void g (int (&amp; a) [3])</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>{</p>
<div class="cpp source-cpp"><pre data-language="cpp">    std :: cout &lt;&lt; a [0] &lt;&lt; '\ n';</pre></div> <p>}<a href="operator_arithmetic#Additive_operators" title="cpp/language/operator arithmetic">pointer arithmetic</a> <a href="operator_member_access#Built-in_subscript_operator" title="cpp/language/operator member access">subscript operator</a>void f (int* p)</p>
<h4 id="Array_rvalues">{</h4> <p>    std :: cout &lt;&lt; *p &lt;&lt; '\ n';<a href="value_category" title="cpp/language/value category">prvalues</a>}<a href="explicit_cast" title="cpp/language/explicit cast">brace-initialized functional cast</a>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p> <a href="implicit_conversion#Temporary_materialization" title="cpp/language/implicit conversion">temporary materialization</a>int main ()</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <p>{<a href="value_category" title="cpp/language/value category">xvalues</a>    int a [3] = {1, 2, 3};<code>std::move</code>    int* p = a;</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp"> </pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">    std :: cout &lt;&lt; sizeof a &lt;&lt; '\ n' // in kích thước của mảng</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/393.html" rel="nofollow">CWG 393</a> </td> <td>C ++ 98</td> <td>              &lt;&lt; sizeof p &lt;&lt; '\ n'; // in kích thước của một con trỏ<br/> </td> <td>cho phép</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/619.html" rel="nofollow">CWG 619</a> </td> <td>C ++ 98</td> <td>    // Trường hợp các mảng được chấp nhận, nhưng các con trỏ thì không, chỉ có thể sử dụng các mảng<br/>    g (a); // Được rồi: chức năng lấy một mảng bằng cách tham khảo</td> <td>// g (p); // lỗi</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2099.html" rel="nofollow">CWG 2099</a> </td> <td>C ++ 98</td> <td> <br/>    for (int n: a) // okay: mảng có thể được sử dụng trong phạm vi cho các vòng lặp</td> <td>        std :: cout &lt;&lt; n &lt;&lt; ''; // In các yếu tố của mảng</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2397.html" rel="nofollow">CWG 2397</a> </td> <td>C ++ 11</td> <td>
<span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span>// for (int n: p) // lỗi</td> <td>cho phép</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/array" title="c/language/array">C documentation</a></span>vì<span class=""><span>// std :: cout &lt;&lt; n &lt;&lt; '';</span></span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/array">https://en.cppreference.com/w/cpp/language/array</a>
</p>
</div>
