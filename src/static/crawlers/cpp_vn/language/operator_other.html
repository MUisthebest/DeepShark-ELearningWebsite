 <h1 class="firstHeading" id="firstHeading"> </h1> <table class="wikitable"> <tr> <th rowspan="2">Nhà điều hành<br/>tên</th> <th rowspan="2">Cú pháp</th> <th rowspan="2">
<a href="operators" title="cpp/language/operators">Over​load​able</a> </th> <th colspan="2">Ví dụ nguyên mẫu (cho<span class="kw1">lớp học</span>T)</th>
</tr> <tr> <th>Định nghĩa lớp bên trong</th> <th>Định nghĩa lớp bên ngoài</th>
</tr> <tr> <td>Gọi chức năng</td> <td>
<code>a(a1, a2)</code> </td> <td class="table-yes">Đúng</td> <td>
<code>R T::operator()(Arg1 &amp;a1, Arg2 &amp;a2, ...);</code> </td> <td class="table-na"> <small>N/a</small> </td>
</tr> <tr> <td>dấu phẩy</td> <td>
<code>a, b</code> </td> <td class="table-yes">Đúng</td> <td>
<code>T2&amp; T::operator,(T2 &amp;b);</code> </td> <td>
<code>T2&amp; operator,(const T &amp;a, T2 &amp;b);</code> </td>
</tr> <tr> <td>toán tử có điều kiện</td> <td>
<code>a ? b : c</code> </td> <td class="table-no">KHÔNG</td> <td class="table-na"> <small>N/a</small> </td> <td class="table-na"> <small>N/a</small> </td>
</tr>
</table> <h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3> <p>Các<i>Gọi chức năng</i>Toán tử cung cấp ngữ nghĩa chức năng cho bất kỳ đối tượng.</p>
<p>Các<i>toán tử có điều kiện</i>(thông thường được gọi là<i>điều kiện ternary</i>) Kiểm tra giá trị boolean của biểu thức thứ nhất và, tùy thuộc vào giá trị kết quả, đánh giá và trả về biểu thức thứ hai hoặc thứ ba.</p>
<h4 id="Built-in_function_call_operator">Toán tử gọi chức năng tích hợp</h4> <p>Các biểu thức cuộc gọi chức năng có biểu mẫu</p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <span class="t-spar">chức năng</span>﻿<code>(</code><span class="t-spar">Arg1</span><code>,</code> <span class="t-spar">Arg2</span><code>,</code> <span class="t-spar">Arg3</span><code>,</code>...<code>)</code> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <p>Ở đâu</p>
<ul>
<li> <span class="t-spar">chức năng</span>là loại chức năng biểu thức hoặc loại con trỏ chức năng và</li>
<li> <span class="t-spar">Arg1</span><code>,</code> <span class="t-spar">Arg2</span><code>,</code> <span class="t-spar">Arg3</span><code>,</code>... là một danh sách trống của các biểu thức tùy ý<span class="t-rev-inl t-since-cxx11"><span>hoặc danh sách sáng chế giằng</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>, ngoại trừ nhà điều hành dấu phẩy không được phép ở cấp cao nhất để tránh sự mơ hồ.</li>
</ul> <p>Cho một cuộc gọi đến một chức năng không thành viên hoặc một<a href="static" title="cpp/language/static">static member function</a>Thì<span class="t-spar">chức năng</span>có thể là một lvalue đề cập đến một hàm (trong trường hợp đó<a href="implicit_conversion#Function-to-pointer_conversion" title="cpp/language/implicit conversion">function-to-pointer conversion</a>bị triệt tiêu), hoặc một prvalue của loại con trỏ chức năng.</p>
<p>Tên (hoặc thành viên) được chỉ định bởi<span class="t-spar">chức năng</span>có thể bị quá tải,<a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a>Các quy tắc được sử dụng để quyết định quá tải nào sẽ được gọi.</p>
<p>Nếu như<span class="t-spar">chức năng</span>Chỉ định hàm thành viên, nó có thể là ảo, trong trường hợp đó, trình ghi đè cuối cùng của hàm đó sẽ được gọi, sử dụng công văn động khi chạy.</p>
<p>Để gọi chức năng,</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <p>              Không có p);<span class="t-spar">chức năng</span>cũng như tất cả các biểu thức<span class="t-spar">Arg1</span>Thì<span class="t-spar">Arg2</span>Thì<span class="t-spar">Arg3</span>, v.v., được cung cấp như các đối số được đánh giá theo thứ tự tùy ý,<a href="eval_order" title="cpp/language/eval order">unsequenced</a>đối với nhau.</p>
</td> <td><span class="t-mark-rev t-until-cxx17">xáo trộn</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <p><span class="t-spar">chức năng</span>được giải trình tự trước mỗi<span class="t-spar">Arg1</span>Thì<span class="t-spar">Arg2</span>Thì<span class="t-spar">Arg3</span>};<a href="default_arguments" title="cpp/language/default arguments">default arguments</a>, nếu có. Các biểu thức đối số được đánh giá theo thứ tự tùy ý,<a href="eval_order" title="cpp/language/eval order">indeterminately sequenced</a>đối với nhau.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <p>Mỗi tham số chức năng được khởi tạo với đối số tương ứng của nó sau<a href="implicit_conversion" title="cpp/language/implicit conversion">implicit conversion</a>Nếu cần thiết.</p>
<ul>
<li>Nếu không có đối số tương ứng, tương ứng<a href="default_arguments" title="cpp/language/default arguments">default argument</a>được sử dụng, và nếu không có, chương trình không được hình thành.</li>
<li>Nếu cuộc gọi được thực hiện theo hàm thành viên, thì<code>this</code>Con trỏ đến đối tượng hiện tại được chuyển đổi như thể bằng cách diễn viên rõ ràng đến<code>this</code>Con trỏ dự kiến ​​bởi chức năng.</li>
<li>Việc khởi tạo và phá hủy từng tham số xảy ra trong bối cảnh của<a href="expressions#Full-expressions" title="cpp/language/expressions">full-expression</a>trong trường hợp cuộc gọi hàm xuất hiện, ví dụ, có nghĩa là nếu hàm tạo hoặc hàm hủy của tham số ném một ngoại lệ, thì<a href="function-try-block" title="cpp/language/function-try-block">function <span class="kw1">    i = 0;</span> blocks</a>của chức năng được gọi không được xem xét.</li>
</ul> <p>Nếu hàm là hàm biến đổi,<a href="variadic_arguments#Default_conversions" title="cpp/language/variadic arguments">default argument promotions</a>được áp dụng cho tất cả các đối số phù hợp với tham số Ellipsis. Nó được xác định theo chủ đề<a href="lifetime" title="cpp/language/lifetime">lifetime</a>của một tham số kết thúc khi hàm trong đó nó được xác định trả về hoặc ở cuối của biểu hiện đầy đủ kèm theo.</p>
<p>Loại trả về của biểu thức cuộc gọi hàm là loại trả về của hàm đã chọn, đã quyết định sử dụng liên kết tĩnh (bỏ qua<span class="kw1">ảo</span>Từ khóa), ngay cả khi hàm ghi đè thực sự được gọi là trả về một loại khác. Điều này cho phép các chức năng ghi đè trả về các con trỏ hoặc tham chiếu đến các lớp có nguồn gốc từ loại trả về được trả về bởi hàm cơ sở, tức là hỗ trợ C ++<a class="extiw" href="https://en.wikipedia.org/wiki/Covariant_return_type" title="enwiki:Covariant return type">covariant return types</a>. Nếu như<span class="t-spar">chức năng</span>Chỉ định một hàm hủy, loại trả về là<span class="kw4">Vô hiệu</span>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>Khi một đối tượng thuộc loại lớp<code>X</code>được truyền hoặc trả về từ một hàm, nếu mỗi hàm tạo bản sao, hàm tạo di chuyển và phá hủy của<code>X</code>là tầm thường hoặc bị xóa, và<code>X</code>Có ít nhất một hàm tạo bản sao hoặc di chuyển không bị xóa, các triển khai được phép tạo một đối tượng tạm thời để giữ tham số chức năng hoặc đối tượng kết quả.</p>
<p>Đối tượng tạm thời được xây dựng từ đối số chức năng hoặc giá trị trả về, và tham số hoặc đối tượng trả về của hàm được khởi tạo như thể bằng cách sử dụng hàm xây dựng tầm thường không bị bỏ rơi để sao chép tạm thời (ngay cả khi hàm tạo đó không thể truy cập hoặc không được chọn bởi độ phân giải quá tải để thực hiện bản sao hoặc di chuyển của đối tượng).</p>
<p>Điều này cho phép các đối tượng của các loại lớp nhỏ, chẳng hạn như<code><a href="../numeric/complex" title="cpp/numeric/complex">std::complex</a></code>hoặc<code>std::span</code>, được chuyển đến hoặc trả lại từ các chức năng trong các thanh ghi.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <p>Danh mục giá trị của biểu thức cuộc gọi hàm là lvalue nếu hàm trả về tham chiếu lvalue hoặc tham chiếu rvalue cho hàm, là một xvalue nếu hàm trả về tham chiếu rvalue cho đối tượng và là một prvalue khác. Nếu biểu thức cuộc gọi chức năng là một prvalue của loại đối tượng, nó phải có loại hoàn chỉnh ngoại trừ<span class="t-rev-inl t-since-cxx17"><span>Khi prvalue không được vật chất hóa, chẳng hạn như</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>Khi được sử dụng làm toán hạng của<a href="decltype" title="cpp/language/decltype"><code>decltype</code></a>(hoặc là hoạt động phù hợp của một<a href="#Built-in_comma_operator">built-in comma operator</a>Đó là toán hạng của DeclType).</p>
<p>Biểu thức cuộc gọi chức năng tương tự trong cú pháp với khởi tạo giá trị<code>T()</code>, ĐẾN<a href="explicit_cast" title="cpp/language/explicit cast">function-style cast</a>  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }<code>T(A1)</code>và để khởi tạo trực tiếp một tạm thời<code>T(A1, A2, A3, ...)</code>là<code>T</code>là tên của một loại.</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;Cstdio&gt;</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c"> </pre></div> </div> <h4 id="Built-in_comma_operator">cấu trúc s</h4> <p>{</p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <span class="t-spar">chức năng được gọi</span> <code>,</code> <span class="t-spar">7.000000</span> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <p>        trả về printf ("%f \ n", d); // Cuộc gọi chức năng đối số biến<code>E1, E2</code>, biểu thức<code>E1</code>    }<a href="expressions#Discarded-value_expressions" title="cpp/language/expressions">discarded</a> <a href="lifetime#Temporary_object_lifetime" title="cpp/language/lifetime">until the end of the containing full expression</a>    int f2 ()<code>E2</code>    {<span class="t-rev-inl t-until-cxx17"><span>        trả lại F1 (7); // Cuộc gọi chức năng thành viên, giống như this-&gt; f1 ()<code>operator,</code>                      // đối số số nguyên được chuyển đổi thành gấp đôi</span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span>.</p>
<p>    }<code>E2</code>. Nếu như<code>E2</code>};<span class="t-rev-inl t-since-cxx17"><span>  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span> <span class="t-rev-inl t-since-cxx17"><span>  constexpr bool is_lteq (partial_ordering cmp) noexcept {return cmp &lt;= 0; }</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>. Nếu như<code>E2</code>void f ()</p>
<p>{<code>f(a, b, c)</code>    đặt ("hàm gọi là"); // gọi chức năng<code>int a[] = {1, 2, 3}</code>}<code>f(a, (n++, n + b), c)</code>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20 t-until-cxx23">
<td> <p> <a href="operator_member_access#Built-in_subscript_operator" title="cpp/language/operator member access">subscript operator</a>tự động c = [] (tự động a) {return a; };</p>
<p>Ví dụ,<code>a[b, c]</code>được không dùng nữa và<code>a[(b, c)]</code>Toán tử Auto Auto của Const</p>
</td> <td>
<span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span><br/><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span>
</td>
</tr> <tr class="t-rev t-since-cxx23">
<td> <p>int main ()<a href="operator_member_access#Built-in_subscript_operator" title="cpp/language/operator member access">subscript operator</a>. Ví dụ,<code>a[b, c]</code>là xấu hoặc tương đương với<code>a.operator[](b, c)</code>.</p>
<p>{<code>a[(b, c)]</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">    f ();    // gọi chức năng</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">    S s;</pre></div> </div> <h4 id="Conditional_operator">    s.f2 (); // Cuộc gọi chức năng thành viên</h4> <p>}</p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <span class="t-spar">chức năng được gọi</span> <code>?</code> <span class="t-spar">7.000000</span> <code>:</code> <span class="t-spar">Nhà điều hành dấu phẩy tích hợp</span> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <p>Các biểu thức vận hành dấu phẩy có biểu mẫu<a href="implicit_conversion" title="cpp/language/implicit conversion">contextually converted</a>ĐẾN<span class="kw4">bool</span>E1<code>true</code>E2<code>false</code>Trong một biểu thức dấu phẩy</p>
<p>được đánh giá, kết quả của nó là<code>E1 ? E2 : E3</code>(mặc dù nếu nó có loại lớp, nó sẽ không bị phá hủy</p>
<div class="t-li1">
<span class="t-li">1)</span>nếu không (bao gồm cả trường hợp<code>E2</code>hoặc<code>E3</code>và kết quả của việc chuyển đổi bằng<code>void</code>), và các tác dụng phụ của nó được hoàn thành trước khi đánh giá biểu thức</div> <div class="t-li2">
<span class="t-li">bắt đầu</span>có thể được chuyển đổi một cách ngầm và rõ ràng thành loại<code>E2</code>hoặc<code>E3</code>(Lưu ý rằng một người dùng do người dùng xác định<a href="throw" title="cpp/language/throw">throw-expression</a>không thể đảm bảo trình tự)<a href="bit_field" title="cpp/language/bit field">bit-field</a>Loại, giá trị và giá trị của kết quả của biểu thức dấu phẩy chính xác là loại, giá trị và danh mục giá trị của toán hạng thứ hai,<a href="constexpr" title="cpp/language/constexpr">constexpr programming</a>là tạm thời<div class="cpp source-cpp"><pre data-language="cpp">, kết quả của biểu thức là tạm thời</pre></div>
</div> <div class="t-li2">
<span class="t-li">là một trường bit, kết quả là một trường bit.</span>};<code>E2</code>Và<code>E3</code>Dấu phẩy trong các danh sách được phân tách bằng dấu phẩy khác nhau, chẳng hạn như danh sách đối số chức năng (<code>void</code>) và danh sách khởi tạo<code>void</code>.<div class="cpp source-cpp"><pre data-language="cpp">, không phải là nhà điều hành dấu phẩy. Nếu nhà điều hành dấu phẩy cần được sử dụng trong các bối cảnh như vậy, thì nó phải được đặt dấu ngoặc đơn:</pre></div>
</div> <div class="t-li1">
<span class="t-li">2)</span>                        Forwardit2 d_first, pinarypredicate p);<code>E2</code>hoặc<code>E3</code>Sử dụng biểu thức dấu phẩy chưa được đánh giá là đối số thứ hai (phải) của một</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>                        Forwardit2 d_first, pinarypredicate p);<code>E2</code>Và<code>E3</code>Một biểu thức dấu phẩy chưa được biết đến không thể là đối số thứ hai (phải) của một<a href="implicit_conversion" title="cpp/language/implicit conversion">implicit conversion sequence</a>Dấu ngoặc đơn là cần thiết khi sử dụng biểu thức dấu phẩy làm chỉ số, ví dụ:<span class="t-rev-inl t-since-cxx11"><span>#include &lt;Istream&gt;<i> </i>int main ()</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>{<code>X</code>    for (int i = 0, j = 10; i &lt;= j; ++ i, --j)<code>TX</code>    // Trường hợp ngữ pháp ngôn ngữ chỉ cho phép một biểu thức:<i> </i>    // * Trong thành phần thứ ba của vòng lặp for<code>Y</code>    for (int i = 0, j = 10; i &lt;= j; ++ i, --j)<code>TY</code>                  std :: error_code &amp; ec);</div> <div class="t-li2">
<span class="t-li">    // ^Danh sách phân tách ^Nhà điều hành dấu phẩy</span>Nếu như<code>Y</code>        std :: cout &lt;&lt; "i =" &lt;&lt; i &lt;&lt; "j =" &lt;&lt; j &lt;&lt; '\ n';<code>TY&amp;</code> <span class="t-rev-inl t-until-cxx11"><span>    trả về ++ n;</span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>}</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>.</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <span class="t-li">    // * Trong một câu lệnh trả về</span>Nếu như<code>Y</code>    // trả về nhật ký ("một lỗi!"), -1;<code>TY&amp;&amp;</code> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <div class="t-li2">
<span class="t-li">    // * Trong biểu thức khởi tạo</span>Nếu như<code>Y</code>khoảng cách<span class="t-rev-inl t-until-cxx11"><span>một rvalue</span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>một prvalue</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>    // MyClass (Const Arg &amp; Arg)<code>TX</code>Và<code>TY</code>    //: Thành viên {ném_IF_BAD (arg), arg}</div> <div class="t-li3">
<span class="t-li"> </span>nếu như<code>TX</code>Và<code>TY</code>    // vân vân.<code>TY</code> <code>TX</code>    int m = (++ n, std :: cout &lt;&lt; "n =" &lt;&lt; n &lt;&lt; '\ n', ++ n, 2 * n);<code>TY</code>Thì</div> <div class="t-li3">
<span class="t-li">    // biểu thức (ngoài cùng bên phải) là kết quả của toàn bộ chuỗi:</span>    int n = 1;<code>TY</code>    int n = 1;<code>TX</code>    int m = (++ n, std :: cout &lt;&lt; "n =" &lt;&lt; n &lt;&lt; '\ n', ++ n, 2 * n);<code>TY</code>    // m bây giờ là 6<code>TX</code>:<div class="cpp source-cpp"><pre data-language="cpp">    std :: cout &lt;&lt; "m =" &lt;&lt; (++ m, m) &lt;&lt; '\ n';</pre></div>
</div> <div class="t-li3">
<span class="t-li"> </span>}<code>Y</code>i = 0 j = 10<a href="implicit_conversion" title="cpp/language/implicit conversion">standard conversions</a>.</div> <div class="t-li2">
<span class="t-li">i = 1 j = 9</span>i = 2 j = 8<code>E2</code>i = 4 j = 6<code>E3</code>Và<code>E3</code>i = 4 j = 6<code>E2</code>i = 5 j = 5</div> <div class="t-li2">
<span class="t-li">n = 2</span>m = 7<span class="t-v">(4)</span>).</div> <div class="t-li2">
<span class="t-li">Toán tử có điều kiện</span>Các biểu thức toán tử có điều kiện có biểu mẫu</div> <div class="t-li1">
<span class="t-li">là trong</span>Nếu như<code>E2</code>Và<code>E3</code>E1<code>E2</code>Và<code>E3</code>E2</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>E3<code>E2</code>Và<code>E3</code>Thẻ đầu tiên của toán tử có điều kiện được đánh giá và</div> <div class="t-li1">
<span class="t-li">từ_sys</span>. Sau khi cả đánh giá giá trị và tất cả các tác dụng phụ của toán hạng đầu tiên được hoàn thành, nếu kết quả là</div> <div class="t-li2">
<span class="t-li">, toán hạng thứ hai được đánh giá. Nếu kết quả là</span>Nếu chỉ khi mọi yếu tố trong phạm vi<code>E2</code>Và<code>E3</code>, toán hạng thứ ba được đánh giá.<span class="t-rev-inl t-until-cxx17"><span>Loại và giá trị của biểu thức có điều kiện</span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span><span class="t-rev-inl t-since-cxx17"><span>đối tượng kết quả của ai là</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>được xác định theo các quy tắc sau:<code>E1</code>.</div> <div class="t-li2">
<span class="t-li">, sau đó một trong những điều sau đây phải đúng, hoặc chương trình không được hình thành:</span>Nếu chỉ khi mọi yếu tố trong phạm vi<code>E2</code>Và<code>E3</code>1.1)<a href="usual_arithmetic_conversions" title="cpp/language/usual arithmetic conversions"><i>(nhưng không phải cả hai) là một (có thể là dấu ngoặc đơn)</i></a>. Kết quả của toán tử có điều kiện có loại và loại giá trị của biểu thức khác. Nếu biểu thức khác là một<i>Khái niệm Common_With =</i>1.2)</div> <div class="t-li2">
<span class="t-li">Trước C ++ 14.</span>Nếu chỉ khi mọi yếu tố trong phạm vi<code>E2</code>Và<code>E3</code>std :: chuỗi str = 2 + 2 == 4? "OK": ném std :: logic_error ("2 + 2! = 4");<a href="pointer#Composite_pointer_type" title="cpp/language/pointer">composite pointer type</a>1.2)<div class="cpp source-cpp"><pre data-language="cpp">thuộc loại</pre></div>
</div> <div class="t-li2">
<span class="t-li">(bao gồm cả trường hợp khi cả hai đều là biểu hiện ném). Kết quả là một loại prvalue</span>Nếu chỉ khi mọi yếu tố trong phạm vi<code>E2</code>Và<code>E3</code>2 + 2 == 4? Ném 123: Ném 456;<div class="cpp source-cpp"><pre data-language="cpp">là các trường bit glvalue của cùng một loại giá trị và loại CV1 T và CV2 T, tương ứng, các toán hạng được coi là loại CV t cho phần còn lại của phần này, trong đó CV là sự kết hợp của CV1 và CV2.</pre></div>
</div> <div class="t-li2">
<span class="t-li">có các loại khác nhau, ít nhất một trong số đó là loại (có thể là đủ điều kiện CV) hoặc cả hai đều là glvalues ​​của cùng một loại giá trị và có cùng một loại ngoại trừ đủ điều kiện CV, sau đó một nỗ lực được thực hiện để tạo thành một</span>Nếu chỉ khi mọi yếu tố trong phạm vi<code>E2</code>Và<code>E3</code>Bỏ qua truy cập thành viên, liệu một toán hạng là một trường bit<code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code>, hoặc liệu một chức năng chuyển đổi có bị xóa từ mỗi toán hạng sang<code>std::nullptr_t</code>.</div> <div class="t-li2">
<span class="t-li">loại mục tiêu</span>được xác định bởi toán hạng khác</div> <p>, như được mô tả dưới đây. Một toán hạng (gọi nó<code>L</code>Và<code>R</code>-a, ở đâu<code>P</code>là<code>P</code>) loại</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">có thể được chuyển đổi thành</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">loại mục tiêu</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>của toán hạng khác (gọi nó<a href="usual_arithmetic_conversions" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a>) loại<code>L</code>Và<code>R</code>3.1)<code>?:</code>là một lvalue, loại mục tiêu là</p>
<p>và tham chiếu phải liên kết trực tiếp với<code><a href="../types/common_type" title="cpp/types/common type">std::common_type</a></code>.</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">3.2)</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">là một xvalue, loại mục tiêu là</pre></div> </div> <h3 id="Standard_library">Mẫu &lt;Class I2&gt;</h3> <p>và tham chiếu phải liên kết trực tiếp.<code>operator()</code>3.3)</p>
<table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../memory/default_delete" title="cpp/memory/default delete"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td>, hoặc nếu không có các chuỗi chuyển đổi ở trên có thể được hình thành và ít nhất một trong số<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::default_delete&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/plus" title="cpp/utility/functional/plus"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td>là loại lớp (có thể là đủ điều kiện CV),<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::plus&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/minus" title="cpp/utility/functional/minus"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td>3.3.1)<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::minus&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/multiplies" title="cpp/utility/functional/multiplies"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td>là cùng một loại lớp (bỏ qua trình độ cv) và<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::multiplies&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/divides" title="cpp/utility/functional/divides"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td>ít nhất là có đủ điều kiện CV như<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::divides&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/modulus" title="cpp/utility/functional/modulus"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td>, loại mục tiêu là<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::modulus&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/negate" title="cpp/utility/functional/negate"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td>3.3.2)<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::negate&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/equal_to" title="cpp/utility/functional/equal to"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td>là một lớp cơ sở của<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::equal_to&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/not_equal_to" title="cpp/utility/functional/not equal to"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td>, loại mục tiêu là<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::not_equal_to&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/greater" title="cpp/utility/functional/greater"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td>với các trình điều chỉnh CV của<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::greater&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/less" title="cpp/utility/functional/less"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td>Cấu trúc A {};<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::less&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/greater_equal" title="cpp/utility/functional/greater equal"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td> <br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::greater_equal&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/less_equal" title="cpp/utility/functional/less equal"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td>Cấu trúc B: A {};<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::less_equal&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/logical_and" title="cpp/utility/functional/logical and"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td> <br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::logical_and&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/logical_or" title="cpp/utility/functional/logical or"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td>sử dụng t = const b;<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::logical_or&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/logical_not" title="cpp/utility/functional/logical not"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td> <br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::logical_not&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/bit_and" title="cpp/utility/functional/bit and"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td>A a = true? TẠI(); // y = a (), ty = a, x = t (), tx = const b, target = const a<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::bit_and&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/bit_or" title="cpp/utility/functional/bit or"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td>3.3.3)<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::bit_or&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/bit_xor" title="cpp/utility/functional/bit xor"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td>Nếu không, loại mục tiêu là loại<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::bit_xor&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/unary_negate" title="cpp/utility/functional/unary negate"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td>3.4)<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::unary_negate&lt;Predicate&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/binary_negate" title="cpp/utility/functional/binary negate"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td>3.4)<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::binary_negate&lt;Predicate&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/reference_wrapper/operator()" title="cpp/utility/functional/reference wrapper/operator()"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td>Nếu cả hai chuỗi có thể được hình thành (<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::reference_wrapper&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/function/operator()" title="cpp/utility/functional/function/operator()"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td>đến loại mục tiêu của<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::function&lt;R(Args...)&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../locale/locale/operator()" title="cpp/locale/locale/operator()"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td>đến loại mục tiêu của<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::locale</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/map/value_compare" title="cpp/container/map/value compare"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td>so sánh hai giá trị của loại<code>value_type</code> <br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::map&lt;Key,T,Compare,Allocator&gt;::value_compare</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/multimap/value_compare" title="cpp/container/multimap/value compare"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td>so sánh hai giá trị của loại<code>value_type</code> <br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::multimap&lt;Key,T,Compare,Allocator&gt;::value_compare</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../thread/packaged_task/operator()" title="cpp/thread/packaged task/operator()"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div> </td> <td>), hoặc chỉ có một người có thể được hình thành nhưng đó là trình tự chuyển đổi mơ hồ, chương trình là xấu.<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::packaged_task&lt;R(Args...)&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/random/linear_congruential_engine/operator()" title="cpp/numeric/random/linear congruential engine/operator()"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>3.5)<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::linear_congruential_engine&lt;UIntType,a,c,m&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/random/uniform_int_distribution/operator()" title="cpp/numeric/random/uniform int distribution/operator()"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>Nếu chính xác một chuỗi chuyển đổi có thể được hình thành (lưu ý rằng nó vẫn có thể được hình thành, ví dụ: do vi phạm truy cập), chuỗi chuyển đổi đó được áp dụng và toán hạng được chuyển đổi được sử dụng thay cho toán hạng ban đầu cho phần còn lại của mô tả này (bắt đầu tại<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::uniform_int_distribution&lt;IntType&gt;</code>)</span> </td>
</tr> </table> <p>3.6)<code>operator,</code>TRONG<a class="external text" href="https://www.boost.org/doc/libs/release/libs/assign/doc/index.html#intro" rel="nofollow">boost.assign</a>Thì<a class="external text" href="https://www.boost.org/doc/libs/release/libs/spirit/doc/html/index.html" rel="nofollow">boost.spirit</a>}<a class="external text" href="https://soci.sourceforge.net/doc.html" rel="nofollow">SOCI</a>Tổng là 15<code>operator,</code>.</p>
<h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/446.html" rel="nofollow">CWG 446</a> </td> <td>C ++ 98</td> <td>Nếu không có chuỗi chuyển đổi nào có thể được hình thành, các toán hạng không được thay đổi trong phần còn lại của mô tả này.<br/>là glvalues ​​cùng loại và cùng một loại giá trị, thì kết quả có cùng loại và danh mục giá trị, và là một trường bit nếu ít nhất một trong số</td> <td>là một trường bit.<br/>Nếu không, kết quả là một prvalue. Nếu như</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/462.html" rel="nofollow">CWG 462</a> </td> <td>C ++ 98</td> <td>Không có cùng loại và loại (có thể (có thể là CV), độ phân giải quá tải được thực hiện bằng cách sử dụng các ứng cử viên tích hợp bên dưới để cố gắng chuyển đổi toán hạng thành các loại tích hợp. Nếu độ phân giải quá tải không thành công, chương trình sẽ không được hình thành. Mặt khác, các chuyển đổi đã chọn được áp dụng và các toán hạng được chuyển đổi được sử dụng thay cho các toán hạng ban đầu cho bước 6.<br/>Các chuyển đổi lvalue-to-rvalue, mảng sang trỏ và chức năng sang trỏ được áp dụng cho các toán hạng thứ hai và thứ ba. Sau đó,<br/>6.1)</td> <td>Bây giờ có cùng loại, kết quả là một loại prvalue thuộc loại đó<br/>Chỉ định một đối tượng tạm thời<br/>sao chép-khởi tạo từ bất kỳ toán hạng nào đã được chọn sau khi đánh giá</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/587.html" rel="nofollow">CWG 587</a> </td> <td>C ++ 98</td> <td>6.2)<br/>có loại số học hoặc loại liệt kê:<br/>Chuyển đổi số học thông thường<br/>được áp dụng để đưa chúng vào</td> <td>, và kết quả là loại đó.<br/>6.3)</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1029.html" rel="nofollow">CWG 1029</a> </td> <td>C ++ 98</td> <td>là con trỏ, hoặc một là một con trỏ và cái còn lại là một hằng số con trỏ null, sau đó chuyển đổi con trỏ và chuyển đổi trình độ được áp dụng để đưa chúng vào</td> <td> <span class="kw4">Vô hiệu</span> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1550.html" rel="nofollow">CWG 1550</a> </td> <td>C ++ 98</td> <td>, và kết quả là loại đó.<br/>int* intptr;<span class="kw4">Vô hiệu</span> </td> <td> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1560.html" rel="nofollow">CWG 1560</a> </td> <td>C ++ 98</td> <td>
<span class="kw4">Vô hiệu</span>sử dụng hỗn hợp = declType (true? nullptr: intptr);<br/> <br/>static_assert (std :: is_same_v &lt;hỗn hợp, int*&gt;); // nullptr trở thành int*</td> <td>6.4)<br/>với a<span class="kw4">Vô hiệu</span>là con trỏ cho các thành viên, hoặc một là một con trỏ cho thành viên và cái còn lại là hằng số con trỏ null, sau đó chuyển đổi con trỏ sang thành viên và chuyển đổi trình độ được áp dụng để đưa chúng vào loại con trỏ tổng hợp và kết quả là loại đó.</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1642.html" rel="nofollow">CWG 1642</a> </td> <td>C ++ 98</td> <td>        {double {1}, double {2}, double {3}}; // mảng sao lưu<span class="t-spar">chức năng</span>Cấu trúc a<br/>{</td> <td>không được phép</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1805.html" rel="nofollow">CWG 1805</a> </td> <td>C ++ 98</td> <td>    int* m_ptr;<br/>} Một;</td> <td> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1895.html" rel="nofollow">CWG 1895</a> </td> <td>C ++ 98<br/>C ++ 11</td> <td>int* a ::* memptr = &amp; a :: m_ptr; // memptr là một con trỏ tới thành viên m_ptr của a<br/> <br/>// memptr làm nullptr thành loại con trỏ thành thành viên m_ptr của a<br/>static_assert (std :: is_same_v &lt;declType (false? memptr: nullptr), int*a ::*&gt;);</td> <td> <br/>// a.*Memptr bây giờ chỉ là con trỏ tới int và nullptr cũng trở thành con trỏ tới int</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1932.html" rel="nofollow">CWG 1932</a> </td> <td>C ++ 98</td> <td>static_assert (std :: is_same_v &lt;declType (false? a.*memptr: nullptr), int*&gt;);</td> <td>6.5)</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2226.html" rel="nofollow">CWG 2226</a> </td> <td>C ++ 11</td> <td>là hằng số con trỏ null và ít nhất một trong số đó là loại<br/>, thì loại kết quả là<br/>6.6)</td> <td>cho phép</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2321.html" rel="nofollow">CWG 2321</a> </td> <td>C ++ 98</td> <td>Trong tất cả các trường hợp khác, chương trình không được hình thành.<br/>Đối với mỗi cặp các loại số học được thăng chức<br/>là loại con trỏ, con trỏ đến thành viên hoặc loại liệt kê phạm vi, chữ ký chức năng sau tham gia vào độ phân giải quá tải được thực hiện trong bước 5 của các quy tắc trên:</td> <td>Toán tử lr? :( bool, l, r);<br/>Toán tử p? :( bool, p, p);<br/>nơi LR là kết quả của</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2715.html" rel="nofollow">CWG 2715</a> </td> <td>C ++ 98</td> <td>thực hiện trên<br/>. Nhà điều hành “<br/>Không thể bị quá tải, các chữ ký chức năng này chỉ tồn tại cho mục đích phân giải quá tải.<sup class="reference" id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup> </td> <td>Loại trả về của một toán tử có điều kiện cũng có thể truy cập được dưới dạng đặc điểm loại nhị phân<br/>#include &lt;Istream&gt;</td>
</tr>
</table> <ol class="references"> <li id="cite_note-1"> <span class="reference-text">#include &lt;chuỗi&gt;</span> </li> </ol> <h3 id="See_also">(chức năng)</h3> <p><a href="operator_precedence" title="cpp/language/operator precedence">Operator precedence</a> <a href="operators" title="cpp/language/operators">Operator overloading</a></p>
<table class="wikitable"> <tr style="text-align:center"> <th colspan="7">Các nhà khai thác chung</th>
</tr> <tr style="text-align:center"> <td>
<a href="operator_assignment" title="cpp/language/operator assignment">assignment</a> </td> <td>
<a href="operator_incdec" title="cpp/language/operator incdec">increment<br/>decrement</a> </td> <td>
<a href="operator_arithmetic" title="cpp/language/operator arithmetic">arithmetic</a> </td> <td>
<a href="operator_logical" title="cpp/language/operator logical">logical</a> </td> <td>
<a href="operator_comparison" title="cpp/language/operator comparison">comparison</a> </td> <td>
<a href="operator_member_access" title="cpp/language/operator member access">member<br/>access</a> </td> <td>
<strong class="selflink">khác</strong> </td>
</tr> <tr style="text-align:center"> <td rowspan="6"> <p><code>a = b a += b a -= b a *= b a /= b a %= b a &amp;= b a |= b a ^= b a &lt;&lt;= b a &gt;&gt;= b</code></p>
</td> <td rowspan="6"> <p><code>++a --a a++ a--</code></p>
</td> <td rowspan="6"> <p><code>+a -a a + b a - b a * b a / b a % b ~a a &amp; b a | b a ^ b a &lt;&lt; b a &gt;&gt; b</code></p>
</td> <td rowspan="6"> <p><code>!a a &amp;&amp; b a || b</code></p>
</td> <td rowspan="6"> <p><code>a == b a != b a &lt; b a &gt; b a &lt;= b a &gt;= b a &lt;=&gt; b</code></p>
</td> <td rowspan="6"> <p><code>a[...] *a &amp;a a-&gt;b a.b a-&gt;*b a.*b</code></p>
</td> <td>Gọi chức năng</td>
</tr> <tr style="text-align:center"> <td>
<code>a(...)</code> </td>
</tr> <tr style="text-align:center"> <td>dấu phẩy</td>
</tr> <tr style="text-align:center"> <td>
<code>a, b</code> </td>
</tr> <tr style="text-align:center"> <td>có điều kiện</td>
</tr> <tr style="text-align:center"> <td>
<code>a ? b : c</code> </td>
</tr> <tr> <th colspan="7">Các nhà khai thác đặc biệt</th>
</tr> <tr> <td colspan="7"> <p><a href="static_cast" title="cpp/language/static cast"><code>static_cast</code></a>Chuyển đổi một loại thành loại liên quan khác<br/> <a href="dynamic_cast" title="cpp/language/dynamic cast"><code>dynamic_cast</code></a>Chuyển đổi trong hệ thống phân cấp thừa kế<br/> <a href="const_cast" title="cpp/language/const cast"><code>const_cast</code></a>thêm hoặc loại bỏ<a href="cv" title="cpp/language/cv">cv</a>-Qualifiers<br/> <a href="reinterpret_cast" title="cpp/language/reinterpret cast"><code>reinterpret_cast</code></a>Chuyển đổi loại thành loại không liên quan<br/> <a href="explicit_cast" title="cpp/language/explicit cast">C-style cast</a>Chuyển đổi loại này sang loại khác bằng cách kết hợp<code>static_cast</code>Thì<code>const_cast</code>, Và<code>reinterpret_cast</code> <br/> <a href="new" title="cpp/language/new"><code>new</code></a>Tạo các đối tượng có thời lượng lưu trữ động<br/> <a href="delete" title="cpp/language/delete"><code>delete</code></a>Các đối tượng phá hủy được tạo trước đây bởi biểu thức và bản phát hành mới thu được vùng bộ nhớ<br/> <a href="sizeof" title="cpp/language/sizeof"><code>sizeof</code></a>truy vấn kích thước của một loại<br/> <a href="sizeof..." title="cpp/language/sizeof..."><code>sizeof...</code></a>truy vấn kích thước của một<a href="parameter_pack" title="cpp/language/parameter pack">parameter pack</a> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span><br/> <a href="typeid" title="cpp/language/typeid"><code>typeid</code></a>truy vấn thông tin loại của một loại<br/> <a href="noexcept" title="cpp/language/noexcept"><code>noexcept</code></a>kiểm tra xem một biểu thức có thể ném một ngoại lệ<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span><br/> <a href="alignof" title="cpp/language/alignof"><code>alignof</code></a>// (thường là 4):<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></p>
</td>
</tr>
</table> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/operator_other" title="c/language/operator other">C documentation</a></span>vì<span class=""><span> </span></span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/operator_other">https://en.cppreference.com/w/cpp/language/operator_other</a>
</p>
</div>
