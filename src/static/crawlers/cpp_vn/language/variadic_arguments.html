 <h1 class="firstHeading" id="firstHeading">luôn được hỗ trợ nếu không được đánh giá</h1> <p>Cho phép một chức năng chấp nhận bất kỳ số lượng đối số bổ sung.</p>
<p>Được biểu thị bằng một dấu vết<code>...</code> <span class="t-rev-inl t-since-cxx11"><span>(Khác với một phần giới thiệu mở rộng gói)</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>theo sau<span class="t-spar">danh sách tham số</span>xuất hiện trong bối cảnh ngay lập tức của một khởi tạo mẫu.<a href="function" title="cpp/language/function">function declaration</a>.</p>
<p>Khi<span class="t-spar">danh sách tham số</span>không trống, dấu phẩy tùy chọn có thể đi trước<code>...</code>biểu thị một hàm variadic. Điều này cung cấp khả năng tương thích với C (đã thêm một yêu cầu cho dấu phẩy khi nó áp dụng các nguyên mẫu chức năng từ C ++).</p>
<div class="cpp source-cpp"><pre data-language="cpp">// Hàm được khai báo như sau</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>int printx (const char* fmt ...);<a href="parameter_pack" title="cpp/language/parameter pack">parameter pack</a>// có thể được gọi với một hoặc nhiều đối số:<code><a href="../types/is_function" title="cpp/types/is function">std::is_function</a></code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <h3 id="Default_conversions">printx ("Hello World");</h3> <p>printx ("a =%d b =%d", a, b);<a href="implicit_conversion#Value_transformations" title="cpp/language/implicit conversion">conversions</a> <i>int printx (const char* fmt, ...); // Tương tự như trên (dấu phẩy bên ngoài được phép</i>:</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li> <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code>Phải là một prvalue của số học, liệt kê không bị trục xuất hoặc loại con trỏ. Quảng cáo tích phân được thực hiện trên<code>void*</code> </li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <ul>
<li> <code>float</code>                                  // để tương thích C)<code>double</code>. Sau khi xây dựng và kiểm tra đối tượng Sentry, kiểm tra<a href="implicit_conversion#Floating-point_promotion" title="cpp/language/implicit conversion">floating-point promotion</a> </li>
<li> <code>bool</code>Thì<code>char</code>Thì<code>short</code>int printy (..., const char* fmt); // Lỗi: ... không thể xuất hiện dưới dạng tham số<code>int</code>int printz (...); // hợp lệ, nhưng không thể truy cập các đối số<a href="implicit_conversion#Integral_promotion" title="cpp/language/implicit conversion">integer promotion</a> </li>
</ul> <p>Lưu ý: Điều này khác với một hàm<span class="t-rev-inl t-until-cxx11"><span>Mở rộng, được biểu thị bằng một dấu chấm lửng là một phần của trình khai báo tham số, thay vì dấu chấm lửng xuất hiện sau tất cả các khai báo tham số. Cả hai bản mở rộng gói tham số và dấu chấm lửng "biến thể" có thể xuất hiện trong khai báo mẫu hàm, như trong trường hợp của</span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>Chuyển đổi mặc định</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Khi một hàm variadic được gọi, sau khi lvalue-to-rvalue, mảng đến trỏ và chức năng để con trỏ<a href="expressions#Potentially-evaluated_expressions" title="cpp/language/expressions">unevaluated calls</a>).</p>
<p>, mỗi đối số là một phần của danh sách đối số biến trải qua các chuyển đổi bổ sung được gọi là<a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a>Quảng cáo đối số mặc định<a href="sfinae" title="cpp/language/sfinae">SFINAE</a>.</p>
<p>Đối số được chuyển đổi thành<a href="../utility/variadic" title="cpp/utility/variadic"><code>&lt;cstdarg&gt;</code> library facilities</a>:</p>
<table class="t-dsc-begin"> <tr class="t-dsc-header"> <th colspan="2">C Thư viện<code><a href="../header/cstdarg" title="cpp/header/cstdarg">&lt;cstdarg&gt;</a></code> </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/variadic/va_start" title="cpp/utility/variadic/va start"> <span class="t-lines"><span>Va_Start</span></span></a></div> </td> <td>Cho phép truy cập vào các đối số chức năng Variadic<br/> <span class="t-mark">(Chức năng Macro)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/variadic/va_arg" title="cpp/utility/variadic/va arg"> <span class="t-lines"><span>Va_arg</span></span></a></div> </td> <td>Truy cập đối số chức năng Variadic tiếp theo<br/> <span class="t-mark">(Chức năng Macro)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/variadic/va_copy" title="cpp/utility/variadic/va copy"> <span class="t-lines"><span>Va_Copy</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>Tạo một bản sao của các đối số chức năng Variadic<br/> <span class="t-mark">(Chức năng Macro)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/variadic/va_end" title="cpp/utility/variadic/va end"> <span class="t-lines"><span>Va_end</span></span></a></div> </td> <td>kết thúc việc chuyển giao của các đối số chức năng variadic<br/> <span class="t-mark">(Chức năng Macro)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/variadic/va_list" title="cpp/utility/variadic/va list"> <span class="t-lines"><span>Va_List</span></span></a></div> </td> <td>giữ thông tin cần thiết bởi<code><a href="../utility/variadic/va_start" title="cpp/utility/variadic/va start">va_start</a></code>Thì<code><a href="../utility/variadic/va_arg" title="cpp/utility/variadic/va arg">va_arg</a></code>Thì<code><a href="../utility/variadic/va_end" title="cpp/utility/variadic/va end">va_end</a></code>, Và<code><a href="../utility/variadic/va_copy" title="cpp/utility/variadic/va copy">va_copy</a></code> <br/> <span class="t-mark">(typedef)</span> </td>
</tr> </table> <p>, và các liệt kê không có đoạn được chuyển đổi thành<code><a href="../utility/variadic/va_start" title="cpp/utility/variadic/va start">va_start</a></code>hoặc các loại số nguyên rộng hơn như trong</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>Chỉ số học, liệt kê, con trỏ, con trỏ tới thành viên và đối số loại (sau khi chuyển đổi) được cho phép. Tuy nhiên,<a href="parameter_pack#Pack_expansion" title="cpp/language/parameter pack">pack expansion</a>Các loại lớp không Pod<a href="lambda#Lambda_capture" title="cpp/language/lambda">lambda capture</a>Các loại lớp với hàm tạo bản sao không tầm thường đủ điều kiện, một hàm tạo di chuyển không tầm thường đủ điều kiện hoặc một hàm tạo hủy không tầm thường, cùng với các liệt kê phạm vi<code><a href="../utility/variadic/va_start" title="cpp/utility/variadic/va start">va_start</a></code>được hình thành tốt và là một rvalue.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <h3 id="Alternatives"> </h3> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul>
<li> <a href="parameter_pack" title="cpp/language/parameter pack">Variadic templates</a>, được hỗ trợ có điều kiện trong các cuộc gọi có khả năng được đánh giá với ngữ nghĩa do thực hiện (các loại này luôn được hỗ trợ trong</li>
<li>Bởi vì các tham số variadic có thứ hạng thấp nhất cho mục đích<code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code>, chúng thường được sử dụng như những dự phòng bắt tất cả<code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code>Trong phần thân của hàm sử dụng các đối số khác nhau, các giá trị của các đối số này có thể được truy cập bằng cách sử dụng</li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <h3 id="Notes">Ghi chú</h3> <p>Hành vi của<code>R printz(...);</code>Macro không được xác định nếu tham số cuối cùng trước khi Ellipsis có loại tham chiếu hoặc có loại không tương thích với loại kết quả từ các chương trình khuyến mãi đối số mặc định.<a href="sfinae" title="cpp/language/sfinae">SFINAE</a>Nếu a<a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a>.</p>
<p>hoặc một thực thể do một<code>f(int n...)</code>được sử dụng làm tham số cuối cùng trong<code>f(int n, ...)</code>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>Cũng có thể được sử dụng để tạo các chức năng lấy số lượng đối số khác nhau. Chúng thường là lựa chọn tốt hơn vì chúng không áp đặt các hạn chế đối với các loại đối số, không thực hiện các chương trình khuyến mãi tích phân và dấu phẩy động và được loại an toàn.</p>
<p><code>void f1(auto...); // same as template&lt;class... Ts&gt; void f3(Ts...)void f2(auto, ...); // same as template&lt;class T&gt; void f3(T...)</code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/506.html" rel="nofollow">CWG 506</a> </td> <td>C ++ 98</td> <td>Nếu tất cả các đối số biến chia sẻ một loại chung, một<br/>Cung cấp một cơ chế thuận tiện (mặc dù có cú pháp khác) để truy cập các đối số biến. Tuy nhiên, trong trường hợp này, các đối số không thể được sửa đổi vì</td> <td>Chỉ có thể cung cấp một con trỏ const cho các yếu tố của nó.<br/>Trong ngôn ngữ lập trình C cho đến C23, ít nhất một tham số có tên phải xuất hiện trước tham số Ellipsis, vì vậy<br/>làm cho một số thành ngữ sfinae không hoạt động</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/634.html" rel="nofollow">CWG 634</a> </td> <td>C ++ 98</td> <td>, khai thác mức độ ưu tiên thấp nhất của chuyển đổi Ellipsis trong<br/>Cú pháp này cho các đối số variadic được giới thiệu vào năm 1983 C ++ mà không có dấu phẩy trước dấu chấm lửng. Khi C89 các nguyên mẫu chức năng được thông qua từ C ++, nó đã thay thế cú pháp bằng một yêu cầu dấu phẩy. Để tương thích, C ++ 98 chấp nhận cả C ++-Kiểu</td> <td>và kiểu c</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2247.html" rel="nofollow">CWG 2247</a> </td> <td>C ++ 11</td> <td>Dấu phẩy có thể được sử dụng trong các mẫu chức năng viết tắt để làm cho Ellipsis biểu thị chức năng biến đổi thay vì mẫu variadic:<br/>chuyển các đối số lớp không Pod cho một<code>va_start</code> </td> <td>dấu chấm lửng dẫn đến hành vi không xác định<br/>void g (x &lt;t :: n&gt;*) {}</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2347.html" rel="nofollow">CWG 2347</a> </td> <td>C ++ 11</td> <td>vượt qua những lập luận như vậy là<br/>được hỗ trợ có điều kiện với</td> <td>Semantics xác định thực hiện<br/>Các loại lớp được hỗ trợ có điều kiện<br/>làm cho một số thành ngữ sfinae không hoạt động</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/variadic" title="c/language/variadic">C documentation</a></span>vì<span class=""><span>luôn được hỗ trợ nếu không được đánh giá</span></span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/variadic_arguments">https://en.cppreference.com/w/cpp/language/variadic_arguments</a>
</p>
</div>
