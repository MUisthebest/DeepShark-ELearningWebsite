 <h1 class="firstHeading" id="firstHeading">Biểu hiện mới</h1> <p>Tạo và khởi tạo các đối tượng với động<a href="storage_duration" title="cpp/language/storage duration">storage duration</a>, nghĩa là, các đối tượng có trọn đời không nhất thiết phải bị giới hạn bởi phạm vi mà chúng được tạo ra.</p>
<h3 id="Syntax">Cú pháp</h3> <table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <code>::</code><span class="t-mark">ATOMIC_INTPTR_T</span> <code>new</code> <code>(</code><span class="t-spar">kiểu</span>﻿<code>)</code> <span class="t-spar">hoặc một mảng các đối tượng như vậy, biểu hiện mới vượt qua yêu cầu căn chỉnh (được gói trong</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>::</code><span class="t-mark">ATOMIC_INTPTR_T</span> <code>new</code> <span class="t-spar">kiểu</span> <span class="t-spar">hoặc một mảng các đối tượng như vậy, biểu hiện mới vượt qua yêu cầu căn chỉnh (được gói trong</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> </td> <td>(2)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>::</code><span class="t-mark">ATOMIC_INTPTR_T</span> <code>new</code> <code>(</code><span class="t-spar">Ngay cả khi kích thước đầu tiên bằng không, các ràng buộc ngữ nghĩa của việc khởi tạo giá trị, một yếu tố giả thuyết vẫn cần được đáp ứng.</span>﻿<code>)</code> <code>(</code><span class="t-spar">kiểu</span>﻿<code>)</code> <span class="t-spar">hoặc một mảng các đối tượng như vậy, biểu hiện mới vượt qua yêu cầu căn chỉnh (được gói trong</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> </td> <td>(3)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>::</code><span class="t-mark">ATOMIC_INTPTR_T</span> <code>new</code> <code>(</code><span class="t-spar">Ngay cả khi kích thước đầu tiên bằng không, các ràng buộc ngữ nghĩa của việc khởi tạo giá trị, một yếu tố giả thuyết vẫn cần được đáp ứng.</span>﻿<code>)</code> <span class="t-spar">kiểu</span> <span class="t-spar">hoặc một mảng các đối tượng như vậy, biểu hiện mới vượt qua yêu cầu căn chỉnh (được gói trong</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> </td> <td>(4)</td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <div class="t-li1">
<span class="t-li">Đầu vào</span>Cố gắng tạo một đối tượng thuộc loại, được biểu thị bằng<a href="type#Type_naming" title="cpp/language/type">type-id</a> <span class="t-spar">kiểu</span>, có thể là loại mảng<span class="t-rev-inl t-since-cxx11"><span>và có thể bao gồm một<a href="auto" title="cpp/language/auto">placeholder type specifier</a></span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx17"><span>hoặc bao gồm một tên mẫu lớp có đối số sẽ được suy luận bởi<a href="class_template_argument_deduction" title="cpp/language/class template argument deduction">class template argument deduction</a></span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>.</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>                                   Nhị phân p);<span class="t-v">Outputit adjacent_difference (đầu vào đầu tiên, đầu vào cuối cùng, </span>, nhưng cung cấp các đối số bổ sung cho chức năng phân bổ, xem<a href="new#Placement_new" title="cpp/language/new">placement new</a>.</div> <h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">kiểu</span> </td> <td>-</td> <td>Các loại mục tiêu ID</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">hoặc một mảng các đối tượng như vậy, biểu hiện mới vượt qua yêu cầu căn chỉnh (được gói trong</span> </td> <td>-</td> <td>Danh sách biểu thức được bao trong dấu ngoặc đơn<span class="t-rev-inl t-since-cxx11"><span>hoặc a<span class="t-spar">{</span></span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">Ngay cả khi kích thước đầu tiên bằng không, các ràng buộc ngữ nghĩa của việc khởi tạo giá trị, một yếu tố giả thuyết vẫn cần được đáp ứng.</span> </td> <td>-</td> <td>Đối số vị trí bổ sung</td>
</tr>
</table> <p><br/>Các<code>new</code>Biểu thức cố gắng phân bổ lưu trữ và sau đó cố gắng xây dựng và khởi tạo một đối tượng không tên hoặc một mảng đối tượng không tên trong bộ lưu trữ được phân bổ. Biểu hiện mới trả về một con trỏ prvalue cho đối tượng được xây dựng hoặc, nếu một mảng các đối tượng được xây dựng, một con trỏ đến phần tử ban đầu của mảng.</p>
<p>Cú pháp<span class="t-v">(1)</span>hoặc<span class="t-v">(3)</span>được yêu cầu nếu<span class="t-spar">kiểu</span>Bao gồm dấu ngoặc đơn:</p>
<div class="cpp source-cpp"><pre data-language="cpp">int mới (*[10]) ();    // lỗi: phân tích cú pháp là (new int) (*[10]) () ()</pre></div> <p>Ngoài ra,<span class="t-spar">kiểu</span>Mới (int (*[10]) ()); // Được rồi: phân bổ một mảng 10 con trỏ cho các chức năng</p>
<div class="cpp source-cpp"><pre data-language="cpp">được phân tích cú pháp tham lam: nó sẽ được lấy bao gồm mọi mã thông báo có thể là một phần của người khai báo:</pre></div> <p>Các<span class="t-spar">hoặc một mảng các đối tượng như vậy, biểu hiện mới vượt qua yêu cầu căn chỉnh (được gói trong</span>Int mới * 1; // Lỗi: được phân tích cú pháp là (new int*) (1)</p>
<ul><li> <span class="t-spar">kiểu</span> <a href="array#Arrays_of_unknown_bound" title="cpp/language/array">array of unknown bound</a>Thì</li></ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li>Một<a href="auto" title="cpp/language/auto">placeholder</a>người khởi tạo mới<span class="t-spar">kiểu</span>, đó là,<span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span> <span class="t-rev-inl t-since-cxx14"><span>hoặc<code>decltype(auto)</code></span><span><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></span></span><span class="t-rev-inl t-since-cxx20"><span>không phải là tùy chọn nếu<a href="constraints#Concepts" title="cpp/language/constraints">type constraint</a></span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>Thì</li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <ul><li>được sử dụng trong<span class="t-spar">kiểu</span>, có thể kết hợp với một<a href="class_template_argument_deduction" title="cpp/language/class template argument deduction">deduced</a>.</li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <div class="cpp source-cpp"><pre data-language="cpp">Một mẫu lớp được sử dụng trong</pre></div> <h3 id="Dynamic_arrays">đối số của ai cần phải là</h3> <p>Nếu như<span class="t-spar">kiểu</span>double* p = new Double [] {1, 2, 3}; // Tạo một mảng loại đôi [3]<span class="t-rev-inl t-until-cxx14"><span><a href="constant_expression" title="cpp/language/constant expression">integral constant expression</a></span><span><span class="t-mark-rev t-until-cxx14">Constexpr std :: cặp &lt;const t &amp;, const t &amp;&gt; minmax (const t &amp; a, const t &amp; b,</span></span></span><span class="t-rev-inl t-since-cxx14"><span><a href="constant_expression" title="cpp/language/constant expression">converted constant expression</a>nó đến một đối tượng<code><a href="../types/size_t" title="cpp/types/size t">std::size_t</a></code></span><span><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></span></span>Auto P = new Auto ('C');            // Tạo một đối tượng duy nhất của loại char. P là một char*<span class="t-v">(2)</span>Và<span class="t-v">(4)</span> <span class="t-rev-inl t-until-cxx14"><span>Auto Q = New Std :: Tích hợp Auto (1);         // ok: q là một int*</span><span><span class="t-mark-rev t-until-cxx14">Constexpr std :: cặp &lt;const t &amp;, const t &amp;&gt; minmax (const t &amp; a, const t &amp; b,</span></span></span><span class="t-rev-inl t-since-cxx14"><span>auto q = new std :: floating_point auto (true) // lỗi: loại ràng buộc không được thỏa mãn<code><a href="../types/size_t" title="cpp/types/size t">std::size_t</a></code></span><span><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></span></span> <i>Auto r = new std :: cặp (1, true); // OK: r là STD :: Cặp &lt;int, bool&gt;*</i>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">Auto r = new std :: vector;        // Lỗi: Loại phần tử không thể được suy luận</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <p>Mảng động</p>
</td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> <p>là một loại mảng, tất cả các kích thước khác với loại đầu tiên phải được chỉ định là dương</p>
<ul>
<li>, nhưng (chỉ khi sử dụng cú pháp không được sắp xếp<code><a href="../types/size_t" title="cpp/types/size t">std::size_t</a></code>bất kỳ biểu thức nào có thể chuyển đổi thành</li>
<li>một biểu thức của loại tích phân, loại liệt kê hoặc loại lớp với chức năng chuyển đổi không thể trừ đơn sang loại tích phân hoặc bảng liệt kê<a href="implicit_conversion" title="cpp/language/implicit conversion">second standard conversion</a>bất kỳ biểu thức nào có thể chuyển đổi thành</li>
<li>. Đây là cách duy nhất để trực tiếp tạo một mảng có kích thước được xác định trong thời gian chạy, các mảng đó thường được gọi là</li>
<li>Mảng động<a href="aggregate_initialization" title="cpp/language/aggregate initialization">the brace-enclosed initializer</a>int n = 42;<code>'\0'</code>trên a<a href="string_literal" title="cpp/language/string literal">string literal</a>).</li>
</ul> <p>Nhân đôi A [N] [5]; // lỗi</p>
<ul>
<li>Auto P1 = new Double [n] [5];  // ĐƯỢC RỒI<code><a href="../types/size_t" title="cpp/types/size t">std::size_t</a></code>Auto P2 = new Double [5] [n];  // Lỗi: Chỉ có chiều đầu tiên có thể không phải là người quan hệ<a href="constant_expression#Core_constant_expressions" title="cpp/language/constant expression">core constant expression</a>Tự động P3 = Mới (gấp đôi [n] [5]); // Lỗi: cú pháp (1) không thể được sử dụng cho các mảng động<a href="expressions#Potentially-evaluated_expressions" title="cpp/language/expressions">potentially evaluated</a>Hành vi không được xác định nếu giá trị trong kích thước đầu tiên (được chuyển đổi thành loại tích phân hoặc liệt kê nếu cần) là âm.</li>
<li>Trong các trường hợp sau đây, biểu thức chỉ định kích thước đầu tiên là sai:<code><a href="../memory/new/nothrow" title="cpp/memory/new/nothrow">std::nothrow</a></code>biểu thức thuộc loại không thuộc lớp và giá trị của nó trước khi chuyển đổi thành<code>noexcept</code>là tiêu cực;<a href="try_catch" title="cpp/language/try catch">exception handler</a>nó đến một đối tượng<code><a href="../memory/new/bad_array_new_length" title="cpp/memory/new/bad array new length">std::bad_array_new_length</a></code>Thì</li>
<li>Biểu thức thuộc loại lớp và giá trị của nó sau chức năng chuyển đổi do người dùng xác định và trước</li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <p>là tiêu cực;</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>Nếu như<span class="t-spar">hoặc một mảng các đối tượng như vậy, biểu hiện mới vượt qua yêu cầu căn chỉnh (được gói trong</span>Điều đó như vậy<span class="t-spar">{</span>giá trị nhỏ hơn số lượng phần tử mảng được cung cấp trong<a href="expressions#Potentially-evaluated_expressions" title="cpp/language/expressions">potentially evaluated</a>(bao gồm cả việc chấm dứt<a href="constant_expression#Core_constant_expressions" title="cpp/language/constant expression">core constant expression</a>Nếu giá trị trong chiều đầu tiên là sai vì bất kỳ lý do nào,<a href="copy_initialization" title="cpp/language/copy initialization">copy-initializing</a>Nếu, sau khi chuyển đổi sang</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <h3 id="Allocation">, chiều đầu tiên là một</h3> <p>Và nó là<a href="../memory/new/operator_new" title="cpp/memory/new/operator new">allocation function</a>. Nếu như<span class="t-spar">kiểu</span>, chương trình không được hình thành,<code><a href="http://en.cppreference.com/w/cpp/memory/new/operator_new"><span class="kw690">nhà điều hành mới</span></a></code>. Nếu như<span class="t-spar">kiểu</span>mặt khác, nếu hàm phân bổ được gọi là không ném (bao gồm cả<code><a href="http://en.cppreference.com/w/cpp/memory/new/operator_new"><span class="kw690">nhà điều hành mới</span></a><span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span><span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span></code>.</p>
<p>Quá tải không được khai báo<a href="../memory/new/operator_new" title="cpp/memory/new/operator new">allocation function</a>), biểu hiện mới không gọi hàm phân bổ và thay vào đó ném một ngoại lệ của một loại phù hợp với<code>::</code>Mặt khác, biểu hiện mới trả về con trỏ null của loại kết quả cần thiết.<code>::new T</code>hoặc<code>::new T[n]</code>Kích thước đầu tiên của số 0 là chấp nhận được và hàm phân bổ được gọi.<a href="lookup" title="cpp/language/lookup">looked up</a>người khởi tạo mới<a href="scope" title="cpp/language/scope">scope</a>, và chiều đầu tiên là<code>T</code>và không phải a<code>T</code>.</p>
<p>, những hạn chế về ngữ nghĩa của<code><a href="../types/size_t" title="cpp/types/size t">std::size_t</a></code>Một yếu tố giả thuyết của mảng từ một danh sách khởi tạo trống được kiểm tra.<code>sizeof(T)</code>Phân bổ<code>T</code>.</p>
<p>Biểu hiện mới phân bổ lưu trữ bằng cách gọi<a href="delete" title="cpp/language/delete">delete<span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span><span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span></a>là một loại không phải, tên của hàm là<span class="kw4">char</span>Thì<span class="kw4">STD</span> <span class="kw4">char</span><span class="t-rev-inl t-since-cxx17"><span>, hoặc<a href="../types/byte" title="cpp/types/byte"><code>std::byte</code></a></span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>là một loại mảng, tên của hàm là</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>Như mô tả trong<code>E1</code>, Chương trình C ++ có thể cung cấp các thay thế toàn cầu và cụ thể cho các chức năng này. Nếu biểu hiện mới bắt đầu với tùy chọn<code>E2</code>Nếu tất cả những điều sau đây là đúng:</p>
<span class="t-li">1)</span>Nhà điều hành, như trong<code>E1</code>, thay thế cụ thể theo lớp sẽ bị bỏ qua (chức năng là<code>E2</code>.<span class="t-li">2)</span> <code>E1</code>Và<code>E2</code>trong toàn cầu<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>). Nếu không, nếu<code>E1</code>Và<code>E2</code>là một loại lớp, tra cứu bắt đầu trong phạm vi lớp học của<p>Khi gọi chức năng phân bổ, biểu thức mới vượt qua số lượng byte được yêu cầu là đối số đầu tiên, loại<code>delete[] new int[10];</code>, đó là chính xác<code><a href="http://en.cppreference.com/w/cpp/memory/new/operator_delete"><span class="kw692">Xóa toán tử</span></a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/memory/new/operator_new"><span class="kw690">nhà điều hành mới</span></a><span class="br0">.</span><span class="nu0">10</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>Đối với không phải là không có</p>
</td> <td><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p>Phân bổ mảng có thể cung cấp chi phí không được xác định, có thể thay đổi từ cuộc gọi này sang mức mới sang tiếp theo, trừ khi hàm phân bổ được chọn là dạng không phân bổ tiêu chuẩn. Con trỏ được trả về bởi biểu thức mới sẽ được bù bởi giá trị đó từ con trỏ được trả về bởi hàm phân bổ. Nhiều triển khai sử dụng chi phí mảng để lưu trữ số lượng đối tượng trong mảng được sử dụng bởi<a href="constant_expression" title="cpp/language/constant expression">constant expression</a>Biểu thức để gọi số lượng chính xác của các chất hủy diệt. Ngoài ra, nếu biểu hiện mới được sử dụng để phân bổ một mảng</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <h4 id="Placement_new">, nó có thể yêu cầu bộ nhớ bổ sung từ chức năng phân bổ nếu cần thiết để đảm bảo căn chỉnh chính xác các đối tượng thuộc mọi loại không lớn hơn kích thước mảng được yêu cầu, nếu sau đó một người được đặt vào mảng được phân bổ.</h4> <p>Nếu như<span class="t-spar">Ngay cả khi kích thước đầu tiên bằng không, các ràng buộc ngữ nghĩa của việc khởi tạo giá trị, một yếu tố giả thuyết vẫn cần được đáp ứng.</span>có thể được mở rộng để cung cấp lưu trữ bổ sung cho một biểu thức mới khác<code><span class="kw4">Vô hiệu</span><span class="sy2">*</span> <a href="http://en.cppreference.com/w/cpp/memory/new/operator_new"><span class="kw690">nhà điều hành mới</span></a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">Điều đó cho tất cả<span class="me2">size_t</span></span></a>, <span class="kw4">Vô hiệu</span><span class="sy2">*</span><span class="br0">)</span></code>Tuổi thọ của đối tượng được phân bổ bởi</p>
<div class="cpp source-cpp"><pre data-language="cpp">chứa nghiêm ngặt thời gian tồn tại của đối tượng được phân bổ bởi</pre></div> <p>sẽ gọi cùng một chức năng phân bổ toàn cầu có thể thay thế.<a href="../named_req/allocator" title="cpp/named req/Allocator">Allocator</a>Đối với một hàm phân bổ ném, các ngoại lệ trong</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>đầu tiên sẽ bị bắt trong cùng một người xử lý.<a href="../preprocessor/replace#Predefined_macros" title="cpp/preprocessor/replace"><code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code></a>Lưu ý rằng tối ưu hóa này chỉ được phép khi sử dụng biểu hiện mới, không phải bất kỳ phương pháp nào khác để gọi hàm phân bổ có thể thay thế:<code><a href="../memory/new/align_val_t" title="cpp/memory/new/align val t">std::align_val_t</a></code>có thể được tối ưu hóa, nhưng<span class="t-spar">không thể.</span>Trong quá trình đánh giá một</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <div class="cpp source-cpp"><pre data-language="cpp">, một cuộc gọi đến một chức năng phân bổ luôn bị bỏ qua. Chỉ các biểu hiện mới mà nếu không sẽ dẫn đến một cuộc gọi đến chức năng phân bổ toàn cầu có thể thay thế mới có thể được đánh giá trong các biểu thức không đổi.</pre></div> <p>Vị trí mới<code>new<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/memory/new/nothrow"><span class="kw701">Điều đó cho tất cả<span class="me2">Nothrow</span></span></a><span class="br0">)</span> T</code>Vị trí-Vị trí</p>
<h3 id="Initialization">Khởi tạo</h3> <p>được cung cấp, chúng được chuyển cho chức năng phân bổ như các đối số bổ sung. Các hàm phân bổ như vậy được gọi là "vị trí mới", sau khi chức năng phân bổ tiêu chuẩn</p>
<p>Nếu như<span class="t-spar">kiểu</span>, mà chỉ đơn giản là trả lại đối số thứ hai của nó không thay đổi. Điều này được sử dụng để xây dựng các đối tượng trong bộ lưu trữ được phân bổ:</p>
<ul>
<li>Nếu như<span class="t-spar">hoặc một mảng các đối tượng như vậy, biểu hiện mới vượt qua yêu cầu căn chỉnh (được gói trong</span>{<a href="default_initialization" title="cpp/language/default initialization">default-initialized</a>.</li>
<li>Nếu như<span class="t-spar">hoặc một mảng các đối tượng như vậy, biểu hiện mới vượt qua yêu cầu căn chỉnh (được gói trong</span>    // đủ lớn cho bất kỳ đối tượng nào của loại T Tiên.<a href="direct_initialization" title="cpp/language/direct initialization">direct-initialized</a>.</li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li>Nếu như<span class="t-spar">hoặc một mảng các đối tượng như vậy, biểu hiện mới vượt qua yêu cầu căn chỉnh (được gói trong</span>Điều đó như vậy<span class="t-spar">{</span> <a href="list_initialization" title="cpp/language/list initialization">list-initialized</a>.</li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <p>Nếu như<span class="t-spar">kiểu</span>    T* tptr = new (buf) t; // Xây dựng một đối tượng của T -t, đặt nó trực tiếp vào </p>
<ul>
<li>Nếu như<span class="t-spar">hoặc một mảng các đối tượng như vậy, biểu hiện mới vượt qua yêu cầu căn chỉnh (được gói trong</span> <a href="default_initialization" title="cpp/language/default initialization">default-initialized</a>.</li>
<ul><li>    tptr-&gt; ~ t ();           // bạn phải ** thủ công ** gọi cho kẻ phá hủy của đối tượng</li></ul>
<li>Nếu như<span class="t-spar">hoặc một mảng các đối tượng như vậy, biểu hiện mới vượt qua yêu cầu căn chỉnh (được gói trong</span>} // Rời khỏi phạm vi khối này tự động giải quyết vấn đề BUF.<a href="value_initialization" title="cpp/language/value initialization">value-initialized</a>.</li>
<ul><li>Lưu ý: Chức năng này được gói gọn bởi các chức năng thành viên của</li></ul>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li>Nếu như<span class="t-spar">hoặc một mảng các đối tượng như vậy, biểu hiện mới vượt qua yêu cầu căn chỉnh (được gói trong</span>Điều đó như vậy<span class="t-spar">{</span>Khi phân bổ một đối tượng có yêu cầu liên kết vượt quá<a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate-initialized</a>.</li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <ul><li>Nếu như<span class="t-spar">hoặc một mảng các đối tượng như vậy, biểu hiện mới vượt qua yêu cầu căn chỉnh (được gói trong</span>) là đối số thứ hai cho hàm phân bổ (cho các biểu mẫu vị trí,<a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate-initialized</a>.</li></ul> </td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <h4 id="Initialization_failure">Vị trí-Ass</h4> <p>xuất hiện sau khi căn chỉnh, như các đối số thứ ba, thứ tư, v.v.). Nếu độ phân giải quá tải không thành công (xảy ra khi hàm phân bổ dành riêng cho lớp được xác định với một chữ ký khác, vì nó ẩn trên toàn cầu), độ phân giải quá tải được cố gắng lần thứ hai, mà không liên kết trong danh sách đối số. Điều này cho phép các hàm phân bổ dành riêng cho lớp liên kết-không biết được ưu tiên hơn các hàm phân bổ nhận biết liên kết toàn cầu.</p>
<ul>
<li>mới t;      // Gọi toán tử mới (sizeof (t))</li>
<li>            // (c ++ 17) hoặc toán tử mới (sizeof (t), std :: align_val_t (alignof (t)))))</li>
</ul> <p>mới t [5];   // gọi toán tử mới [] (sizeof (t)*5 + chi phí trên đầu)<a href="lookup" title="cpp/language/lookup">lookup</a>            // (c ++ 17) hoặc toán tử mới (sizeof (t)*5+chi phí, std :: align_val_t (alignof (t)))))</p>
<ul>
<li>Mới (2, f) t; // Gọi toán tử mới (sizeof (t), 2, f)<code>::</code>            // (c ++ 17) hoặc toán tử mới (sizeof (t), std :: align_val_t (alignof (t)), 2, f)<code>T</code>Nếu một hàm phân bổ không ném (ví dụ: một chức năng được chọn bởi<code>T</code>) Trả về một con trỏ NULL vì lỗi phân bổ, sau đó biểu hiện mới trả về ngay lập tức, nó không cố gắng khởi tạo một đối tượng hoặc gọi chức năng phân giải. Nếu một con trỏ null được truyền dưới dạng đối số cho một biểu hiện mới của vị trí không phân bổ, điều này làm cho chức năng phân bổ vị trí không phân bổ tiêu chuẩn được chọn trở lại một con trỏ null, hành vi không được xác định.<code>T</code>.</li>
<li>Đối tượng được tạo bởi một biểu thức mới được khởi tạo theo các quy tắc sau.<code>T</code>Không phải là loại mảng, đối tượng đơn được xây dựng trong vùng bộ nhớ thu được:<a href="scope" title="cpp/language/scope">global scope</a>.</li>
</ul> <p>người khởi tạo mới<a href="delete" title="cpp/language/delete">delete-expression</a>).</p>
<p>vắng mặt, đối tượng là<a href="function#Function_type" title="cpp/language/function">parameter transformations</a>).</p>
<ul>
<li>người khởi tạo mới</li>
<li>là một danh sách biểu thức được bao trong dấu ngoặc đơn, đối tượng là</li>
</ul> <p>người khởi tạo mới<span class="t-rev-inl t-since-cxx11"><span>, đối tượng là</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>là loại mảng, một mảng các đối tượng được khởi tạo:</p>
<div class="cpp source-cpp"><pre data-language="cpp">người khởi tạo mới</pre></div> <p>vắng mặt, mỗi yếu tố là</p>
<ul>
<li>Ngay cả khi kích thước đầu tiên bằng không, các ràng buộc ngữ nghĩa của việc khởi tạo mặc định, một yếu tố giả thuyết vẫn cần được đáp ứng.<span class="kw4">Vô hiệu</span><span class="sy2">*</span>người khởi tạo mới</li>
<li>là một cặp dấu ngoặc đơn, mỗi phần tử là<span class="t-spar">Ngay cả khi kích thước đầu tiên bằng không, các ràng buộc ngữ nghĩa của việc khởi tạo giá trị, một yếu tố giả thuyết vẫn cần được đáp ứng.</span>người khởi tạo mới</li>
</ul> <p>, mảng là</p>
<h3 id="Memory_leaks">người khởi tạo mới</h3> <p>là một danh sách biểu thức không trống được bao trong dấu ngoặc đơn, mảng là<a href="delete" title="cpp/language/delete">delete-expression</a>Thất bại khởi tạo<i>Nếu khởi tạo chấm dứt bằng cách ném một ngoại lệ (ví dụ: từ hàm tạo), chương trình sẽ tìm ra chức năng phân giải phù hợp, thì:</i>Biểu thức truy cập thành viên lớp,</p>
<p>Nếu có thể tìm thấy một chức năng giải quyết phù hợp, chức năng giải quyết được gọi để giải phóng bộ nhớ trong đó đối tượng đang được xây dựng. Sau đó, ngoại lệ tiếp tục tuyên truyền trong bối cảnh biểu hiện mới.</p>
<div class="cpp source-cpp"><pre data-language="cpp">Nếu không thể tìm thấy chức năng giao dịch phù hợp rõ ràng, việc truyền bá ngoại lệ không khiến bộ nhớ đối tượng được giải phóng. Nó chỉ phù hợp nếu hàm phân bổ được gọi không phân bổ bộ nhớ, nếu không nó có khả năng dẫn đến rò rỉ bộ nhớ.</pre></div> <p>Phạm vi của</p>
<div class="cpp source-cpp"><pre data-language="cpp">của chức năng phân giải phù hợp được xác định như sau:</pre></div> <p>Nếu biểu hiện mới không bắt đầu</p>
<div class="cpp source-cpp"><pre data-language="cpp">và loại được phân bổ là loại lớp</pre></div> <p>hoặc một mảng loại lớp<a href="../memory#Smart_pointers" title="cpp/memory">smart pointer</a>:<span class="t-rev-inl t-until-cxx17"><span><code><a href="../memory/auto_ptr" title="cpp/memory/auto ptr">std::auto_ptr</a></code> </span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span><span class="t-rev-inl t-since-cxx11"><span><code><a href="../memory/unique_ptr" title="cpp/memory/unique ptr">std::unique_ptr</a></code>, hoặc<code><a href="../memory/shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code></span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>, một tìm kiếm được thực hiện cho chức năng Deallocation tên trong phạm vi lớp học của</p>
<h3 id="Keywords">không định nghĩa macro như vậy. Tuy nhiên, nó xác định hằng số macro</h3> <p><a href="../keyword/new" title="cpp/keyword/new"><code>new</code></a></p>
<h3 id="Notes">Ghi chú</h3> <p><a class="external text" href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html#array-cookies" rel="nofollow">Itanium C++ ABI</a>Nếu không, hoặc nếu không có gì được tìm thấy trong</p>
<p>Phạm vi lớp của lớp, chức năng giải quyết tên tên được tra cứu bằng cách tìm kiếm nó trong<a class="external text" href="https://cplusplus.github.io/CWG/issues/2382.html" rel="nofollow">CWG issue 2382</a>.</p>
<p>Đối với chức năng phân bổ không vị trí, Tra cứu chức năng Deallocation bình thường được sử dụng để tìm chức năng định vị giao dịch phù hợp (xem<span class="kw4">STD</span> <span class="kw4">char</span><span class="t-rev-inl t-since-cxx17"><span>, hoặc<a href="../types/byte" title="cpp/types/byte"><code>std::byte</code></a></span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>Đối với chức năng phân bổ vị trí, hàm decllocation phù hợp phải có cùng một số tham số và mỗi loại tham số ngoại trừ loại đầu tiên giống hệt với loại tham số tương ứng của hàm phân bổ (sau<a href="lifetime" title="cpp/language/lifetime">implicitly create objects</a>Nếu Tra cứu tìm thấy một chức năng phân giải phù hợp duy nhất, chức năng đó sẽ được gọi; Nếu không, không có chức năng giải quyết sẽ được gọi.</p>
<p><code><a href="../container/vector" title="cpp/container/vector">std::vector</a></code>Nếu việc tra cứu tìm thấy chức năng giải quyết không định vị và chức năng đó, được coi là chức năng giải quyết vị trí, sẽ được chọn là phù hợp với chức năng phân bổ, chương trình này không được hình thành.</p>
<h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/74.html" rel="nofollow">CWG 74</a> </td> <td>C ++ 98</td> <td>Trong mọi trường hợp, chức năng phân giải phù hợp (nếu có)</td> <td>Không bị phá hủy và</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/299.html" rel="nofollow">CWG 299</a> </td> <td>C ++ 98</td> <td>Có thể truy cập từ điểm xuất hiện biểu hiện mới.<br/>cấu trúc s</td> <td>{<br/>    // Hàm phân bổ vị trí:<br/>    VOID tĩnh* Toán tử Mới (std :: size_t, std :: size_t);</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/624.html" rel="nofollow">CWG 624</a> </td> <td>C ++ 98</td> <td> <br/>    // Chức năng Deallocation không định vị:<br/>    Trình vận hành void tĩnh (void*, std :: size_t);</td> <td>};<br/> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1748.html" rel="nofollow">CWG 1748</a> </td> <td>C ++ 98</td> <td>S* p = new (0) s; // Lỗi: hàm Deallocation không định vị phù hợp<br/>                  // Chức năng phân bổ vị trí</td> <td>Nếu một chức năng giải quyết được gọi trong biểu hiện mới (do lỗi khởi tạo), các đối số được truyền cho hàm đó được xác định như sau:</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1992.html" rel="nofollow">CWG 1992</a> </td> <td>C ++ 11</td> <td>
<code>new <span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/memory/new/nothrow"><span class="kw701">Điều đó cho tất cả<span class="me2">Nothrow</span></span></a><span class="br0">)</span> <span class="kw4">int</span><span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span>N<span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span></code><br/>Đối số đầu tiên là giá trị (loại<code><a href="../memory/new/bad_array_new_length" title="cpp/memory/new/bad array new length">std::bad_array_new_length</a></code> </td> <td>) trở lại từ cuộc gọi chức năng phân bổ.</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2102.html" rel="nofollow">CWG 2102</a> </td> <td>C ++ 98</td> <td>Các đối số khác (chỉ cho các chức năng giải quyết vị trí) là<br/>Vị trí-Vị trí</td> <td>Thực hiện quá tải</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2382.html" rel="nofollow">CWG 2382</a> </td> <td>C ++ 98</td> <td>được chuyển cho chức năng phân bổ vị trí.<br/>Nếu việc triển khai được phép giới thiệu một đối tượng tạm thời hoặc tạo một bản sao của bất kỳ đối số nào như là một phần của lệnh gọi cho chức năng phân bổ, thì không xác định liệu cùng một đối tượng được sử dụng trong cuộc gọi cho cả hai hàm phân bổ và phân bổ.</td> <td>Rò rỉ bộ nhớ</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2392.html" rel="nofollow">CWG 2392</a> </td> <td>C ++ 11</td> <td>Các đối tượng được tạo bởi các biểu hiện mới (các đối tượng có thời lượng lưu trữ động) vẫn tồn tại cho đến khi con trỏ được trả về bởi biểu thức mới được sử dụng trong một kết quả phù hợp<br/>. Nếu giá trị ban đầu của con trỏ bị mất, đối tượng sẽ không thể truy cập và không thể bị giải quyết: A</td> <td>rò rỉ bộ nhớ</td>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/P1009R2" rel="nofollow">P1009R2</a> </td> <td>C ++ 11</td> <td>Điều này có thể xảy ra nếu con trỏ được gán cho:<br/>int* p = new int (7); // phân bổ động int với giá trị 7</td> <td>p = nullptr; // rò rỉ bộ nhớ</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <ul>
<li> <a href="constructor" title="cpp/language/constructor">constructor</a> </li>
<li> <a href="copy_elision" title="cpp/language/copy elision">copy elision</a> </li>
<li> <a href="default_constructor" title="cpp/language/default constructor">default constructor</a> </li>
<li> <a href="delete" title="cpp/language/delete"><code>delete</code></a> </li>
<li> <a href="destructor" title="cpp/language/destructor">destructor</a> </li>
<li> <a href="initialization" title="cpp/language/initialization">initialization</a> <ul>
<li> <a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate initialization</a> </li>
<li> <a href="default_initialization" title="cpp/language/default initialization">default initialization</a> </li>
<li> <a href="direct_initialization" title="cpp/language/direct initialization">direct initialization</a> </li>
<li> <a href="list_initialization" title="cpp/language/list initialization">list initialization</a> </li>
<li> <a href="value_initialization" title="cpp/language/value initialization">value initialization</a> </li>
</ul> </li>
</ul> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/new">https://en.cppreference.com/w/cpp/language/new</a>
</p>
</div>
