 <h1 class="firstHeading" id="firstHeading">Bộ nhớ giao dịch</h1> <div class="plainlinks fmbox fmbox-system noprint">Làm việc đang tiến hành Trang này đang được xây dựng</div> <div class="plainlinks fmbox fmbox-system noprint">Tính năng thử nghiệm Chức năng được mô tả trên trang này là một phần của Thông số kỹ thuật bộ nhớ giao dịch ISO/IEC TS 19841: 2015 (TM TS)</div> <p>Bộ nhớ giao dịch là một cơ chế đồng bộ hóa đồng thời kết hợp các nhóm báo cáo trong các giao dịch, đó là</p>
<ul>
<li>nguyên tử (hoặc tất cả các tuyên bố xảy ra, hoặc không có gì xảy ra)</li>
<li>bị cô lập (các tuyên bố trong một giao dịch có thể không quan sát các ghi được viết một nửa được thực hiện bởi một giao dịch khác, ngay cả khi chúng thực hiện song song)</li>
</ul> <p>Việc triển khai điển hình sử dụng bộ nhớ giao dịch phần cứng khi được hỗ trợ và các giới hạn có sẵn (ví dụ: cho đến khi các thay đổi được bão hòa) và quay trở lại bộ nhớ giao dịch phần mềm, thường được thực hiện với sự đồng thời lạc quan: nếu một giao dịch khác được cập nhật một số biến được sử dụng bởi một giao dịch, nó được đưa ra âm thầm. Vì lý do đó, các giao dịch có thể truy xuất ("Khối nguyên tử") chỉ có thể gọi các chức năng an toàn giao dịch.</p>
<p>Lưu ý rằng việc truy cập một biến trong một giao dịch và ngoài một giao dịch mà không có sự đồng bộ hóa bên ngoài khác là một cuộc đua dữ liệu.</p>
<p>Nếu kiểm tra tính năng được hỗ trợ, các tính năng được mô tả ở đây được biểu thị bằng hằng số macro<code>__cpp_transactional_memory</code>với giá trị bằng hoặc lớn hơn<code>201505</code>.</p>
<h3 id="Synchronized_blocks">Các khối đồng bộ</h3> <p><code>synchronized</code> <span class="t-spar">Tệp hỗn hợp</span></p>
<p>Thực thi<a href="statements#Compound_statements" title="cpp/language/statements">compound statement</a>Như thể trong khóa toàn cầu: Tất cả các khối được đồng bộ hóa ngoài cùng trong chương trình thực thi theo một thứ tự tổng số. Phần cuối của mỗi khối được đồng bộ hóa đồng bộ hóa với phần đầu của khối đồng bộ tiếp theo theo thứ tự đó. Các khối đồng bộ được lồng trong các khối đồng bộ khác không có ngữ nghĩa đặc biệt.</p>
<p>Các khối được đồng bộ hóa không phải là giao dịch (không giống như các khối nguyên tử bên dưới) và có thể gọi các chức năng giao dịch không an toàn.</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;Istream&gt;</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">#include &lt;Chủ đề&gt;</pre></div> </div> <p>#include &lt;Vector&gt;<code><a href="../utility/program/longjmp" title="cpp/utility/program/longjmp">std::longjmp</a></code> </p>
<p>int f ()</p>
<p>{<code>transaction_safe</code>    tĩnh int i = 0;<code>[[optimize_for_synchronized]]</code>    Được đồng bộ hóa {// BẮT ĐẦU Khối đồng bộ</p>
<h3 id="Atomic_blocks">        std :: cout &lt;&lt; i &lt;&lt; " -&gt;";</h3> <p><code>atomic_noexcept</code> <span class="t-spar">Tệp hỗn hợp</span></p>
<p><code>atomic_cancel</code> <span class="t-spar">Tệp hỗn hợp</span></p>
<p><code>atomic_commit</code> <span class="t-spar">Tệp hỗn hợp</span></p>
<div class="t-li1">
<span class="t-li">1)</span>        std :: cout &lt;&lt; i &lt;&lt; '\ n';<code><a href="http://en.cppreference.com/w/cpp/utility/program/abort"><span class="kw968">Điều đó cho tất cả<span class="me2">khẳng định ((2 + 2 == 5) &amp;&amp; "Có năm đèn");</span></span></a></code>Chuỗi để giữ tên viết tắt múi giờ hoặc tên tương ứng với</div> <div class="t-li1">
<span class="t-li">2)</span>        std :: cout &lt;&lt; i &lt;&lt; '\ n';<code><a href="http://en.cppreference.com/w/cpp/utility/program/abort"><span class="kw968">Điều đó cho tất cả<span class="me2">khẳng định ((2 + 2 == 5) &amp;&amp; "Có năm đèn");</span></span></a></code>        trả lại tôi;  // kết thúc khối đồng bộ hóa<i>    }</i>}</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span> </div> <p>int main ()<code>atomic_cancel</code>{<code><a href="../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>Thì<code><a href="../memory/new/bad_array_new_length" title="cpp/memory/new/bad array new length">std::bad_array_new_length</a></code>Thì<code><a href="../types/bad_cast" title="cpp/types/bad cast">std::bad_cast</a></code>Thì<code><a href="../types/bad_typeid" title="cpp/types/bad typeid">std::bad_typeid</a></code>Thì<code><a href="../error/bad_exception" title="cpp/error/bad exception">std::bad_exception</a></code>Thì<code><a href="../error/exception" title="cpp/error/exception">std::exception</a></code>    std :: vector &lt;std :: thread&gt; v (10);<a href="../error/tx_exception" title="cpp/error/tx exception"><code>std::tx_exception&lt;T&gt;</code></a>.</p>
<p>Các<span class="t-spar">Tệp hỗn hợp</span>    for (auto &amp; t: v)<code>transaction_safe</code>        t = std :: Thread ([] {for (int n = 0; n &lt;10; ++ n) f ();});</p>
<div class="cpp source-cpp"><pre data-language="cpp">    for (auto &amp; t: v)</pre></div> <p>        T.Join ();<code><a href="../utility/program/longjmp" title="cpp/utility/program/longjmp">std::longjmp</a></code>}</p>
<h3 id="Transaction-safe_functions">0 -&gt; 1</h3> <p>1 -&gt; 2<code>transaction_safe</code>2 -&gt; 3</p>
<p>Trong a<a href="lambda" title="cpp/language/lambda">lambda</a>...<code>mutable</code>99 -&gt; 100</p>
<div class="cpp source-cpp"><pre data-language="cpp">Để lại một khối đồng bộ bằng bất kỳ phương tiện nào (đạt đến cuối, thực hiện goto, phá vỡ, tiếp tục hoặc quay lại hoặc ném một ngoại lệ) thoát ra khỏi khối và đồng bộ hóa-với khối tiếp theo trong tổng số đơn hàng nếu khối thoát là một khối bên ngoài. Hành vi không xác định nếu</pre></div> <div class="cpp source-cpp"><pre data-language="cpp">được sử dụng để thoát một khối đồng bộ.</pre></div> <p>Nhập một khối đồng bộ bằng goto hoặc công tắc không được phép.</p>
<p><br/>Mặc dù các khối đồng bộ thực thi AS-IF theo khóa toàn cầu, việc triển khai dự kiến ​​sẽ kiểm tra mã trong mỗi khối và sử dụng đồng thời lạc quan (được hỗ trợ bởi bộ nhớ giao dịch phần cứng có sẵn) cho mã an toàn giao dịch và khóa tối thiểu cho mã an toàn không chuyển đổi. Khi một khối đồng bộ thực hiện cuộc gọi đến hàm không được đặt, trình biên dịch có thể phải bỏ khỏi thực thi đầu cơ và giữ khóa xung quanh toàn bộ cuộc gọi trừ khi hàm được khai báo</p>
<h4 id="Transaction-safe_virtual_functions">(xem bên dưới) hoặc thuộc tính</h4> <p>(xem bên dưới) được sử dụng.<code>transaction_safe_dynamic</code>Khối nguyên tử<code>transaction_safe</code>Nếu một ngoại lệ bị ném,</p>
<h3 id="Standard_library">Mẫu &lt;Class I2&gt;</h3> <p>Nếu một ngoại lệ bị ném,<a href="../error/tx_exception" title="cpp/error/tx exception"><code>std::tx_exception</code></a>được gọi, trừ khi ngoại lệ là một trong những ngoại lệ được sử dụng để hủy giao dịch (xem bên dưới) trong trường hợp đó là giao dịch</p>
<ul>
<li>(Đây là lỗi thời gian biên dịch).<code>transaction_safe</code>:</li>
<ul><li> <code><a href="../utility/forward" title="cpp/utility/forward">std::forward</a></code>Thì<code>std::move</code>Thì<code><a href="../utility/move_if_noexcept" title="cpp/utility/move if noexcept">std::move_if_noexcept</a></code>Thì<code><a href="../memory/align" title="cpp/memory/align">std::align</a></code>Thì<code><a href="../utility/program/abort" title="cpp/utility/program/abort">std::abort</a></code>Nếu một ngoại lệ được ném, giao dịch được cam kết bình thường.<code><a href="../memory/new/operator_new" title="cpp/memory/new/operator new">operator new</a></code>Nếu một ngoại lệ được ném, giao dịch được cam kết bình thường.<code><a href="../memory/new/operator_delete" title="cpp/memory/new/operator delete">operator delete</a></code>Thì<code><a href="../memory/allocator/construct" title="cpp/memory/allocator/construct">std::allocator::construct</a></code>Các ngoại lệ được sử dụng để hủy giao dịch trong<code><a href="../memory/allocator/destroy" title="cpp/memory/allocator/destroy">std::allocator::destroy</a></code>khối là<code><a href="../memory/get_temporary_buffer" title="cpp/memory/get temporary buffer">std::get_temporary_buffer</a></code>Thì<code><a href="../memory/return_temporary_buffer" title="cpp/memory/return temporary buffer">std::return_temporary_buffer</a></code>Thì<code><a href="../memory/addressof" title="cpp/memory/addressof">std::addressof</a></code>Thì<code><a href="../memory/pointer_traits/pointer_to" title="cpp/memory/pointer traits/pointer to">std::pointer_traits::pointer_to</a></code>và tất cả các ngoại lệ thư viện tiêu chuẩn xuất phát từ nó và loại ngoại lệ đặc biệt<code>atomic_cancel</code>int f ()</li></ul>
<li>(Đây là lỗi thời gian biên dịch).<code>transaction_safe_dynamic</code> </li>
<ul><li>// Mỗi cuộc gọi đến f () lấy một giá trị duy nhất của tôi, ngay cả khi được thực hiện song song<code>atomic_cancel</code>int f ()</li></ul>
<li>{<a href="../named_req/allocator" title="cpp/named req/Allocator">Allocator</a>    tĩnh int i = 0;<code>X::rebind&lt;&gt;::other</code> </li>
</ul> <h3 id="Attributes">Thuộc tính</h3> <p>    Atomic_NoExcept {// Bắt đầu giao dịch<code>[[<a href="attributes/optimize_for_synchronized" title="cpp/language/attributes/optimize for synchronized">optimize_for_synchronized</a>]]</code>// printf ("trước %d \ n", i); // Lỗi: Không thể gọi chức năng không an toàn không giao dịch</p>
<p>        ++ i;<code>[[optimize_for_synchronized]]</code>        trả lại tôi; // Cam kết giao dịch<code>[[optimize_for_synchronized]]</code>    }</p>
<p>}<code>synchronized</code>Để lại một khối nguyên tử bằng bất kỳ phương tiện nào khác ngoài ngoại lệ (đạt đến cuối, goto, break, tiếp tục, trả lại) thực hiện giao dịch. Hành vi không xác định nếu</p>
<div class="cpp source-cpp"><pre data-language="cpp">được sử dụng để thoát một khối nguyên tử.</pre></div> <p>Chức năng an toàn giao dịch</p>
<pre data-language="c">Một chức năng có thể được khai báo rõ ràng là an toàn giao dịch bằng cách sử dụng từ khóa</pre> <p>Trong tuyên bố của nó.</p>
<pre data-language="c">Tuyên bố, nó xuất hiện ngay sau danh sách bắt giữ, hoặc ngay sau (từ khóa</pre> <h3 id="Notes">Ghi chú</h3> <h3 id="Compiler_support">Hỗ trợ trình biên dịch</h3> <p>(nếu một được sử dụng).<code>-fgnu-tm</code>extern dễ bay hơi int * p = 0;<a class="external text" href="http://www-users.cs.umn.edu/~boutcher/stm/" rel="nofollow">supported in GCC</a>cấu trúc s</p>
<div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/transactional_memory">https://en.cppreference.com/w/cpp/language/transactional_memory</a>
</p>
</div>
