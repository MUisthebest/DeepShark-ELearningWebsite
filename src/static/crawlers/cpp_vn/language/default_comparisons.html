 <h1 class="firstHeading" id="firstHeading">So sánh mặc định<span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span>
</h1> <p>Cung cấp một cách để yêu cầu trình biên dịch tạo ra các toán tử so sánh nhất quán cho một lớp.</p>
<h3 id="Syntax">Cú pháp</h3> <table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <span class="t-spar">Tên lớp trở lại</span>﻿<code>::operator</code><span class="t-spar">Không hợp lệ bất kỳ trình lặp nào (bao gồm cả bộ lặp cuối) hoặc sửa đổi bất kỳ yếu tố nào của phạm vi liên quan, hành vi không được xác định.</span><br/> <code>(</code><span class="kw4">hằng số</span> <span class="t-spar">tên lớp</span>﻿<code>&amp;</code><code>) const &amp;</code><span class="t-mark">ATOMIC_INTPTR_T</span> <code>= default;</code> </td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td>
</tr> <tr class="t-sdsc"> <td> <code>friend</code> <span class="t-spar">kiểu trả lại</span> <code>operator</code><span class="t-spar">Không hợp lệ bất kỳ trình lặp nào (bao gồm cả bộ lặp cuối) hoặc sửa đổi bất kỳ yếu tố nào của phạm vi liên quan, hành vi không được xác định.</span>﻿<code>(</code><span class="kw4">hằng số</span> <span class="t-spar">tên lớp</span>﻿<code>&amp;</code><code>,</code> <span class="kw4">hằng số</span> <span class="t-spar">tên lớp</span>﻿<code>&amp;</code><code>) = default;</code> </td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td>
</tr> <tr class="t-sdsc"> <td> <code>friend</code> <span class="t-spar">kiểu trả lại</span> <code>operator</code><span class="t-spar">Không hợp lệ bất kỳ trình lặp nào (bao gồm cả bộ lặp cuối) hoặc sửa đổi bất kỳ yếu tố nào của phạm vi liên quan, hành vi không được xác định.</span>﻿<code>(</code><span class="t-spar">tên lớp</span>﻿<code>,</code> <span class="t-spar">tên lớp</span>﻿<code>) = default;</code> </td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">Tên lớp trở lại</span>﻿<code>::operator</code><span class="t-spar">Không hợp lệ bất kỳ trình lặp nào (bao gồm cả bộ lặp cuối) hoặc sửa đổi bất kỳ yếu tố nào của phạm vi liên quan, hành vi không được xác định.</span><br/> <code>(</code>cái này<span class="kw4">hằng số</span> <span class="t-spar">tên lớp</span>﻿<code>&amp;</code><code>,</code> <span class="kw4">hằng số</span> <span class="t-spar">tên lớp</span>﻿<code>&amp;</code><code>) = default;</code> </td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">Tên lớp trở lại</span>﻿<code>::operator</code><span class="t-spar">Không hợp lệ bất kỳ trình lặp nào (bao gồm cả bộ lặp cuối) hoặc sửa đổi bất kỳ yếu tố nào của phạm vi liên quan, hành vi không được xác định.</span>﻿<code>(</code>cái này<span class="t-spar">tên lớp</span>﻿<code>,</code> <span class="t-spar">tên lớp</span>﻿<code>) = default;</code> </td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td>
</tr>
</table> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">Không hợp lệ bất kỳ trình lặp nào (bao gồm cả bộ lặp cuối) hoặc sửa đổi bất kỳ yếu tố nào của phạm vi liên quan, hành vi không được xác định.</span> </td> <td>-</td> <td>một toán tử so sánh (<code>&lt;=&gt;</code>Thì<code>==</code>Thì<code>!=</code>Thì<code>&lt;</code>Thì<code>&gt;</code>Thì<code>&lt;=</code>, hoặc<code>&gt;=</code>)</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">kiểu trả lại</span> </td> <td>-</td> <td>Trả về loại của chức năng toán tử. Phải là<ul>
<li> <a href="auto" title="cpp/language/auto"><code>auto</code></a>hoặc một trong số<a href="#Custom_comparisons_and_comparison_categories">three comparison category types</a>nếu như<span class="t-spar">Không hợp lệ bất kỳ trình lặp nào (bao gồm cả bộ lặp cuối) hoặc sửa đổi bất kỳ yếu tố nào của phạm vi liên quan, hành vi không được xác định.</span>khoảng cách<code>&lt;=&gt;</code>Thì</li>
<li>    toán tử &gt;&gt; (basic_istream &lt;char, đặc điểm&gt; &amp; st, không dấu char* s);<span class="kw4">bool</span> </li>
</ul> </td>
</tr>
</table> <h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3> <div class="t-li1">
<span class="t-li">1)</span>Khai báo hàm so sánh mặc định như là một hàm thành viên.</div> <div class="t-li1">
<span class="t-li">2)</span>Khai báo hàm so sánh mặc định là hàm không thành viên.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Khai báo hàm so sánh mặc định là hàm không thành viên. Đối số được truyền qua giá trị.</div> <p>Hàm so sánh ba chiều (dù mặc định hay không) được gọi bất cứ khi nào các giá trị được so sánh bằng cách sử dụng<code>&lt;</code>Thì<code>&gt;</code>Thì<code>&lt;=</code>Thì<code>&gt;=</code>, hoặc<code>&lt;=&gt;</code>và độ phân giải quá tải chọn quá tải này.</p>
<p>Hàm so sánh bình đẳng (dù có mặc định hay không) được gọi bất cứ khi nào các giá trị được so sánh bằng cách sử dụng<code>==</code>hoặc<code>!=</code>và độ phân giải quá tải chọn quá tải này.</p>
<p>Giống như các chức năng thành viên đặc biệt mặc định, một hàm so sánh mặc định được xác định nếu<a href="definition#ODR-use" title="cpp/language/definition">odr-used</a>hoặc<a href="constant_expression#Functions_and_variables_needed_for_constant_evaluation" title="cpp/language/constant expression">needed for constant evaluation</a>.</p>
<h3 id="Defaulted_comparisons">So sánh mặc định</h3> <h4 id="Defaulted_three-way_comparison">Mặc định so sánh ba chiều</h4> <p>Toán tử mặc định<span class="sy1">&lt;=&gt;</span>thực hiện so sánh từ vựng bằng cách so sánh liên tiếp các cơ sở (độ sâu từ trái sang phải) và sau đó là thành viên không tĩnh (theo thứ tự khai báo)<code>T</code>để tính toán<code>&lt;=&gt;</code>, các thành viên mảng mở rộng đệ quy (theo thứ tự tăng chỉ số) và dừng sớm khi tìm thấy kết quả không bình đẳng, đó là:</p>
<div class="cpp source-cpp"><pre data-language="cpp">for /*mỗi cơ sở hoặc thành viên tiểu mục o của t* /</pre></div> <p>    if (auto cmp = static_cast &lt;r&gt; (so sánh (lhs.o, rhs.o)); cmp! = 0)</p>
<p>        trả lại CMP;<span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span>trả về static_cast &lt;r&gt; (strong_ordering :: bằng);<a href="../utility/compare/common_comparison_category" title="cpp/utility/compare/common comparison category"><code>std::common_comparison_category</code></a>Nó không được xác định liệu các tiểu mục cơ sở ảo có được so sánh nhiều lần hay không.</p>
<div class="cpp source-cpp"><pre data-language="cpp">Nếu loại trả lại được khai báo là</pre></div> <p>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;<code>R</code>, sau đó loại trả về thực tế là loại so sánh phổ biến của các phần tử mảng cơ sở và thành viên thành viên được so sánh (xem<code>a</code>Thì<code>b</code>). Điều này giúp việc viết các trường hợp dễ dàng hơn trong đó loại trả về không quan trọng phụ thuộc vào các thành viên, chẳng hạn như:</p>
<ul>
<li>Nếu như<code>a &lt;=&gt; b</code>Mẫu &lt;Class T1, Class T2&gt;<code>R</code>    Count_if (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);<a href="static_cast" title="cpp/language/static cast"><code>static_cast</code></a>Cấu trúc p<code>static_cast&lt;R&gt;(a &lt;=&gt; b)</code>.</li>
<li>{<code>a &lt;=&gt; b</code>    T1 X1;<span class="sy1">&lt;=&gt;</span>là loại trả về, mỗi cặp tiểu mục</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>R</code>    Toán tử tự động kết bạn &lt;=&gt; (const p &amp;, const p &amp;) = mặc định;<code>a == b</code>hoặc<code>a &lt; b</code>};<span class="sy1">&lt;=&gt;</span>là loại trả về, mỗi cặp tiểu mục</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>R</code>khoảng cách<a href="../utility/compare/strong_ordering" title="cpp/utility/compare/strong ordering"><code>std::strong_ordering</code></a>, kết quả của sự so sánh là</li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">có thể sử dụng được và có thể được chuyển đổi rõ ràng thành</pre></div> <ul><li>                        Forwardit2 d_first, pinarypredicate p);<code>R</code>khoảng cách<a href="../utility/compare/weak_ordering" title="cpp/utility/compare/weak ordering"><code>std::weak_ordering</code></a>, kết quả của sự so sánh là</li></ul> <div class="cpp source-cpp"><pre data-language="cpp">Nếu không, nếu độ phân giải quá tải cho</pre></div> <ul><li>, điều này dẫn đến một động thái yếu tố khôn ngoan. (Trong trường hợp đó,<code>R</code>khoảng cách<a href="../utility/compare/partial_ordering" title="cpp/utility/compare/partial ordering"><code>std::partial_ordering</code></a>được thực hiện và tìm thấy ít nhất một ứng cử viên khả thi, so sánh không được xác định (toán tử</li></ul> <div class="cpp source-cpp"><pre data-language="cpp">được định nghĩa là xóa).</pre></div> <p>không phải là loại loại so sánh (xem bên dưới) hoặc một trong hai<span class="sy1">&lt;=&gt;</span>không thể sử dụng được, so sánh không được xác định (toán tử<code>&lt;=&gt;</code>được định nghĩa là xóa).<code>&lt;</code>Thì<code>&lt;=</code>Thì<code>&gt;</code>, Và<code>&gt;=</code>.</p>
<p>, kết quả là<span class="sy1">&lt;=&gt;</span>a == b? R :: bằng:<span class="sy1">==</span>A &lt;B? R :: Ít hơn:<span class="sy1">==</span>         R :: lớn hơn</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">, kết quả là</pre></div> </div> <h4 id="Defaulted_equality_comparison">a == b? R :: Tương đương:</h4> <p>A &lt;B? R :: Ít hơn:<span class="sy1">==</span>         R :: lớn hơn<span class="kw4">bool</span>), kết quả là</p>
<p>a == b? R :: Tương đương:<span class="sy1">==</span>A &lt;B? R :: Ít hơn:</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">b &lt;a? R :: lớn hơn: </pre></div> </div> <h4 id="Other_defaulted_comparison_operators">         R :: Không có thứ tự</h4> <p>Theo các quy tắc cho bất kỳ nhà điều hành nào<span class="kw4">bool</span>.</p>
<p>Quá tải, một mặc định<code>x &lt;=&gt; y</code> <span class="sy1">&lt;=&gt;</span>Nếu toán tử<code>x &lt;=&gt; y</code>được mặc định và toán tử<code>x &lt;=&gt; y @ 0</code>hoàn toàn không được khai báo<span class="sy1">&lt;=&gt;</span>được mặc định ngầm.<code>0 @ y &lt;=&gt; x</code>tinh chỉnh</p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;so sánh&gt;</pre></div> <p>#include &lt;Istream&gt;<span class="sy3">Nếu tồn tại một</span><span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span>#include &lt;set&gt;<code>x == y</code> <span class="sy1">==</span>Điểm cấu trúc<code>x == y</code>{<span class="kw4">bool</span>    int x;<span class="sy3">Nếu tồn tại một</span><span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span>cuộc gọi<code>!(x == y)</code>hoặc<code>!(y == x)</code>    int y;</p>
<p>    toán tử tự động &lt;=&gt; (const point &amp;) const = mặc định;<span class="sy1">&lt;=&gt;</span>và vận hành<span class="sy1">==</span>.</p>
<h3 id="Custom_comparisons_and_comparison_categories">    // ... các chức năng không liên quan ...</h3> <p>};<span class="sy1">&lt;=&gt;</span>// Trình biên dịch tạo ra tất cả sáu toán tử so sánh hai chiều<span class="sy1">&lt;=&gt;</span>.</p>
<p> </p>
<table class="wikitable"> <tr> <th>    std :: decay_t &lt;std :: indoke_result_t &lt;f &amp;, t, std :: iter_reference_t &lt;i &gt;&gt;&gt;&gt; &amp;&amp;&amp;&amp;</th> <th>int main ()</th> <th>{</th>
</tr> <tr> <td>
<a href="../utility/compare/strong_ordering" title="cpp/utility/compare/strong ordering"><code>std::strong_ordering</code></a> </td> <td>    Điểm pt1 {1, 1}, pt2 {1, 2};</td> <td>không được phép</td>
</tr> <tr> <td>
<a href="../utility/compare/weak_ordering" title="cpp/utility/compare/weak ordering"><code>std::weak_ordering</code></a> </td> <td>    s.insert (PT1);     // ĐƯỢC RỒI</td> <td>không được phép</td>
</tr> <tr> <td>
<a href="../utility/compare/partial_ordering" title="cpp/utility/compare/partial ordering"><code>std::partial_ordering</code></a> </td> <td>    s.insert (PT1);     // ĐƯỢC RỒI</td> <td>cho phép</td>
</tr>
</table> <h4 id="Strong_ordering"> </h4> <p>}<span class="sy1">&lt;=&gt;</span>So sánh bình đẳng mặc định<a href="../utility/compare/strong_ordering" title="cpp/utility/compare/strong ordering"><code>std::strong_ordering</code></a>        &lt;&lt; (pt1! = pt2) &lt;&lt; '' // true</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">        &lt;&lt; (pt1 &lt;pt2) &lt;&lt; '' // true</pre></div> </div> <p>        &lt;&lt; (pt1 &lt;= pt2) &lt;&lt; '' // true<a href="../utility/compare/strong_ordering" title="cpp/utility/compare/strong ordering"><code>std::strong_ordering</code></a>        &lt;&lt; (pt1&gt; pt2) &lt;&lt; '' // Sai</p>
<h4 id="Weak_ordering">        &lt;&lt; (pt1&gt; = pt2) &lt;&lt; ''; // SAI</h4> <p>}<span class="sy1">&lt;=&gt;</span>So sánh bình đẳng mặc định<a href="../utility/compare/weak_ordering" title="cpp/utility/compare/weak ordering"><code>std::weak_ordering</code></a>Một lớp có thể xác định toán tử</p>
<div class="cpp source-cpp"><pre data-language="cpp">như mặc định, với giá trị trả về của</pre></div> <p>. Điều này sẽ tạo ra một so sánh bình đẳng của từng lớp cơ sở và tiểu mục thành viên, theo thứ tự khai báo của họ. Hai đối tượng bằng nhau nếu các giá trị của các lớp cơ sở và thành viên của chúng bằng nhau. Bài kiểm tra sẽ ngắn mạch nếu tìm thấy bất bình đẳng trong các thành viên hoặc các lớp cơ sở sớm hơn theo thứ tự khai báo.<span class="sy1">&lt;=&gt;</span>Theo các quy tắc cho nhà điều hành</p>
<h4 id="Partial_ordering">, Điều này cũng sẽ cho phép kiểm tra bất bình đẳng:</h4> <p>#include &lt;Istream&gt;</p>
<div class="cpp source-cpp"><pre data-language="cpp"> </pre></div> <h3 id="See_also">(chức năng)</h3> <ul>
<li> <a href="overload_resolution#Call_to_an_overloaded_operator" title="cpp/language/overload resolution">overload resolution</a>Điểm cấu trúc</li>
<li>{<a href="operator_comparison#Three-way_comparison" title="cpp/language/operator comparison">three-way comparison operator</a> </li>
<li> <a href="operators#Comparison_operators" title="cpp/language/operators">Operator overloading</a>    int x;</li>
</ul> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/default_comparisons">https://en.cppreference.com/w/cpp/language/default_comparisons</a>
</p>
</div>
