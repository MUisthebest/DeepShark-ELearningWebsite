 <h1 class="firstHeading" id="firstHeading">Gói tham số<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span>
</h1> <p>Gói tham số mẫu là một tham số mẫu chấp nhận các đối số mẫu bằng 0 hoặc nhiều hơn (không phải kiểu, loại hoặc mẫu). Gói tham số chức năng là một tham số hàm chấp nhận các đối số chức năng bằng 0 hoặc nhiều hơn.</p>
<p>Một mẫu có ít nhất một gói tham số được gọi là<i>mẫu variadic</i>.</p>
<h3 id="Syntax">Cú pháp</h3> <p>Gói tham số mẫu (xuất hiện trong<a href="type_alias" title="cpp/language/type alias">alias template</a>Thì<a href="class_template" title="cpp/language/class template">class template</a><span class="t-rev-inl t-since-cxx14"><span>Thì<a href="variable_template" title="cpp/language/variable template">variable template</a></span><span><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></span></span>Và<a href="function_template" title="cpp/language/function template">function template</a>Danh sách tham số)</p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <span class="t-spar">kiểu</span> <code>...</code> <span class="t-spar">đóng gói tên</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>typename</code><code>|</code><code>class</code> <code>...</code> <span class="t-spar">đóng gói tên</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> </td> <td>(2)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">Loại hạn chế</span> <code>...</code> <span class="t-spar">đóng gói tên</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> </td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td>
</tr> <tr class="t-sdsc"> <td> <code>template</code> <code>&lt;</code> <span class="t-spar">danh sách tham số</span> <code>&gt;</code> <code>class</code> <code>...</code> <span class="t-spar">đóng gói tên</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> </td> <td>(4)</td> <td> <span class="t-mark-rev t-until-cxx17">xáo trộn</span> </td>
</tr> <tr class="t-sdsc"> <td> <code>template</code> <code>&lt;</code> <span class="t-spar">danh sách tham số</span> <code>&gt;</code> <code>typename</code><code>|</code><code>class</code> <code>...</code> <span class="t-spar">đóng gói tên</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> </td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td>
</tr>
</table> <p>Gói tham số chức năng (một dạng của<a href="declarations" title="cpp/language/declarations">declarator</a>, xuất hiện trong danh sách tham số chức năng của mẫu chức năng Variadic)</p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <span class="t-spar">đóng gói tên</span> <code>...</code> <span class="t-spar">pack-param-name</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> </td> <td>             Không có p);</td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <p>Mở rộng gói tham số (xuất hiện trong một cơ thể của một mẫu variadic)</p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <span class="t-spar">mẫu</span> <code>...</code> </td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <div class="t-li1">
<span class="t-li">1)</span>Gói tham số mẫu không kiểu có tên tùy chọn</div> <div class="t-li1">
<span class="t-li">2)</span>Gói tham số mẫu loại có tên tùy chọn</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>MỘT<a href="constraints" title="cpp/language/constraints">constrained</a>Nhập gói tham số mẫu với tên tùy chọn</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <div class="t-li1">
<span class="t-li">là trong</span>Một gói tham số mẫu mẫu với tên tùy chọn</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Gói tham số chức năng có tên tùy chọn</div> <div class="t-li1">
<span class="t-li">từ_sys</span>Mở rộng gói tham số: Mở rộng sang danh sách được phân tách bằng dấu phẩy hoặc nhiều hơn<code>pattern</code>S. Mẫu phải bao gồm ít nhất một gói tham số.</div> <h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3> <p>Một mẫu lớp Variadic có thể được khởi tạo với bất kỳ số lượng đối số mẫu nào:</p>
<div class="cpp source-cpp"><pre data-language="cpp">Mẫu &lt;class ... loại&gt;</pre></div> <p>struct tuple {};<a href="template_argument_deduction" title="cpp/language/template argument deduction">template argument deduction</a>):</p>
<div class="cpp source-cpp"><pre data-language="cpp"> </pre></div> <p>Tuple &lt;&gt; t0;           // Các loại không chứa đối số</p>
<div class="cpp source-cpp"><pre data-language="cpp">Tuple &lt;Int&gt; t1;        // Các loại chứa một đối số: int</pre></div> <p>Tuple &lt;int, float&gt; t2; // Các loại chứa hai đối số: int và float</p>
<h3 id="Pack_expansion">Tuple &lt;0&gt; t3;          // Lỗi: 0 không phải là loại</h3> <p>Một mẫu chức năng Variadic có thể được gọi với bất kỳ số lượng đối số chức năng nào (các đối số mẫu được suy ra thông qua<i>Mẫu &lt;class ... loại&gt;</i>void f (các loại ... args);<a href="#Alignment_specifier">alignment specifiers</a> </p>
<div class="cpp source-cpp"><pre data-language="cpp">f ();       // ok: args không chứa đối số</pre></div> <p>f (1);      // ok: args chứa một đối số: int</p>
<div class="cpp source-cpp"><pre data-language="cpp">f (2, 1.0); // OK: Args chứa hai đối số: int và double</pre></div> <p>Trong một mẫu lớp chính, gói tham số mẫu phải là tham số cuối cùng trong danh sách tham số mẫu. Trong một mẫu chức năng, gói tham số mẫu có thể xuất hiện trước đó trong danh sách với điều kiện là tất cả các tham số sau có thể được suy ra từ các đối số chức năng hoặc có các đối số mặc định:</p>
<div class="cpp source-cpp"><pre data-language="cpp">mẫu &lt;typename u, typename ... ts&gt; // ok: có thể suy ra u</pre></div> <h3 id="Expansion_loci">cấu trúc hợp lệ;</h3> <p>// Mẫu &lt;typename ... ts, typename u&gt; // error: ts ... không ở cuối<a href="#Alignment_specifier">alignment specifiers</a>// cấu trúc không hợp lệ;</p>
<h4 id="Function_argument_lists"> </h4> <p>Mẫu &lt;typename ... ts, typename u, typename = void&gt;</p>
<div class="cpp source-cpp"><pre data-language="cpp">void hợp lệ (u, ts ...);    // ok: có thể suy luận u</pre></div> <p>// void hợp lệ (ts ..., u); // Không thể được sử dụng: TS ... là một bối cảnh không được xem xét ở vị trí này<i>. Các nhà xây dựng với một</i> <i>Danh sách khởi tạo</i>hợp lệ (1.0, 1, 2, 3);     // ok: suy luận u là gấp đôi, ts là {int, int, int}<i>Điều khoản khởi tạo</i>Nếu mọi chuyên môn hợp lệ của một mẫu variadic yêu cầu một gói tham số mẫu trống, chương trình sẽ không được hình thành, không cần chẩn đoán.<i>Mở rộng gói</i>hoặc a<i>{</i>.</p>
<h4 id="Parenthesized_initializers">Một mẫu theo sau là hình elip, trong đó tên của ít nhất một gói tham số xuất hiện ít nhất một lần, là</h4> <p>mở rộng<a href="direct_initialization" title="cpp/language/direct initialization">direct initializer</a>có thể đại diện cho các phân số của ve.<a href="explicit_cast" title="cpp/language/explicit cast">function-style cast</a>vào 0 hoặc nhiều hơn các phần khởi tạo của mẫu, trong đó tên của gói tham số được thay thế bằng từng phần tử từ gói, theo thứ tự. Khởi tạo của<a class="mw-redirect" href="initializer_list" title="cpp/language/initializer list">member initializer</a>Thì<a href="new" title="cpp/language/new">new-expression</a>được phân tách không gian, các khởi tạo khác được phân tách bằng dấu phẩy.</p>
<div class="cpp source-cpp"><pre data-language="cpp">Mẫu &lt;class ... chúng tôi&gt;</pre></div> <h4 id="Brace-enclosed_initializers">void f (chúng tôi ... pargs) {}</h4> <p>Trong a<i>{</i> <i>{</i>Mẫu &lt;class ... ts&gt;<a href="list_initialization" title="cpp/language/list initialization">list-initialization</a>void g (ts ... args)</p>
<div class="cpp source-cpp"><pre data-language="cpp">{</pre></div> <h4 id="Template_argument_lists">    f (&amp; args ...); // “&amp; args ...” là một bản mở rộng gói</h4> <p>                 // “&amp; args” là mô hình của nó</p>
<div class="cpp source-cpp"><pre data-language="cpp">}</pre></div> <h4 id="Function_parameter_list"> </h4> <p>g (1, 0,2, "a"); // ts ... args mở rộng sang int e1, double e2, const char* e3<span class="t-spar">Loại trở lại của coroutine</span><code>...</code> <span class="t-spar">iterator trước đó phần tử mới sẽ được xây dựng</span>                // &amp; args ... mở rộng sang &amp; e1, &amp; e2, &amp; e3</p>
<div class="cpp source-cpp"><pre data-language="cpp">                // chúng tôi ... pargs mở rộng sang int* e1, gấp đôi* e2, const char ** e3</pre></div> <p>Nếu tên của hai gói tham số xuất hiện trong cùng một mẫu, chúng được mở rộng đồng thời và chúng phải có cùng độ dài:<code>Ts (&amp;...arr)[N]</code>Mẫu &lt;Typename ...&gt;</p>
<p>Ghi chú:<code>Ts (&amp;...)[N]</code>struct tuple {};<a class="external text" href="https://cplusplus.github.io/CWG/issues/1488.html" rel="nofollow">CWG issue 1488</a>.</p>
<h4 id="Template_parameter_list"> </h4> <p>Mẫu &lt;Typename T1, Typename T2&gt;</p>
<div class="cpp source-cpp"><pre data-language="cpp">Cặp cấu trúc {};</pre></div> <h4 id="Base_specifiers_and_member_initializer_lists"> </h4> <p>Mẫu &lt;class ... args1&gt;<a href="class" title="cpp/language/class">class declaration</a>cấu trúc zip<a class="mw-redirect" href="initializer_list" title="cpp/language/initializer list">member initializer list</a>{</p>
<div class="cpp source-cpp"><pre data-language="cpp">    Mẫu &lt;class ... args2&gt;</pre></div> <h4 id="Lambda_captures">    cấu trúc với</h4> <p>    {<a href="lambda" title="cpp/language/lambda">lambda</a>        typedef tuple &lt;cặp &lt;args1, args2&gt; ...&gt; type;</p>
<div class="cpp source-cpp"><pre data-language="cpp">        // cặp &lt;args1, args2&gt; ... là bản mở rộng gói</pre></div> <h4 id="The_sizeof..._operator">        // cặp &lt;args1, args2&gt; là mẫu</h4> <p>Các<a href="sizeof..." title="cpp/language/sizeof..."><code>sizeof...</code></a>    };</p>
<div class="cpp source-cpp"><pre data-language="cpp">};</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <h4 id="Dynamic_exception_specifications"> </h4> <p>typedef zip &lt;short, int&gt; :: với &lt;unsign ngắn, không dấu&gt; :: type T1;<a href="except_spec" title="cpp/language/except spec">dynamic exception specification</a>// cặp &lt;args1, args2&gt; ... mở rộng sang</p>
<div class="cpp source-cpp"><pre data-language="cpp">// cặp &lt;ngắn, không dấu ngắn&gt;, cặp &lt;int, unsign int&gt; </pre></div> </td> <td><span class="t-mark-rev t-until-cxx17">xáo trộn</span></td>
</tr> </table> <h4 id="Alignment_specifier">// t1 là tuple &lt;cặp &lt;short, unsign short&gt;, cặp &lt;int, unsign &gt;&gt;</h4> <p> <a href="alignas" title="cpp/language/alignas"><code>alignas</code></a>// typedef zip &lt;Tnort&gt; :: với &lt;unsign ngắn, không dấu&gt; :: type T2;</p>
<div class="cpp source-cpp"><pre data-language="cpp">// Lỗi: Mở rộng gói chứa các gói tham số có độ dài khác nhau</pre></div> <h4 id="Attribute_list">Nếu một bản mở rộng gói được lồng trong một bản mở rộng gói khác, các gói tham số xuất hiện bên trong mở rộng gói trong cùng được mở rộng bởi nó và phải có một gói khác được đề cập trong mở rộng gói kèm theo, nhưng không phải trong một bên trong:</h4> <p>Mẫu &lt;class ... args&gt;<a href="attributes" title="cpp/language/attributes">attributes</a>void g (args ... args)</p>
<div class="cpp source-cpp"><pre data-language="cpp">{</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <h4 id="Fold-expressions">    f (const_cast &lt;const args*&gt; (&amp; args) ...); </h4> <p>TRONG<a href="fold" title="cpp/language/fold">fold-expressions</a>    // const_cast &lt;const args*&gt; (&amp; args) là mẫu, nó mở rộng hai gói</p>
<h4 id="Using-declarations">không gian tên R // không phải là không gian tên kèm theo cho Q</h4> <p>TRONG<a href="using_declaration" title="cpp/language/using declaration">using declaration</a>    // (args và args) đồng thời</p>
<div class="cpp source-cpp"><pre data-language="cpp"> </pre></div> </td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx26">
<td> <h4 id="Pack_indexing">Gói lập chỉ mục</h4> <p>TRONG<a href="pack_indexing" title="cpp/language/pack indexing">pack indexing</a>    f (h (args ...) + args ...); // Mở rộng gói lồng nhau:<span class="t-spar">định danh</span>    // Mở rộng gói bên trong là "args ...", nó được mở rộng đầu tiên<span class="t-spar">Gói biểu thức lập chỉ mục</span>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">    // Mở rộng gói bên ngoài là H (E1, E2, E3) + Args ..., nó được mở rộng</pre></div> </td> <td><span class="t-mark-rev t-since-cxx26">(kể từ C ++ 26)</span></td>
</tr> </table> <h3 id="Notes">Ghi chú</h3> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>Tính năng Test Macro</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../feature_test#cpp_variadic_templates" title="cpp/feature test"><code>__cpp_variadic_templates</code></a></td> <td><span class="nu0">200704l</span></td> <td><span class="t-mark">unininitialized_copy_n</span></td> <td>    // Thứ hai (như H (E1, E2, E3) + E1, H (E1, E2, E3) + E2, H (E1, E2, E3) + E3)</td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <p>}<code><a href="../io/c/fprintf" title="cpp/io/c/fprintf">std::printf</a></code>Lý giả mở rộng<code>%</code>Tùy thuộc vào nơi mở rộng diễn ra</p>
<p>) Danh sách là một loại danh sách khác: danh sách tham số chức năng, danh sách khởi tạo thành viên, danh sách thuộc tính, v.v ... Sau đây là danh sách tất cả các bối cảnh được phép:</p>
<p>Danh sách đối số chức năng</p>
<p><code>Targs</code>Một bản mở rộng gói có thể xuất hiện bên trong dấu ngoặc đơn của toán tử cuộc gọi chức năng, trong trường hợp đó là biểu thức lớn nhất hoặc danh sách ban đầu được chuẩn bị ở bên trái của dấu chấm lửng là mẫu được mở rộng:<code>Fargs</code>f (args ...);              // Mở rộng sang F (E1, E2, E3)</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">f (&amp; args ...);             // Mở rộng sang F (&amp; E1, &amp; E2, &amp; E3)</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">f (n, ++ args ...);         // Mở rộng sang F (N, ++ E1, ++ E2, ++ E3);</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1533.html" rel="nofollow">CWG 1533</a> </td> <td>C ++ 11</td> <td>f (++ args ..., n);         // Mở rộng sang F (++ E1, ++ E2, ++ E3, N);</td> <td>không được phép</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2717.html" rel="nofollow">CWG 2717</a> </td> <td>C ++ 11</td> <td> </td> <td>f (const_cast &lt;const args*&gt; (&amp; args) ...);</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <a href="function_template" title="cpp/language/function template">function template</a> </td>
</tr> <tr class="t-dsc"> <td colspan="2"> <a href="class_template" title="cpp/language/class template">class template</a> </td>
</tr> <tr class="t-dsc"> <td> <a href="sizeof..." title="cpp/language/sizeof..."><code>sizeof...</code></a> </td> <td>// f (const_cast &lt;const e1*&gt; (&amp; x1), const_cast &lt;const e2*&gt; (&amp; x2), const_cast &lt;const e3*&gt; (&amp; x3))</td>
</tr> <tr class="t-dsc"> <td colspan="2"> <a href="../utility/variadic" title="cpp/utility/variadic">C-style variadic functions</a> </td>
</tr> <tr class="t-dsc"> <td> <a href="../preprocessor/replace" title="cpp/preprocessor/replace">Preprocessor macros</a> </td> <td> </td>
</tr> <tr class="t-dsc"> <td colspan="2"> <a href="fold" title="cpp/language/fold">Fold expressions</a> </td>
</tr> <tr class="t-dsc"> <td> <a href="pack_indexing" title="cpp/language/pack indexing">Pack indexing</a> </td> <td>f (h (args ...) + args ...); // Mở rộng đến </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/parameter_pack">https://en.cppreference.com/w/cpp/language/parameter_pack</a>
</p>
</div>
