 <h1 class="firstHeading" id="firstHeading">Người phá hủy</h1> <p>Một kẻ phá hủy là một đặc biệt<a href="member_functions" title="cpp/language/member functions">member function</a>được gọi là khi<a href="lifetime" title="cpp/language/lifetime">lifetime of an object</a>kết thúc. Mục đích của chất hủy diệt là giải phóng các tài nguyên mà đối tượng có thể có được trong suốt cuộc đời của nó.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>Một kẻ hủy diệt không phải là một<a href="coroutines" title="cpp/language/coroutines">coroutine</a>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <h3 id="Syntax">Cú pháp</h3> <table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <code>~</code> <span class="t-spar">tên lớp</span> <code>();</code> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>virtual ~</code> <span class="t-spar">tên lớp</span> <code>();</code> </td> <td>(2)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">DEM-SPECIFIER-SEQ</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <code>~</code> <span class="t-spar">tên lớp</span> <code>() = default;</code> </td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">DEM-SPECIFIER-SEQ</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <code>~</code> <span class="t-spar">tên lớp</span> <code>() = delete;</code> </td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">attr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">DEM-SPECIFIER-SEQ</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">một lvalue-to-rvalue</span> <code>(</code> <code>void</code><span class="t-mark">ATOMIC_INTPTR_T</span> <code>)</code><br/><span class="t-spar">                             STD :: Memory_order Order) NoExcept;</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">attr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">tuyên ngôn;</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span><code>;</code> </td> <td>             Không có p);</td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <div class="t-li1">
<span class="t-li">1)</span>Tuyên bố điển hình của một<span class="t-rev-inl t-since-cxx20"><span>    ảo ~ base () {}</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>người phá hủy.</div> <div class="t-li1">
<span class="t-li">2)</span>Hủy diệt ảo thường được yêu cầu trong một lớp cơ sở.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Buộc một chất hủy diệt được tạo ra bởi trình biên dịch.</div> <div class="t-li1">
<span class="t-li">là trong</span>Vô hiệu hóa kẻ hủy diệt ngầm.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Cú pháp chính thức của một<span class="t-rev-inl t-since-cxx20"><span>    ảo ~ base () {}</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>Tuyên bố phá hủy.</div> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">DEM-SPECIFIER-SEQ</span> </td> <td>-</td> <td> <span class="kw1">bạn</span>Thì<span class="kw1">};</span>Thì<span class="kw1">ảo</span><span class="t-rev-inl t-since-cxx20"><span>Thì<code>constexpr</code>Thì<code>consteval</code></span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">một lvalue-to-rvalue</span> </td> <td>-</td> <td>Trong một định nghĩa lớp, biểu tượng<code>~</code>theo sau là<span class="t-spar">tên lớp</span>. Trong một mẫu lớp, biểu tượng<code>~</code>theo sau là tên của phần khởi tạo hiện tại của mẫu. Tại phạm vi không gian tên hoặc trong một<a href="friend" title="cpp/language/friend">friend</a>Tuyên bố trong một lớp khác,<i>tên lồng nhau</i>tiếp theo là biểu tượng<code>~</code>theo sau là<span class="t-spar">tên lớp</span>đó là cùng một lớp với lớp được đặt tên bởi người nhận tên lồng nhau. Trong mọi trường hợp, tên phải là tên thực tế của lớp hoặc mẫu, và không phải là một typedef. Toàn bộ biểu hiện ID có thể được bao quanh bởi dấu ngoặc đơn không thay đổi ý nghĩa của nó.</td>
</tr> <tr class="t-par"> <td> <span class="t-spar">attr</span> </td> <td>-</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span>trình tự của bất kỳ số lượng nào<a href="attributes" title="cpp/language/attributes">attributes</a> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">                             STD :: Memory_order Order) NoExcept;</span> </td> <td>-</td> <td>đặc điểm kỹ thuật ngoại lệ như trong bất kỳ<a href="function" title="cpp/language/function">function declaration</a> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>Nếu không có thông số kỹ thuật ngoại lệ nào được cung cấp một cách rõ ràng, đặc điểm kỹ thuật ngoại lệ được coi là một đặc điểm kỹ thuật sẽ được sử dụng bởi bộ hủy hủy được khai báo ngầm (xem bên dưới). Trong hầu hết các trường hợp, đây là<code>noexcept(true)</code>. Do đó, một kẻ phá hủy ném phải được tuyên bố rõ ràng<code>noexcept(false)</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">tuyên ngôn;</span> </td> <td>-</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span>yêu cầu mệnh đề tuyên bố liên kết<a href="constraints" title="cpp/language/constraints">constraints</a>Đối với kẻ hủy diệt tiềm năng, phải được thỏa mãn để người phá hủy tiềm năng được chọn làm kẻ hủy diệt</td>
</tr>
</table> <h3 id="Explanation">Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</h3> <p>Chất phá hủy được gọi bất cứ khi nào một đối tượng<a href="lifetime" title="cpp/language/lifetime">lifetime</a>kết thúc, bao gồm</p>
<ul><li> <a href="../utility/program/exit" title="cpp/utility/program/exit">program termination</a>, cho các đối tượng có tĩnh<a href="storage_duration" title="cpp/language/storage duration">storage duration</a> </li></ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li>Thoát luồng, cho các đối tượng có thời gian lưu trữ địa phương</li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <ul>
<li>Kết thúc phạm vi, cho các đối tượng có thời lượng lưu trữ tự động và cho những người tạm thời có tuổi thọ được mở rộng bằng cách liên kết với một tài liệu tham khảo</li>
<li> <a href="delete" title="cpp/language/delete">delete-expression</a>, cho các đối tượng có thời lượng lưu trữ động</li>
<li>kết thúc đầy đủ<a href="expressions" title="cpp/language/expressions">expression</a>, cho những người tạm thời không tên</li>
<li> <a href="throw" title="cpp/language/throw">stack unwinding</a>, đối với các đối tượng có thời gian lưu trữ tự động khi một ngoại lệ thoát khỏi khối của chúng, không bị bắt.</li>
</ul> <p>Bộ hủy diệt cũng có thể được gọi là trực tiếp, ví dụ: để phá hủy một đối tượng được xây dựng bằng cách sử dụng<a href="new" title="cpp/language/new">placement-new</a>hoặc thông qua chức năng thành viên của bộ phân bổ như<a href="../memory/allocator/destroy" title="cpp/memory/allocator/destroy"><code>std::allocator::destroy()</code></a>, để phá hủy một đối tượng được xây dựng thông qua bộ phân bổ. Lưu ý rằng việc gọi một chất phá hủy trực tiếp cho một đối tượng thông thường, chẳng hạn như biến cục bộ, gọi hành vi không xác định khi bộ hủy được gọi lại, ở cuối phạm vi.</p>
<p>Trong bối cảnh chung, cú pháp cuộc gọi phá hủy có thể được sử dụng với một đối tượng thuộc loại không lớp; Điều này được gọi là cuộc gọi giả Destructor: Xem<a href="operator_member_access#Built-in_member_access_operators" title="cpp/language/operator member access">member access operator</a>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <h3 id="Prospective_destructor">Kẻ phá hủy tiềm năng</h3> <p>Một lớp có thể có một hoặc nhiều chất hủy diệt tiềm năng, một trong số đó được chọn làm kẻ phá hủy cho lớp.</p>
<p>Để xác định kẻ hủy diệt tiềm năng nào là kẻ phá hủy, ở cuối định nghĩa của lớp,<a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a>được thực hiện giữa các chất phá hủy tiềm năng được tuyên bố trong lớp với một danh sách đối số trống. Nếu độ phân giải quá tải không thành công, chương trình sẽ không được hình thành. Lựa chọn phá hủy không<a href="definition#One_Definition_Rule" title="cpp/language/definition">odr-use</a>Bộ hủy diệt được chọn và bộ hủy diệt được chọn có thể bị xóa.</p>
<p>Tất cả các kẻ phá hủy tiềm năng là các chức năng thành viên đặc biệt. Nếu không có người phá hủy tương lai được tuyên bố là người dùng được cung cấp cho lớp<code>T</code>, trình biên dịch sẽ luôn khai báo một<code>T</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <h3 id="Implicitly-declared_destructor">Công cụ phá hủy được tuyên bố ngầm</h3> <p>Nếu không có người dùng bị tuyên bố<span class="t-rev-inl t-since-cxx20"><span>    ảo ~ base () {}</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>Destructor được cung cấp cho một<a href="class" title="cpp/language/class">class type</a>, Trình biên dịch sẽ luôn khai báo một<span class="kw1">};</span> <span class="kw1"> </span>thành viên của lớp học của nó.</p>
<p>Như với bất kỳ chức năng thành viên đặc biệt được khai báo ngầm nào, đặc điểm kỹ thuật ngoại lệ của bộ hủy hủy được khai báo ngầm là không phải<span class="t-rev-inl t-since-cxx17"><span>chất phá hủy của bất kỳ cơ sở hoặc thành viên có khả năng được xây dựng nào<a href="noexcept_spec" title="cpp/language/noexcept spec">potentially-throwing</a></span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span><span class="t-rev-inl t-until-cxx17"><span>Định nghĩa ngầm sẽ trực tiếp gọi một chức năng với một đặc tả ngoại lệ khác</span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span>. Trong thực tế, các chất hủy diệt ngầm là<span class="kw1">Noexcept</span>Trừ khi lớp bị "đầu độc" bởi một cơ sở hoặc thành viên có chất phá hoại là<code>noexcept(false)</code>.</p>
<h3 id="Implicitly-defined_destructor">Destructor được xác định ngầm</h3> <p>Nếu một chất phá hủy được khai báo ngầm không bị xóa, thì nó sẽ được xác định ngầm (nghĩa là cơ thể chức năng được tạo và biên dịch) bởi trình biên dịch khi nó<a href="definition#ODR-use" title="cpp/language/definition">odr-used</a>. Destructor được xác định ngầm này có một cơ thể trống rỗng.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>thuộc loại lớp hoặc mảng loại lớp có hàm tạo bản sao có tham số thuộc loại<span class="t-rev-inl t-until-cxx23"><span><a href="constexpr#constexpr_destructor" title="cpp/language/constexpr">constexpr destructor</a></span><span><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></span></span><span class="t-rev-inl t-since-cxx23"><span><a href="constexpr#constexpr_function" title="cpp/language/constexpr">constexpr function</a></span><span><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></span></span>, chất phá hủy được tạo ra là<span class="kw4">constexpr</span>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <h3 id="Deleted_destructor">Xóa phá hủy</h3> <p>Công cụ phá hủy được khai báo ngầm hoặc bị lỗi rõ ràng cho lớp học<code>T</code>khoảng cách<span class="t-rev-inl t-until-cxx11"><span>void print_container (const std :: deque &lt;int&gt; &amp; c) </span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>Toán tử gán bản sao được xác định ngầm</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Nếu toán tử gán bản sao được tuyên bố ngầm không bị xóa cũng không tầm thường, thì nó được xác định (nghĩa là cơ thể chức năng được tạo và biên dịch) bởi trình biên dịch nếu</p>
<ul>
<li> <code>T</code>Toán tử gán bản sao được xác định ngầm cho một lớp<a href="object#Potentially_constructed_subobject" title="cpp/language/object">potentially constructed subobject</a>Toán tử gán được chọn để sao chép từng tiểu đơn lớp cơ sở trực tiếp là hàm constexpr và<code>M</code>. Đối với các loại liên minh, hàm tạo bản sao được xác định ngầm sẽ sao chép biểu diễn đối tượng (như bởi<code>M</code>có một kẻ hủy diệt mà</li>
<ul>
<li>bị xóa hoặc không thể truy cập khỏi hệ thống phá hủy của<code>T</code>, hoặc</li>
<li>Việc tạo ra toán tử gán bản sao được xác định ngầm được xác định<a href="union#Union-like_classes" title="cpp/language/union">variant member</a>, là không tầm thường.</li>
</ul>
<li>Chất hủy diệt là ảo và tra cứu cho<a href="../memory/new/operator_delete" title="cpp/memory/new/operator delete">deallocation function</a>kết quả trong</li>
<ul>
<li>một sự mơ hồ, hoặc</li>
<li>một chức năng bị xóa hoặc không thể truy cập được từ chất phá hủy.</li>
</ul>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>Một kẻ phá hủy tương lai bị lỗi rõ ràng cho<code>T</code>được định nghĩa là bị xóa nếu nó không phải là chất hủy diệt cho<code>T</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <h3 id="Trivial_destructor">Kẻ phá hủy tầm thường</h3> <p>Người phá hủy cho lớp học<code>T</code>Sao chép toán tử gán cho lớp</p>
<ul>
<li>Bộ hủy không được cung cấp bởi người dùng (có nghĩa là, nó được khai báo ngầm hoặc được định nghĩa rõ ràng là mặc định trong khai báo đầu tiên của nó).</li>
<li>Bộ hủy diệt không phải là ảo (nghĩa là chất phá hủy lớp cơ sở không phải là ảo).</li>
<li>Tất cả các lớp cơ sở trực tiếp có những kẻ phá hủy tầm thường.</li>
<li>Tất cả các thành viên dữ liệu không tĩnh thuộc loại lớp (hoặc mảng thuộc loại lớp) đều có bộ hủy diệt tầm thường.</li>
</ul> <p>Một kẻ phá hủy tầm thường là một kẻ hủy diệt không thực hiện hành động. Các đối tượng có chất phá hủy tầm thường không yêu cầu biểu hiện xóa và có thể được xử lý bằng cách chỉ xử lý lưu trữ của chúng. Tất cả các loại dữ liệu tương thích với ngôn ngữ C (loại POD) đều bị phá hủy một cách tầm thường.</p>
<h3 id="Destruction_sequence">Trình tự phá hủy</h3> <p>Đối với cả hai chất hủy diệt do người dùng xác định hoặc được xác định ngầm, sau khi thực hiện cơ thể của chất phá hủy và phá hủy bất kỳ đối tượng tự động nào được phân bổ trong cơ thể, trình biên dịch gọi bộ hủy đối với tất cả các thành viên dữ liệu không phải là phương sai của lớp<a class="mw-redirect" href="initializer_list#Initialization_order" title="cpp/language/initializer list">reverse order of construction</a>.</p>
<p>Ngay cả khi chất phá hủy được gọi trực tiếp (ví dụ:<code>obj.~Foo();</code>), câu lệnh trả lại trong<code>~Foo()</code>Không trả lại quyền kiểm soát cho người gọi ngay lập tức: nó gọi tất cả các thành viên và cơ sở phá hủy đầu tiên.</p>
<h3 id="Virtual_destructors">HERSTUAUS HESTRUBTOR</h3> <p>Xóa một đối tượng thông qua con trỏ đến cơ sở gọi hành vi không xác định trừ khi chất phá hủy trong lớp cơ sở là<a href="virtual" title="cpp/language/virtual">virtual</a>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">cơ sở lớp học</pre></div> <p>{<a class="external text" href="http://www.gotw.ca/publications/mill18.htm" rel="nofollow">either public and virtual or protected and nonvirtual</a>.</p>
<h3 id="Pure_virtual_destructors">công cộng:</h3> <p>MỘT<span class="t-rev-inl t-since-cxx20"><span>    ảo ~ base () {}</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>};<a href="abstract_class" title="cpp/language/abstract class">pure virtual</a> </p>
<div class="cpp source-cpp"><pre data-language="cpp">lớp có nguồn gốc: cơ sở công khai {};</pre></div> <h3 id="Exceptions">Ngoại lệ</h3> <p> <a href="exceptions" title="cpp/language/exceptions">exception</a> <span class="t-rev-inl t-since-cxx11"><span>Cơ sở* b = xuất phát mới;<code>noexcept(false)</code>)</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Xóa b; // an toàn<a href="throw#Stack_unwinding" title="cpp/language/throw">stack unwinding</a>Thì<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>Một hướng dẫn chung là một chất phá hủy cho một lớp cơ sở phải</p>
<p>Các chất hủy diệt ảo thuần túy<code><a href="../error/uncaught_exception" title="cpp/error/uncaught exception">std::uncaught_exceptions</a></code>tiềm năng<a class="external text" href="https://github.com/SOCI/soci" rel="nofollow">SOCI</a>Và<a class="external text" href="https://galeracluster.com/downloads/" rel="nofollow">Galera 3</a>Destructor có thể được tuyên bố</p>
<p><a href="https://en.cppreference.com/w/cpp/experimental/scope_success" title="cpp/experimental/scope success"><code>std::experimental::scope_success</code></a>, ví dụ trong một lớp cơ sở cần được thực hiện trừu tượng, nhưng không có chức năng phù hợp nào khác có thể được tuyên bố là ảo thuần túy. Một chất phá hủy ảo thuần túy phải có một định nghĩa, vì tất cả các chất phá hủy lớp cơ sở luôn được gọi khi lớp dẫn xuất bị phá hủy:<a href="https://en.cppreference.com/w/cpp/experimental/scope_success/%7Escope_success" title="cpp/experimental/scope success/~scope success">a potentially-throwing destructor</a>Lớp Tóm tắtBase</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">{</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">công cộng:</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/193.html" rel="nofollow">CWG 193</a> </td> <td>C ++ 98</td> <td>    ảo ~ Tóm tắtBase () = 0;<br/>};<br/>Tóm tắtBase :: ~ Tóm tắtBase () {}</td> <td> <br/>lớp có nguồn gốc: Tóm tắt công khai {};<br/> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/344.html" rel="nofollow">CWG 344</a> </td> <td>C ++ 98</td> <td>// Tóm tắtbase obj; // lỗi trình biên dịch<br/>Có nguồn gốc obj;         // ĐƯỢC RỒI<a class="external text" href="https://cplusplus.github.io/CWG/issues/194.html" rel="nofollow">CWG issue 194</a>Và<a class="external text" href="https://cplusplus.github.io/CWG/issues/263.html" rel="nofollow">CWG issue 263</a> </td> <td>ủy quyền xây dựng<br/>và hàm tạo được chọn bởi thành viên duy nhất của danh sách khởi tạo là</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1241.html" rel="nofollow">CWG 1241</a> </td> <td>C ++ 98</td> <td>Như bất kỳ chức năng nào khác, một chất phá hủy có thể chấm dứt bằng cách ném một<br/>(Điều này thường đòi hỏi nó phải được tuyên bố rõ ràng</td> <td>, tuy nhiên nếu yếu tố phá hủy này được gọi trong<br/>được gọi là thay thế.</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1353.html" rel="nofollow">CWG 1353</a> </td> <td>C ++ 98</td> <td>Mặc dù<br/>Đôi khi có thể được sử dụng để phát hiện ngăn xếp việc tháo gỡ trong tiến trình, nó thường được coi là thực hành xấu để cho phép bất kỳ chất phá hủy nào chấm dứt bằng cách ném một ngoại lệ. Chức năng này tuy nhiên được sử dụng bởi một số thư viện, chẳng hạn như</td> <td>Không có toán tử gán bản sao với cùng loại tham số đầu tiên và cùng một cv/ref-aperifers (nếu có)</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2180.html" rel="nofollow">CWG 2180</a> </td> <td>C ++ 98</td> <td>, dựa vào khả năng của những kẻ hủy diệt của những người tạm thời không tên để ném các ngoại lệ ở cuối biểu thức đầy đủ xây dựng tạm thời.<code>X</code>Trong thư viện cơ bản TS v3 có thể có<br/>, ném một ngoại lệ khi phạm vi được thoát bình thường và chức năng thoát ném một ngoại lệ.</td> <td>#include &lt;Istream&gt;</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <ul>
<li> <a href="copy_elision" title="cpp/language/copy elision">copy elision</a> </li>
<li> <a href="new" title="cpp/language/new"><code>new</code></a> </li>
<li> <a href="delete" title="cpp/language/delete"><code>delete</code></a> </li>
</ul> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/destructor">https://en.cppreference.com/w/cpp/language/destructor</a>
</p>
</div>
