 <h1 class="firstHeading" id="firstHeading">Tuyên bố Tuyên bố</h1> <p>MỘT<i>liệt kê</i>là một loại riêng biệt có giá trị bị giới hạn trong một loạt các giá trị (xem bên dưới để biết chi tiết), có thể bao gồm một số hằng số được đặt tên rõ ràng ("<i>Người điều tra</i>").</p>
<p>Các giá trị của các hằng số là các giá trị của một loại tích phân được gọi là<i>loại cơ bản</i>của sự liệt kê. Một liệt kê có cùng<a href="sizeof" title="cpp/language/sizeof">size</a>Thì<a href="object#Object_representation_and_value_representation" title="cpp/language/object">value representation</a>, Và<a href="object#Alignment" title="cpp/language/object">alignment requirements</a>như loại cơ bản của nó. Hơn nữa, mỗi giá trị của một bảng liệt kê có cùng một biểu diễn với giá trị tương ứng của loại cơ bản.</p>
<p>Một bảng liệt kê là (Re) được khai báo bằng cú pháp sau:</p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <span class="t-spar">enum-key</span> <span class="t-spar">attr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">Mỗi bảng điều khiển được liên kết với giá trị của loại cơ bản. Khi khởi tạo được cung cấp trong</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">        Màu sắc trường hợp :: Blue: std :: cout &lt;&lt; "Blue \ n";  phá vỡ;</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span><br/><code>{</code> <span class="t-spar"> </span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <code>}</code> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">enum-key</span> <span class="t-spar">attr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">Mỗi bảng điều khiển được liên kết với giá trị của loại cơ bản. Khi khởi tạo được cung cấp trong</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">        Màu sắc trường hợp :: Blue: std :: cout &lt;&lt; "Blue \ n";  phá vỡ;</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span><br/><code>{</code> <span class="t-spar"> </span> <code>, }</code> </td> <td>(2)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <span class="t-spar">enum-key</span> <span class="t-spar">attr</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">Mỗi bảng điều khiển được liên kết với giá trị của loại cơ bản. Khi khởi tạo được cung cấp trong</span> <span class="t-spar">        Màu sắc trường hợp :: Blue: std :: cout &lt;&lt; "Blue \ n";  phá vỡ;</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <code>;</code> </td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td>
</tr>
</table> <div class="t-li1">
<span class="t-li">1)</span> <span class="t-spar">enum-specifier</span>, xuất hiện trong<span class="t-spar">DEM-SPECIFIER-SEQ</span>của<a href="declarations" title="cpp/language/declarations">declaration</a>Cú pháp: Xác định loại liệt kê và các điều tra viên của nó.</div> <div class="t-li1">
<span class="t-li">2)</span>Một dấu phẩy kéo theo có thể theo dõi<span class="t-spar"> </span>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Tuyên bố Enum mờ: Xác định loại liệt kê nhưng không phải là người liệt kê của nó: sau khai báo này, loại là một loại hoàn chỉnh và kích thước của nó được biết đến.</div> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">enum-key</span> </td> <td>-</td> <td> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <p><code>enum</code></p>
</td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> <p>Một trong số<code>enum</code>Thì<code>enum class</code>, hoặc<code>enum struct</code></p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">attr</span> </td> <td>-</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span>Trình tự tùy chọn của bất kỳ số lượng nào<a href="attributes" title="cpp/language/attributes">attributes</a> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">Mỗi bảng điều khiển được liên kết với giá trị của loại cơ bản. Khi khởi tạo được cung cấp trong</span> </td> <td>-</td> <td> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <p>Tên của sự liệt kê đang được khai báo, nó có thể được bỏ qua.</p>
</td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> <p>tên của sự liệt kê đang được khai báo, tùy chọn đi trước<span class="t-spar">tên lồng nhau</span>: Chuỗi tên và toán tử độ phân giải phạm vi<code>::</code>, kết thúc với toán tử độ phân giải phạm vi. Nó chỉ có thể được bỏ qua trong các tuyên bố liệt kê không có phong trào không bị chi phối.<br/> <span class="t-spar">tên lồng nhau</span>chỉ có thể xuất hiện nếu tên liệt kê có mặt và tuyên bố này là một bản tái cấu trúc. Cho các khai báo liệt kê mờ đục,<span class="t-spar">tên lồng nhau</span>chỉ có thể xuất hiện trước tên của sự liệt kê trong<a href="template_specialization" title="cpp/language/template specialization">explicit specialization declarations</a>.<br/>Nếu như<span class="t-spar">tên lồng nhau</span>là hiện tại,<i>enum-specifier</i>không thể đề cập đến một liệt kê chỉ được thừa hưởng hoặc giới thiệu bởi một<a href="using_declaration" title="cpp/language/using declaration">using-declaration</a>, và<i>enum-specifier</i>Chỉ có thể xuất hiện trong một không gian tên bao quanh tuyên bố trước đó. Trong những trường hợp như vậy,<span class="t-spar">tên lồng nhau</span>không thể bắt đầu với một<a href="decltype" title="cpp/language/decltype">decltype</a>người xác định.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">        Màu sắc trường hợp :: Blue: std :: cout &lt;&lt; "Blue \ n";  phá vỡ;</span> </td> <td>-</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span>dấu hai chấm (<code>:</code>), tiếp theo là một<span class="t-spar">Loại Specifier-seq</span>tên đó là một loại tích phân (nếu nó được sửa chữa CV, trình độ bị bỏ qua) sẽ đóng vai trò là loại cơ bản cố định cho loại bảng liệt kê này</td>
</tr> <tr class="t-par"> <td> <span class="t-spar"> </span> </td> <td>-</td> <td>Danh sách các định nghĩa liệt kê được phân tách bằng dấu phẩy, mỗi trong số đó chỉ đơn giản là một<span class="t-spar">định danh</span>, trở thành tên của người liệt kê hoặc một định danh duy nhất với trình khởi tạo:<span class="t-spar">định danh</span> <code>=</code> <span class="t-spar">constexpr</span>.<span class="t-rev-inl t-since-cxx17"><span>Trong cả hai trường hợp,<span class="t-spar">định danh</span>có thể được theo dõi trực tiếp bởi một tùy chọn<a href="attributes" title="cpp/language/attributes">attribute specifier sequence</a>.</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span> </td>
</tr>
</table> <p>Có hai loại liệt kê riêng biệt:<i>liệt kê không có điểm</i>(tuyên bố với<span class="t-spar">enum-key</span> <code>enum</code>) Và<i>liệt kê phạm vi</i>(tuyên bố với<span class="t-spar">enum-key</span> <code>enum class</code>hoặc<code>enum struct</code>).</p>
<h3 id="Unscoped_enumerations">Liệt kê không có điểm</h3> <table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <code>enum</code> <span class="t-spar">tên</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <code>{</code> <span class="t-spar">luôn được phân tích cú pháp như một phần của Tuyên bố liệt kê:</span> <code>=</code> <span class="t-spar">constexpr</span> <code>,</code> <span class="t-spar">luôn được phân tích cú pháp như một phần của Tuyên bố liệt kê:</span> <code>=</code> <span class="t-spar">constexpr</span> <code>,</code>...<code>}</code> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>enum</code> <span class="t-spar">tên</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <code>:</code> <span class="t-spar">kiểu</span> <code>{</code> <span class="t-spar">luôn được phân tích cú pháp như một phần của Tuyên bố liệt kê:</span> <code>=</code> <span class="t-spar">constexpr</span> <code>,</code> <span class="t-spar">luôn được phân tích cú pháp như một phần của Tuyên bố liệt kê:</span> <code>=</code> <span class="t-spar">constexpr</span> <code>,</code>...<code>}</code> </td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td>
</tr> <tr class="t-sdsc"> <td> <code>enum</code> <span class="t-spar">tên</span> <code>:</code> <span class="t-spar">kiểu</span> <code>;</code> </td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td>
</tr>
</table> <div class="t-li1">
<span class="t-li">1)</span>Khai báo một loại liệt kê không bịa<code>int</code>Trừ khi giá trị của một bảng điều khiển không thể phù hợp với<code>int</code>hoặc<code>unsigned int</code>. Nếu<span class="t-spar"> </span>trống, loại cơ bản như thể bảng liệt kê có một bảng điều khiển duy nhất có giá trị<code>​0​</code>. Nếu không có loại tích phân nào có thể đại diện cho tất cả các giá trị điều tra, thì liệt kê là không được hình thành).</div> <div class="t-li1">
<span class="t-li">2)</span>Tuyên bố một loại bảng liệt kê không được sử dụng có loại cơ bản được cố định.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Tuyên bố enum mờ cho một liệt kê không bị nhiễm phải chỉ định tên và loại cơ bản.</div> <p>Mỗi<span class="t-spar">luôn được phân tích cú pháp như một phần của Tuyên bố liệt kê:</span>cấu trúc s<span class="t-spar">tên</span>), có thể nhìn thấy trong phạm vi kèm theo và có thể được sử dụng bất cứ khi nào các hằng số được yêu cầu.</p>
<div class="cpp source-cpp"><pre data-language="cpp">màu enum {màu đỏ, xanh lá cây, xanh dương};</pre></div> <p>Màu r = đỏ;<span class="t-spar"> </span>chuyển đổi (r)</p>
<div class="cpp source-cpp"><pre data-language="cpp">{</pre></div> <p>Các<span class="t-spar">tên</span>    trường hợp màu đỏ: std :: cout &lt;&lt; "Red \ n";   phá vỡ;</p>
<div class="cpp source-cpp"><pre data-language="cpp">    trường hợp màu xanh lá cây: std :: cout &lt;&lt; "màu xanh lá cây \ n"; phá vỡ;</pre></div> <p>    trường hợp màu xanh: std :: cout &lt;&lt; "blue \ n";  phá vỡ;<code>.</code>Và<code>-&gt;</code>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">}</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>// a và d chuỗi ban đầu chung là A.A và D.D<a href="declarations#Specifiers" title="cpp/language/declarations">declaration specifiers</a>xuất hiện trong bối cảnh ngay lập tức của một khởi tạo mẫu.<a href="class#Member_specification" title="cpp/language/class">member declaration</a>, trình tự<code>enum</code></p>
<span class="t-spar">Mỗi bảng điều khiển được liên kết với giá trị của loại cơ bản. Khi khởi tạo được cung cấp trong</span> <code>:</code> <p>Danh sách liệt kê</p>
<div class="cpp source-cpp"><pre data-language="cpp">, các giá trị của các điều tra viên được xác định bởi các bộ khởi tạo đó. Nếu người liệt kê đầu tiên không có bộ khởi tạo, giá trị liên quan bằng không. Đối với bất kỳ người liệt kê nào khác có định nghĩa không có bộ khởi tạo, giá trị liên quan là giá trị của người liệt kê trước đó cộng với một.</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <h4 id="Enumeration_name_for_linkage_purposes">enum foo {a, b, c = 10, d, e = 1, f, g = f + c};</h4> <p>// a = 0, b = 1, c = 10, d = 11, e = 1, f = 2, g = 12<a href="typedef#typedef_name_for_linkage_purposes" title="cpp/language/typedef">typedef name for linkage purposes</a>của một bảng liệt kê không bị bỏ qua có thể bị bỏ qua: Tuyên bố như vậy chỉ đưa các điều tra viên vào phạm vi kèm theo:<a href="storage_duration" title="cpp/language/storage duration">linkage purposes</a>enum {a, b, c = 0, d = a + 2}; // Xác định a = 0, b = 1, c = 0, d = 2<i>Khi một liệt kê không được đăng ký là thành viên lớp, các bảng điều khiển của nó có thể được truy cập bằng các toán tử truy cập thành viên lớp</i>.</p>
<h3 id="Scoped_enumerations">Cấu trúc x</h3> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <code>enum struct|class</code> <span class="t-spar">tên</span> <code>{</code> <span class="t-spar">luôn được phân tích cú pháp như một phần của Tuyên bố liệt kê:</span> <code>=</code> <span class="t-spar">constexpr</span> <code>,</code> <span class="t-spar">luôn được phân tích cú pháp như một phần của Tuyên bố liệt kê:</span> <code>=</code> <span class="t-spar">constexpr</span> <code>,</code>...<code>}</code> </td> <td>(1)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>enum struct|class</code> <span class="t-spar">tên</span> <code>:</code> <span class="t-spar">kiểu</span> <code>{</code> <span class="t-spar">luôn được phân tích cú pháp như một phần của Tuyên bố liệt kê:</span> <code>=</code> <span class="t-spar">constexpr</span> <code>,</code> <span class="t-spar">luôn được phân tích cú pháp như một phần của Tuyên bố liệt kê:</span> <code>=</code> <span class="t-spar">constexpr</span> <code>,</code>...<code>}</code> </td> <td>(2)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>enum struct|class</code> <span class="t-spar">tên</span> <code>;</code> </td> <td>(3)</td> <td class="t-sdsc-nopad"> </td>
</tr> <tr class="t-sdsc"> <td> <code>enum struct|class</code> <span class="t-spar">tên</span> <code>:</code> <span class="t-spar">kiểu</span> <code>;</code> </td> <td>(4)</td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <span class="t-li">1)</span>int c = x.left;<span class="kw4">int</span> <span class="kw1">lớp học</span>Và<span class="kw1">int a = x :: hướng :: trái; // chỉ được phép trong C ++ 11 trở lên</span>int b = x :: trái;<span class="t-li">2)</span>int c = x.left;<span class="t-spar">kiểu</span> <span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>enum-stand-name<span class="kw4">int</span> <span class="t-li">là trong</span>enum-stand-name<span class="t-spar">kiểu</span> <p>Mỗi<span class="t-spar">luôn được phân tích cú pháp như một phần của Tuyên bố liệt kê:</span>cấu trúc s<span class="t-spar">tên</span>{<a href="static_cast" title="cpp/language/static cast"><code>static_cast</code></a>    enum e1: int {};</p>
<div class="cpp source-cpp"><pre data-language="cpp">    enum e1: int {}; // Lỗi: Tái tạo liệt kê,</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>                      // không được phân tích cú pháp dưới dạng trường bit có độ dài không có độ dài của loại enum e1<a href="list_initialization" title="cpp/language/list initialization">list initialization</a>};</p>
<ul>
<li> </li>
<li>enum e2 {e1};</li>
<li> </li>
<li>void f ()</li>
</ul> <p>{<code>SafeInt</code>    SAI ? enum e2 mới: int (); // ok: 'int' không được phân tích cú pháp là loại cơ bản</p>
<div class="cpp source-cpp"><pre data-language="cpp">}</pre></div> </td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <h3 id="Using-enum-declaration">Tên liệt kê cho mục đích liên kết</h3> <table class="t-sdsc-begin"> <tr class="t-sdsc"> <td> <code>using enum</code> <span class="t-spar">tên lồng nhau</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">tên</span> <code>;</code> </td> <td class="t-sdsc-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td>
</tr>
</table> <p><span class="t-spar">tên lồng nhau</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">tên</span>Một liệt kê không tên mà không có<a href="dependent_name#Dependent_types" title="cpp/language/dependent name">dependent</a>và điều đó có một bảng điều khiển được ký hiệu, cho<a href="qualified_lookup" title="cpp/language/qualified lookup">qualified</a>hoặc<a href="unqualified_lookup" title="cpp/language/unqualified lookup">unqualified</a>, theo loại cơ bản và điều tra viên đầu tiên của nó; Một sự liệt kê như vậy được cho là có một điều tra viên như một<span class="t-spar">tên lồng nhau</span>Tên cho mục đích liên kết</p>
<p>Liệt kê phạm vi<a href="using_declaration" title="cpp/language/using declaration">using-declaration</a>Tận dụng</p>
<div class="cpp source-cpp"><pre data-language="cpp">Tận dụng</pre></div> <p>Tận dụng</p>
<div class="cpp source-cpp"><pre data-language="cpp">Tận dụng</pre></div> </td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <h3 id="Notes">Ghi chú</h3> <p>tuyên bố một loại liệt kê phạm vi có loại cơ bản là<a href="implicit_conversion#Promotion_from_enumeration_types" title="cpp/language/implicit conversion">promoted</a>hoặc<a href="implicit_conversion#Integral_conversions" title="cpp/language/implicit conversion">converted</a>(Các từ khóa</p>
<div class="cpp source-cpp"><pre data-language="cpp">cấu trúc</pre></div> <p>hoàn toàn tương đương)<a href="static_cast" title="cpp/language/static cast"><code>static_cast</code></a>tuyên bố một loại liệt kê phạm vi có loại cơ bản là</p>
<div class="cpp source-cpp"><pre data-language="cpp">Tuyên bố enum mờ đục cho một liệt kê phạm vi có loại cơ bản là</pre></div> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>Tính năng Test Macro</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../feature_test#cpp_enumerator_attributes" title="cpp/feature test"><code>__cpp_enumerator_attributes</code></a></td> <td><span class="nu0">Tương tự như cho</span></td> <td><span class="t-mark">Dest_at</span></td> <td>
<a href="attributes" title="cpp/language/attributes">Attributes</a>cho các điều tra viên</td>
</tr> <tr> <td><a href="../feature_test#cpp_using_enum" title="cpp/feature test"><code>__cpp_using_enum</code></a></td> <td><span class="nu0">201907L</span></td> <td><span class="t-mark">Phạm vi :: Construct_at</span></td> <td>
<a href="#Using-enum-declaration"><code>using enum</code></a> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Tuyên bố enum mờ đục cho một liệt kê phạm vi có loại cơ bản là</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">Tận dụng</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/377.html" rel="nofollow">CWG 377</a> </td> <td>C ++ 98</td> <td>trở thành một hằng số được đặt tên của loại liệt kê (nghĩa là,<br/>), được chứa trong phạm vi liệt kê và có thể được truy cập bằng toán tử phân giải phạm vi. Không có sự chuyển đổi ngầm từ các giá trị của bộ liệt kê phạm vi sang các loại tích phân, mặc dù</td> <td>có thể được sử dụng để có được giá trị số của bộ liệt kê.<br/>phải được sử dụng.</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/518.html" rel="nofollow">CWG 518</a> </td> <td>C ++ 98</td> <td>#include &lt;Istream&gt;</td> <td>cho phép</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1514.html" rel="nofollow">CWG 1514</a> </td> <td>C ++ 11</td> <td> <br/>int main ()</td> <td>{</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1638.html" rel="nofollow">CWG 1638</a> </td> <td>C ++ 11</td> <td>    lớp enum màu {màu đỏ, màu xanh lá cây = 20, xanh dương};<br/>    Màu r = màu :: màu xanh;</td> <td>tên lồng nhau<br/> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1766.html" rel="nofollow">CWG 1766</a> </td> <td>C ++ 98</td> <td>    chuyển đổi (r)<br/>    {</td> <td>hành vi không xác định</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1966.html" rel="nofollow">CWG 1966</a> </td> <td>C ++ 11</td> <td>Tìm kiếm chuyển tiếp của Const<a class="external text" href="https://cplusplus.github.io/CWG/issues/1514.html" rel="nofollow">CWG issue 1514</a>        Màu sắc trường hợp :: Red: std :: cout &lt;&lt; "Red \ n";   phá vỡ;<code>:</code><br/>        Màu sắc trường hợp :: Green: std :: cout &lt;&lt; "Green \ n"; phá vỡ;<span class="t-spar">        Màu sắc trường hợp :: Blue: std :: cout &lt;&lt; "Blue \ n";  phá vỡ;</span> </td> <td>    }<br/> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2156.html" rel="nofollow">CWG 2156</a> </td> <td>C ++ 11</td> <td>    // int n = r; // Lỗi: Không chuyển đổi ngầm từ enum phạm vi sang int<br/>    int n = static_cast &lt;Int&gt; (r); // ok, n = 21</td> <td>bị cấm</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2157.html" rel="nofollow">CWG 2157</a> </td> <td>C ++ 11</td> <td>Tìm kiếm chuyển tiếp của Const<a class="external text" href="https://cplusplus.github.io/CWG/issues/1966.html" rel="nofollow">CWG issue 1966</a>    std :: cout &lt;&lt; n &lt;&lt; '\ n'; // In 21<br/>}</td> <td>Một bảng liệt kê có thể được khởi tạo từ một số nguyên mà không cần đúc, sử dụng</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2530.html" rel="nofollow">CWG 2530</a> </td> <td>C ++ 98</td> <td>, nếu tất cả những điều sau đây là đúng:<br/>Việc khởi tạo là khởi tạo danh sách trực tiếp.</td> <td>bị cấm</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2590.html" rel="nofollow">CWG 2590</a> </td> <td>C ++ 98</td> <td>Danh sách khởi tạo chỉ có một yếu tố duy nhất.<br/>Việc liệt kê được phạm vi hoặc không được sử dụng với loại cơ bản cố định.</td> <td>Việc chuyển đổi là không phải là Narrowing.<br/>Điều này cho phép giới thiệu các loại số nguyên mới (ví dụ:</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2621.html" rel="nofollow">CWG 2621</a> </td> <td>C ++ 20</td> <td>) mà thích các quy ước gọi hiện tại giống như các loại số nguyên cơ bản của chúng, ngay cả trên ABI đã xử phạt các cấu trúc chuyển/trả lại theo giá trị.<br/>enum byte: không dấu char {}; // byte là một loại số nguyên mới; Xem thêm STD :: Byte (C ++ 17)</td> <td>byte b {42};        // OK kể từ C ++ 17 (-Danh sách trực tiếp-khởi tạo)<br/>byte c = {42};     // lỗi</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../types/is_enum" title="cpp/types/is enum"> <span class="t-lines"><span>is_enum</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>kiểm tra xem một loại có phải là loại bảng liệt kê không<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../types/is_scoped_enum" title="cpp/types/is scoped enum"> <span class="t-lines"><span>is_scoped_enum</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td>Kiểm tra xem một loại có phải là loại bảng liệt kê phạm vi không<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../types/underlying_type" title="cpp/types/underlying type"> <span class="t-lines"><span>bên dưới_type</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>có được loại số nguyên cơ bản cho một loại liệt kê nhất định<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/to_underlying" title="cpp/utility/to underlying"> <span class="t-lines"><span>to_underlying</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td>Chuyển đổi một bảng liệt kê thành loại cơ bản của nó<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/enum" title="c/language/enum">C documentation</a></span>vì<span class=""><span>Liệt kê</span></span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/enum">https://en.cppreference.com/w/cpp/language/enum</a>
</p>
</div>
