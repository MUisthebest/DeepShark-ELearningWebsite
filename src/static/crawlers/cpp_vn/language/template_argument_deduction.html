 <h1 class="firstHeading" id="firstHeading">Khấu trừ tranh luận mẫu</h1> <p>Để khởi tạo một<a href="function_template" title="cpp/language/function template">function template</a>, mọi đối số mẫu phải được biết, nhưng không phải mọi đối số mẫu phải được chỉ định. Khi có thể, trình biên dịch sẽ suy ra các đối số mẫu bị thiếu từ các đối số chức năng. Điều này xảy ra khi một cuộc gọi chức năng được thử, khi một địa chỉ của một mẫu chức năng được lấy và trong một số<a href="#Other_contexts">other contexts</a>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">Mẫu &lt;typename to, typename từ&gt;</pre></div> <p>Để chuyển đổi (từ f);</p>
<div class="cpp source-cpp"><pre data-language="cpp">char* p = 0;</pre></div> <p> <a href="lookup" title="cpp/language/lookup">name lookup</a>Mẫu &lt;Class T&gt;<a href="adl" title="cpp/language/adl">argument-dependent lookup</a>T g (t x = &amp; p) {return x; }<a href="function_template#Template_argument_substitution" title="cpp/language/function template">template argument substitution</a>Mẫu &lt;Class T&gt;<a href="sfinae" title="cpp/language/sfinae">SFINAE</a>) Và<a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p> </p>
<div class="cpp source-cpp"><pre data-language="cpp">void G (Double D) </pre></div> <p>{<a href="class_template_argument_deduction" title="cpp/language/class template argument deduction">class template argument deduction</a> </p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <h3 id="Deduction_from_a_function_call">    int i = Chuyển đổi &lt;Int&gt; (d);    // Gọi chuyển đổi &lt;int, double&gt; (double)</h3> <p>    char c = chuyển đổi &lt;par&gt; (d);  // Gọi chuyển đổi &lt;char, double&gt; (double)<code>T</code>    int (*ptr) (float) = chuyển đổi; // Instantiates Chuyển đổi &lt;int, float&gt; (float) <code>TT</code>                                // và lưu trữ địa chỉ của nó trong PTR<code>I</code>}<code>P</code>Cơ chế này cho phép sử dụng các toán tử mẫu, vì không có cú pháp để chỉ định các đối số mẫu cho toán tử khác ngoài việc viết lại nó như một biểu thức cuộc gọi chức năng:<i>Khấu trừ đối số mẫu cũng được thực hiện khi tên của mẫu lớp được sử dụng làm loại đối tượng được xây dựng:</i> <code>A</code>STD :: Cặp P (2, 4.5);<code>A</code>std :: tuple t (4, 3, 2.5);</p>
<p>std :: copy_n (VI1, 3, std :: Back_insert_iterator (VI2));<code>P</code>/<code>A</code>std :: for_each (vi.begin (), vi.end (), foo ([&amp;] (int i) {...}));<code>P</code>/<code>A</code>auto lck = std :: lock_guard (foo.mtx);</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>i), có thể được thay thế thành từng tham số<code>P</code>cho<code><a href="http://en.cppreference.com/w/cpp/utility/initializer_list"><span class="kw962">Điều đó cho tất cả<span class="me2">Khởi tạo_list</span></span></a><span class="sy1">is_trivently_destructible_v</span>P<span class="st0">Khấu trừ đối số mẫu cho các mẫu lớp diễn ra trong các khai báo và trong các biểu thức diễn viên rõ ràng; nhìn thấy</span></code>Và<code>A</code>Điều đó như vậy<a href="list_initialization" title="cpp/language/list initialization">braced-init-list</a>Khấu trừ từ một cuộc gọi chức năng<code>P'</code>Khấu trừ đối số mẫu cố gắng xác định đối số mẫu (loại cho các tham số mẫu loại<code>A'</code>i, mẫu cho các tham số mẫu mẫu</p>
<div class="cpp source-cpp"><pre data-language="cpp">i và các giá trị cho các tham số mẫu không thuộc loại</pre></div> <p>i), có thể được thay thế thành từng tham số<code>P</code>cho<code>P'</code>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;<code>N</code>để sản xuất loại<code>A</code>suy luận<code>N</code>, giống như loại đối số</p>
<div class="cpp source-cpp"><pre data-language="cpp">, sau khi điều chỉnh được liệt kê dưới đây.</pre></div> <p>Để kiểm soát cách giải quyết thời gian địa phương mơ hồ hoặc không tồn tại. Đi qua<a href="parameter_pack" title="cpp/language/parameter pack">parameter pack</a>Nếu có nhiều tham số, mỗi<code>P</code>Cặp được suy luận riêng biệt và các đối số mẫu được suy ra sau đó được kết hợp. Nếu khấu trừ thất bại hoặc mơ hồ đối với bất kỳ<code>P</code>Cặp hoặc nếu các cặp khác nhau mang lại các đối số mẫu được suy ra khác nhau hoặc nếu bất kỳ đối số mẫu nào vẫn không được suy ra cũng như không được chỉ định rõ ràng, việc biên dịch không thành công.<code>A</code>Nếu xóa các tài liệu tham khảo và trình điều trị CV khỏi</p>
<div class="cpp source-cpp"><pre data-language="cpp">'&gt;</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <p>Nếu như<code>P</code>, sau đó khấu trừ được thực hiện cho mọi yếu tố của danh sách khởi tạo, lấy<code>A</code>Điều đó như vậy<a href="overloaded_address" title="cpp/language/overloaded address">set of overloaded functions</a>là tham số và phần tử danh sách</p>
<div class="cpp source-cpp"><pre data-language="cpp">Như lập luận:</pre></div> <p>Mẫu &lt;Class T&gt;<code>P</code>Và<code>A</code>void f (std :: initizer_list &lt;t&gt;);</p>
<div class="t-li1">
<span class="t-li">1)</span>Nếu như<code>P</code>không phải là loại tham chiếu,</div> <div class="t-li2">
<span class="t-li">}</span>nếu như<code>A</code>là một loại mảng,<code>A</code> </div> <div class="t-li2">
<span class="t-li">{</span>    int n = 1;<code>A</code>f ({1, 2, 3});  // p = std :: initizer_list &lt;t&gt;, a = {1, 2, 3}<code>A</code>               // p'1 = t, a'1 = 1: suy luận t = int</div> <div class="t-li2">
<span class="t-li">}</span>    int n = 1;<code>A</code>               // p'2 = t, a'2 = 2: suy luận t = int<div class="cpp source-cpp"><pre data-language="cpp">               // p'3 = t, a'3 = 3: suy luận t = int</pre></div>
</div> <div class="t-li1">
<span class="t-li">2)</span>Nếu như<code>P</code>               // ok: suy luận t = int</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Nếu như<code>P</code> </div> <div class="t-li1">
<span class="t-li">là trong</span>Nếu như<code>P</code>f ({1, "ABC"}); // p = std :: initizer_list &lt;t&gt;, a = {1, "abc"}<a href="reference#Forwarding_references" title="cpp/language/reference">forwarding references</a>               // p'1 = t, a'1 = 1: suy luận t = int<code>A</code>               // p'2 = t, a'2 = "abc": suy luận t = const char*<code>A</code>               // Lỗi: Khấu trừ thất bại, T không rõ ràng<code><a href="../utility/forward" title="cpp/utility/forward">std::forward</a></code> <span class="t-rev-inl t-since-cxx17"><span>Nếu xóa các tài liệu tham khảo và trình điều trị CV khỏi<a href="class_template_argument_deduction" title="cpp/language/class template argument deduction">class template argument deduction</a>], Và</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>):<div class="cpp source-cpp"><pre data-language="cpp">là một danh sách không có giằng trống, thì việc khấu trừ được thực hiện như trên, trừ khi</pre></div>
</div> <p>là một tham số mẫu không phải kiểu, nó được suy ra từ độ dài của danh sách khởi tạo:<a href="#Deduction_from_a_type">deduction from a type</a>Mẫu &lt;class T, int n&gt;<code>A</code>void H (t const (&amp;) [n]);<code>P</code>h ({1, 2, 3}); // suy luận t = int, suy luận n = 3<i> </i> <code>A</code>        : keep_ (std :: di chuyển (x)) {}<code>A</code>Mẫu &lt;Class T&gt;</p>
<p>void f (std :: mảng &lt;int, 2 * n&gt; a);<code>P</code>Và<code>A</code>J ({42}); // suy ra t = int, ràng buộc mảng không phải là một tham số, không được xem xét</p>
<div class="t-li1">
<span class="t-li">1)</span>Nếu như<code>P</code> <code>A</code>Cấu trúc Aggr<code>A</code>:<div class="cpp source-cpp"><pre data-language="cpp">{</pre></div>
</div> <div class="t-li1">
<span class="t-li">2)</span>    int i;<code>A</code>    int j;<code>A</code>};<a class="mw-redirect" href="implicit_cast#Qualification_conversions" title="cpp/language/implicit cast">qualification conversions</a> <span class="t-rev-inl t-since-cxx17"><span> </span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>:<div class="cpp source-cpp"><pre data-language="cpp">Mẫu &lt;int n&gt;</pre></div>
</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Nếu như<code>P</code>void k (agg const (&amp;) [n]);<code>P</code>có hình thức<a href="templates#template-id" title="cpp/language/templates">simple-template-id</a>k ({1, 2, 3});       // Lỗi: Khấu trừ thất bại, không chuyển đổi từ int sang agg<code>A</code>k ({{1}, {2}, {3}}); // ok: suy luận n = 3<code>A</code> <code>P</code>Mẫu &lt;int m, int n&gt;<i>là một tham chiếu rvalue cho loại được khai báo</i>void m (int const (&amp;) [m] [n]);<code>A</code>m ({{1, 2}, {3, 4}}); // suy luận m = 2, suy luận n = 2<code>A</code>:<div class="cpp source-cpp"><pre data-language="cpp"> </pre></div>
</div> <h4 id="Non-deduced_contexts">Mẫu &lt;class T, int n&gt;</h4> <p>void n (t const (&amp;) [n], t);<code>P</code>n ({{1}, {2}, {3}}, agg ()); // suy luận t = agg, suy luận n = 3<i>sử dụng</i>xuất hiện như cuối cùng</p>
<div class="t-li1">
<span class="t-li">1)</span>Các<span class="t-spar">tên lồng nhau</span>, sau đó loại<code>::</code>được khớp với loại<a href="identifiers#Qualified_identifiers" title="cpp/language/identifiers">qualified-id</a>:<div class="cpp source-cpp"><pre data-language="cpp">của mỗi đối số còn lại của cuộc gọi. Mỗi trận đấu suy ra các đối số mẫu cho vị trí tiếp theo trong mở rộng gói:</pre></div>
</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx26">
<td> <span class="t-li">2)</span>MỘT<a href="pack_indexing#Pack_indexing_specifier" title="cpp/language/pack indexing">pack indexing specifier</a>hoặc a<a href="pack_indexing#Pack_indexing_expression" title="cpp/language/pack indexing">pack indexing expression</a>:<div class="cpp source-cpp"><pre data-language="cpp">Mẫu &lt;class ... loại&gt;</pre></div> </td> <td><span class="t-mark-rev t-since-cxx26">(kể từ C ++ 26)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>void f (loại &amp; ...);<a href="decltype" title="cpp/language/decltype">decltype</a> <div class="cpp source-cpp"><pre data-language="cpp">void H (int x, float &amp; y)</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <div class="t-li1">
<span class="t-li">là trong</span>{<div class="cpp source-cpp"><pre data-language="cpp">    const int z = x;</pre></div>
</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>    f (x, y, z); // p = các loại &amp; ..., a1 = x: suy luận thành viên đầu tiên của các loại ... = int<div class="cpp source-cpp"><pre data-language="cpp">                // p = các loại &amp; ..., a2 = y: suy luận thành viên thứ hai của các loại ... = float</pre></div>
</div> <div class="t-li1">
<span class="t-li">từ_sys</span>                                     Forwardit1 đầu tiên, forwardit1 cuối cùng,<code>P</code>Mẫu &lt;Class T&gt;<code>A</code>                // gọi f &lt;int, float, const int&gt;<code>P</code>}<code>P</code>là loại chức năng, loại con trỏ đến loại chức năng hoặc loại con trỏ đến thành viên và nếu<div class="cpp source-cpp"><pre data-language="cpp">Không chứa các mẫu chức năng, Khấu trừ đối số mẫu được thử với mỗi quá tải. Nếu chỉ có một thành công, khoản khấu trừ thành công đó được sử dụng. Nếu không có hoặc nhiều hơn một thành công, tham số mẫu là bối cảnh không được quy định (xem bên dưới):</pre></div>
</div> <div class="t-li1">
<span class="t-li">6)</span>                                     Forwardit1 đầu tiên, forwardit1 cuối cùng,<code>P</code>Mẫu &lt;Class T&gt;<code>A</code>int f (t (*p) (t));<code>P</code># Elif __has_include (&lt;thử nghiệm/tùy chọn&gt;) // Kiểm tra phiên bản thử nghiệm<code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code> <span class="t-rev-inl t-since-cxx17"><span>int g (int);</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>:<div class="cpp source-cpp"><pre data-language="cpp">int g (char);</pre></div>
</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <span class="t-li">. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu biểu thức</span>                                     Forwardit1 đầu tiên, forwardit1 cuối cùng,<code>P</code> <div class="cpp source-cpp"><pre data-language="cpp">f (g); // p = t (*) (t), a = bộ quá tải</pre></div> <span class="t-li">được hình thành tốt. Chương trình không được hình thành nếu</span>      // p = t (*) (t), a1 = int (int): suy luận t = int<code>P</code>      // p = t (*) (t), a2 = int (char): không suy ra t<div class="cpp source-cpp"><pre data-language="cpp">      // Chỉ có một quá tải hoạt động, Khấu trừ thành công</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <div class="t-li1">
<span class="t-li">Toán tử bool constexpr&gt; (const std :: Chrono :: sys_time &lt;fending&gt; &amp; x,</span>Bool Binary_Search (Forwardit First, Forwardit Last,<code>P</code>Trước khi khấu trừ bắt đầu, các điều chỉnh sau đây đối với<div class="cpp source-cpp"><pre data-language="cpp">được thực hiện:</pre></div>
</div> <p>được thay thế bằng loại con trỏ thu được từ chuyển đổi mảng sang con trỏ;<code>A&lt;T&gt;::B&lt;T2&gt;</code>Thì<code>T</code>là một loại chức năng,<code>T2</code>được thay thế bằng loại con trỏ thu được từ chuyển đổi chức năng sang con trỏ;<code>void(*f)(typename A&lt;T&gt;::B, A&lt;T&gt;)</code>    toán tử-= (const std :: chrono :: tháng &amp; dm) const noexcept;<code>T</code>TRONG<code>A&lt;T&gt;::B</code>là một loại đủ điều kiện CV, các trình điều trị CV cấp cao nhất bị bỏ qua để khấu trừ:<code>T</code>TRONG<code>A&lt;T&gt;</code>Mẫu &lt;Class T&gt;</p>
<h4 id="Deduction_from_a_type">void f (t);</h4> <p> <code>P</code>int a [3];<code>T</code>f (a); // p = t, a = int [3], được điều chỉnh thành int*: suy luận t = int*<code>TT</code> <code>I</code>void B (int);<code>A</code>f (b); // p = t, a = void (int), được điều chỉnh thành void (*) (int): suy luận t = void (*) (int)<code>P</code> </p>
<ul>
<li> <code><i>không ngụ ý rằng</i></code><span class="t-mark">ATOMIC_INTPTR_T</span> <code>T</code>Số lượng các yếu tố để sao chép</li>
<li> <code>T*</code>Số lượng các yếu tố để sao chép</li>
<li> <code>T&amp;</code>Số lượng các yếu tố để sao chép</li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li> <code>T&amp;&amp;</code>Số lượng các yếu tố để sao chép</li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <ul><li> <code>T</code><span class="t-mark">ATOMIC_INTPTR_T</span> <code>[</code><code>I</code><span class="t-mark">ATOMIC_INTPTR_T</span><code>]</code>Số lượng các yếu tố để sao chép</li></ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <ul><li> <code>T</code><span class="t-mark">ATOMIC_INTPTR_T</span> <code>(</code><code>U</code><span class="t-mark">ATOMIC_INTPTR_T</span><code>)</code>Số lượng các yếu tố để sao chép</li></ul> </td> <td><span class="t-mark-rev t-until-cxx17">xáo trộn</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <ul><li> <code>T</code><span class="t-mark">ATOMIC_INTPTR_T</span> <code>(</code><code>U</code><span class="t-mark">ATOMIC_INTPTR_T</span><code>)</code> <code>noexcept(</code><code>I</code><span class="t-mark">ATOMIC_INTPTR_T</span><code>)</code>Số lượng các yếu tố để sao chép</li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <ul>
<li> <code>T</code><span class="t-mark">ATOMIC_INTPTR_T</span> <code>U</code><span class="t-mark">ATOMIC_INTPTR_T</span><code>::*</code>Số lượng các yếu tố để sao chép</li>
<li> <code>TT</code><span class="t-mark">ATOMIC_INTPTR_T</span><code>&lt;T&gt;</code>Số lượng các yếu tố để sao chép</li>
<li> <code>TT</code><span class="t-mark">ATOMIC_INTPTR_T</span><code>&lt;I&gt;</code>Số lượng các yếu tố để sao chép</li>
<li> <code>TT</code><span class="t-mark">ATOMIC_INTPTR_T</span><code>&lt;TU&gt;</code>Số lượng các yếu tố để sao chép</li>
<li> <code>TT</code><span class="t-mark">ATOMIC_INTPTR_T</span><code>&lt;&gt;</code>.</li>
</ul> <p>const int c = 13;</p>
<ul>
<li> <code>T</code><span class="t-mark">ATOMIC_INTPTR_T</span>hoặc<code>U</code><span class="t-mark">ATOMIC_INTPTR_T</span>f (c); // p = t, a = const int, được điều chỉnh thành int: suy luận t = int<span class="t-spar">. Độ phân giải là coi tên loại là</span>là một loại đủ điều kiện CV, các trình điều trị CV cấp cao nhất bị bỏ qua để khấu trừ.<code>P</code>hoặc<code>A</code>là một loại tham chiếu, loại được tham chiếu được sử dụng để khấu trừ.<code>P</code>Và<code>A</code>.</li>
<li> <code>TT</code><span class="t-mark">ATOMIC_INTPTR_T</span>hoặc<code>TU</code><span class="t-mark">ATOMIC_INTPTR_T</span>là một tham chiếu rvalue cho tham số mẫu không đủ điều kiện CV (được gọi là</li>
<li> <code>I</code><span class="t-mark">ATOMIC_INTPTR_T</span>) và đối số cuộc gọi chức năng tương ứng là một lvalue, tham chiếu lvalue loại<code>I</code>được sử dụng thay cho<code>P</code>hoặc<code>A</code>để khấu trừ (lưu ý: đây là cơ sở cho hành động của<code>P</code>Và<code>A</code>.</li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <ul><li> <code>noexcept(</code><code>I</code><span class="t-mark">ATOMIC_INTPTR_T</span><code>)</code>Lưu ý: Trong<a href="noexcept_spec" title="cpp/language/noexcept spec">exception specification</a>, tham số mẫu của mẫu lớp không bao giờ là tham chiếu chuyển tiếp<code>noexcept</code>Mẫu &lt;Class T&gt;<code>I</code><span class="t-mark">ATOMIC_INTPTR_T</span>int f (t &amp;&amp;);       // P là một tham chiếu rvalue về c-unqualified t (tham chiếu chuyển tiếp)</li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <p>Nếu như<code>P</code> <code>&lt;T&gt;</code>hoặc<code>&lt;I&gt;</code>Mẫu &lt;Class T&gt;<code>P</code>int g (const t &amp;&amp;); // P là một tham chiếu rvalue về t đủ điều kiện c (không đặc biệt)<code>A</code> <code>A</code>int main ()<code>P</code>{<code>A</code>    int i;</p>
<p>Nếu như<code>P</code>    int n1 = f (i); // Đối số là lvalue: gọi f &lt;int &amp;&gt; (int &amp;) (trường hợp đặc biệt)<code>(T)</code>    int n2 = f (0); // Đối số không phải là lvalue: gọi f &lt;int&gt; (int &amp;&amp;)<code>P</code> <code>A</code>// int n3 = g (i); // Lỗi: khấu trừ cho g &lt;int&gt; (const int &amp;&amp;), mà<code>A</code>                   // không thể liên kết tham chiếu rvalue với lvalue<code>P</code>}<code>A</code>Sau các phép biến đổi này, các quy trình khấu trừ như được mô tả dưới đây (xem phần<code>A</code>.</p>
<p>) và cố gắng tìm các đối số mẫu như vậy sẽ khiến cho sự suy luận</p>
<ul><li> <code>X&lt;int&gt;(*)(char[6])</code>là một loại tham chiếu, suy luận<code>T*</code>là<code>T</code>khoảng cách<code>X&lt;int&gt;(char[6])</code>Số lượng các yếu tố để sao chép</li></ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <ul><li> <code>X&lt;int&gt;(char[6])</code>là một loại tham chiếu, suy luận<code>T</code><span class="t-mark">ATOMIC_INTPTR_T</span> <code>(</code><code>U</code><span class="t-mark">ATOMIC_INTPTR_T</span><code>)</code>là<code>T</code>khoảng cách<code>X&lt;int&gt;</code>Và<code>U</code>khoảng cách<code>char[6]</code>Số lượng các yếu tố để sao chép</li></ul> </td> <td><span class="t-mark-rev t-until-cxx17">xáo trộn</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <ul><li> <code>X&lt;int&gt;(char[6])</code>là một loại tham chiếu, suy luận<code>T</code><span class="t-mark">ATOMIC_INTPTR_T</span> <code>(</code><code>U</code><span class="t-mark">ATOMIC_INTPTR_T</span><code>)</code> <code>noexcept(</code><code>I</code><span class="t-mark">ATOMIC_INTPTR_T</span><code>)</code>là<code>T</code>khoảng cách<code>X&lt;int&gt;</code>Thì<code>U</code>khoảng cách<code>char[6]</code>, Và<code>I</code>Sau khi các điều chỉnh được liệt kê ở trên.<code>noexcept</code>Nếu khoản khấu trừ thông thường từ<code>false</code>Số lượng các yếu tố để sao chép</li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <ul>
<li> <code>X&lt;int&gt;</code>là một loại tham chiếu, suy luận<code>TT</code><span class="t-mark">ATOMIC_INTPTR_T</span><code>&lt;T&gt;</code>là<code>TT</code>khoảng cách<code>X</code>Và<code>T</code>khoảng cách<code>int</code>, Và</li>
<li> <code>char[6]</code>là một loại tham chiếu, suy luận<code>T</code><span class="t-mark">ATOMIC_INTPTR_T</span> <code>[</code><code>I</code><span class="t-mark">ATOMIC_INTPTR_T</span><code>]</code>là<code>T</code>khoảng cách<code>char</code>Và<code>I</code>khoảng cách<code><a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">Điều đó cho tất cả<span class="me2">size_t</span></span></a><span class="br0">.</span><span class="nu0">6</span><span class="br0">)</span></code>.</li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <p>(tức là, loại được đề cập bởi tham chiếu) có thể được tiết lộ CV hơn</p>
<div class="cpp source-cpp"><pre data-language="cpp">Mẫu &lt;Typename T&gt;</pre></div> </td> <td><span class="t-mark-rev t-until-cxx17">xáo trộn</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <p>void f (const t &amp; t);</p>
<div class="cpp source-cpp"><pre data-language="cpp"> </pre></div> <p>Loại của<code>N</code>bool a = false;<code>T[N]</code>khoảng cách<code><a href="../types/size_t" title="cpp/types/size t">std::size_t</a></code>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">f (a); // p = const t &amp;, được điều chỉnh theo const t, a = bool:</pre></div> <p>Loại của<code>B</code>TRONG<code>noexcept(B)</code>      // suy luận t = bool, suy luận a = const bool<code>bool</code>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">      // suy luận A có đủ điều kiện CV hơn so với</pre></div> </td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <p>Sự biến đổi<code>bool</code>có thể là một con trỏ hoặc con trỏ sang loại thành viên khác có thể được chuyển đổi thành suy luận<code>true</code>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">thông qua a</pre></div> <p>hoặc chuyển đổi con trỏ chức năng</p>
<div class="cpp source-cpp"><pre data-language="cpp">Mẫu &lt;Typename T&gt;</pre></div> <p>void f (const t*);</p>
<div class="cpp source-cpp"><pre data-language="cpp"> </pre></div> <h3 id="Other_contexts">int* p;</h3> <p>f (p); // p = const t*, a = int*:</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <h4 id="auto_type_deduction">      // suy luận t = int, suy luận a = const int*</h4> <p>      // loại tham số (const f &amp;) của tham số chức năng comp,<a href="declarations" title="cpp/language/declarations">declarations</a>là một lớp học và<b><a href="auto" title="cpp/language/auto">auto specifier</a></b>, sau đó biến đổi</p>
<p>                                     Forwardit1 đầu tiên, forwardit1 cuối cùng,<code>P</code>          // A có nguồn gốc từ một<code>T</code>. Tương tự như vậy, nếu<code>auto</code>Bối cảnh không được cung cấp<code>auto</code>Trong các trường hợp sau, các loại, mẫu và các giá trị không phải là loại được sử dụng để soạn thảo<code>U</code>có thể là một con trỏ đến một lớp dẫn xuất được chỉ ra bởi sự suy luận<code>std::initializer_list&lt;U&gt;</code>Không tham gia vào việc khấu trừ đối số mẫu, mà thay vào đó<code>A</code>struct b {};<code>U</code>từ<code>P</code>Và<code>A</code>// Mẫu danh tính, thường được sử dụng để loại trừ các đối số cụ thể khỏi các khoản khấu trừ<code>U</code>// (có sẵn dưới dạng std :: type_identity kể từ C ++ 20)<code>P</code>Struct D: công khai B &lt;t&gt; {};</p>
<div class="cpp source-cpp"><pre data-language="cpp"> </pre></div> <p>Mẫu &lt;Class T&gt;<a href="auto" title="cpp/language/auto">auto</a>void f (b &lt;t&gt; &amp;) {}</p>
<div class="cpp source-cpp"><pre data-language="cpp"> </pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <h4 id="auto-returning_functions">void f ()</h4> <p>{<a href="functions" title="cpp/language/functions">functions</a>    D &lt;tn&gt; d;<a href="auto" title="cpp/language/auto">auto</a>    f (d); // p = b &lt;t&gt; &amp;, được điều chỉnh thành p = b &lt;t&gt; (a đơn giản-mplate-id), a = d &lt;int&gt;:</p>
<p>          // suy luận t = int, suy luận a = b &lt;int&gt;<code>P</code>          // A có nguồn gốc từ một<code>T</code>}<code>auto</code>Bối cảnh không được cung cấp<code>auto</code>Trong các trường hợp sau, các loại, mẫu và các giá trị không phải là loại được sử dụng để soạn thảo<code>U</code>Không tham gia vào việc khấu trừ đối số mẫu, mà thay vào đó<code>A</code>Các đối số mẫu được suy ra ở nơi khác hoặc được chỉ định rõ ràng. Nếu một tham số mẫu chỉ được sử dụng trong các bối cảnh không được đưa ra và không được chỉ định rõ ràng, thì suy luận đối số mẫu không thành công.<a href="return" title="cpp/language/return">return</a>(Mọi thứ ở bên trái của toán tử phân giải phạm vi<code>A</code>khoảng cách<code>void()</code>) thuộc loại được chỉ định bằng cách sử dụng<code>U</code>từ<code>P</code>Và<code>A</code>// Mẫu danh tính, thường được sử dụng để loại trừ các đối số cụ thể khỏi các khoản khấu trừ<code>U</code>// (có sẵn dưới dạng std :: type_identity kể từ C ++ 20)<code>T</code>Mẫu &lt;Typename T&gt;</p>
<div class="cpp source-cpp"><pre data-language="cpp">Nhận dạng cấu trúc {typedef t loại; };</pre></div> <p> </p>
<p>Mẫu &lt;Typename T&gt;<code>A</code>khoảng cách<code>void()</code>void xấu (std :: vector &lt;t&gt; x, t value = 1);</p>
<p> <code>decltype(auto)</code>Mẫu &lt;Typename T&gt;</p>
</td> <td><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></td>
</tr> </table> <h4 id="Overload_resolution">Độ phân giải quá tải</h4> <p>f (3, std :: tuple (5, 'a'));<a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a> <code>P</code>Và<code>A</code>std :: vector &lt;std :: phức tạp &lt;double &gt;&gt; x;</p>
<div class="cpp source-cpp"><pre data-language="cpp"> </pre></div> <p>xấu (x, 1.2);  // p1 = std :: vector &lt;t&gt;, a1 = std :: vector &lt;std :: phức tạp &lt;double &gt;&gt;<a href="sfinae" title="cpp/language/sfinae">SFINAE</a>.</p>
<h4 id="Address_of_an_overload_set">              // p1/a1: suy luận t = std :: phức tạp &lt;double&gt;</h4> <p>              // p2 = T, A2 = Double<a href="overloaded_address" title="cpp/language/overloaded address">address of an overload set</a>              // p2/a2: suy luận t = double</p>
<p>              // Lỗi: Khấu trừ thất bại, T không rõ ràng<code>P</code>. Các<a href="overloaded_address" title="cpp/language/overloaded address">target type</a>Các biểu thức gán hợp chất có biểu mẫu<code>A</code>:</p>
<div class="cpp source-cpp"><pre data-language="cpp"> </pre></div> <p>void out (const t &amp; value) {std :: cout &lt;&lt; value; }<code>P</code> <code>A</code>ra ("123");     // p = const t &amp;, a = const char [4] lvalue: suy luận t = char [4]<code>P</code>ra (std :: endl); // p = const t &amp;, a = mẫu chức năng: t ở trong bối cảnh không do<code>A</code>, của ai<code>P</code>là một danh sách sáng chế, nhưng</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>void f (ts ... [0], std :: tuple &lt;ts ...&gt;);<code>auto</code>hoặc<code>decltype(auto)</code> </p>
</td> <td><span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span></td>
</tr> </table> <h4 id="Partial_ordering">, Điều này cũng sẽ cho phép kiểm tra bất bình đẳng:</h4> <p>f (3, std :: tuple (5, 'a'));<a href="function_template" title="cpp/language/function template">partial ordering of overloaded function templates</a>.</p>
<h4 id="Conversion_function_template">// p2 = std :: tuple &lt;ts ...&gt;, a2 = std :: tuple &lt;int, char&gt;</h4> <p>// p2/a2: suy luận thành viên đầu tiên của ts ... = int<a href="cast_operator" title="cpp/language/cast operator">user-defined conversion function</a>// p2/a2: suy luận thành viên thứ hai của ts ... = char</p>
<p><code>A</code>// p1 = ts ... [0], a1 = int: ts ... [0] trong bối cảnh không được ghi nhận<code>P</code>Biểu hiện của một<code>P</code>-Specifier:<code>P</code>Mẫu &lt;Typename T&gt;</p>
<p>Nếu như<code>A</code>void f (declType (*std :: declval &lt;t&gt; ()) arg);</p>
<div class="t-li1">
<span class="t-li">}</span>về lỗi.<code>P</code> <code>P</code>Số lượng các yếu tố để sao chép</div> <div class="t-li1">
<span class="t-li">{</span>về lỗi.<code>P</code>int n;<code>P</code>Số lượng các yếu tố để sao chép</div> <div class="t-li1">
<span class="t-li">}</span>nếu như<code>P</code>f &lt;int*&gt; (n); // p = DeclType (*Declval &lt;t&gt; ()), a = int: t là trong bối cảnh không được chứng minh</div> <p>Nếu như<code>A</code>Đối số mẫu không thuộc loại hoặc một mảng bị ràng buộc trong đó biểu hiện phụ tham chiếu tham số mẫu:<code>A</code>Mẫu &lt;std :: size_t n&gt;</p>
<p>void f (std :: mảng &lt;int, 2 * n&gt; a);<code>P</code>Và<code>A</code> </p>
<div class="t-li1">
<span class="t-li">}</span>nếu như<code>A</code>std :: mảng &lt;int, 10&gt; a;<code>A</code>f (a); // p = std :: mảng &lt;int, 2 * n&gt;, a = std :: mảng &lt;int, 10&gt;:<code>A</code>Số lượng các yếu tố để sao chép</div> <div class="t-li1">
<span class="t-li">{</span>nếu như<code>A</code>      // 2 * n là bối cảnh không do đó, n không thể được suy luận<code>A</code>      // Lưu ý: f (std :: mảng &lt;int, n&gt; a) có thể suy luận n<code>A</code>Một tham số mẫu được sử dụng trong loại tham số của tham số chức năng có đối số mặc định đang được sử dụng trong cuộc gọi cho việc khấu trừ đối số đang được thực hiện:<div class="cpp source-cpp"><pre data-language="cpp">Mẫu &lt;typename t, typename f&gt;</pre></div>
</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <span class="t-li">}</span>nếu như<code>A</code>void f (const std :: vector &lt;t&gt; &amp; v, const f &amp; comp = std :: Ít &lt;t&gt; ());<code>A</code> <code>A</code>std :: vector &lt;std :: chuỗi&gt; v (3);<span class="t-li">tải trong luồng B.</span>nếu như<code>A</code>f (v); // p1 = const std :: vector &lt;t&gt; &amp;, a1 = std :: vector &lt;std :: string&gt; lvalue<code>A</code>      // p1/a1 suy luận t = std :: chuỗi<code>A</code>      // p2 = const f &amp;, a2 = std :: Ít &lt;std :: chuỗi&gt; rvalue</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <p>(Raco).<a href="member_template#Conversion_function_templates" title="cpp/language/member template">member template</a>      // P2 là bối cảnh không được ghi nhận cho F (tham số mẫu) được sử dụng trong</p>
<h4 id="Explicit_instantiation">Khởi tạo rõ ràng</h4> <p>      // loại tham số (const f &amp;) của tham số chức năng comp,<a href="function_template#Explicit_instantiation" title="cpp/language/function template">explicit instantiations</a>Thì<a href="template_specialization" title="cpp/language/template specialization">explicit specializations</a>      // có đối số mặc định đang được sử dụng trong cuộc gọi f (v)<a href="friend#Template_friends" title="cpp/language/friend">friend declarations</a>, của ai<code>friend ostream&amp; operator&lt;&lt; &lt;&gt; (...)</code>là một hàm hoặc một tập hợp quá tải sao cho nhiều hơn một hàm khớp</p>
<p><code>P</code>void g1 (std :: vector &lt;t&gt;);<code>A</code>hoặc tập hợp quá tải bao gồm một hoặc nhiều mẫu chức năng:</p>
<div class="cpp source-cpp"><pre data-language="cpp">Mẫu &lt;Typename T&gt;</pre></div> <p>void out (const t &amp; value) {std :: cout &lt;&lt; value; }<code>P</code> <code>A</code>ra ("123");     // p = const t &amp;, a = const char [4] lvalue: suy luận t = char [4]<code>P</code>ra (std :: endl); // p = const t &amp;, a = mẫu chức năng: t ở trong bối cảnh không do<code>A</code>, của ai<code>P</code>là một danh sách sáng chế, nhưng</p>
<h4 id="Deallocation_function_template">, một tham chiếu đến một (có thể là đủ điều kiện CV)</h4> <p>, hoặc một tham chiếu đến một mảng<a href="../memory/new/operator_delete" title="cpp/memory/new/operator delete">deallocation function</a>Mẫu &lt;Class T&gt;<code>operator new</code>.</p>
<p><code>P</code>void g1 (std :: vector &lt;t&gt;);<code>A</code> </p>
<div class="cpp source-cpp"><pre data-language="cpp">Mẫu &lt;Class T&gt;</pre></div> <h3 id="Alias_templates">void g2 (std :: vector &lt;t&gt;, t x);</h3> <p><a href="type_alias" title="cpp/language/type alias">Alias templates</a> <span class="t-rev-inl t-since-cxx20"><span>G1 ({1, 2, 3});     // p = std :: vector &lt;t&gt;, a = {1, 2, 3}: t nằm trong bối cảnh không do<a href="class_template_argument_deduction#Deduction_for_alias_templates" title="cpp/language/class template argument deduction">class template argument deduction</a></span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">                   // Lỗi: T không được chỉ định rõ ràng hoặc suy ra từ một P/A khác</pre></div> <h3 id="Implicit_conversions">    T2 PCC = PPC; // Lỗi: T3 không giống với T2 không đủ điều kiện CV,</h3> <p> <a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a>G2 ({1, 2, 3}, 10); // p1 = std :: vector &lt;t&gt;, a1 = {1, 2, 3}: t ở trong bối cảnh không được chứng minh<code>P</code>                   // p2 = t, a2 = int: suy luận t = int<code>A</code>đó là gói tham số và không xảy ra ở cuối danh sách tham số:<code>P</code>Mẫu &lt;class ... ts, class T&gt;</p>
<p>void f1 (t n, ts ... args);</p>
<div class="cpp source-cpp"><pre data-language="cpp"> </pre></div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/70.html" rel="nofollow">CWG 70</a> </td> <td>C ++ 98</td> <td>Mẫu &lt;class ... ts, class T&gt;</td> <td>void f2 (ts ... args, t n);</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/300.html" rel="nofollow">CWG 300</a> </td> <td>C ++ 98</td> <td> <br/><code>type(*)(T)/T(*)()/T(*)(T)</code>F1 (1, 2, 3, 4); // p1 = t, a1 = 1: suy luận t = int<br/>                // p2 = ts ..., a2 = 2, a3 = 3, a4 = 4: suy luận ts = [int, int, int]</td> <td> <br/><code>type(T)/T()/T(T)</code>F2 (1, 2, 3, 4); // p1 = ts ...: ts là bối cảnh không được ghi nhận<br/>Danh sách tham số mẫu xuất hiện trong tham số</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/322.html" rel="nofollow">CWG 322</a> </td> <td>C ++ 98</td> <td>, và bao gồm một bản mở rộng gói không ở cuối danh sách tham số mẫu:<br/>Mẫu &lt;int ...&gt;</td> <td>struct t {};</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/976.html" rel="nofollow">CWG 976</a> </td> <td>C ++ 98</td> <td> <br/><code>const T&amp;</code>Mẫu &lt;int ... ts1, int n, int ... ts2&gt;<code>T</code>void tốt (const t &lt;n, ts1 ...&gt; &amp; arg1, const t &lt;n, ts2 ...&gt; &amp;);</td> <td> <br/>Mẫu &lt;int ... ts1, int n, int ... ts2&gt;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1387.html" rel="nofollow">CWG 1387</a> </td> <td>C ++ 11</td> <td>void xấu (const t &lt;ts1 ..., n&gt; &amp; arg1, const t &lt;ts2 ..., n&gt; &amp;);</td> <td>Một chức năng được sử dụng ODR trong các trường hợp sau:</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1391.html" rel="nofollow">CWG 1391</a> </td> <td>C ++ 98</td> <td> <br/>T &lt;1, 2&gt; t1;</td> <td>T &lt;1, -1, 0&gt; t2;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/1591.html" rel="nofollow">CWG 1591</a> </td> <td>C ++ 11</td> <td> <i>{</i> </td> <td>Tốt (T1, T2); // p1 = const t &lt;n, ts1 ...&gt; &amp;, a1 = t &lt;1, 2&gt;:</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2052.html" rel="nofollow">CWG 2052</a> </td> <td>C ++ 98</td> <td>              // suy ra n = 1, suy luận ts1 = [2]<br/>              // p2 = const t &lt;n, ts2 ...&gt; &amp;, a2 = t &lt;1, -1, 0&gt;:</td> <td>              // suy ra n = 1, suy luận TS2 = [-1, 0]<br/> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2091.html" rel="nofollow">CWG 2091</a> </td> <td>C ++ 98</td> <td>xấu (t1, t2);  // p1 = const t &lt;ts1 ..., n&gt; &amp;, a1 = t &lt;1, 2&gt;:<br/>              // &lt;ts1 ..., n&gt;</td> <td>              // p2 = const t &lt;ts2 ..., n&gt; &amp;, a2 = t &lt;1, -1, 0&gt;:</td>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/N3922" rel="nofollow">N3922</a> </td> <td>C ++ 11</td> <td>              // &lt;ts2 ..., n&gt;<code>auto</code>thuộc loại mảng (nhưng không tham chiếu đến mảng hoặc con trỏ đến mảng), mảng chính bị ràng buộc:<code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code> </td> <td>Mẫu &lt;int i&gt;<br/>void f1 (int a [10] [i]);<br/> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/2355.html" rel="nofollow">CWG 2355</a> </td> <td>C ++ 17</td> <td>Mẫu &lt;int i&gt;<code>noexcept</code>void f2 (int a [i] [20]);    // p = int [i] [20], loại mảng</td> <td> </td>
</tr>
</table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/language/template_argument_deduction">https://en.cppreference.com/w/cpp/language/template_argument_deduction</a>
</p>
</div>
