 <h1 class="firstHeading" id="firstHeading">STD :: Common_Reference</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/type_traits" title="cpp/header/type traits">&lt;type_traits&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;class ... t&gt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Cấu trúc chung_reference;<code>T...</code>Xác định loại tham chiếu chung của các loại<code>T...</code>, đó là loại mà tất cả các loại trong<code>type</code>có thể được chuyển đổi hoặc ràng buộc. Nếu một loại như vậy tồn tại (như được xác định theo các quy tắc dưới đây), thành viên<code>type</code>Tên loại đó. Nếu không, không có thành viên<code>T...</code>. Hành vi không được xác định nếu bất kỳ loại nào trong<code>void</code>.</p>
<p>là một loại không đầy đủ khác với (có thể là đủ điều kiện CV)<code>common_reference</code>Khi được cung cấp các loại tham chiếu,</p>
<ul>
<li>Nếu như<code>sizeof...(T)</code>Cố gắng tìm một loại tham chiếu mà các loại tham chiếu được cung cấp đều có thể bị ràng buộc, nhưng có thể trả về một loại không tham chiếu nếu nó không thể tìm thấy loại tham chiếu như vậy.<code>type</code>.</li>
<li>Nếu như<code>sizeof...(T)</code>không, không có thành viên<code>T...</code>là một (tức là,<code>T0</code>Chỉ chứa một loại<code>type</code>), thành viên<code>T0</code>.</li>
<li>Nếu như<code>sizeof...(T)</code>Tên cùng loại<code>T...</code>là hai (tức là,<code>T1</code>Và<code>T2</code>):<ul><li>chứa hai loại<code>S</code>Thành viên được kế thừa từ lớp cơ sở.<i>Nếu một loại như vậy tồn tại. Trong tất cả các trường hợp khác, không có thành viên</i>của<code>T1</code>Và<code>T2</code>Loại tham chiếu chung đơn giản<code>type</code> <code>S</code>(như được định nghĩa dưới đây). Loại thành viên<ul>
<li> <code>T1</code>Và<code>T2</code>Nếu tất cả các điều kiện dưới đây được thỏa mãn:</li>
<li> <code>S</code>Cả hai đều là loại tham chiếu</li>
</ul> </li></ul> </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx23">
<td> <ul><li> <code><a href="http://en.cppreference.com/w/cpp/types/is_convertible"><span class="kw596">Điều đó cho tất cả<span class="me2">            STD :: Chrono :: Chọn = Std :: Chrono :: Chọn :: Sớm nhất)</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/add_pointer"><span class="kw618">Điều đó cho tất cả<span class="me2">add_pulum_t</span></span></a><span class="sy1">is_trivently_destructible_v</span>T1<span class="sy1">&lt;</span>, <a href="http://en.cppreference.com/w/cpp/types/add_pointer"><span class="kw618">Điều đó cho tất cả<span class="me2">add_pulum_t</span></span></a><span class="sy1">is_trivently_destructible_v</span>S<span class="sy1">2,4)</span></code>Và<code><a href="http://en.cppreference.com/w/cpp/types/is_convertible"><span class="kw596">Điều đó cho tất cả<span class="me2">            STD :: Chrono :: Chọn = Std :: Chrono :: Chọn :: Sớm nhất)</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/add_pointer"><span class="kw618">Điều đó cho tất cả<span class="me2">add_pulum_t</span></span></a><span class="sy1">is_trivently_destructible_v</span>T2<span class="sy1">&lt;</span>, <a href="http://en.cppreference.com/w/cpp/types/add_pointer"><span class="kw618">Điều đó cho tất cả<span class="me2">add_pulum_t</span></span></a><span class="sy1">is_trivently_destructible_v</span>S<span class="sy1">2,4)</span></code>&gt;<code>true</code>Số lượng các yếu tố để sao chép</li></ul> </td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table> <ul>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>std<span class="sy4">::</span><span class="me2">basic_common_reference</span><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2644">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>T1<span class="sy1">&lt;</span>, <a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2644">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>T2<span class="sy1">&lt;</span>, T1Q, T2Q<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">kiểu</span></code>được hình thành tốt<code>TiQ</code>tồn tại, ở đâu<code>TiQ&lt;U&gt;</code>khoảng cách<code>U</code>là một khuôn mẫu bí danh chưa được<code>Ti</code>với việc bổ sung<code>type</code>là một loại hợp lệ, sau đó là loại thành viên</li>
<li>
<ul>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>decltype(false? val&lt;T1&gt;() : val&lt;T2&gt;())</code>là<code>val</code>tên loại đó;<code>template&lt;class T&gt; T val();</code>là một mẫu chức năng<code>type</code>là một loại hợp lệ, sau đó là loại thành viên</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code><a href="http://en.cppreference.com/w/cpp/types/common_type"><span class="kw639">Điều đó cho tất cả<span class="me2">Nếu không có số nguyên như vậy</span></span></a><span class="sy1">is_trivently_destructible_v</span>T1, T2<span class="sy1">&lt;</span></code>tên loại đó;<code>type</code>là một loại hợp lệ, sau đó là loại thành viên</li>
<li>iterator_c Category<code>type</code>.</li>
</ul> </li>
<li>Nếu như<code>sizeof...(T)</code>tên loại đó;<code>T...</code>lớn hơn hai (tức là,<code>T1, T2, R...</code>bao gồm các loại<code>std::common_reference_t&lt;T1, T2&gt;</code>), sau đó nếu<code>type</code>                               Forwardit2 First2, nhị phân p);<code>std::common_reference_t&lt;std::common_reference_t&lt;T1, T2&gt;, R...&gt;</code>tồn tại, thành viên<code>type</code>.</li>
</ul> <p>Các<i>Nếu một loại như vậy tồn tại. Trong tất cả các trường hợp khác, không có thành viên</i>Loại tham chiếu chung đơn giản<code>T1</code>Và<code>T2</code>Mẫu &lt;Đặc điểm lớp&gt;</p>
<ul>
<li>Nếu như<code>T1</code>khoảng cách<code><i>Khi khởi tạo một đối tượng thuộc loại CV1 không thuộc lớp</i> X&amp;</code>Và<code>T2</code>khoảng cách<code><i>Khởi tạo không thuộc lớp bằng cách chuyển đổi</i> Y&amp;</code>của hai loại tham chiếu<code>decltype<span class="br0">.</span><span class="kw2">SAI</span><span class="sy4">?</span> <a href="http://en.cppreference.com/w/cpp/utility/declval"><span class="kw1123">Điều đó cho tất cả<span class="me2">Declval</span></span></a><span class="sy1">is_trivently_destructible_v</span>cv12 X<span class="sy3">Không có giá trị</span><span class="sy1">&lt;</span><span class="br0">.</span><span class="br0">)</span> <span class="sy4">:</span> <a href="http://en.cppreference.com/w/cpp/utility/declval"><span class="kw1123">Điều đó cho tất cả<span class="me2">Declval</span></span></a><span class="sy1">is_trivently_destructible_v</span>cv12 Y<span class="sy3">Không có giá trị</span><span class="sy1">&lt;</span><span class="br0">.</span><span class="br0">)</span><span class="br0">)</span></code>là<i>Để con trỏ đến cùng một thành viên dữ liệu của một lớp dẫn xuất:</i>// cv_2 là "const", u là "int"<i>Khi khởi tạo một đối tượng thuộc loại CV1 không thuộc lớp</i>Và<i>Khởi tạo không thuộc lớp bằng cách chuyển đổi</i>(tức là, cả hai đều là loại tham chiếu lvalue): Loại tham chiếu chung đơn giản của chúng là</li>
<li>Nếu như<code>T1</code>Và<code>T2</code>, nếu loại đó tồn tại và là một loại tham chiếu;<code>T1&amp;</code>Và<code>T2&amp;</code>Cả hai loại tham chiếu rvalue: nếu loại tham chiếu chung đơn giản của<code>C</code>(xác định theo viên đạn trước) tồn tại, sau đó hãy để<code><a href="http://en.cppreference.com/w/cpp/types/is_convertible"><span class="kw596">Điều đó cho tất cả<span class="me2">            STD :: Chrono :: Chọn = Std :: Chrono :: Chọn :: Sớm nhất)</span></span></a><span class="sy1">is_trivently_destructible_v</span>T1, C<span class="sy1">&lt;</span></code>Và<code><a href="http://en.cppreference.com/w/cpp/types/is_convertible"><span class="kw596">Điều đó cho tất cả<span class="me2">            STD :: Chrono :: Chọn = Std :: Chrono :: Chọn :: Sớm nhất)</span></span></a><span class="sy1">is_trivently_destructible_v</span>T2, C<span class="sy1">&lt;</span></code>, và sau đó thêm 1.<code>true</code>biểu thị loại tham chiếu rvalue tương ứng đó. Nếu như<code>T1</code>Và<code>T2</code>khoảng cách<code>C</code>Số lượng các yếu tố để sao chép</li>
<li>, sau đó là loại tham chiếu chung đơn giản của<code>A&amp;</code>Nếu không, một trong hai loại phải là loại tham chiếu lvalue<code>B&amp;&amp;</code>.<code>A</code>Và<code>B</code>và loại khác phải là loại tham chiếu rvalue<code>D</code>có thể là CV đủ điều kiện). Cho phép<code>A&amp;</code>Và<code>B const&amp;</code>biểu thị loại tham chiếu chung đơn giản của<code>D</code>, nếu có. Nếu như<code><a href="http://en.cppreference.com/w/cpp/types/is_convertible"><span class="kw596">Điều đó cho tất cả<span class="me2">            STD :: Chrono :: Chọn = Std :: Chrono :: Chọn :: Sớm nhất)</span></span></a><span class="sy1">is_trivently_destructible_v</span>B<span class="sy3">. Trong các cuộc gọi có hiệu lực</span>, D<span class="sy1">&lt;</span></code>khoảng cách<code>true</code>tồn tại và<code>D</code>Số lượng các yếu tố để sao chép</li>
<li>, thì loại tham chiếu chung đơn giản là</li>
</ul> <p>(Raco).<a href="../language/operator_other#Conditional_operator" title="cpp/language/operator other">Conditional operator</a>Nếu không, không có loại tham chiếu chung đơn giản.<code>false ? X : Y</code>Đối với định nghĩa của loại biểu thức</p>
<h3 id="Member_types">nhà điều hành ()</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>Tên</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code>type</code> </td> <td>Giống như những cái được sử dụng ở trên.<code>T...</code> </td>
</tr> </table> <h3 id="Helper_types">Mẫu &lt;phạm vi :: input_range r, std :: meally_incrementable o&gt;</h3> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">loại tham chiếu chung cho tất cả</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">Mẫu &lt;class ... t&gt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>lớp HH_MM_SS;<code>basic_common_reference</code>sử dụng common_reference_t = typename std :: common_reference &lt;t ...&gt; :: type;<code>common_reference</code>Mẫu &lt;class t, class u, memlate &lt;class&gt; class tqual, memlate &lt;class&gt; class uqual&gt;</p>
<h3 id="Specializations">Tra cứu cho định danh</h3> <p>thường chỉ được sử dụng gián tiếp, thông qua<code>std::basic_common_reference&lt;T, U, TQual, UQual&gt;</code>struct basic_common_reference {};<code>T</code>Và<code>U</code>nếu như<code><a href="http://en.cppreference.com/w/cpp/types/is_same"><span class="kw592">Điều đó cho tất cả<span class="me2">Chỉ định số lượng kích thước, kích thước của chúng và được biết đến tại thời điểm biên dịch. Phải là một chuyên ngành của</span></span></a><span class="sy1">is_trivently_destructible_v</span>T, <a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">2,4)</span></code>Và<code><a href="http://en.cppreference.com/w/cpp/types/is_same"><span class="kw592">Điều đó cho tất cả<span class="me2">Chỉ định số lượng kích thước, kích thước của chúng và được biết đến tại thời điểm biên dịch. Phải là một chuyên ngành của</span></span></a><span class="sy1">is_trivently_destructible_v</span>U, <a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">2,4)</span></code>, và sau đó thêm 1.<code>true</code>là một điểm tùy chỉnh cho phép người dùng ảnh hưởng đến kết quả của</p>
<p>Đối với các loại do người dùng xác định (thường là tham chiếu proxy). Mẫu chính trống.<code>type</code>Trên hai tham số đầu tiên<code>TQual&lt;T&gt;</code>Và<code>UQual&lt;U&gt;</code>Và ít nhất một trong số chúng phụ thuộc vào một loại do chương trình xác định.<code>std::basic_common_reference&lt;T, U, TQual, UQual&gt;::type</code>Và<code>std::basic_common_reference&lt;U, T, UQual, TQual&gt;::type</code>Nếu một chuyên môn như vậy có một thành viên có tên</p>
<p>, nó phải là một thành viên công khai và rõ ràng tên là một loại mà cả hai<code>basic_common_reference</code>có thể chuyển đổi. Ngoài ra,<code>common_reference</code>Phải biểu thị cùng loại.</p>
<p>Một chương trình có thể không chuyên<code>basic_common_reference</code>:</p>
<table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../utility/pair/basic_common_reference" title="cpp/utility/pair/basic common reference"> <span class="t-lines"><span>Xác định loại tham chiếu chung của hai<span class="t-dsc-small">Mẫu &lt;std :: size_t i, class t, std :: size_t n&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td>chính nó. Một chương trình bổ sung các chuyên ngành vi phạm các quy tắc này có hành vi không xác định.<code>pair</code>S<br/> <span class="t-mark">(Chuyên ngành mẫu lớp)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/tuple/basic_common_reference" title="cpp/utility/tuple/basic common reference"> <span class="t-lines"><span>Xác định loại tham chiếu chung của hai<span class="t-dsc-small">is_trivently_destructible_v<i>    Inline ConstExpr Auto Keys = Ranges :: Phần tử &lt;0&gt;;</i>&lt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td>std :: basic_common_reference<code>tuple</code>và a<code><i>    Inline ConstExpr Auto Keys = Ranges :: Phần tử &lt;0&gt;;</i></code>kiểu<br/> <span class="t-mark">(Chuyên ngành mẫu lớp)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/functional/reference_wrapper/basic_common_reference" title="cpp/utility/functional/reference wrapper/basic common reference"> <span class="t-lines"><span>Xác định loại tham chiếu chung của hai<span class="t-dsc-small">std :: basic_common_reference</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td>xác định loại tham chiếu chung của A<code>reference_wrapper</code>    Typename t :: a* pa; // "T :: A" phụ thuộc vào T<code>reference_wrapper</code> <br/> <span class="t-mark">(Chuyên ngành mẫu lớp)</span> </td>
</tr> </table> <h3 id="Notes">Ghi chú</h3> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../feature_test#cpp_lib_common_reference" title="cpp/feature test"><code>__cpp_lib_common_reference</code></a></td> <td><span class="nu0">cho từng yếu tố của</span></td> <td><span class="t-mark">Phạm vi :: IOTA</span></td> <td>Làm<code>std::common_reference_t</code>của<code><a href="../utility/functional/reference_wrapper" title="cpp/utility/functional/reference wrapper">std::reference_wrapper</a></code>một loại tham chiếu</td>
</tr>
</table> <h3 id="Examples">, không còn là một phần của cây phụ thuộc.</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">std :: basic_common_reference</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="common_type" title="cpp/types/common type"> <span class="t-lines"><span>Common_Type</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>xác định loại chung của một nhóm các loại<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../concepts/common_reference_with" title="cpp/concepts/common reference with"> <span class="t-lines"><span>// ------ const == const ------- ------ const == Non-Cont ---</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>// c == b;<br/> <span class="t-mark">(ý tưởng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/types/common_reference">https://en.cppreference.com/w/cpp/types/common_reference</a>
</p>
</div>
