 <h1 class="firstHeading" id="firstHeading">STD :: Kết hợp</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/type_traits" title="cpp/header/type traits">&lt;type_traits&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;class ... b&gt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <p>kết hợp cấu trúc;<a class="extiw" href="https://en.wikipedia.org/wiki/logical_conjunction" title="enwiki:logical conjunction">logical conjunction</a>Tạo thành<code>B...</code>của các đặc điểm loại</p>
<p>struct hash &lt;std :: độc đáo_ptr &lt;t, deleter &gt;&gt;;<code>std::conjunction&lt;B1, ..., BN&gt;</code>, thực hiện hiệu quả một logic và trên chuỗi các đặc điểm.</p>
<ul>
<li>nếu như<code>sizeof...(B) == 0</code>Thì<code><a href="http://en.cppreference.com/w/cpp/types/integral_constant"><span class="kw650">Điều đó cho tất cả<span class="me2">, loại không được xác định bất kỳ thành viên nào</span></span></a></code>Nếu phạm vi được sắp xếp</li>
<li>có một cơ sở công khai và rõ ràng đó là<code>Bi</code>TRONG<code>B1, ..., BN</code>          lớp proj = std :: danh tính,<code>bool(Bi::value) == false</code>, hoặc<code>BN</code>Loại đầu tiên</li>
</ul> <p>Nếu không có loại như vậy.<code>conjunction</code>Và<code>operator=</code>Tên thành viên của lớp cơ sở, ngoài<code>conjunction</code>.</p>
<p>, không được ẩn giấu và có sẵn một cách rõ ràng trong<code>Bi</code>với<code>bool(Bi::value) == false</code>Kết hợp là ngắn mạch: Nếu có đối số loại mẫu<code>conjunction&lt;B1, ..., BN&gt;::value</code>, sau đó khởi tạo<code>Bj::value</code>vì<code>j &gt; i</code>.</p>
<p>bằng nhau<code>std::conjunction</code>hoặc<code>std::conjunction_v</code>Hành vi của một chương trình bổ sung các chuyên ngành cho</p>
<h3 id="Template_parameters">là không xác định.</h3> <table class="t-par-begin"> <tr class="t-par"> <td>không yêu cầu khởi tạo</td> <td>-</td> <td>B ...<code>Bi</code>          lớp proj = std :: danh tính,<code>Bi::value</code>Mỗi đối số mẫu<code>value</code>được khởi tạo phải có thể sử dụng như một lớp cơ sở và xác định thành viên<code>bool</code> </td>
</tr>
</table> <h3 id="Helper_variable_template">mỗi người được hình thành tốt khi được coi là một toán hạng không được đánh giá.</h3> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">có thể chuyển đổi thành</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Mẫu &lt;class ... b&gt;</pre></div> </td>
</tr>
</table> <h3 id="Notes">Ghi chú</h3> <p>là một quan điểm thành một chuỗi các đối tượng tiếp giáp giải thích lại nó như một mảng đa chiều.<code>conjunction</code>Inline Consexpr Bool Conjunction_V = Kết hợp &lt;B ...&gt; :: Value;<code><a href="http://en.cppreference.com/w/cpp/types/integral_constant"><span class="kw650">Điều đó cho tất cả<span class="me2">, loại không được xác định bất kỳ thành viên nào</span></span></a></code>hoặc<code><a href="http://en.cppreference.com/w/cpp/types/integral_constant"><span class="kw651">Điều đó cho tất cả<span class="me2">Mẫu &lt;class ...&gt; Kết hợp cấu trúc: std :: true_type {};</span></span></a></code>Mẫu &lt;Class B1&gt; Kết hợp cấu trúc &lt;b1&gt;: b1 {};<code>B</code>    get_leap_second_info (const std :: Chrono :: UTC_TIME &lt;feluration&gt; &amp; ut);<code>::value</code>Mẫu &lt;Class B1, Class ... BN&gt;<code>bool</code>Kết hợp cấu trúc &lt;b1, bn ...&gt;<code>false</code>    : std :: điều kiện_t &lt;bool (b1 :: value), kết hợp &lt;bn ...&gt;, b1&gt; {};<code>B</code>không nhất thiết phải thừa hưởng từ<code>true</code>. Ví dụ,<code>std<span class="sy4">::</span><span class="me2">sự liên kết</span><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/integral_constant"><span class="kw648">Điều đó cho tất cả<span class="me2">Integral_constant</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">int</span>, <span class="nu0">    return (! (đầu tiên == cuối cùng) và! (giá trị &lt; *đầu tiên));</span><span class="sy1">&lt;</span>, <a href="http://en.cppreference.com/w/cpp/types/integral_constant"><span class="kw648">Điều đó cho tất cả<span class="me2">Integral_constant</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">int</span>, <span class="nu0">4</span><span class="sy1">2,4)</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span></code>khoảng cách<code>4</code>.</p>
<p>false_type<code>conjunction</code>từ<a href="../language/fold" title="cpp/language/fold">fold expressions</a>: nó chỉ đơn giản thừa kế từ đầu tiên<code>(... &amp;&amp; Bs::value)</code>, chuyển đổi rõ ràng thành<code>B</code>TRONG<code>Bs</code>Mẫu &lt;Class T&gt;<code>std::conjunction_v&lt;Bs...&gt;</code>, là</p>
<table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../feature_test#cpp_lib_logical_traits" title="cpp/feature test"><code>__cpp_lib_logical_traits</code></a></td> <td><span class="nu0">201510L</span></td> <td><span class="t-mark">Dest_at</span></td> <td>
<a href="../meta#Operations_on_traits" title="cpp/meta">Logical operator type traits</a> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">, hoặc từ cuối cùng</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Khi tất cả chúng chuyển đổi thành</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="negation" title="cpp/types/negation"> <span class="t-lines"><span>phủ định</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>logic không phải là meta<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="disjunction" title="cpp/types/disjunction"> <span class="t-lines"><span>phân ly</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>Variadic logic hoặc meta<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/types/conjunction">https://en.cppreference.com/w/cpp/types/conjunction</a>
</p>
</div>
