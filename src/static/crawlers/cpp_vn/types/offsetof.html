 <h1 class="firstHeading" id="firstHeading">offsetof</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/cstddef" title="cpp/header/cstddef">&lt;cstddef&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">#Define offsetOf (loại, thành viên) / * Xác định triển khai * /</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Vĩ mô<code>offsetof</code>Mở rộng sang một biểu thức không đổi không thể thiếu của loại<code><a href="size_t" title="cpp/types/size t">std::size_t</a></code>, giá trị của nó là phần bù, tính<a href="../language/object#Object_representation_and_value_representation" title="cpp/language/object">padding bits</a>Nếu có.</p>
<p>    sử dụng argen_type = std :: ptrdiff_t;<code>o</code>nó đến một đối tượng<code>type</code>và thời lượng lưu trữ tĩnh,<code>o.member</code>sẽ là một biểu thức hằng số lvalue đề cập đến một tiểu mục của<code>o</code>. Nếu không, hành vi là không xác định. Đặc biệt, nếu<code>member</code>Điều đó như vậy<a href="../language/static" title="cpp/language/static">static data member</a>có thể đại diện cho các phân số của ve.<a href="../language/bit_field" title="cpp/language/bit field">bit-field</a>được đặt ở chế độ mở của gói<a href="../language/member_functions" title="cpp/language/member functions">member function</a>Hoạt động tương đương cho quá tải</p>
<p>Nếu như<code>type</code>Cụ thể,<span class="t-rev-inl t-until-cxx11"><span><a href="../named_req/podtype" title="cpp/named req/PODType">PODType</a></span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span><a href="../language/data_members#Standard-layout" title="cpp/language/data members">standard-layout</a>kiểu</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Thì<span class="t-rev-inl t-until-cxx17"><span>(Nói cách khác, việc thêm một khai báo chức năng mới sau khi định nghĩa mẫu không hiển thị nó, ngoại trừ thông qua ADL).<code>offsetof</code>của các biểu thức Lambda không được thực hiện</span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span><span class="t-rev-inl t-since-cxx17"><span>Sử dụng<code>offsetof</code>Macro được hỗ trợ có điều kiện</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>.</p>
<p>              Không có p);<code>offsetof(type, member)</code>, chỉ các biểu diễn từ vựng được so sánh. Vì thế,<a href="../language/dependent_name#Dependent_types" title="cpp/language/dependent name">type-dependent</a>và nó phụ thuộc vào giá trị khi và chỉ khi<code>type</code>là phụ thuộc.</p>
<h3 id="Exceptions">Ngoại lệ</h3> <p><code>offsetof</code>Ném không có ngoại lệ.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>              Không có p);<code>noexcept(offsetof(type, member))</code>Luôn luôn đánh giá<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <h3 id="Notes">Ghi chú</h3> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>Phần bù của thành viên đầu tiên của loại Layout tiêu chuẩn luôn bằng không (<a href="../language/ebo" title="cpp/language/ebo">empty-base optimization</a>là bắt buộc).</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <p><code>offsetof</code>Không thể được thực hiện trong C ++ tiêu chuẩn và yêu cầu hỗ trợ trình biên dịch:<a class="external text" href="https://github.com/gcc-mirror/gcc/blob/68ec60c4a377b532ec2d265ea542107c36b1d15c/gcc/ginclude/stddef.h#L406" rel="nofollow">GCC</a>Thì<a class="external text" href="https://github.com/llvm-mirror/clang/blob/release_70/lib/Headers/stddef.h#L120" rel="nofollow">LLVM</a>.</p>
<p><code>member</code>không bị giới hạn trong một thành viên trực tiếp. Nó có thể biểu thị một tiểu mục của một thành viên nhất định, chẳng hạn như một yếu tố của một thành viên mảng. Điều này được chỉ định bởi<a class="external text" href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2396.htm#dr_496" rel="nofollow">C DR 496</a>.</p>
<p>Nó được chỉ định trong C23 rằng việc xác định một loại mới liên kết một dấu phẩy chưa được biết đến trong<code>offsetof</code>là hành vi không xác định và việc sử dụng như vậy thường không được hỗ trợ bởi các triển khai trong các chế độ C ++:<code>offsetof(struct Foo { int a, b; }, a)</code>bị từ chối bởi tất cả các triển khai đã biết.</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;CstDdef&gt;</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">#include &lt;Istream&gt;</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/CWG/issues/273.html" rel="nofollow">CWG 273</a> </td> <td>C ++ 98</td> <td>
<code>offsetof</code> <code>operator&amp;</code>phá hủy một ví dụ về phân bổ</td> <td>cấu trúc s<br/>nếu như<code>operator&amp;</code>phá hủy một ví dụ về phân bổ</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue306" rel="nofollow">LWG 306</a> </td> <td>C ++ 98</td> <td>{<code>type</code>Cụ thể,<a href="../named_req/podtype" title="cpp/named req/PODType">PODType</a> </td> <td>    char m0;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue449" rel="nofollow">LWG 449</a> </td> <td>C ++ 98</td> <td>    gấp đôi M1;<code>offsetof</code>    // Số:<br/>    M2 ngắn;<a class="external text" href="https://cplusplus.github.io/LWG/issue306" rel="nofollow">LWG issue 306</a> </td> <td>    char m3;</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="size_t" title="cpp/types/size t"> <span class="t-lines"><span>size_t</span></span></a></div> </td> <td>loại số nguyên không dấu được trả về bởi<a href="../language/sizeof" title="cpp/language/sizeof"><code>sizeof</code></a>nhà điều hành<br/> <span class="t-mark">(typedef)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="is_standard_layout" title="cpp/types/is standard layout"> <span class="t-lines"><span>is_standard_layout</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>kiểm tra xem một loại là<a href="../language/data_members#Standard-layout" title="cpp/language/data members">standard-layout</a>kiểu<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/types/offsetof" title="c/types/offsetof">C documentation</a></span>vì<code>offsetof</code> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/types/offsetof">https://en.cppreference.com/w/cpp/types/offsetof</a>
</p>
</div>
