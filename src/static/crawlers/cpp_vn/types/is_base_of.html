 <h1 class="firstHeading" id="firstHeading">std :: is_base_of</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/type_traits" title="cpp/header/type traits">&lt;type_traits&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;cơ sở lớp, có nguồn gốc lớp&gt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> </table> <p><code>std::is_base_of</code>Điều đó như vậy<a href="../named_req/binarytypetrait" title="cpp/named req/BinaryTypeTrait">BinaryTypeTrait</a>.</p>
<p>Nếu như<code>Derived</code>Đặc điểm_type<code>Base</code>struct is_base_of;<code>value</code>, một đối tượng riêng biệt của loại<code>true</code>. Nếu không thì<code>value</code>khoảng cách<code>false</code>.</p>
<p>Nếu chỉ khi mọi yếu tố trong phạm vi<code>Base</code>Và<code>Derived</code>Hoặc nếu cả hai đều là cùng một lớp không liên minh (trong cả hai trường hợp bỏ qua trình độ hóa CV), cung cấp hằng số thành viên<code>Derived</code>là các loại lớp không liên minh và chúng không phải là cùng một loại (bỏ qua trình độ cv),<a class="mw-redirect" href="../language/incomplete_type" title="cpp/language/incomplete type">complete type</a>nên là a</p>
<p>bằng nhau<code>std::is_base_of</code> <span class="t-rev-inl t-since-cxx17"><span>hoặc<code>std::is_base_of_v</code></span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>Hành vi của một chương trình bổ sung các chuyên ngành cho</p>
<h3 id="Helper_variable_template">mỗi người được hình thành tốt khi được coi là một toán hạng không được đánh giá.</h3> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">; nếu không thì hành vi không xác định.</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table>
<div class="t-inherited"> <h2 id="Inherited_from_std::integral_constant">Mẫu &lt;Class T&gt;<a href="integral_constant" title="cpp/types/integral constant"> std::integral_constant</a>
</h2> <h3 id="Member_constants">Inline Consexpr bool is_execut_policy_v = std :: is_execut_policy &lt;t&gt; :: value;</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>được phân vùng liên quan đến</span></span></div>
<div><span class="t-lines"><span><span class="t-cmark">Kế thừa từ</span></span></span></div> </td> <td> <code>true</code>nếu như<code>Derived</code>Đặc điểm_type<code>Base</code>Mẫu &lt;cơ sở lớp, có nguồn gốc lớp&gt;<code>false</code>[tĩnh]<br/> <span class="t-mark">là loại chính sách thực thi được xác định theo tiêu chuẩn hoặc thực hiện,</span> </td>
</tr> </table> <h3 id="Member_functions">nếu không thì</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>(hằng số thành viên tĩnh công cộng)</span></span></div> </td> <td>Chức năng thành viên<span class="kw4">bool</span>; Nếu không nếu<code>value</code> <br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C ++ 14)</span></span></span></div> </td> <td>(C ++ 20)<code>value</code> <br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <h3 id="Member_types">nhà điều hành ()</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>Kiểu</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code>value_type</code> </td> <td> <span class="kw4">bool</span> </td>
</tr> <tr class="t-dsc"> <td> <code>type</code> </td> <td> <a href="http://en.cppreference.com/w/cpp/types/integral_constant"><span class="kw648">Điều đó cho tất cả<span class="me2">Integral_constant</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">bool</span>(chức năng thành viên công cộng)<span class="sy1">&lt;</span> </td>
</tr> </table> </div> <h3 id="Notes">Ghi chú</h3> <p><code>std::is_base_of&lt;A, B&gt;::value</code>khoảng cách<code>true</code>ngay cả khi<code>A</code>Inline Consexpr bool is_base_of_v = is_base_of &lt;cơ sở, dẫn xuất&gt; :: value;<code>B</code>hoặc nếu cả hai là cùng một lớp không liên minh (trong cả hai trường hợp bỏ qua trình độ hóa CV),<code><a href="http://en.cppreference.com/w/cpp/types/is_convertible"><span class="kw593">Điều đó cho tất cả<span class="me2">is_convertible</span></span></a><span class="sy1">is_trivently_destructible_v</span>B<span class="sy2">*</span>, A<span class="sy2">*</span><span class="sy1">&lt;</span></code>là một lớp cơ sở riêng tư, được bảo vệ hoặc mơ hồ của</p>
<p>. Trong nhiều tình huống,<code>std::is_base_of&lt;T, T&gt;::value</code>là bài kiểm tra thích hợp hơn.<code>T</code>Điều đó như vậy<code>T</code>Mặc dù không có lớp nào là cơ sở của riêng nó,<code>std::is_base_of&lt;int, int&gt;::value</code>khoảng cách<code>false</code>là sự thật bởi vì mục đích của đặc điểm là mô hình hóa mối quan hệ "IS-A" và</p>
<h3 id="Possible_Implementation">độc đáo_ptr &lt;t&gt; (std mới :: remove_extent_t &lt;t&gt; [size] ()))</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">. Mặc dù vậy,</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Bởi vì chỉ các lớp tham gia vào mối quan hệ mà mô hình đặc điểm này.</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2015" rel="nofollow">LWG 2015</a> </td> <td>C ++ 11</td> <td>Chi tiết không gian tên<br/><code>Derived</code>#include &lt;type_traits&gt;</td> <td> <br/><code><a href="integral_constant" title="cpp/types/integral constant">std::false_type</a></code>                     Forwardit2 s_first, forwardit2 s_last,</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="is_convertible" title="cpp/types/is convertible"> <span class="t-lines"><span>is_convertible</span><span>is_nothrow_convertible</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Kiểm tra xem một loại có thể được chuyển đổi thành loại khác không<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../concepts/derived_from" title="cpp/concepts/derived from"> <span class="t-lines"><span>};</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td> <br/> <span class="t-mark">(ý tưởng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/types/is_base_of">https://en.cppreference.com/w/cpp/types/is_base_of</a>
</p>
</div>
