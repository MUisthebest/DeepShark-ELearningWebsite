 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: iter_move</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/iterator" title="cpp/header/iterator">&lt;iterator&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">không gian tên nội tuyến / * không xác định * / {</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark">(Đối tượng điểm tùy chỉnh)</span> </td> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">    Inline Consexpr / * không xác định * /iter_move = / * không xác định * /;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>}</p>
<p>MỘT<code>ranges::iter_move(t)</code>khoảng cách<a href="../../language/expressions#Expression-equivalence" title="cpp/language/expressions">expression-equivalent</a>Mẫu &lt;Class T&gt;</p>
<ol>
<li> <code>iter_move(t)</code>Sử dụng chức năng nhị phân đã cho<code>t</code>    yêu cầu / * xem bên dưới * /<a href="../../language/expressions#Potentially-evaluated_expressions" title="cpp/language/expressions">unevaluated operand</a>constexpr DeclType (auto) iter_move (t &amp;&amp; t) noExcept (/ * xem bên dưới */);<a href="../../language/overload_resolution" title="cpp/language/overload resolution">overload resolution</a>của<code>iter_move</code>Có được một tham chiếu rvalue hoặc tạm thời prvalue từ một trình lặp nhất định.<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>Là xấu nếu<code>std::move(*t)</code>nếu như<code>*t</code>ĐẾN:</li>
<li>Là xấu nếu<code>*t</code>nếu như<code>*t</code>có một loại hoặc loại liệt kê và biểu thức được hình thành tốt khi được coi là</li>
</ol> <p>, nơi<code>ranges::iter_move</code>chỉ được thực hiện với các ứng cử viên được tìm thấy bởi<a href="../../language/sfinae" title="cpp/language/sfinae">substitution failure</a>Chuyển đổi danh tính:<code>ranges::iter_move(e)</code>được hình thành tốt và là một lvalue.</p>
<p>Nếu như<code>ranges::iter_move(e)</code>không bằng<code>*e</code>được hình thành tốt và là một rvalue.</p>
<h3 id="Customization_point_objects">Nhìn thấy</h3> <p>Tên<code>ranges::iter_move</code>biểu thị a<i>Trong tất cả các trường hợp khác, một cuộc gọi đến</i>là xấu, có thể dẫn đến<a href="../../named_req/functionobject" title="cpp/named req/FunctionObject">function object</a>xuất hiện trong bối cảnh ngay lập tức của một khởi tạo mẫu.<a href="../../named_req/literaltype" title="cpp/named req/LiteralType">literal</a> <a href="../../concepts/semiregular" title="cpp/concepts/semiregular"><code>semiregular</code></a>, chương trình là không có hình thành, không cần chẩn đoán.<code><i>đáp ứng các yêu cầu cho các đối số để</i></code>.</p>
<p>, đó là một const<code><i>đáp ứng các yêu cầu cho các đối số để</i></code>Loại lớp. Đối với mục đích giải thích, phiên bản CV-UNQUENEDED của loại được ký hiệu là<code><i>đáp ứng các yêu cầu cho các đối số để</i></code>Tất cả các trường hợp của<code>ranges::iter_move</code>__iter_move_fn</p>
<p>bằng nhau. Những ảnh hưởng của việc gọi các trường hợp khác nhau của loại<code>Args...</code>Sử dụng chức năng nhị phân đã cho<code><a href="http://en.cppreference.com/w/cpp/utility/declval"><span class="kw1123">Điều đó cho tất cả<span class="me2">Declval</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span><span class="br0">)</span>...</code>__iter_move_fn<code>ranges::iter_move</code>Trên cùng một đối số là tương đương, bất kể biểu thức biểu thị thể hiện là một lvalue hay rvalue, và có đủ điều kiện hay không (tuy nhiên, một trường hợp đủ điều kiện dễ bay hơi không bắt buộc phải được cấp). Như vậy,<code><i>đáp ứng các yêu cầu cho các đối số để</i></code>Range constexpr :: mượn_subrange_t &lt;r&gt;<br/></p>
<ul>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2958">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span>__iter_move_fn, Args...<span class="sy1">&lt;</span></code>Thì</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2958">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> __iter_move_fn, Args...<span class="sy1">&lt;</span></code>Thì</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2958">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span>__iter_move_fn<span class="sy3">Không có giá trị</span>, Args...<span class="sy1">&lt;</span></code>, Và</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2958">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> __iter_move_fn<span class="sy3">Không có giá trị</span>, Args...<span class="sy1">&lt;</span></code>.<br/> </li>
</ul> <p>Đưa ra một tập hợp các loại<code><i>đáp ứng các yêu cầu cho các đối số để</i></code>(Một hoạt động đọc sửa đổi-viết). Bộ nhớ bị ảnh hưởng theo giá trị của</p>
<h3 id="Example">Ví dụ</h3> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../reverse_iterator/iter_move" title="cpp/iterator/reverse iterator/iter move"> <span class="t-lines"><span>iter_move</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>trả về một bản sao<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../move_iterator/iter_move" title="cpp/iterator/move iterator/iter move"> <span class="t-lines"><span>iter_move</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Chuyển đổi thành bất kỳ trình lặp liên tục nào mà một trình lặp cơ bản có thể được chuyển đổi<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/iterator/ranges/iter_move">https://en.cppreference.com/w/cpp/iterator/ranges/iter_move</a>
</p>
</div>
