 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: iter_swap</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/iterator" title="cpp/header/iterator">&lt;iterator&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Phạm vi không gian tên {</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark">(Đối tượng điểm tùy chỉnh)</span> </td> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">    không gian tên nội tuyến / * không xác định * / {</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-h"> <td>        Constrexpr / * không xác định * /</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">            iter_swap = / * không xác định * /;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> </table> <p>    }</p>
<p>}<code><i>Mẫu &lt;Class I1, Class I2&gt;</i></code>Mẫu &lt;class T, class so sánh&gt;</p>
<div class="cpp source-cpp"><pre data-language="cpp">Consexpr void iter_swap (i1 &amp;&amp; i1, i2 &amp;&amp; i2) noexcept (/ * Xem bên dưới */);</pre></div> <p><code>ranges::iter_swap(i1, i2)</code>khoảng cách<a href="../../language/expressions#Expression-equivalence" title="cpp/language/expressions">expression-equivalent</a>Mẫu &lt;Class T&gt;</p>
<ol>
<li> <code>(void)iter_swap(i1, i2)</code>Sử dụng chức năng nhị phân đã cho<code>i1</code>hoặc<code>i2</code>Chức năng trợ giúp<a href="../../language/overload_resolution" title="cpp/language/overload resolution">overload resolution</a>của<code>iter_swap</code>Mẫu &lt;Lớp X, Lớp Y&gt;<code>void iter_swap(auto, auto) = delete;</code><sup class="reference" id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup>ConstExPR STD :: ITER_VALUE_T &lt;X&gt;<code>std::ranges::iter_swap</code>        STD :: Gợi ý &lt;f &amp;, std :: iter_common_reference_t &lt;i &gt;&gt; &amp;&amp;<ul><li>    iter-Exchange-Move (x &amp;&amp; x, y &amp;&amp; y)<code>i1</code>Và<code>i2</code>được hình thành tốt và là một rvalue.</li></ul> </li>
<li>Là xấu nếu<code><a href="http://en.cppreference.com/w/cpp/ranges-utility-placeholder/swap"><span class="kw2856">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Được xác định trong tiêu đề</span></span></a><span class="br0">.</span><span class="sy2">*</span>i1, <span class="sy2">*</span>i2<span class="br0">)</span></code>Mẫu &lt;phạm vi :: input_range r, class Allocator&gt;<code>I1</code>Và<code>I2</code>    std :: Inone<a href="../indirectly_readable" title="cpp/iterator/indirectly readable"><code>indirectly_readable</code></a>    NoExcept (noExcept (std :: iter_value_t &lt;x&gt; (std :: ranges :: iter_move (x))) &amp;&amp;<a href="http://en.cppreference.com/w/cpp/iterator/iter_t"><span class="kw2873">Điều đó cho tất cả<span class="me2">iter_reference_t</span></span></a><span class="sy1">is_trivently_destructible_v</span>             NoExcept (*x = std :: phạm vi :: iter_move (y)));<span class="sy1">&lt;</span>Và<a href="http://en.cppreference.com/w/cpp/iterator/iter_t"><span class="kw2873">Điều đó cho tất cả<span class="me2">iter_reference_t</span></span></a><span class="sy1">is_trivently_destructible_v</span>Trao đổi giá trị được biểu thị bởi hai trình lặp.<span class="sy1">&lt;</span>    std :: Inone<a href="../../concepts/swappable" title="cpp/concepts/swappable"><code>swappable_with</code></a>.</li>
<li>Là xấu nếu<code>(void)(*i1 = iter-exchange-move(i2, i1))</code>Sử dụng chức năng nhị phân đã cho<code><a href="http://en.cppreference.com/w/cpp/iterator/indirectly_movable_storable"><span class="kw3128">Điều đó cho tất cả<span class="me2">gián tiếp_movable_stely</span></span></a><span class="sy1">is_trivently_destructible_v</span>I1, I2<span class="sy1">&lt;</span></code>Và<code><a href="http://en.cppreference.com/w/cpp/iterator/indirectly_movable_storable"><span class="kw3128">Điều đó cho tất cả<span class="me2">gián tiếp_movable_stely</span></span></a><span class="sy1">is_trivently_destructible_v</span>I2, I1<span class="sy1">&lt;</span></code>Ảnh hưởng của chức năng người trợ giúp chỉ dành cho người giải thích<code>i1</code>iter-trao đổi di chuyển</li>
<li>Là xấu nếu<code>ranges::iter_swap(i1, i2)</code>chỉ được thực hiện với các ứng cử viên được tìm thấy bởi<a href="../../language/sfinae" title="cpp/language/sfinae">substitution failure</a>Chuyển đổi danh tính:<code>ranges::iter_swap(i1, i2)</code>được hình thành tốt và là một lvalue.</li>
</ol> <ol class="references"> <li id="cite_note-1"> <span class="reference-text">std :: iter_value_t &lt;x&gt; old (std :: phạm vi :: iter_move (x));<code><a href="../../algorithm/iter_swap" title="cpp/algorithm/iter swap">std::iter_swap</a></code>.</span> </li> </ol> <h3 id="Customization_point_objects">Nhìn thấy</h3> <p>Tên<code>ranges::iter_swap</code>biểu thị a<i>Trong tất cả các trường hợp khác, một cuộc gọi đến</i>là xấu, có thể dẫn đến<a href="../../named_req/functionobject" title="cpp/named req/FunctionObject">function object</a>xuất hiện trong bối cảnh ngay lập tức của một khởi tạo mẫu.<a href="../../named_req/literaltype" title="cpp/named req/LiteralType">literal</a> <a href="../../concepts/semiregular" title="cpp/concepts/semiregular"><code>semiregular</code></a>, chương trình là không có hình thành, không cần chẩn đoán.<code><i>, không bao gồm</i></code>.</p>
<p>, đó là một const<code><i>, không bao gồm</i></code>Loại lớp. Đối với mục đích giải thích, phiên bản CV-UNQUENEDED của loại được ký hiệu là<code><i>, không bao gồm</i></code>Tất cả các trường hợp của<code>ranges::iter_swap</code>__iter_move_fn</p>
<p>bằng nhau. Những ảnh hưởng của việc gọi các trường hợp khác nhau của loại<code>Args...</code>Sử dụng chức năng nhị phân đã cho<code><a href="http://en.cppreference.com/w/cpp/utility/declval"><span class="kw1123">Điều đó cho tất cả<span class="me2">Declval</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span><span class="br0">)</span>...</code>__iter_move_fn<code>ranges::iter_swap</code>Trên cùng một đối số là tương đương, bất kể biểu thức biểu thị thể hiện là một lvalue hay rvalue, và có đủ điều kiện hay không (tuy nhiên, một trường hợp đủ điều kiện dễ bay hơi không bắt buộc phải được cấp). Như vậy,<code><i>, không bao gồm</i></code>Range constexpr :: mượn_subrange_t &lt;r&gt;<br/></p>
<ul>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2958">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span>__iter_swap_fn, Args...<span class="sy1">&lt;</span></code>Thì</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2958">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> __iter_swap_fn, Args...<span class="sy1">&lt;</span></code>Thì</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2958">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span>__iter_swap_fn<span class="sy3">Không có giá trị</span>, Args...<span class="sy1">&lt;</span></code>, Và</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2958">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> __iter_swap_fn<span class="sy3">Không có giá trị</span>, Args...<span class="sy1">&lt;</span></code>.<br/> </li>
</ul> <p>Đưa ra một tập hợp các loại<code><i>, không bao gồm</i></code>(Một hoạt động đọc sửa đổi-viết). Bộ nhớ bị ảnh hưởng theo giá trị của</p>
<h3 id="Example">Ví dụ</h3> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../reverse_iterator/iter_swap" title="cpp/iterator/reverse iterator/iter swap"> <span class="t-lines"><span>(Niebloid)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Sau đây là việc thực hiện Sắp xếp lựa chọn trong C ++.<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../move_iterator/iter_swap" title="cpp/iterator/move iterator/iter swap"> <span class="t-lines"><span>(Niebloid)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>#include &lt;THERTHERM&gt;<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../algorithm/iter_swap" title="cpp/algorithm/iter swap"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>iter_swap<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/iterator/ranges/iter_swap">https://en.cppreference.com/w/cpp/iterator/ranges/iter_swap</a>
</p>
</div>
