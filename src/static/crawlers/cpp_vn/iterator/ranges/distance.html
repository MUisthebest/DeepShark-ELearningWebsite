 <h1 class="firstHeading" id="firstHeading">STD :: Phạm vi :: Khoảng cách</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/iterator" title="cpp/header/iterator">&lt;iterator&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Class I, std :: sentinel_for &lt;i&gt; s&gt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">    Yêu cầu (! STD :: Sized_sentinel_for &lt;s, i&gt;)</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Consexpr std :: iter_difference_t &lt;i&gt;</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">Đầu vào</span>Typename std :: iterator_traits &lt;futputit&gt; :: arget_type <code>first</code>ĐẾN<code>last</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>    khoảng cách (tôi đầu tiên, s cuối cùng);<code>r</code>Mẫu &lt;class I, std :: sized_sentinel_for &lt;std :: decay_t &lt;i &gt;&gt; s&gt;</div> <p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>đến phạm vi bắt đầu tại</td> <td>-</td> <td>, hành vi không xác định nếu</td>
</tr> <tr class="t-par"> <td>cuối cùng</td> <td>-</td> <td>phải cùng loại<code>first</code>được cung cấp, nếu không hành vi là không xác định.</td>
</tr> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>Consexpr std :: iter_difference_t &lt;std :: decay_t &lt;i &gt;&gt;</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">1)</span>Trình lặp chỉ vào cuối phạm vi<code>first</code>ĐẾN<code>last</code>.</div> <div class="t-li1">
<span class="t-li">2)</span> <code>last <span class="sy2">-</span> <span class="kw1">Mẫu &lt;Biểu đồ lớp, Đặc điểm lớp, Alloc Class, Class Parsable&gt;</span><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> <a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>I<span class="sy1">&lt;</span><span class="sy3">Không có giá trị</span><span class="sy1">&lt;</span><span class="br0">.</span>first<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Nếu như<code>R</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<code><a href="http://en.cppreference.com/w/cpp/ranges/sized_range"><span class="kw2900">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Mẫu &lt;phạm vi :: phạm vi r&gt;</span></span></a></code>; Nếu không nếu<code><a href="http://en.cppreference.com/w/cpp/ranges/size"><span class="kw3100">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kích cỡ</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>Nếu phạm vi được sắp xếp<code>ranges<span class="sy4">::</span><span class="me2">STD ::</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span><span class="br0">)</span></code>.</div> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <div class="t-li1">
<span class="t-li">1)</span>    if (pre (*đầu tiên))</div> <div class="t-li1">
<span class="t-li">2)</span>trình rút vào các yếu tố để hoán đổi</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Nếu như<code>R</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<code><a href="http://en.cppreference.com/w/cpp/ranges/sized_range"><span class="kw2900">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Mẫu &lt;phạm vi :: phạm vi r&gt;</span></span></a></code>(Cho đến C ++ 14)<code><a href="http://en.cppreference.com/w/cpp/iterator/sized_sentinel_for"><span class="kw2863">Điều đó cho tất cả<span class="me2">Kích thước_sentinel_for</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2891">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Range constexpr :: Range_Difference_T &lt;R&gt;</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">&lt;</span>, <a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2890">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    khoảng cách (r &amp;&amp; r);</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">2,4)</span></code>Trả về kích thước của</div> <h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">như một số nguyên có chữ ký.</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">phạm vi để tính khoảng cách của</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3392" rel="nofollow">LWG 3392</a> </td> <td>C ++ 20</td> <td>đã được sắp xếp bởi<span class="t-v">(1)</span>Kích thước_range<br/>Kích thước_range</td> <td> <span class="t-v">(2)</span> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3664" rel="nofollow">LWG 3664</a> </td> <td>C ++ 20</td> <td>Tìm kiếm chuyển tiếp của Const<a class="external text" href="https://cplusplus.github.io/LWG/issue3392" rel="nofollow">LWG issue 3392</a>làm ra<br/><code>ranges::distance</code>Sentinel_t</td> <td>iterator_t</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="advance" title="cpp/iterator/ranges/advance"> <span class="t-lines"><span>Phạm vi :: Nâng cao</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>tiến lên một trình lặp bằng khoảng cách đã cho hoặc đến một ràng buộc nhất định<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../algorithm/ranges/count" title="cpp/algorithm/ranges/count"> <span class="t-lines"><span>(Mẫu chức năng)</span><span>Phạm vi :: đếm</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../distance" title="cpp/iterator/distance"> <span class="t-lines"><span>STD ::</span></span></a></div> </td> <td>Trả về khoảng cách giữa hai trình lặp<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/iterator/ranges/distance">https://en.cppreference.com/w/cpp/iterator/ranges/distance</a>
</p>
</div>
