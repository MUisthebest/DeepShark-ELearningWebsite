 <h1 class="firstHeading" id="firstHeading">std :: cỡ_sentinel_for, std :: vô hiệu hóa_sized_sentinel_for</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/iterator" title="cpp/header/iterator">&lt;iterator&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Lớp S, Lớp I&gt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">    Khái niệm có kích thước_sentinel_for =</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Các<code>sized_sentinel_for</code>        std :: sentinel_for &lt;s, i&gt; &amp;&amp;<code>I</code>        ! std :: vô hiệu<code>S</code>        Yêu cầu (Const I &amp; I, Const S &amp; S) {</div> <div class="t-li1">
<span class="t-li">2)</span>Các<code>disable_sized_sentinel_for</code>            {s - i} -&gt; std :: more_as &lt;std :: iter_difference_t &lt;i &gt;&gt;;<code>sized_sentinel_for</code>            {i - s} -&gt; std :: more_as &lt;std :: iter_difference_t &lt;i &gt;&gt;;<br/>        };<code>S</code>Và<code>I</code>Mẫu &lt;Lớp S, Lớp I&gt;<a href="../language/constant_expression" title="cpp/language/constant expression">constant expressions</a>    Inline Consexpr bool vô hiệu hóa_sized_sentinel_for = false;<code>const bool</code>.</div> <h3 id="Semantic_requirements">        const std :: remove_reference_t &lt;lhs&gt; &amp;,</h3> <p>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;<code>i</code>Khái niệm chỉ định rằng một đối tượng của loại lặp<code>I</code>, Và<code>s</code>và một đối tượng của loại sentinel<code>S</code>chỉ vào trình tự và mọi số nguyên không âm<code>[i, s)</code>có thể được trừ để tính khoảng cách giữa chúng trong thời gian không đổi.<code>n</code>Mẫu biến có thể được sử dụng để ngăn chặn các trình lặp và sentinels có thể bị trừ nhưng không thực sự mô hình<code>++i</code>từ việc thỏa mãn khái niệm.<code>bool(i == s)</code>{<code>true</code>.<code>I</code>Và<code>S</code>    std :: Inone<code>sized_sentinel_for&lt;S, I&gt;</code>Mẫu biến được phép chuyên dụng cho loại đối tượng không tự động được cv</p>
<ul>
<li>Nếu như<code>n</code>là một trình lặp thuộc loại<code><a href="http://en.cppreference.com/w/cpp/iterator/iter_t"><span class="kw2874">Điều đó cho tất cả<span class="me2">iter_difference_t</span></span></a><span class="sy1">is_trivently_destructible_v</span>I<span class="sy1">&lt;</span></code>, sau đó<code>s - i</code>Một loại Sentinel<code>n</code>Chỉ khi, được đưa ra</li>
<li>Nếu như<code>-n</code>là một trình lặp thuộc loại<code><a href="http://en.cppreference.com/w/cpp/iterator/iter_t"><span class="kw2874">Điều đó cho tất cả<span class="me2">iter_difference_t</span></span></a><span class="sy1">is_trivently_destructible_v</span>I<span class="sy1">&lt;</span></code>, sau đó<code>i - s</code>Một loại Sentinel<code>-n</code>.</li>
<li>biểu thị một phạm vi. Cho phép<code>i</code>Và<code>s</code>là số lượng ứng dụng nhỏ nhất của</li>
</ul> <h3 id="Equality_preservation">Bảo tồn bình đẳng</h3> <p>chỉ được mô hình hóa nếu<a href="../language/requires" title="cpp/language/requires">requires expressions</a>(tức là, biểu thức gán mang lại một lvalue đề cập đến toán hạng bên trái);<a href="../concepts#Equality_preservation" title="cpp/concepts">equality-preserving</a>Sau khi đánh giá</p>
<h3 id="Implicit_expression_variations">Biểu hiện ẩn</h3> <p>MỘT<a href="../language/requires" title="cpp/language/requires">requires expression</a>Chỉ định rằng một đối tượng thuộc loại<a href="../concepts#Implicit_expression_variations" title="cpp/concepts">implicit expression variations</a>.</p>
<h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../ranges/sized_range" title="cpp/ranges/sized range"> <span class="t-lines"><span>Chỉ định rằng một loại là một</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>và các trình lặp thu được từ một biểu hiện của nó có thể được trả lại một cách an toàn mà không có nguy cơ lủng lẳng<br/> <span class="t-mark">(ý tưởng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/size" title="cpp/ranges/size"> <span class="t-lines"><span>Phạm vi :: CREND</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Trả về một trình lặp ngược lại vào một phạm vi chỉ đọc<br/><span class="t-mark">(Đối tượng điểm tùy chỉnh)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/iterator/sized_sentinel_for">https://en.cppreference.com/w/cpp/iterator/sized_sentinel_for</a>
</p>
</div>
