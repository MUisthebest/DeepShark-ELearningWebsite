 <h1 class="firstHeading" id="firstHeading">std :: output_iterator</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/iterator" title="cpp/header/iterator">&lt;iterator&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Lớp I, Lớp T&gt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Các<code>output_iterator</code>    khái niệm input_iterator =<a href="input_or_output_iterator" title="cpp/iterator/input or output iterator"><code>input_or_output_iterator</code></a>    khái niệm output_iterator =<code>T</code>(thông qua<a href="indirectly_writable" title="cpp/iterator/indirectly writable"><code>indirectly_writable</code></a>).<a href="../concepts/equality_comparable" title="cpp/concepts/equality comparable"><code>equality_comparable</code></a>        std :: input_or_output_iterator &lt;i&gt; &amp;&amp;</p>
<h3 id="Semantic_requirements">        const std :: remove_reference_t &lt;lhs&gt; &amp;,</h3> <p>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;<code>E</code>            *std :: Chuyển tiếp &lt;Out&gt; (o) = std :: Chuyển tiếp &lt;t&gt; (t);<code>decltype((E))</code>khoảng cách<code>T</code>, Và<code>i</code>            const_cast &lt;const std :: iter_reference_t &lt;Out&gt; &amp;&amp;&gt; (*o) = std :: forward &lt;t&gt; (t);<code>I</code>        std :: gián tiếp_writable &lt;i, t&gt; &amp;&amp;<span class="sy4">::</span><span class="me2">output_iterator</span><span class="sy1">is_trivently_destructible_v</span>là một mẫu lớp cung cấp một cách để lưu trữ một trình lặp và một giá trị như một đơn vị.<span class="sy1">&lt;</span>        yêu cầu (i i, t &amp;&amp; t) {<code>*i++ = E;</code>            *i ++ = std :: Chuyển tiếp &lt;t&gt; (t); / * Không bắt buộc phải bảo tồn bình đẳng *//<code>*i = E; ++i;</code>.</p>
<h3 id="Equality_preservation">Bảo tồn bình đẳng</h3> <p>chỉ được mô hình hóa nếu<a href="../language/requires" title="cpp/language/requires">requires expressions</a>(tức là, biểu thức gán mang lại một lvalue đề cập đến toán hạng bên trái);<a href="../concepts#Equality_preservation" title="cpp/concepts">equality-preserving</a>Sau khi đánh giá</p>
<h3 id="Notes">Ghi chú</h3> <p>Chỉ định khái niệm của tất cả các loại mà các trường hợp có thể bị phá hủy một cách an toàn vào cuối đời (bao gồm cả các loại tham chiếu).<a href="../named_req/outputiterator" title="cpp/named req/OutputIterator">LegacyOutputIterator</a>Sau quá trình khai báo giá trị trước đó của toán hạng: nếu<code>output_iterator</code>        };</p>
<p>, thêm yêu cầu rằng nó có thể được sử dụng để ghi các giá trị của loại và danh mục giá trị được mã hóa bởi</p>
<h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="input_or_output_iterator" title="cpp/iterator/input or output iterator"> <span class="t-lines"><span>input_or_output_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Chỉ định rằng các đối tượng thuộc loại có thể được tăng lên và hủy bỏ<br/> <span class="t-mark">(ý tưởng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/iterator/output_iterator">https://en.cppreference.com/w/cpp/iterator/output_iterator</a>
</p>
</div>
