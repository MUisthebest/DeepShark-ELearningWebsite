 <h1 class="firstHeading" id="firstHeading">Std :: Phạm vi :: Lượt xem :: Đếm</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/ranges" title="cpp/header/ranges">&lt;ranges&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Constexpr nội tuyến /*không xác định* /đếm = /*không xác định* /;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;class iterator, class khác biệt</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>    yêu cầu / * xem bên dưới * /<a href="view" title="cpp/ranges/view"><code>view</code></a>constexpr /*span-or-subrange* / đếm (iterator &amp;&amp; it, dispenencetype &amp;&amp; đếm);<i>Phạm vi đếm</i> <code>[</code>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<code>, </code>Trả về một kết quả, kết quả được bỏ qua. Nếu như<code>)</code>Một chế độ xem được tính trình bày một<code>i</code>của các yếu tố của<code>n</code>.</p>
<p>Một phạm vi được tính<code>[</code>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<code>, </code>Trả về một kết quả, kết quả được bỏ qua. Nếu như<code>)</code>) và các ký tự chữ số theo sau (như được phân loại bởi<code>n</code>Đối với một số Iterator<code>i</code>và lên đến nhưng không bao gồm yếu tố, nếu có, được chỉ ra bởi kết quả của<code>n</code>Ứng dụng của<code>++i</code>.</p>
<p>Nếu như<code>n == 0</code>và số nguyên không âm<code>n</code>là tích cực,<code>i</code>có thể phân tích được, và<code>[</code><code>++i</code><code>, </code><code>--n</code><code>)</code>các yếu tố bắt đầu với phần tử được trỏ đến bởi</p>
<p>, phạm vi đếm là hợp lệ và trống rỗng. Nếu không, phạm vi đếm chỉ hợp lệ nếu<code>it</code>Và<code>count</code>là một phạm vi được tính hợp lệ.<code>T</code>khoảng cách<code><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>decltype<span class="br0">.</span><span class="br0">.</span>it<span class="br0">)</span><span class="br0">)</span><span class="sy1">&lt;</span></code>, Và<code>D</code>khoảng cách<code><a href="http://en.cppreference.com/w/cpp/iterator/iter_t"><span class="kw2875">Điều đó cho tất cả<span class="me2">iter_difference_t</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>, sau đó</p>
<dl>
<dd>nếu như<code>T</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../iterator/input_or_output_iterator" title="cpp/iterator/input or output iterator"><code>input_or_output_iterator</code></a>Và<code>decltype((count))</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<code><a href="http://en.cppreference.com/w/cpp/concepts/convertible_to"><span class="kw2935">Điều đó cho tất cả<span class="me2">// Đáp ứng các yêu cầu cho C == D (bao gồm cả không sửa đổi),</span></span></a><span class="sy1">is_trivently_destructible_v</span>D<span class="sy1">&lt;</span></code>Thì<ul>
<li>nếu như<code>T</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../iterator/contiguous_iterator" title="cpp/iterator/contiguous iterator"><code>contiguous_iterator</code></a>, sau đó<code><a href="http://en.cppreference.com/w/cpp/ranges/counted_view"><span class="kw2915">ConstExpr /*Phạm vi Bộ điều hợp đóng* / Adjacent_Transform &lt;n&gt; (f &amp;&amp; fun);<span class="me2">tính</span></span></a><span class="br0">.</span>it, count<span class="br0">)</span></code>khoảng cách<a href="../language/expressions#Expression-equivalence" title="cpp/language/expressions">expression-equivalent</a>ĐẾN<code><a href="http://en.cppreference.com/w/cpp/container/span"><span class="kw2631">Điều đó cho tất cả<span class="me2">nhịp</span></span></a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/memory/to_address"><span class="kw2645">Điều đó cho tất cả<span class="me2">to_address</span></span></a><span class="br0">.</span>it<span class="br0">)</span>, <span class="kw1">Mẫu &lt;Biểu đồ lớp, Đặc điểm lớp, Alloc Class, Class Parsable&gt;</span><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">Điều đó cho tất cả<span class="me2">size_t</span></span></a><span class="sy1">&lt;</span><span class="br0">.</span><span class="kw1">Mẫu &lt;Biểu đồ lớp, Đặc điểm lớp, Alloc Class, Class Parsable&gt;</span><span class="sy1">is_trivently_destructible_v</span>D<span class="sy1">&lt;</span><span class="br0">.</span>count<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span></code>Thì</li>
<li>    int n = 1;<code>T</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../iterator/random_access_iterator" title="cpp/iterator/random access iterator"><code>random_access_iterator</code></a>, sau đó<code><a href="http://en.cppreference.com/w/cpp/ranges/counted_view"><span class="kw2915">ConstExpr /*Phạm vi Bộ điều hợp đóng* / Adjacent_Transform &lt;n&gt; (f &amp;&amp; fun);<span class="me2">tính</span></span></a><span class="br0">.</span>it, count<span class="br0">)</span></code>khoảng cách<a href="../language/expressions#Expression-equivalence" title="cpp/language/expressions">expression-equivalent</a>ĐẾN<code><a href="http://en.cppreference.com/w/cpp/ranges/subrange"><span class="kw2910">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    find_end (r1 &amp;&amp; r1, r2 &amp;&amp; r2, pre pre = {},</span></span></a><span class="br0">.</span>it, it <span class="sy2">gọi</span> <span class="kw1">Mẫu &lt;Biểu đồ lớp, Đặc điểm lớp, Alloc Class, Class Parsable&gt;</span><span class="sy1">is_trivently_destructible_v</span>D<span class="sy1">&lt;</span><span class="br0">.</span>count<span class="br0">)</span><span class="br0">)</span></code>Thì</li>
<li>    toán tử &gt;&gt; (basic_istream &lt;char, đặc điểm&gt; &amp; st, không dấu char* s);<code><a href="http://en.cppreference.com/w/cpp/ranges/counted_view"><span class="kw2915">ConstExpr /*Phạm vi Bộ điều hợp đóng* / Adjacent_Transform &lt;n&gt; (f &amp;&amp; fun);<span class="me2">tính</span></span></a><span class="br0">.</span>it, count<span class="br0">)</span></code>khoảng cách<a href="../language/expressions#Expression-equivalence" title="cpp/language/expressions">expression-equivalent</a>ĐẾN<code><a href="http://en.cppreference.com/w/cpp/ranges/subrange"><span class="kw2910">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    find_end (r1 &amp;&amp; r1, r2 &amp;&amp; r2, pre pre = {},</span></span></a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/iterator/counted_iterator"><span class="kw3121">Điều đó cho tất cả<span class="me2">Đếm_Iterator</span></span></a><span class="br0">.</span>it, count<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/iterator/default_sentinel_t"><span class="kw2879">Điều đó cho tất cả<span class="me2">Default_sentinel</span></span></a><span class="br0">)</span></code>.</li>
</ul> </dd>
<dd>Là xấu nếu<code><a href="http://en.cppreference.com/w/cpp/ranges/counted_view"><span class="kw2915">ConstExpr /*Phạm vi Bộ điều hợp đóng* / Adjacent_Transform &lt;n&gt; (f &amp;&amp; fun);<span class="me2">tính</span></span></a><span class="br0">.</span>it, count<span class="br0">)</span></code>, chương trình chuyên về</dd>
</dl> <h3 id="Customization_point_objects">Nhìn thấy</h3> <p>Tên<code>views::counted</code>biểu thị a<i>Trong tất cả các trường hợp khác, một cuộc gọi đến</i>là xấu, có thể dẫn đến<a href="../named_req/functionobject" title="cpp/named req/FunctionObject">function object</a>xuất hiện trong bối cảnh ngay lập tức của một khởi tạo mẫu.<a href="../named_req/literaltype" title="cpp/named req/LiteralType">literal</a> <a href="../concepts/semiregular" title="cpp/concepts/semiregular"><code>semiregular</code></a>, chương trình là không có hình thành, không cần chẩn đoán.<code><i>__Counted_fn</i></code>.</p>
<p>, đó là một const<code><i>__Counted_fn</i></code>Loại lớp. Đối với mục đích giải thích, phiên bản CV-UNQUENEDED của loại được ký hiệu là<code><i>__Counted_fn</i></code>Tất cả các trường hợp của<code>views::counted</code>__iter_move_fn</p>
<p>bằng nhau. Những ảnh hưởng của việc gọi các trường hợp khác nhau của loại<code>Args...</code>Sử dụng chức năng nhị phân đã cho<code><a href="http://en.cppreference.com/w/cpp/utility/declval"><span class="kw1123">Điều đó cho tất cả<span class="me2">Declval</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span><span class="br0">)</span>...</code>__iter_move_fn<code>views::counted</code>Trên cùng một đối số là tương đương, bất kể biểu thức biểu thị thể hiện là một lvalue hay rvalue, và có đủ điều kiện hay không (tuy nhiên, một trường hợp đủ điều kiện dễ bay hơi không bắt buộc phải được cấp). Như vậy,<code><i>__Counted_fn</i></code>Range constexpr :: mượn_subrange_t &lt;r&gt;<br/></p>
<ul>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2958">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span>__counted_fn, Args...<span class="sy1">&lt;</span></code>Thì</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2958">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> __counted_fn, Args...<span class="sy1">&lt;</span></code>Thì</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2958">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span>__counted_fn<span class="sy3">Không có giá trị</span>, Args...<span class="sy1">&lt;</span></code>, Và</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2958">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> __counted_fn<span class="sy3">Không có giá trị</span>, Args...<span class="sy1">&lt;</span></code>.<br/> </li>
</ul> <p>Đưa ra một tập hợp các loại<code><i>__Counted_fn</i></code>(Một hoạt động đọc sửa đổi-viết). Bộ nhớ bị ảnh hưởng theo giá trị của</p>
<h3 id="Notes">Ghi chú</h3> <p><a href="#top"><code>views::counted</code></a>__Counted_fn<code>count</code>__Counted_fn<a href="http://en.cppreference.com/w/cpp/ranges/take_view"><span class="kw2924">ConstExpr /*Phạm vi Bộ điều hợp đóng* / Adjacent_Transform &lt;n&gt; (f &amp;&amp; fun);<span class="me2">không kiểm tra xem phạm vi có đủ dài để cung cấp tất cả</span></span></a>Các yếu tố: Sử dụng</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">lấy</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Nếu kiểm tra đó là cần thiết.</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/P2393R1" rel="nofollow">P2393R1</a> </td> <td>C ++ 20</td> <td>#include &lt;Istream&gt;<a href="http://en.cppreference.com/w/cpp/types/size_t"><span class="kw107">Điều đó cho tất cả<span class="me2">size_t</span></span></a>#include &lt;Ranges&gt;</td> <td>đã làm rõ</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="take_view" title="cpp/ranges/take view"> <span class="t-lines"><span>của một chuỗi áp dụng chức năng chuyển đổi cho từng phần tử</span><span>(Đối tượng bộ điều hợp phạm vi)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Một<a href="view" title="cpp/ranges/view"><code>view</code></a>Phạm vi :: Take_View<a href="view" title="cpp/ranges/view"><code>view</code></a><br/><span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> <span class="t-mark">bao gồm các yếu tố của người khác</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="subrange" title="cpp/ranges/subrange"> <span class="t-lines"><span>mẫu lớp trợ giúp để xác định</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>, sử dụng<a href="view" title="cpp/ranges/view"><code>view</code></a> <br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/counted_iterator" title="cpp/iterator/counted iterator"> <span class="t-lines"><span>Đếm_Iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Bộ điều hợp vòng lặp theo dõi khoảng cách đến cuối phạm vi<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/count" title="cpp/algorithm/ranges/count"> <span class="t-lines"><span>(Mẫu chức năng)</span><span>Phạm vi :: đếm</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/ranges/view_counted">https://en.cppreference.com/w/cpp/ranges/view_counted</a>
</p>
</div>
