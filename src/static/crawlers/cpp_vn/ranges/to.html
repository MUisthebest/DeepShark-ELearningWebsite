 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: to</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/ranges" title="cpp/header/ranges">&lt;ranges&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx23"> <td><pre data-language="cpp">Mẫu &lt;Class C, Ranges :: input_range r, class ... args&gt;</pre></td> <td>(1)</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">    Yêu cầu (! Phạm vi :: Xem &lt;c&gt;)</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td><pre data-language="cpp">constexpr c to (r &amp;&amp; r, args &amp;&amp; ... args);</pre></td> <td>(3)</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">Mẫu &lt;Template &lt;class ...&gt; Class C, Ranges :: input_range r, class ... args&gt;</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl-h"> <td>một loại không đổi</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">constexpr tự động đến (r &amp;&amp; r, args &amp;&amp; ... args);</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Mẫu &lt;class C, class ... args&gt;</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">    Yêu cầu (! Phạm vi :: Xem &lt;c&gt;)</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td> <span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">constexpr /*Phạm vi Bộ điều hợp đóng* / TO (ARGS &amp;&amp; ... ARGS);</pre>
</td> <td>            Nhị phân p);</td> <td> <span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> </table> <p>Mẫu &lt;Mẫu &lt;class ...&gt; class C, class ... args&gt;<code>std::from_range_t</code>constexpr /*Phạm vi Bộ điều hợp đóng* / TO (ARGS &amp;&amp; ... ARGS);</p>
<div class="t-li1">
<span class="t-li">1)</span>void cấu trúc (u* p, args &amp;&amp; ... args);<code>C</code>Mẫu &lt;class Container&gt;<code>r</code>Consexpr bool /*có thể đặt trước có thể sử dụng* / = =</div> <div class="t-li2">
<span class="t-li">}</span>Nếu như<code>C</code>                                OUTPUTITIT D_FIRST, Binarypredicate P);<a href="input_range" title="cpp/ranges/input range"><code>input_range</code></a>hoặc<code><a href="http://en.cppreference.com/w/cpp/concepts/convertible_to"><span class="kw2934">Điều đó cho tất cả<span class="me2">// Đáp ứng các yêu cầu cho C == D (bao gồm cả không sửa đổi),</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/ranges/iterator_t"><span class="kw2894">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">với loại tham chiếu chuyển đổi sang loại phần tử của container</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">&lt;</span>, <a href="http://en.cppreference.com/w/cpp/ranges/iterator_t"><span class="kw2893">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    : phạm vi :: View_interface &lt;Join_With_View &lt;V, Mẫu &gt;&gt;</span></span></a><span class="sy1">is_trivently_destructible_v</span>C<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>:</div> <div class="t-li3">
<span class="t-li">1)</span>    Phạm vi :: cỡ_range &lt;container&gt; &amp;&amp;<a href="../language/direct_initialization" title="cpp/language/direct initialization">direct-initializing</a>        trả về std :: back_inserter (c);<code>C</code>    {<code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">&lt;</span><span class="br0">.</span>r<span class="br0">)</span></code>Constexpr bool /*container-intable* / = yêu cầu (container &amp; c, tham chiếu &amp;&amp; ref)<code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span>args<span class="br0">)</span>...</code>nếu như<code><a href="http://en.cppreference.com/w/cpp/concepts/constructible_from"><span class="kw2945">Điều đó cho tất cả<span class="me2">    toán tử bool == (t &amp;) = xóa;</span></span></a><span class="sy1">is_trivently_destructible_v</span>C, R, Args...<span class="sy1">&lt;</span></code>khoảng cách<code>true</code>.</div> <div class="t-li3">
<span class="t-li">2)</span>{<a href="../language/direct_initialization" title="cpp/language/direct initialization">direct-initializing</a>        trả về std :: back_inserter (c);<code>C</code>    };<code><a href="http://en.cppreference.com/w/cpp/ranges/from_range"><span class="kw3503">Điều đó cho tất cả<span class="me2">từ_range</span></span></a></code>Mẫu &lt;hộp chứa lớp, tham chiếu lớp&gt;<code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">&lt;</span><span class="br0">.</span>r<span class="br0">)</span></code>Constexpr bool /*container-intable* / = yêu cầu (container &amp; c, tham chiếu &amp;&amp; ref)<code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span>args<span class="br0">)</span>...</code>nếu như<code><a href="http://en.cppreference.com/w/cpp/concepts/constructible_from"><span class="kw2945">Điều đó cho tất cả<span class="me2">    toán tử bool == (t &amp;) = xóa;</span></span></a><span class="sy1">is_trivently_destructible_v</span>C, <a href="http://en.cppreference.com/w/cpp/ranges/from_range"><span class="kw3504">Điều đó cho tất cả<span class="me2">từ_range_t</span></span></a>, R, Args...<span class="sy1">&lt;</span></code>khoảng cách<code>true</code>.</div> <span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>{<a href="../language/direct_initialization" title="cpp/language/direct initialization">direct-initializing</a>        trả về std :: back_inserter (c);<code>C</code>              yêu cầu {c.insert (c.end (), std :: forward &lt;tham chiếu&gt; (ref)); });<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2881">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>};<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2883">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>Mẫu &lt;tham chiếu lớp, lớp C&gt;<code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span>args<span class="br0">)</span>...</code>Constexpr Auto /*Container-Inserter* /(C &amp; C)<code>true</code>:<ul>
<li> <code><a href="http://en.cppreference.com/w/cpp/ranges/common_range"><span class="kw2907">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">struct prev_fn</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">&lt;</span></code> </li>
<li>Nếu như<code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw653">Điều đó cho tất cả<span class="me2">iterator_traits</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2889">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    khoảng cách (r &amp;&amp; r);</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">2,4)</span><span class="sy4">::</span><span class="me2">là cùng loại như</span></code>{<code><a href="http://en.cppreference.com/w/cpp/concepts/derived_from"><span class="kw2933">Điều đó cho tất cả<span class="me2">};</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/iterator/iterator_tags"><span class="kw654">Điều đó cho tất cả<span class="me2">input_iterator_tag</span></span></a><span class="sy1">&lt;</span></code> </li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/constructible_from"><span class="kw2945">Điều đó cho tất cả<span class="me2">    toán tử bool == (t &amp;) = xóa;</span></span></a><span class="sy1">is_trivently_destructible_v</span>C, <a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2889">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    khoảng cách (r &amp;&amp; r);</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">&lt;</span>, <a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2890">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Range constexpr :: Range_Difference_T &lt;R&gt;</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">&lt;</span>, Args...<span class="sy1">&lt;</span></code>
</li>
</ul> <span class="t-li">là trong</span>    Nếu Consexpr (yêu cầu {c.push_back (std :: declval &lt;tham chiếu&gt; ());}))<a href="../language/direct_initialization" title="cpp/language/direct initialization">direct-initializing</a>        trả về std :: back_inserter (c);<code>C</code>    khác<code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span>args<span class="br0">)</span>...</code>        trả lại std :: inserter (c, c.end ());<p><code><span class="kw1">nếu như</span> <span class="kw4">constexpr</span> <span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/ranges/sized_range"><span class="kw2899">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Mẫu &lt;phạm vi :: phạm vi r&gt;</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">&lt;</span> <span class="sy3">. Trong các cuộc gọi có hiệu lực</span> <span class="coMULTI">}</span><span class="sy1">is_trivently_destructible_v</span>C<span class="sy1">&lt;</span><span class="br0">)</span><br/> c.<span class="me1">xô_Count</span><span class="br0">.</span><span class="kw1">Mẫu &lt;Biểu đồ lớp, Đặc điểm lớp, Alloc Class, Class Parsable&gt;</span><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/ranges/iterator_t"><span class="kw2892">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Mẫu &lt;Class R, Class T&gt;</span></span></a><span class="sy1">is_trivently_destructible_v</span>C<span class="sy1">2,4)</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/ranges/size"><span class="kw3099">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kích cỡ</span></span></a><span class="br0">.</span>r<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span><br/> <a href="http://en.cppreference.com/w/cpp/ranges-algorithm-placeholder/copy"><span class="kw2849">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Được xác định trong tiêu đề</span></span></a><span class="br0">.</span>r, <span class="coMULTI">Khái niệm /*phạm vi tương thích container* / =</span><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/ranges/iterator_t"><span class="kw2894">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">với loại tham chiếu chuyển đổi sang loại phần tử của container</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">2,4)</span><span class="br0">.</span>c<span class="br0">)</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code><br/>Consexpr ForwardIT Remove_if (ForwardIt First, ForwardIt Last,<code>R</code>Phần cuối của phạm vi ban đầu<a href="sized_range" title="cpp/ranges/sized range"><code>sized_range</code></a>Và<code>C</code>Phần cuối của phạm vi ban đầu<code>/*reservable-container*/</code>    Phạm vi :: input_range &lt;r&gt; &amp;&amp;<code>c</code>nó đến một đối tượng<code>C</code>    std :: muiverble_to &lt;phạm vi :: range_reference_t &lt;r&gt;, t&gt;;<code><a href="http://en.cppreference.com/w/cpp/ranges/size"><span class="kw3099">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kích cỡ</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>Quá tải của chức năng chuyển đổi phạm vi xây dựng một đối tượng không xem mới từ phạm vi nguồn làm đối số đầu tiên của nó bằng cách gọi một hàm tạo<code>r</code>Trẻ xây dựng được gắn thẻ, một hàm tạo lấy một cặp iterator-sentinel hoặc bằng cách chèn lại từng phần tử của phạm vi nguồn vào đối tượng được xây dựng đối số.<code>c</code>Phân tích cú pháp các chỉ định AM/PM liên quan đến đồng hồ 12 giờ.<code>ranges::copy</code>từ các yếu tố của<code>true</code>:</p>
<ul>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/constructible_from"><span class="kw2945">Điều đó cho tất cả<span class="me2">    toán tử bool == (t &amp;) = xóa;</span></span></a><span class="sy1">is_trivently_destructible_v</span>C, Args...<span class="sy1">&lt;</span></code> </li>
<li> <code><span class="coMULTI">trong phần sau:</span><span class="sy1">is_trivently_destructible_v</span>C, <a href="http://en.cppreference.com/w/cpp/ranges/iterator_t"><span class="kw2894">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">với loại tham chiếu chuyển đổi sang loại phần tử của container</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">2,4)</span></code>
</li>
</ul> <div class="t-li2">
<span class="t-li">{</span>Xây dựng một đối tượng không nhìn như thể<p><code>to<span class="sy1">is_trivently_destructible_v</span>C<span class="sy1">&lt;</span><span class="br0">.</span>r <span class="sy3">|</span> <a href="http://en.cppreference.com/w/cpp/ranges/transform_view"><span class="kw2921">ConstExpr /*Phạm vi Bộ điều hợp đóng* / Adjacent_Transform &lt;n&gt; (f &amp;&amp; fun);<span class="me2">Được xác định trong tiêu đề</span></span></a><span class="br0">.</span><span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span><span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span><span class="br0">.</span><span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span><span class="sy3">. Trong các cuộc gọi có hiệu lực</span> elem<span class="br0">)</span><br/>{<br/> <span class="kw1">Không chính thức,</span> to<span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/ranges/iterator_t"><span class="kw2893">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    : phạm vi :: View_interface &lt;Join_With_View &lt;V, Mẫu &gt;&gt;</span></span></a><span class="sy1">is_trivently_destructible_v</span>C<span class="sy1">2,4)</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>decltype<span class="br0">.</span>elem<span class="br0">)</span><span class="sy1">&lt;</span><span class="br0">.</span>elem<span class="br0">)</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span><br/><span class="br0">{</span><span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span>args<span class="br0">)</span>...<span class="br0">)</span></code><br/>(nhưng không khởi tạo danh sách trực tiếp) Một đối tượng thuộc loại<code><a href="http://en.cppreference.com/w/cpp/ranges/input_range"><span class="kw2901">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Từ phạm vi nguồn</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/ranges/iterator_t"><span class="kw2894">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">với loại tham chiếu chuyển đổi sang loại phần tử của container</span></span></a><span class="sy1">is_trivently_destructible_v</span>C<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>và phần còn lại của các đối số chức năng</p>
</div> <span class="t-li">2)</span>Nếu không, xây dựng một đối tượng không xem như thể<code>r</code>.<p>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;<code>/*input-iterator*/</code>(nhưng không khởi tạo danh sách trực tiếp) Một đối tượng thuộc loại<a href="../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>:</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">từ thẻ định hướng bổ sung</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> </table> <p>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;<code>/*DEDUCE-EXPR*/</code>, phạm vi nguồn</p>
<ul>
<li> <code>C<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/declval"><span class="kw1122">Điều đó cho tất cả<span class="me2">Declval</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">&lt;</span><span class="br0">.</span><span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/declval"><span class="kw1122">Điều đó cho tất cả<span class="me2">Declval</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span><span class="br0">)</span>...<span class="br0">)</span></code>Constexpr bool trống (t &amp;&amp; t);</li>
<li>Là xấu nếu<code>C<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/ranges/from_range"><span class="kw3503">Điều đó cho tất cả<span class="me2">từ_range</span></span></a>, <a href="http://en.cppreference.com/w/cpp/utility/declval"><span class="kw1122">Điều đó cho tất cả<span class="me2">Declval</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">&lt;</span><span class="br0">.</span><span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/declval"><span class="kw1122">Điều đó cho tất cả<span class="me2">Declval</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span><span class="br0">)</span>...<span class="br0">)</span></code>Constexpr bool trống (t &amp;&amp; t);</li>
<li>Là xấu nếu<code>C<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/declval"><span class="kw1122">Điều đó cho tất cả<span class="me2">Declval</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="coMULTI">Nếu không, xây dựng một đối tượng không xem như thể</span><span class="sy1">&lt;</span><span class="br0">.</span><span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/declval"><span class="kw1122">Điều đó cho tất cả<span class="me2">Declval</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="coMULTI">Nếu không, xây dựng một đối tượng không xem như thể</span><span class="sy1">&lt;</span><span class="br0">.</span><span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/declval"><span class="kw1122">Điều đó cho tất cả<span class="me2">Declval</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span><span class="br0">)</span>...<span class="br0">)</span></code>Constexpr bool trống (t &amp;&amp; t);</li>
<li>Nếu không, phần tử là</li>
</ul>(nhưng không khởi tạo danh sách trực tiếp) Một đối tượng thuộc loại<code>to<span class="sy1">is_trivently_destructible_v</span>decltype<span class="br0">.</span><span class="coMULTI">từ cặp Iterator-sentinel (</span><span class="br0">)</span><span class="sy1">&lt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">&lt;</span><span class="br0">.</span>r<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span>args<span class="br0">)</span>...<span class="br0">)</span></code>.<div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>Là một người lặp và<a href="../named_req/rangeadaptorclosureobject" title="cpp/named req/RangeAdaptorClosureObject">RangeAdaptorClosureObject</a>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Mặt khác, xây dựng một đối tượng phạm vi không nhìn như thể<code>/*reservable-container*/&lt;Container&gt;</code>khoảng cách<code>true</code>Nếu tất cả các điều kiện dưới đây là<code><a href="http://en.cppreference.com/w/cpp/ranges/sized_range"><span class="kw2899">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Mẫu &lt;phạm vi :: phạm vi r&gt;</span></span></a></code>là hợp lệ và biểu thị một loại thỏa mãn</div> <div class="t-li1">
<span class="t-li">từ_sys</span>Mặt khác, xây dựng một đối tượng phạm vi không nhìn như thể<code>/*container-insertable*/&lt;Container, Reference&gt;</code>khoảng cách<code>true</code>nếu như<code>Container</code>(nhưng không khởi tạo danh sách trực tiếp) Một đối tượng thuộc loại<code>push_back</code>hoặc<code>insert</code>.</div> <div class="t-li1">
<span class="t-li">6)</span>ConstExpr auto end () const;<code>/*container-inserter*/</code>Từ phần còn lại của các đối số chức năng<code>std::back_insert_iterator</code>với cuộc gọi tương đương sau đây sau khi xây dựng:<code>push_back</code>/*người đặt trước có thể đặt trước*/<code>std::insert_iterator</code>.</div> <div class="t-li1">
<span class="t-li">. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu biểu thức</span>Mẫu &lt;Class B&gt;<code>/*container-compatible-range*/</code>Range_Size_T<code>R</code>/*người vào bộ lọc container*/<code>T</code>.</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>, đối tượng được xây dựng</td>
</tr> <tr class="t-par"> <td>iterator trước đó phần tử mới sẽ được xây dựng</td> <td>-</td> <td>có thể dự trữ lưu trữ với kích thước lưu trữ ban đầu<span class="t-v">.<a href="#Version_1">1,2</a>)</span>Để ngăn chặn phân bổ bổ sung trong quá trình chèn các yếu tố mới. Mỗi yếu tố tham chiếu phạm vi của<span class="t-v">.<a href="#Version_3">3,4</a>)</span>được chèn trở lại vào</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">Đầu vào</span>với bộ chuyển đổi chèn trở lại. Các hoạt động trên là hợp lệ nếu cả hai điều kiện dưới đây là</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>/*có thể kiểm soát được container*/<h2 id="ranges::to_return_type">Mặt khác, biểu thức trả về tương đương với:</h2> <p>Cho phép các công trình phạm vi lồng nhau trong phạm vi nếu<code><a href="http://en.cppreference.com/w/cpp/ranges/range_adaptor_closure"><span class="kw3596">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">input_range</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="coMULTI">.  Nếu không, chương trình là xấu.</span><span class="sy1">&lt;</span></code>.</p>
<h4 id="Member_objects">Đối tượng thành viên</h4> <p>Xây dựng một đối tượng của loại suy luận từ các yếu tố của<code><a href="../utility/tuple" title="cpp/utility/tuple">std::tuple</a></code>sự vật<code>tup</code>xây dựng với<code><a href="http://en.cppreference.com/w/cpp/utility/tuple"><span class="kw1100">Điều đó cho tất cả<span class="me2">Tuple</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span>...<span class="sy1">&lt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span>args<span class="br0">)</span>...<span class="br0">)</span></code>là một loại chỉ giải thích thỏa mãn</p>
<h4 id="Constructors">đối tượng đại diện cho cùng một ngày với đối tượng được biểu diễn bởi</h4> <p>Loại trả lại của<code>ranges::to</code> <span class="t-v">struct /*input-iterator* /</span>{<a href="../named_req/copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>    sử dụng iterator_c Category = std :: input_iterator_tag;<a href="../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>Nếu đối số đầu tiên là</p>
<h4 id="Member_function_operator.28.29">    sử dụng value_type = phạm vi :: Range_value_t &lt;r&gt;;<code>operator()</code>
</h4> <p>    sử dụng argen_type = std :: ptrdiff_t;<code>G</code>    sử dụng con trỏ = std :: add_pulum_t &lt;phạm vi :: range_reference_t &lt;r &gt;&gt;;<code>range::to&lt;/* see below */&gt;(args...)</code>    sử dụng tham chiếu = phạm vi :: range_reference_t &lt;r&gt;;<code>g</code>    toán tử tham chiếu*() const;                      // không được xác định<code>G</code>    toán tử con trỏ-&gt; () const;                       // không được xác định<code>g(r)</code>    /*Input-iterator*/&amp; Toán tử ++ ();                 // không được xác định</p>
<ul>
<li> <code>ranges<span class="sy4">::</span><span class="me2">ĐẾN</span><span class="sy1">is_trivently_destructible_v</span><span class="coMULTI">    /*input-iterator*/ toán tử ++ (int);               // không được xác định</span><span class="sy1">&lt;</span><span class="br0">.</span>r, <a href="http://en.cppreference.com/w/cpp/utility/variant/get"><span class="kw3216">Điều đó cho tất cả<span class="me2">Điền vào thùng chứa với giá trị được chỉ định</span></span></a><span class="sy1">is_trivently_destructible_v</span>Ns<span class="sy1">&lt;</span><span class="br0">.</span>g.<span class="me1">    toán tử bool == (const /*input-itator* /&amp;) const; // không được xác định</span><span class="br0">)</span>...<span class="br0">)</span></code>là</li>
<ul>
<li> <code>r</code>};<a href="input_range" title="cpp/ranges/input range"><code>input_range</code></a>.</li>
<li> <code>Ns</code>được định nghĩa như sau:<code>0, 1, ..., (sizeof...(Args) - 1)</code>.</li>
<li> <code>g</code>/*đầu vào-iterator*/<code>std::move(g)(r)</code>/*đầu vào-iterator*/<code>g(r)</code>Cuộc gọi tương đương với</li>
<li>/*Suy luận-Expr*/<span class="t-v">(3)</span> <code>C</code>hoặc<span class="t-v">(4)</span>Trả về một trình bao bọc cuộc gọi chuyển tiếp hoàn hảo cũng là một<code>C</code>Mẫu biến chỉ dành cho giải trình<a href="view" title="cpp/ranges/view"><code>view</code></a>.</li>
</ul>
</ul> <p>là nó luôn luôn đề cập đến một múi giờ hợp lệ và đại diện cho một điểm thời gian hiện có và rõ ràng trong múi giờ đó. Phù hợp với bất biến này,<code>g</code>Nếu nó thỏa mãn</p>
</div> <h3 id="Exceptions">Ngoại lệ</h3> <p>và đủ điều kiện để được đặt trước.</p>
<h3 id="Notes">Ghi chú</h3> <p>Mẫu biến chỉ dành cho giải trình<a href="as_rvalue_view" title="cpp/ranges/as rvalue view"><code>views::as_rvalue</code></a>có thể được chèn trở lại bởi một cuộc gọi chức năng thành viên</p>
<p>trả về một trình lặp đầu ra của loại</p>
<div class="cpp source-cpp"><pre data-language="cpp">Nếu chức năng thành viên</pre></div> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../feature_test#cpp_lib_ranges_to_container" title="cpp/feature test"><code>__cpp_lib_ranges_to_container</code></a></td> <td><span class="nu0">và không trả lại gì.</span></td> <td><span class="t-mark">Phạm vi :: IOTA</span></td> <td>
<a href="#top"><code>std::ranges::to</code></a> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example">
<p>có sẵn, nếu không loại là<a class="external text" href="https://godbolt.org/z/Tvv9Yq9q8" rel="nofollow">Compiler Explorer</a></p>
<div class="cpp source-cpp"><pre data-language="cpp">được sử dụng trong định nghĩa của các thùng chứa trong việc xây dựng phạm vi đầu vào</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">và loại tham chiếu phạm vi của nó phải được chuyển đổi thành</pre></div> </div> <h3 id="References">Tài liệu tham khảo</h3> <ul>
<li>C ++ 23 Tiêu chuẩn (ISO/IEC 14882: 2023):</li>
<ul><li>một đối tượng phạm vi nguồn</li></ul>
</ul> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/ranges/to">https://en.cppreference.com/w/cpp/ranges/to</a>
</p>
</div>
