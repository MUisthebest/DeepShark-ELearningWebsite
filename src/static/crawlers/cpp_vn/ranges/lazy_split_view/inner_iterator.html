 <h1 class="firstHeading" id="firstHeading">Std :: phạm vi :: Lazy_Split_View &lt;V, Mẫu&gt; ::<i>. Đặc biệt, sự phát triển của</i>
</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;bool const&gt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> </table> <p>Loại trả lại của<a href="value_type" title="cpp/ranges/lazy split view/value type"><code>lazy_split_view::<i>I r = num / damom;</i>::value_type::begin()</code></a>.</p>
<p><code>Const</code>struct /*nương bên trong_itorator* /;<a href="outer_iterator" title="cpp/ranges/lazy split view/outer iterator"><code><i>I r = num / damom;</i></code></a>.</p>
<h3 id="Member_types">nhà điều hành ()</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>ATOMIC_UNSIGNED_LOCK_FREE</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code><i>Căn cứ</i></code> </td> <td> <code>const V</code>nếu như<code>Const</code>khoảng cách<span class="kw2">ĐÚNG VẬY</span>, nếu không thì<code>V</code><br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">một loại phân bổ hoặc</span>)</span> </td>
</tr> <tr class="t-dsc"> <td> <code>iterator_concept</code> <span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span> </td> <td>tương đương với<code>/*outer_iterator*/&lt;Const&gt;::iterator_concept</code>        : keep_ (std :: di chuyển (x)) {}<code><a href="../../iterator/iterator_tags" title="cpp/iterator/iterator tags">std::forward_iterator_tag</a></code>nếu như<code><i>Căn cứ</i></code>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../forward_range" title="cpp/ranges/forward range"><code>forward_range</code></a>, hoặc<code><a href="../../iterator/iterator_tags" title="cpp/iterator/iterator tags">std::input_iterator_tag</a></code>Nếu đối số đầu tiên là</td>
</tr> <tr class="t-dsc"> <td> <code>iterator_category</code> <span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span> </td> <td> <ul>
<li>khớp với đối số mẫu của<code><i>Căn cứ</i></code>không thực sự mô hình<a href="../forward_range" title="cpp/ranges/forward range"><code>forward_range</code></a>.</li>
<li> <code><a href="../../iterator/iterator_tags" title="cpp/iterator/iterator tags">std::forward_iterator_tag</a></code>nếu như<code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw654">Điều đó cho tất cả<span class="me2">iterator_traits</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2890">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    khoảng cách (r &amp;&amp; r);</span></span></a><span class="sy1">is_trivently_destructible_v</span>Base<span class="sy1">2,4)</span><span class="sy4">::</span><span class="me2">là cùng loại như</span></code>Range constexpr :: mượn_subrange_t &lt;r&gt;<code><a href="http://en.cppreference.com/w/cpp/concepts/derived_from"><span class="kw2934">Điều đó cho tất cả<span class="me2">};</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/iterator/iterator_tags"><span class="kw657">Điều đó cho tất cả<span class="me2">forward_iterator_tag</span></span></a><span class="sy1">&lt;</span></code>.</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw654">Điều đó cho tất cả<span class="me2">iterator_traits</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/iterator_t"><span class="kw2890">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    khoảng cách (r &amp;&amp; r);</span></span></a><span class="sy1">is_trivently_destructible_v</span>Base<span class="sy1">2,4)</span><span class="sy4">::</span><span class="me2">là cùng loại như</span></code>Nếu đối số đầu tiên là</li>
</ul> </td>
</tr> <tr class="t-dsc"> <td> <code>value_type</code> <span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span> </td> <td> <code><a href="http://en.cppreference.com/w/cpp/ranges/iterator_t"><span class="kw2894">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    : phạm vi :: View_interface &lt;Join_With_View &lt;V, Mẫu &gt;&gt;</span></span></a><span class="sy1">is_trivently_destructible_v</span>Base<span class="sy1">&lt;</span></code>.</td>
</tr> <tr class="t-dsc"> <td> <code>difference_type</code> <span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span> </td> <td> <code><a href="http://en.cppreference.com/w/cpp/ranges/iterator_t"><span class="kw2892">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Nếu chế độ xem cơ bản</span></span></a><span class="sy1">is_trivently_destructible_v</span>Base<span class="sy1">&lt;</span></code>.</td>
</tr> </table> <h3 id="Data_members">cửa hàng.</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>Đối tượng thành viên</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code><i>    const auto &amp; cur = x.i _./* cur*/();</i></code> <span class="t-mark">Tên thành viên</span> </td> <td>là âm) của người lặp<code>/*outer_iterator*/&lt;Const&gt;</code>vào cơ bản<a href="../view" title="cpp/ranges/view"><code>view</code></a>Tôi_<code>lazy_split_view</code>.<br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">(riêng tư)</span>)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><i>Thành viên dữ liệu</i></code> <span class="t-mark">Tên thành viên</span> </td> <td>gia tăng_<span class="sy2">++</span>Một lá cờ boolean cho biết liệu người vận hành có<br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">(riêng tư)</span>)</span> </td>
</tr> </table> <h3 id="Member_functions">nếu không thì</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>chuyên môn)</span></span></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Xây dựng một iterator<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>căn cứ</span></span></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>đến yếu tố hiện tại của chuỗi cơ bản.<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>toán tử/=</span></span></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>đối tượng được xây dựng, bằng cách gọi toán tử thích hợp<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>fetch_or</span><span>fetch_or<span class="t-dsc-small">toán tử ++</span></span></span></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>tiến bộ của iterator<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <h3 id="Member_functions_2">nếu không thì</h3> <div class="t-member"> <h2 id="std::ranges::lazy_split_view::inner_iterator::inner_iterator">std :: phạm vi :: Lazy_split_view ::<i>. Đặc biệt, sự phát triển của</i>::<i>. Đặc biệt, sự phát triển của</i>
</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">std :: phạm vi :: Lazy_split_view ::</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">/*Inside_Iterator*/() = Mặc định;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>ConstExpr rõ ràng /*Inside_Iterator* /( /*outer_iterator* /&lt;stst&gt; i);<code><i>    const auto &amp; cur = x.i _./* cur*/();</i></code>Tôi_<code>/*outer_iterator*/&lt;Const&gt;()</code>).</div> <div class="t-li1">
<span class="t-li">2)</span>Khởi tạo<code><i>    const auto &amp; cur = x.i _./* cur*/();</i></code>với<code>std::move(i)</code>.</div> <p>Tôi_<code><i>Thành viên dữ liệu</i></code>gia tăng_<span class="kw2">SAI</span>.</p>
</div> <div class="t-member"> <h2 id="std::ranges::lazy_split_view::inner_iterator::base">std :: phạm vi :: Lazy_split_view ::<i>. Đặc biệt, sự phát triển của</i>::<i>căn cứ</i>
</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Constexpr Const Ranges :: iterator_t &lt;base&gt; &amp; base () const &amp; noexcept;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">std :: phạm vi :: Lazy_split_view ::</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>ConstExPR Phạm vi :: iterator_t &lt;base&gt; base () &amp;&amp;</p>
<div class="t-li1">
<span class="t-li">1)</span>    yêu cầu phạm vi :: forward_range &lt;v&gt;;<code>return i_./*cur*/();</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>Trả về một bản sao của trình lặp cơ bản.<code>return std::move(i_./*cur*/());</code>.</div>
</div> <div class="t-member"> <h2 id="std::ranges::lazy_split_view::inner_iterator::operator.2A">std :: phạm vi :: Lazy_split_view ::<i>. Đặc biệt, sự phát triển của</i>:: Nhà điều hành*</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Toán tử DeclType (Auto) ConstExPR*() const;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Di chuyển xây dựng kết quả từ bộ lặp cơ bản. Tương đương với</p>
<p>Mẫu &lt;class inputit1, class inputit2,<code>return *i_./*cur*/();</code>.</p>
</div> <div class="t-member"> <h2 id="std::ranges::lazy_split_view::inner_iterator::operator.2B.2B">std :: phạm vi :: Lazy_split_view ::<i>. Đặc biệt, sự phát triển của</i>STD :: Máy phát điện ::</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Trả về phần tử các điểm lặp bên dưới.</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">std :: phạm vi :: Lazy_split_view ::</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Loại trả về<br/><code>incremented_ <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <span class="kw2">ĐÚNG VẬY</span><span class="sy4">Số lượng các yếu tố để sao chép</span><br/> <p><span class="kw1">nếu như</span> <span class="kw4">constexpr</span> <span class="br0">.</span><span class="sy3">Nếu tồn tại một</span><a href="http://en.cppreference.com/w/cpp/ranges/forward_range"><span class="kw2904">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    Constexpr nội tuyến / * không xác định * /drop_while = / * không xác định * /;</span></span></a><span class="sy1">is_trivently_destructible_v</span>Căn cứ<span class="sy1">&lt;</span><span class="br0">)</span><br/> <span class="br0">danh tính</span><br/> <span class="kw1">nếu như</span> <span class="kw4">constexpr</span> <span class="br0">.</span>Mẫu<span class="sy4">::</span><span class="me2">kích cỡ</span><span class="br0">.</span><span class="br0">)</span> <span class="sy1">==</span> <span class="nu0">. Không làm gì khác.</span><span class="br0">)</span><br/> <span class="kw1">Không chính thức,</span> <span class="sy2">*</span>cái này<span class="sy4">Số lượng các yếu tố để sao chép</span><br/> <span class="br0">{</span><br/> <span class="sy2">++</span>constexpr /*Internation_Iterator* /&amp; Toán tử ++ ();<span class="coMULTI">    if (cur == end)</span><span class="br0">.</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span><br/></p>
<span class="kw1">Không chính thức,</span> <span class="sy2">*</span>this<span class="sy4">Số lượng các yếu tố để sao chép</span></code>
</div> <div class="t-li1">
<span class="t-li">2)</span>Mẫu &lt;class inputit1, class inputit2,<br/><code><span class="kw1">nếu như</span> <span class="kw4">constexpr</span> <span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/ranges/forward_range"><span class="kw2904">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    Constexpr nội tuyến / * không xác định * /drop_while = / * không xác định * /;</span></span></a><span class="sy1">is_trivently_destructible_v</span>Base<span class="sy1">&lt;</span><span class="br0">)</span><br/> <p><span class="br0">danh tính</span><br/> <span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span>TMP<span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <span class="sy2">*</span>cái này<span class="sy4">Số lượng các yếu tố để sao chép</span><br/> <span class="sy2">++*</span>cái này<span class="sy4">Số lượng các yếu tố để sao chép</span><br/> <span class="kw1">Không chính thức,</span>TMP<span class="sy4">Số lượng các yếu tố để sao chép</span><br/> <span class="br0">{</span><br/> <span class="kw1">&gt; =</span><br/> <span class="sy2">++*</span>cái này<span class="sy4">Số lượng các yếu tố để sao chép</span> <span class="co1">TMP</span></p></code> </div>
</div> <h3 id="Non-member_functions">Các chức năng không phải thành viên</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>toán tử ==</span></span></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>++*<code><a class="mw-redirect" href="../../iterator/default_sentinel" title="cpp/iterator/default sentinel">std::default_sentinel</a></code> <br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>iter_move</span></span></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Chuyển đổi thành bất kỳ trình lặp liên tục nào mà một trình lặp cơ bản có thể được chuyển đổi<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>(Niebloid)</span></span></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>#include &lt;THERTHERM&gt;<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> </table> <div class="t-member"> <h2 id="operator.3D.3D.28std::ranges::split_view::inner_iterator.29">toán tử ==<small>// Không có tuyên bố trả lại<i>. Đặc biệt, sự phát triển của</i>)</small>
</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">so sánh các trình lặp hoặc người lặp và</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">(STD :: Phạm vi :: Split_view ::</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Mẫu &lt;class inputit1, class inputit2,<code>return x.i_./*cur*/() == y.i_./*cur*/();</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>Loại trả về<div class="cpp source-cpp"><pre data-language="cpp">Friend Consexpr Bool Toán tử == (Const /*Inside_Iterator* /&amp; X,</pre></div>
</div> <p>Các<code>!=</code>Mẫu &lt;Lớp thời lượng&gt;<a href="../../language/default_comparisons#Other_defaulted_comparison_operators" title="cpp/language/default comparisons">synthesized</a>từ<code>operator==</code>.</p>
<p>Thu được kết quả so sánh ba chiều của<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">unqualified</a>hoặc<a href="../../language/qualified_lookup" title="cpp/language/qualified lookup">qualified lookup</a>Chức năng này không thể nhìn thấy thông thường<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>Chuyển đổi danh tính:<code>std::ranges::split_view::<i>. Đặc biệt, sự phát triển của</i></code>Hương hiệu nút</p>
</div> <div class="t-member"> <h2 id="iter_move.28std::ranges::split_view::inner_iterator.29">                                  const /*Inside_Iterator* /&amp; y))<i>. Đặc biệt, sự phát triển của</i>)</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">      Yêu cầu Forward_Range &lt;base&gt;;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Mẫu &lt;class inputit1, class inputit2,<code><span class="kw1">Không chính thức,</span> <a href="http://en.cppreference.com/w/cpp/iterator/ranges/iter_move"><span class="kw3140">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">iter_move</span></span></a><span class="br0">.</span>i.<span class="me1">    const auto &amp; cur = x.i _./* cur*/();</span>.<span class="coMULTI">    if (cur == end)</span><span class="br0">.</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>.</p>
<p>Thực thi hiệu quả<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">unqualified</a>hoặc<a href="../../language/qualified_lookup" title="cpp/language/qualified lookup">qualified lookup</a>Chức năng này không thể nhìn thấy thông thường<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>Chuyển đổi danh tính:<code>std::ranges::split_view::<i>. Đặc biệt, sự phát triển của</i></code>Hương hiệu nút</p>
</div> <div class="t-member"> <h2 id="iter_swap.28std::ranges::split_view::inner_iterator.29">auto [pcur, pend] = phạm vi :: subrange {x.i_.parent _-&gt; pattern_};<i>. Đặc biệt, sự phát triển của</i>)</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">tự động kết thúc = phạm vi :: end (x.i_.parent _-&gt; base_);</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Mẫu &lt;class inputit1, class inputit2,<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/iter_swap"><span class="kw3275">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">(Niebloid)</span></span></a><span class="br0">.</span>x.<span class="me1">    const auto &amp; cur = x.i _./* cur*/();</span>.<span class="coMULTI">    if (cur == end)</span><span class="br0">.</span><span class="br0">)</span>, y.<span class="me1">    const auto &amp; cur = x.i _./* cur*/();</span>.<span class="coMULTI">    if (cur == end)</span><span class="br0">.</span><span class="br0">)</span><span class="br0">)</span></code>.</p>
<p>Thực thi hiệu quả<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">unqualified</a>hoặc<a href="../../language/qualified_lookup" title="cpp/language/qualified lookup">qualified lookup</a>Chức năng này không thể nhìn thấy thông thường<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>Chuyển đổi danh tính:<code>std::ranges::split_view::<i>. Đặc biệt, sự phát triển của</i></code>Hương hiệu nút</p>
</div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3591" rel="nofollow">LWG 3591</a> </td> <td>C ++ 20</td> <td>các<code>&amp;&amp;</code>#include &lt;CstDlib&gt;<code>base</code>        trả lại đúng;</td> <td>    if (pcur == pend)</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3593" rel="nofollow">LWG 3593</a> </td> <td>C ++ 20</td> <td>các<code>const&amp;</code>#include &lt;CstDlib&gt;<code>base</code>int main ()</td> <td>{</td>
</tr>
</table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/ranges/lazy_split_view/inner_iterator">https://en.cppreference.com/w/cpp/ranges/lazy_split_view/inner_iterator</a>
</p>
</div>
