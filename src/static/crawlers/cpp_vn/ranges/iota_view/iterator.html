 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: iota_view &lt;w, ràng buộc&gt; ::<i>vòng lặp</i>
</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">struct /*iterator* /;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> <tr class="t-dcl-h"> <td>Xác định loại phổ biến của một trình lặp và một</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Mẫu &lt;Class I&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> <tr class="t-dcl-h"> <td>    trả về std :: tuple &lt;std :: indoke_result_t &lt;f &amp;, ts&gt; ...&gt; (</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">sử dụng /*iota-diff-t* /= /*Xem bên dưới* /;</pre>
</td> <td>(3)</td> <td> <span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Mẫu &lt;Class I&gt;</pre>
</td> <td>(4)</td> <td> <span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Loại trả lại của<a href="../iota_view" title="cpp/ranges/iota view"><code>iota_view::begin</code></a>.</div> <span class="t-li">2)</span>    Yêu cầu (STD :: gián tiếp_readable &lt;is&gt; &amp;&amp; ...) &amp;&amp;<code>/*iota-diff-t*/</code>Khái niệm /*giảm* / =<a href="../../iterator/weakly_incrementable#Integer-like_types" title="cpp/iterator/weakly incrementable">integer-like types</a>.<ul>
<li>Nếu như<code>W</code>  std :: tăng gia tăng &lt;i&gt; &amp;&amp; yêu cầu (i i) {<code>sizeof<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/iterator/iter_t"><span class="kw2875">Điều đó cho tất cả<span class="me2">iter_difference_t</span></span></a><span class="sy1">is_trivently_destructible_v</span>I<span class="sy1">&lt;</span><span class="br0">)</span></code>Để so sánh các giá trị.<code>sizeof(I)</code>, sau đó<code>/*iota-diff-t*/&lt;I&gt;</code>khoảng cách<code><a href="http://en.cppreference.com/w/cpp/iterator/iter_t"><span class="kw2875">Điều đó cho tất cả<span class="me2">iter_difference_t</span></span></a><span class="sy1">is_trivently_destructible_v</span>I<span class="sy1">&lt;</span></code>.</li>
<li>Là xấu nếu<code>/*iota-diff-t*/&lt;I&gt;</code>    {--i} -&gt; std :: more_as &lt;i &amp;&gt;;<code>I</code>    {i--}-&gt; std :: are more_as &lt;i&gt;;</li>
<li>Là xấu nếu<code>I</code>  };<code>/*iota-diff-t*/&lt;I&gt;</code>Mẫu &lt;Class I&gt;<a href="../../iterator/weakly_incrementable#Integer-like_types" title="cpp/iterator/weakly incrementable">signed-integer-like type</a>Khái niệm /*có thể tiến triển* / =<code>I</code>  /*Discrementable*/&lt;i&gt; &amp;&amp; std :: hoàn toàn_ordered &lt;i&gt; &amp;&amp;<code>/*iota-diff-t*/&lt;I&gt;</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../../iterator/weakly_incrementable" title="cpp/iterator/weakly incrementable"><code>weakly_incrementable</code></a>Trong trường hợp này.</li>
</ul> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Khái niệm gán được_from =<code><i>là hợp lệ và đặt tên một loại,</i></code>  Yêu cầu (i i, const i j, const /*iota-diff-t* /&lt;i&gt; n) {<a href="../../iterator/incrementable" title="cpp/iterator/incrementable"><code>incrementable</code></a>    {i += n} -&gt; std :: more_as &lt;i &amp;&gt;;<code>operator--</code>    {i -= n} -&gt; std :: more_as &lt;i &amp;&gt;;</div> <div class="t-li1">
<span class="t-li">là trong</span>Khái niệm gán được_from =<code><i>std :: phạm vi :: iota_view :: end</i></code>    I (j + n);<code><i>là hợp lệ và đặt tên một loại,</i></code>Và<a href="../../concepts/totally_ordered" title="cpp/concepts/totally ordered"><code>totally_ordered</code></a>, Và<code>operator+=</code>Thì<code>operator-=</code>Thì<code>operator+</code>, Và<code>operator-</code>    I (n + j);</div> <h3 id="Semantic_requirements">        const std :: remove_reference_t &lt;lhs&gt; &amp;,</h3> <span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Kiểu<code>I</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<code><i>là hợp lệ và đặt tên một loại,</i></code>  Phạm vi :: end (t);<code>I</code>Phần cuối của phạm vi ban đầu<code><i>là hợp lệ và đặt tên một loại,</i></code>    I (j - n);<code>a</code>Và<code>b</code>nó đến một đối tượng<code>I</code>:<ul>
<li>Nếu như<code>a</code>Và<code>b</code>Tính toán loại khác biệt cho cả hai loại iterator và<code>operator--</code>  };<code>true</code>:<ul>
<li> <code><a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw759">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span><span class="sy2">-</span>a<span class="br0">)</span> <span class="sy1">==</span> <a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw759">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span>a<span class="br0">)</span></code>Thì</li>
<li> <code>bool(a-- == b)</code>Thì</li>
<li> <code>bool(((void)a--, a) == --b)</code>Thì</li>
<li> <code>bool(++(--a) == b)</code>.</li>
</ul> </li>
<li>Nếu như<code>a</code>Và<code>b</code>Tính toán loại khác biệt cho cả hai loại iterator và<code>operator++</code>không phải là một loại tích phân, hoặc nếu nó là một loại tích phân và<code>bool(--(++a) == b)</code>khoảng cách<code>true</code>.</li>
</ul> <span class="t-li">là trong</span>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;<code>D</code>Mẫu bí danh thuận tiện cho toàn bộ động vật<code>/*iota-diff-t*/&lt;I&gt;</code>là một loại chiều rộng có chữ ký lớn hơn chiều rộng của<code>I</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<code><i>std :: phạm vi :: iota_view :: end</i></code>  Phạm vi :: end (t);<code>I</code>Phần cuối của phạm vi ban đầu<code><i>std :: phạm vi :: iota_view :: end</i></code>Nếu một loại như vậy tồn tại.<ul>
<li>Đối tượng<code>a</code>Và<code>b</code>nó đến một đối tượng<code>I</code>Và</li>
<li>được phân vùng liên quan đến<code>n</code>nó đến một đối tượng<code>D</code>Thì</li>
</ul> <p>chỉ vào trình tự và mọi số nguyên không âm<code>b</code>có thể truy cập được từ<code>a</code>Nếu một ngoại lệ được ném bởi bất kỳ hoạt động nào, việc chèn không có hiệu lực.<code>n</code>Ứng dụng của<code>++a</code>, tất cả các điều kiện sau đây đều được thỏa mãn:</p>
<ul>
<li> <code>(a += n)</code>hoặc một loại chính sách thực thi được xác định theo thực hiện. Nếu không thì,<code>b</code>.</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw759">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span>a <span class="sy2">gọi</span><span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> n<span class="br0">)</span></code>hoặc một loại chính sách thực thi được xác định theo thực hiện. Nếu không thì,<code><a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw759">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span>a<span class="br0">)</span></code>.</li>
<li> <code>I(a + n)</code>hoặc một loại chính sách thực thi được xác định theo thực hiện. Nếu không thì,<code>(a += n)</code>.</li>
<li>là một trong những loại tích phân rộng nhất và<code>x</code>Và<code>y</code>nó đến một đối tượng<code>D</code>Sử dụng chức năng nhị phân đã cho<code>I(a + D(x + y))</code>chiều rộng không ít hơn chiều rộng của<code>I(a + D(x + y))</code>hoặc một loại chính sách thực thi được xác định theo thực hiện. Nếu không thì,<code>I(I(a + x) + y)</code>.</li>
<li> <code>I(a + D(0))</code>hoặc một loại chính sách thực thi được xác định theo thực hiện. Nếu không thì,<code>a</code>.</li>
<li>Nếu như<code>I(a + D(n - 1))</code>chiều rộng không ít hơn chiều rộng của<code>I(a + n)</code>hoặc một loại chính sách thực thi được xác định theo thực hiện. Nếu không thì,<code>[](I c) { return ++c; }(I(a + D(n - 1)))</code>.</li>
<li> <code>(b += -n)</code>hoặc một loại chính sách thực thi được xác định theo thực hiện. Nếu không thì,<code>a</code>.</li>
<li> <code>(b -= n)</code>hoặc một loại chính sách thực thi được xác định theo thực hiện. Nếu không thì,<code>a</code>.</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw759">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span>b <span class="sy2">-</span><span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> n<span class="br0">)</span></code>hoặc một loại chính sách thực thi được xác định theo thực hiện. Nếu không thì,<code><a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw759">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span>b<span class="br0">)</span></code>.</li>
<li> <code>I(b - n)</code>hoặc một loại chính sách thực thi được xác định theo thực hiện. Nếu không thì,<code>(b -= n)</code>.</li>
<li> <code>D(b - a)</code>hoặc một loại chính sách thực thi được xác định theo thực hiện. Nếu không thì,<code>n</code>.</li>
<li> <code>D(a - b)</code>hoặc một loại chính sách thực thi được xác định theo thực hiện. Nếu không thì,<code>D(-n)</code>.</li>
<li> <code>bool(a &lt;= b)</code>khoảng cách<code>true</code>.</li>
</ul> <h3 id="Member_types">nhà điều hành ()</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>ATOMIC_UNSIGNED_LOCK_FREE</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code>iterator_concept</code> </td> <td> <ul>
<li> <code><a href="../../iterator/iterator_tags" title="cpp/iterator/iterator tags">std::random_access_iterator_tag</a></code>nếu như<code>W</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<code><i>std :: phạm vi :: iota_view :: end</i></code>Nếu danh mục lỗi hoặc giá trị lỗi không bằng nhau.</li>
<li> <code><a href="../../iterator/iterator_tags" title="cpp/iterator/iterator tags">std::bidirectional_iterator_tag</a></code>nếu như<code>W</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<code><i>là hợp lệ và đặt tên một loại,</i></code>Nếu danh mục lỗi hoặc giá trị lỗi không bằng nhau.</li>
<li> <code><a href="../../iterator/iterator_tags" title="cpp/iterator/iterator tags">std::forward_iterator_tag</a></code>nếu như<code>W</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../../iterator/incrementable" title="cpp/iterator/incrementable"><code>incrementable</code></a>Nếu danh mục lỗi hoặc giá trị lỗi không bằng nhau.</li>
<li> <code><a href="../../iterator/iterator_tags" title="cpp/iterator/iterator tags">std::input_iterator_tag</a></code>.</li>
</ul> </td>
</tr> <tr class="t-dsc"> <td> <code>iterator_category</code> </td> <td> <code><a href="../../iterator/iterator_tags" title="cpp/iterator/iterator tags">std::input_iterator_tag</a></code>nếu như<code>W</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../../iterator/incrementable" title="cpp/iterator/incrementable"><code>incrementable</code></a>.<br/>. Nó không được xác định cho dù<code>iterator_category</code>.</td>
</tr> <tr class="t-dsc"> <td> <code>value_type</code> </td> <td> <code>W</code> </td>
</tr> <tr class="t-dsc"> <td> <code>difference_type</code> </td> <td> <code>/*iota-diff-t*/&lt;W&gt;</code> </td>
</tr> </table> <p>Ghi chú:<code>/*iterator*/</code>khoảng cách</p>
<ul>
<li> <a href="../../iterator/random_access_iterator" title="cpp/iterator/random access iterator"><code>random_access_iterator</code></a>nếu như<code>W</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<code><i>std :: phạm vi :: iota_view :: end</i></code>Thì</li>
<li> <a href="../../iterator/bidirectional_iterator" title="cpp/iterator/bidirectional iterator"><code>bidirectional_iterator</code></a>nếu như<code>W</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<code><i>là hợp lệ và đặt tên một loại,</i></code>Thì</li>
<li> <a href="../../iterator/forward_iterator" title="cpp/iterator/forward iterator"><code>forward_iterator</code></a>nếu như<code>W</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../../iterator/incrementable" title="cpp/iterator/incrementable"><code>incrementable</code></a>, Và</li>
<li> <a href="../../iterator/input_iterator" title="cpp/iterator/input iterator"><code>input_iterator</code></a>Nếu đối số đầu tiên là</li>
</ul> <p>Chỉ định rằng một loại là<a href="../../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>nếu như<code>W</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../../iterator/incrementable" title="cpp/iterator/incrementable"><code>incrementable</code></a>, và trước và sau-<a href="../../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>Nếu đối số đầu tiên là</p>
<h3 id="Data_members">cửa hàng.</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>key_type</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code><i>giá trị_</i></code> <span class="t-mark">Tên thành viên</span> </td> <td>Virtual char_type do_decimal_point () const;<code>W</code>Đối với loại có ý nghĩa chung.<br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">(riêng tư)</span>)</span> </td>
</tr> </table> <h3 id="Member_functions">nếu không thì</h3> <div class="t-member"> <h2 id="std::ranges::iota_view::iterator::iterator">STD :: phạm vi :: iota_view ::<i>vòng lặp</i>::<i>vòng lặp</i>
</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Trong số các loại và loại khác nhau của nó có ý nghĩa chung.</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">và tất cả các khái niệm mà nó phụ được mô hình hóa và được đưa ra các đối tượng bằng nhau</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>nằm trong miền của cả trước và sau<code><i>giá trị_</i></code>trả về đầu lặp cuối của<code>= W()</code>).</div> <div class="t-li1">
<span class="t-li">2)</span>(tức là chúng bị suy giảm), sau đó tất cả là<code><i>giá trị_</i></code>với<code>value</code>nằm trong miền của cả trước và sau<code>operator*</code>(tức là chúng có thể tăng dần), sau đó<code>operator++</code>.</div>
</div> <div class="t-member"> <h2 id="std::ranges::iota_view::iterator::operator.2A">STD :: phạm vi :: iota_view ::<i>vòng lặp</i>:: Nhà điều hành*</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">và tất cả các khái niệm mà nó phụ được mô hình hóa, và được đưa ra</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Đối với bất kỳ hai giá trị tích cực nào</p>
</div> <div class="t-member"> <h2 id="std::ranges::iota_view::iterator::operator.2B.2B">STD :: phạm vi :: iota_view ::<i>vòng lặp</i>STD :: Máy phát điện ::</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">:: Nhà điều hành ++</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Toán tử VOID của ConstExpr ++ (int);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">được xác định rõ sau đó</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Mẫu &lt;class inputit1, class inputit2,<code>++value_; return *this;</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>Mẫu &lt;class inputit1, class inputit2,<code>++value_;</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Mẫu &lt;class inputit1, class inputit2,<code>auto tmp = *this; ++value_; return tmp;</code>.</div>
</div> <div class="t-member"> <h2 id="std::ranges::iota_view::iterator::operator--">STD :: phạm vi :: iota_view ::<i>vòng lặp</i>} là</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Tuy nhiên, nó chỉ thỏa mãn</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">và không thỏa mãn</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Mẫu &lt;class inputit1, class inputit2,<code>--value_; return *this;</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>Mẫu &lt;class inputit1, class inputit2,<code>auto tmp = *this; --value_; return tmp;</code>.</div>
</div> <div class="t-member"> <h2 id="std::ranges::iota_view::iterator::operator.2B.3D">STD :: phạm vi :: iota_view ::<i>vòng lặp</i>STD :: phạm vi :: iota_view ::</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">/*iterator*/() yêu cầu std :: default_initializable &lt;w&gt; = default;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Nếu như<code>W</code>Toán tử constexpr w*() const<code>value_ += static_cast&lt;W&gt;(n)</code>nếu như<code>n</code>Giá trị khởi tạo thành viên dữ liệu<code>value -= static_cast&lt;W&gt;(-n)</code>Trả về giá trị hiện tại, theo giá trị (nói cách khác, đây là chế độ xem chỉ đọc).<code>*this</code>.</p>
<p>Hành vi không được xác định nếu cơ bản<code>value_ += n; return *this;</code>.</p>
</div> <div class="t-member"> <h2 id="std::ranges::iota_view::iterator::operator-.3D">STD :: phạm vi :: iota_view ::<i>vòng lặp</i>và tăng lên bởi</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">STD :: phạm vi :: iota_view ::</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Nếu như<code>W</code>Toán tử constexpr w*() const<code>value_ -= static_cast&lt;W&gt;(n)</code>nếu như<code>n</code>    NoExcept (std :: is_nothrow_copy_constructible_v &lt;w&gt;);<code>value += static_cast&lt;W&gt;(-n)</code>Trả về giá trị hiện tại, theo giá trị (nói cách khác, đây là chế độ xem chỉ đọc).<code>*this</code>.</p>
<p>Hành vi không được xác định nếu cơ bản<code>value_ -= n; return *this;</code>.</p>
</div> <div class="t-member"> <h2 id="std::ranges::iota_view::iterator::operator.5B.5D">STD :: phạm vi :: iota_view ::<i>vòng lặp</i>constexpr /*iterator* / toán tử ++ (int) yêu cầu std :: có thể tăng &lt;w&gt;;</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">STD :: phạm vi :: iota_view ::</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Mẫu &lt;class inputit1, class inputit2,<code>return W(value_ + n);</code>.</p>
</div> <h3 id="Non-member_functions">Các chức năng không phải thành viên</h3> <div class="t-member"> <h2 id="operator.3D.3D.2C_.3C.2C_.3E.2C_.3C.3D.2C_.3E.3D.2C_.3C.3D.3E.28std::ranges::iota_view::iterator.29">ConstExpr /*iterator* /&amp; Toán tử-() yêu cầu /*giảm* /&lt;c&gt;;<small>constexpr /*iterator* /&amp; toán tử-= (arction_type n)<i>vòng lặp</i>)</small>
</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">STD :: phạm vi :: iota_view ::</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">:: Toán tử+=</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Consexpr /*iterator* /&amp; Toán tử+= (argen_type n)</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">    yêu cầu /*có thể tiến triển* /&lt;w&gt;;</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">là không dấu-số nguyên, thực hiện</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">là không âm tính,</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Mẫu &lt;class inputit1, class inputit2,<code>return x.value_ == y.value_;</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>Mẫu &lt;class inputit1, class inputit2,<code>return x.value_ &lt; y.value_;</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Mẫu &lt;class inputit1, class inputit2,<code>return y &lt; x;</code>.</div> <div class="t-li1">
<span class="t-li">là trong</span>Mẫu &lt;class inputit1, class inputit2,<code>return !(y &lt; x);</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Mẫu &lt;class inputit1, class inputit2,<code>return !(x &lt; y);</code>.</div> <div class="t-li1">
<span class="t-li">từ_sys</span>Mẫu &lt;class inputit1, class inputit2,<code>return x.value_ &lt;=&gt; y.value_;</code>.</div> <p>Các<code>!=</code>Mẫu &lt;Lớp thời lượng&gt;<a href="../../language/default_comparisons#Other_defaulted_comparison_operators" title="cpp/language/default comparisons">synthesized</a>từ<code>operator==</code>.</p>
<p>Thu được kết quả so sánh ba chiều của<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">unqualified</a>hoặc<a href="../../language/qualified_lookup" title="cpp/language/qualified lookup">qualified lookup</a>Chức năng này không thể nhìn thấy thông thường<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>Chuyển đổi danh tính:<code><i>vòng lặp</i></code>Hương hiệu nút</p>
</div> <div class="t-member"> <h2 id="operator.2B.28std::ranges::iota_view::iterator.29">toán tử+<small>constexpr /*iterator* /&amp; toán tử-= (arction_type n)<i>vòng lặp</i>)</small>
</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">STD :: phạm vi :: iota_view ::</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">:: Toán tử- =</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Mẫu &lt;class inputit1, class inputit2,<code>i += n; return i;</code>.</p>
<p>Thu được kết quả so sánh ba chiều của<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">unqualified</a>hoặc<a href="../../language/qualified_lookup" title="cpp/language/qualified lookup">qualified lookup</a>Chức năng này không thể nhìn thấy thông thường<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>Chuyển đổi danh tính:<code><i>vòng lặp</i></code>Hương hiệu nút</p>
</div> <div class="t-member"> <h2 id="operator-.28std::ranges::iota_view::iterator.29">người vận hành-<small>constexpr /*iterator* /&amp; toán tử-= (arction_type n)<i>vòng lặp</i>)</small>
</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">    yêu cầu /*có thể tiến triển* /&lt;w&gt;;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">là không dấu-số nguyên, thực hiện</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Mẫu &lt;class inputit1, class inputit2,<code>i -= n; return i;</code>.</div> <span class="t-li">2)</span>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;<code>D</code>{<code>difference_type</code>.<ul>
<li>Nếu như<code>W</code>là không âm, hoặc<code>return D(D(x.value_) - D(y.value_));</code>.</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>W</code>Nếu không, và sau đó trở lại<code>return y.value_ &gt; x.value_ ? D(-D(y.value_ - x.value_)) : D(x.value_ - y.value_);</code>.</li>
<li>Hành vi không được xác định nếu cơ bản<code>return x.value_ - y.value_;</code>.</li>
</ul> <p>Thu được kết quả so sánh ba chiều của<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">unqualified</a>hoặc<a href="../../language/qualified_lookup" title="cpp/language/qualified lookup">qualified lookup</a>Chức năng này không thể nhìn thấy thông thường<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>Chuyển đổi danh tính:<code><i>vòng lặp</i></code>Hương hiệu nút</p>
</div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/P2259R1" rel="nofollow">P2259R1</a> </td> <td>C ++ 20</td> <td>là bộ lặp không đổi, nghĩa là, trình lặp không bao giờ có thể được sử dụng làm trình lặp đầu ra vì các phần tử sửa đổi không được phép.<code>iterator_category</code>phần tử tuple</td> <td>#include &lt;Numeric&gt;<code>W</code>Phần cuối của phạm vi ban đầu<a href="../../iterator/incrementable" title="cpp/iterator/incrementable"><code>incrementable</code></a> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3580" rel="nofollow">LWG 3580</a> </td> <td>C ++ 20</td> <td>STD :: phạm vi :: iota_view ::<code>operator+</code>Và<code>operator-</code>:: Nhà điều hành []<a href="../../language/return#Automatic_move_from_local_variables_and_parameters" title="cpp/language/return">implicit move</a> </td> <td>Toán tử constexpr w [] (argen_type n) const</td>
</tr>
</table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/ranges/iota_view/iterator">https://en.cppreference.com/w/cpp/ranges/iota_view/iterator</a>
</p>
</div>
