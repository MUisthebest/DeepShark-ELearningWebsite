 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: subrange &lt;i, s, k&gt; :: cặp điều hành</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt; / * Xem bên dưới * / Pairlike&gt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-h"> <td>    trả về std :: tuple &lt;std :: indoke_result_t &lt;f &amp;, ts&gt; ...&gt; (</td> <td></td> <td></td> </tr> <tr class="t-dcl t-until-cxx23"> <td> <pre data-language="cpp">    Yêu cầu cặp giống như con quay giống như-prom &lt;cặp, const i &amp;, const s &amp;&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span> <br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(3)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx23"> <td><pre data-language="cpp">Consexpr Toán tử giống như () const;</pre></td> <td>
<span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span> <br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span>
</td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> <br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Yêu cầu STD :: Convertible_to &lt;Const I &amp;, I2&gt;<code>subrange</code>Khái niệm giống như cặp =<span class="t-rev-inl t-until-cxx23"><span>    ! std :: is_reference_v &lt;t&gt; &amp;&amp; yêu cầu (t t) {<code><i>    std :: constructible_from &lt;t, u, v&gt; &amp;&amp;</i></code>                                           // hoàn thành</span><span><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></span></span><span class="t-rev-inl t-since-cxx23"><span><a href="../../utility/tuple/tuple-like" title="cpp/utility/tuple/tuple-like"><code>pair-like</code></a></span><span><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></span></span>        Yêu cầu STD :: DOIVED_FROM &lt;STD :: TUPLE_SIZE &lt;T&gt;,<code>return PairLike(i_, s_);</code>là<code><i>    const auto &amp; cur = x.i _./* cur*/();</i></code>Và<code><i>                                   std :: integral_constant &lt;std :: size_t, 2 &gt;&gt;;</i></code>        Tên std :: tuple_element_t &lt;0, std :: remove_const_t &lt;t&gt;&gt;;</div> <div class="t-li1">
<code>PairLike</code>        Tên std :: tuple_element_t &lt;1, std :: remove_const_t &lt;t&gt;&gt;;<code><a href="http://en.cppreference.com/w/cpp/concepts/same_as"><span class="kw2933">Điều đó cho tất cả<span class="me2">    c == D;           // Biểu thức số 1: Không sửa đổi các toán hạng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2644">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>PairLike<span class="sy1">&lt;</span>, subrange<span class="sy1">&lt;</span></code>khoảng cách<code>false</code>.</div> <div class="t-li1">        {std :: get &lt;0&gt; (t)} -&gt; std :: muiverbleble_to &lt;<code><i>                                  const std :: tuple_element_t &lt;0, t&gt; &amp;&gt;;</i></code>Đó là hành vi không xác định để khai báo chuyên môn đầy đủ hoặc một phần của bất kỳ mẫu biến thư viện tiêu chuẩn nào, ngoại trừ khi được phép rõ ràng.</div> <div class="t-li1">
<span class="t-li">2)</span>Mẫu &lt;Class B&gt;<code><i>    std :: constructible_from &lt;t, u, v&gt; &amp;&amp;</i></code>                                  const std :: tuple_element_t &lt;1, t&gt; &amp;&gt;;<code>e</code>    };<a href="../../language/structured_binding" title="cpp/language/structured binding">structured binding</a>biểu thị<code>auto const&amp; [x, y] = e;</code>Mẫu &lt;class t, class u, class v&gt;<span class="t-rev-inl t-since-cxx23"><span>Khái niệm giống như-converbleble-prom-from =<a href="../../utility/tuple/tuple-like" title="cpp/utility/tuple/tuple-like"><code>pair-like</code></a>.</span><span><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></span></span>
</div> <span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Mẫu &lt;Class B&gt;<code><i>    ! phạm vi :: phạm vi &lt;t&gt; &amp;&amp; cặp giống như &lt;t&gt; &amp;&amp;</i></code>    Khái niệm hai chiều_iterator =<code><i>    std :: constructible_from &lt;t, u, v&gt; &amp;&amp;</i></code>    Convertible-to-non-sliging &lt;u, std :: tuple_element_t &lt;0, t &gt;&gt; &amp;&amp;<ul>
<li>  ((phạm vi :: Xem &lt;std :: remove_cvref_t &lt;t &gt;&gt; &amp;&amp;<span class="t-rev-inl t-since-cxx23"><span>    std :: muiverble_to &lt;v, std :: tuple_element_t &lt;1, t &gt;&gt;;</span><span><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></span></span><a href="../range" title="cpp/ranges/range"><code>range</code></a>            Tên std :: iter_difference_t &lt;i&gt;;</li>
<li>Mẫu &lt;class t, class u, class v&gt;<code>U</code>Và<code>V</code>Khái niệm giống như-converbleble-prom-from =<code>T</code>              STD :: Dự kiến ​​&lt;i2, proj2 &gt;&gt; comp = phạm vi :: Ít hơn&gt;</li>
<li>    ! phạm vi :: phạm vi &lt;t&gt; &amp;&amp;! std :: is_reference_v &lt;t&gt; &amp;&amp; cặp giống như &lt;t&gt; &amp;&amp;<code>U</code>    std :: constructible_from &lt;t, u, v&gt; &amp;&amp;<code>const I&amp;</code>    Convertible-to-non-sliging &lt;u, std :: tuple_element_t &lt;0, t &gt;&gt; &amp;&amp;<a href="subrange" title="cpp/ranges/subrange/subrange"><code>convertible-to-non-slicing</code></a>).</li>
</ul> <h3 id="Parameters">) với giá trị ban đầu</h3> <p>Gán cho đã cho</p>
<h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>MỘT<code>PairLike</code>    std :: muiverble_to &lt;v, std :: tuple_element_t &lt;1, t &gt;&gt;;</p>
<h3 id="Notes">Ghi chú</h3> <p>theo loại giống như cặp (nghĩa là một kiểu mẫu</p>
<ul>
<li> <a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1099">Điều đó cho tất cả<span class="me2">đôi</span></span></a><span class="sy1">is_trivently_destructible_v</span>Loại tham chiếu chung<span class="sy1">&lt;</span> </li>
<li> <a href="http://en.cppreference.com/w/cpp/utility/tuple"><span class="kw1101">Điều đó cho tất cả<span class="me2">Tuple</span></span></a><span class="sy1">is_trivently_destructible_v</span>Loại tham chiếu chung<span class="sy1">&lt;</span> </li>
<li> <a href="http://en.cppreference.com/w/cpp/container/array"><span class="kw1271">Điều đó cho tất cả<span class="me2">Mảng</span></span></a><span class="sy1">is_trivently_destructible_v</span>một thùng chứa khác để hợp nhất<span class="nu0">    return (! (đầu tiên == cuối cùng) và! (giá trị &lt; *đầu tiên));</span><span class="sy1">&lt;</span> </li>
<li>STD<span class="sy4">::</span><a href="http://en.cppreference.com/w/cpp/ranges/subrange"><span class="kw2910">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    find_end (r1 &amp;&amp; r1, r2 &amp;&amp; r2, pre pre = {},</span></span></a><span class="sy1">is_trivently_destructible_v</span>Khái niệm người trợ giúp<span class="sy1">&lt;</span> </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx23">
<td> <p>giống như cặp</p>
<ul>
<li> <a href="../../utility/tuple_size" title="cpp/utility/tuple size"><code>std::tuple_size</code></a>Và<a href="../../utility/tuple_element" title="cpp/utility/tuple element"><code>std::tuple_element</code></a>được xác định dưới đây</li>
<li>các thùng chứa không có thứ tự để so sánh<code><a href="http://en.cppreference.com/w/cpp/utility/variant/get"><span class="kw3217">Điều đó cho tất cả<span class="me2">Điền vào thùng chứa với giá trị được chỉ định</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="nu0">. Không làm gì khác.</span><span class="sy1">&lt;</span></code>Và<code><a href="http://en.cppreference.com/w/cpp/utility/variant/get"><span class="kw3217">Điều đó cho tất cả<span class="me2">Điền vào thùng chứa với giá trị được chỉ định</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="nu0">, nếu như</span><span class="sy1">&lt;</span></code>). Tương đương với</li>
</ul> </td> <td><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></td>
</tr> </table> <p>Từ<code>subrange</code>S_<a href="../range" title="cpp/ranges/range"><code>range</code></a>là người lặp được lưu trữ và sentinel tương ứng.</p>
<p><code><a href="../../container/array" title="cpp/container/array">std::array</a></code>bị hạn chế rằng<code>subrange</code>Hàm chuyển đổi này có các ràng buộc bổ sung được áp đặt bởi<a href="../range" title="cpp/ranges/range"><code>range</code></a>loại.</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Cặp đôi giống như có thể chuyển đổi</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">giống như cặp</pre></div> </div> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/ranges/subrange/operator_PairLike">https://en.cppreference.com/w/cpp/ranges/subrange/operator_PairLike</a>
</p>
</div>
