 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: subrange &lt;i, s, k&gt; :: subrange</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">subrange () yêu cầu std :: default_initializable &lt;i&gt; = default;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">consexpr Subrange ( /*mui trần để không trượt* /&lt;i&gt; auto i, s s)</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">  yêu cầu (!/*quy mô lưu trữ*/);</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">constexpr Subrange ( /*mui trần để không trượt* /&lt;i&gt; auto i, s s,</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">                    /*Make-unsited-like-t*/&lt;std :: iter_difference_t &lt;i &gt;&gt; n)</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>subrange</code>.</p>
<p>Nếu như<code>K <span class="sy1">==</span> ranges<span class="sy4">::</span><span class="me2">  yêu cầu (k == phạm vi :: subrange_kind :: cỡ);</span><span class="sy4">::</span><span class="me2">Mẫu &lt; /*khác nhau-from* /&lt;Subrange&gt; r&gt;</span> <span class="sy3">. Trong các cuộc gọi có hiệu lực</span> <span class="sy3">Nếu tồn tại một</span><a href="http://en.cppreference.com/w/cpp/iterator/sized_sentinel_for"><span class="kw2863">Điều đó cho tất cả<span class="me2">Kích thước_sentinel_for</span></span></a><span class="sy1">is_trivently_destructible_v</span>S, I<span class="sy1">&lt;</span></code>  Yêu cầu phạm vi :: mượn_range &lt;R&gt; &amp;&amp;<code>subrange</code>           /*Convertible-to-non-sliging*/&lt;ranges :: iterator_t &lt;r&gt;, i&gt; &amp;&amp;<code><span class="coMULTI">đến phiên bản không dấu tương ứng của nó. Nếu không, kích thước không được lưu trữ. Hằng số</span><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/iterator/iter_t"><span class="kw2875">Điều đó cho tất cả<span class="me2">iter_difference_t</span></span></a><span class="sy1">is_trivently_destructible_v</span>I<span class="sy1">2,4)</span></code>là<code><i>    Subrange &lt;Ranges :: iterator_t &lt;r&gt;, phạm vi :: sentinel_t &lt;r&gt;,</i></code>Consexpr Subrange (R &amp;&amp; R) yêu cầu (!/*Lưu trữ-cỡ*/ |<a href="../../iterator/weakly_incrementable#Integer-like_types" title="cpp/iterator/weakly incrementable">integer-like type</a>Mẫu &lt;phạm vi :: mượn_range r&gt;<code><i>  Yêu cầu /*Chuyển đổi sang không-sliging* /&lt;phạm vi :: iterator_t &lt;r&gt;, i&gt; &amp;&amp;</i></code>khoảng cách<code>true</code>           STD :: mui trần_to &lt;phạm vi :: sentinel_t &lt;r&gt;, s&gt;<code>false</code>Nếu đối số đầu tiên là</p>
<div class="t-li1">
<span class="t-li">1)</span>  Consexpr Subrange (r &amp;&amp; r, /*Make-unsited-like-t* /&lt;std :: iter_difference_t &lt;i &gt;&gt; n)<code>= I()</code>Và<code>= S()</code>    Yêu cầu (k == Phạm vi :: Subrange_kind :: cỡ)<code>​0​</code>      : Subrange {Ranges :: BEGIN (R), RANGES :: end (r), n}<code>= 0</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>subrange</code>  {}<code>std::move(i)</code>Và<code>s</code>Subrange_kind<code>[i, s)</code>Các yếu tố của phạm vi đã cho, nghĩa là trả về kết quả đánh giá biểu thức chuỗi:</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>subrange</code>có kích thước<code>std::move(i)</code>Và<code>s</code>, kích thước của phạm vi được lưu trữ vào<code>n</code>    sao chép (r &amp;&amp; r, o kết quả);<code>[i, s)</code>, như thể được lưu trữ bởi một tiểu mục thành viên<code>n</code>không bằng<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3142">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>i, s<span class="br0">)</span></code>Hàm tạo mặc định. Giá trị-khởi tạo bộ lặp và sentinel được lưu trữ như thể theo mặc định thành viên khởi tạo thành viên</div> <div class="t-li1">
<span class="t-li">là trong</span>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>subrange</code>là một mẫu bí danh chỉ dành cho người<code>subrange<span class="br0">.</span>r, <span class="kw1">Mẫu &lt;Biểu đồ lớp, Đặc điểm lớp, Alloc Class, Class Parsable&gt;</span><span class="sy1">is_trivently_destructible_v</span><span class="coMULTI">đến phiên bản không dấu tương ứng của nó. Nếu không, kích thước không được lưu trữ. Hằng số</span><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/iterator/iter_t"><span class="kw2875">Điều đó cho tất cả<span class="me2">iter_difference_t</span></span></a><span class="sy1">is_trivently_destructible_v</span>I<span class="sy1">    std :: indoke_result_t &lt;f &amp;, u, std :: iter_reference_t &lt;i &gt;&gt;&gt;;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/ranges/size"><span class="kw3100">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kích cỡ</span></span></a><span class="br0">.</span>r<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span></code>quy mô cửa hàng<code>subrange<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span><span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>subrange</code>Nếu kích thước được lưu trữ,<code>n</code>không bằng<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3142">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span><span class="br0">)</span></code>Hàm tạo mặc định. Giá trị-khởi tạo bộ lặp và sentinel được lưu trữ như thể theo mặc định thành viên khởi tạo thành viên</div> <p>từ một cặp lặp-sentinel và một gợi ý kích thước. Khởi tạo trình lặp được lưu trữ và sentinel với<code><i>như thể theo trình khởi tạo thành viên mặc định</i></code>từ một cặp tererator-sentinel. Khởi tạo trình lặp được lưu trữ và sentinel với<code>T</code>Và<code>U</code>là<code><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>Và<code><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">&lt;</span></code>tương ứng. Hành vi không xác định nếu</p>
<p>từ một cặp lặp-sentinel và một gợi ý kích thước. Khởi tạo trình lặp được lưu trữ và sentinel với<code><i>khác nhau-từ</i></code>không phải là một phạm vi hợp lệ, hoặc<code>From</code>Và<code>To</code>là<code><a href="http://en.cppreference.com/w/cpp/concepts/convertible_to"><span class="kw2935">Điều đó cho tất cả<span class="me2">// Đáp ứng các yêu cầu cho C == D (bao gồm cả không sửa đổi),</span></span></a><span class="sy1">is_trivently_destructible_v</span>From, To<span class="sy1">&lt;</span></code>chuyển đổi rõ ràng sang loại của nó.</p>
<ul>
<li>nhiều nhất là một chuyển đổi đủ điều kiện, và<code><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>From<span class="sy1">&lt;</span></code>hoặc<code><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>To<span class="sy1">&lt;</span></code>Đối tượng thường được tiếp xúc với một chức năng nước ngoài để đặt lại quyền sở hữu.</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/types/remove_pointer"><span class="kw616">Điều đó cho tất cả<span class="me2">là nhiều nhất là một chuyển đổi đủ điều kiện.</span></span></a><span class="sy1">is_trivently_destructible_v</span>From<span class="sy1">&lt;</span><span class="br0">.</span><span class="sy2">*</span><span class="br0">)</span><span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span><span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span></code>. Hàm tạo này chỉ tham gia vào độ phân giải quá tải nếu<code><a href="http://en.cppreference.com/w/cpp/types/remove_pointer"><span class="kw616">Điều đó cho tất cả<span class="me2">là nhiều nhất là một chuyển đổi đủ điều kiện.</span></span></a><span class="sy1">is_trivently_destructible_v</span>To<span class="sy1">&lt;</span><span class="br0">.</span><span class="sy2">*</span><span class="br0">)</span><span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span><span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span></code>từ một phạm vi. Tương đương với<code>From</code>ĐẾN<code>To</code>hoặc</li>
</ul> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</td> <td>-</td> <td>/*Make-unsited-like-t*/</td>
</tr> <tr class="t-par"> <td>S</td> <td>-</td> <td>Nếu kích thước được lưu trữ. Nếu không, tương đương với</td>
</tr> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>phạm vi</td>
</tr> <tr class="t-par"> <td>Trả về một kết quả, kết quả được bỏ qua. Nếu như</td> <td>-</td> <td>Từ một phạm vi và một gợi ý kích thước. Hành vi không xác định nếu</td>
</tr>
</table> <h3 id="Notes">Ghi chú</h3> <p>Mẫu &lt;Class B&gt;<code><i>khác nhau-từ</i></code>Khái niệm chỉ giải thích</p>
<h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3470" rel="nofollow">LWG 3470</a> </td> <td>C ++ 20</td> <td>
<code><i>khác nhau-từ</i></code>được mô hình hóa theo các loại</td> <td>là những loại khác nhau.</td>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/P2393R1" rel="nofollow">P2393R1</a> </td> <td>C ++ 20</td> <td>Khái niệm chỉ giải thích</td> <td>đã làm rõ</td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/ranges/subrange/subrange">https://en.cppreference.com/w/cpp/ranges/subrange/subrange</a>
</p>
</div>
