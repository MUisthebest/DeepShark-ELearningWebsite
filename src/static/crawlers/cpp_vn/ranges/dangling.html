 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: lơ lửng</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/ranges" title="cpp/header/ranges">&lt;ranges&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">cấu trúc lủng lẳng;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p><code>dangling</code>là loại trình giữ chỗ và loại lớp trống, được sử dụng cùng với các bí danh mẫu<a href="borrowed_iterator_t" title="cpp/ranges/borrowed iterator t"><code>ranges::borrowed_iterator_t</code></a>Và<a href="borrowed_iterator_t" title="cpp/ranges/borrowed iterator t"><code>ranges::borrowed_subrange_t</code></a>.</p>
<p>Khi một số<a href="../algorithm/ranges" title="cpp/algorithm/ranges">constrained algorithms</a>thường trả lại một tererator hoặc một subrange của một<a href="range" title="cpp/ranges/range"><code>range</code></a>lấy một rvalue cụ thể<code>range</code>Đối số không mô hình<a href="borrowed_range" title="cpp/ranges/borrowed range"><code>borrowed_range</code></a>Thì<code>dangling</code>Thay vào đó, sẽ được trả lại để tránh trả lại kết quả lủng lẳng.</p>
<h3 id="Member_functions">nếu không thì</h3> <div class="t-member"> <h2 id="std::ranges::dangling::dangling">std :: phạm vi :: lơ lửng :: lủng lẳng</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">Consexpr lalle () NoExcept = mặc định;</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Mẫu &lt;class ... args&gt;</pre>
</td> <td>(2)</td> <td class="t-dcl-nopad"> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span> <code>dangling</code>Constexpr lơ lửng (args &amp;&amp; ...) NoExcept {}</div> <div class="t-li1">
<span class="t-li">2)</span> <code>dangling</code>được xây dựng mặc định tầm thường.<p>có thể được xây dựng từ các đối số của số tùy ý và loại không độc hại tùy ý. Việc xây dựng không có bất kỳ tác dụng phụ nào.<code>dangling</code>Nói cách khác, sau khi thay thế loại (ví dụ: loại iterator) trong một khởi tạo không tổng hợp được hình thành tốt với</p>
</div>
</div> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">, khởi tạo kết quả cũng được hình thành tốt.</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">#include &lt;THERTHERM&gt;</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="borrowed_iterator_t" title="cpp/ranges/borrowed iterator t"> <span class="t-lines"><span>một loại trình giữ chỗ chỉ ra rằng một trình lặp hoặc một</span><span>không nên được trả lại vì nó sẽ bị treo lủng lẳng</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Phạm vi :: mượn_iterator_t<code>subrange</code>Phạm vi :: mượn_subrange_t<a href="borrowed_range" title="cpp/ranges/borrowed range"><code>borrowed_range</code></a><br/><span class="t-mark">(Mẫu bí danh)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="borrowed_range" title="cpp/ranges/borrowed range"> <span class="t-lines"><span>Chỉ định rằng một loại là một phạm vi, nghĩa là nó cung cấp một</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Iterator và một<a href="range" title="cpp/ranges/range"><code>range</code></a>Phạm vi :: mượn_range<br/> <span class="t-mark">(ý tưởng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/ranges/dangling">https://en.cppreference.com/w/cpp/ranges/dangling</a>
</p>
</div>
