 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: phạm vi</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/ranges" title="cpp/header/ranges">&lt;ranges&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Các<code>range</code>Khái niệm phạm vi = Yêu cầu (T &amp; T) {</p>
<h3 id="Semantic_requirements">        const std :: remove_reference_t &lt;lhs&gt; &amp;,</h3> <p>bao gồm tất cả các yếu tố của nó<code>E</code>  Phạm vi :: Bắt đầu (t); // bảo quản bình đẳng cho các trình rút tiền chuyển tiếp<span class="br0">.</span><span class="br0">.</span>E<span class="br0">)</span><span class="br0">)</span>khoảng cách<code>T</code>Thì<code>T</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<code>range</code>  Phạm vi :: end (t);</p>
<ul>
<li> <code>[</code><code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>E<span class="br0">)</span></code><code>, </code><code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>E<span class="br0">)</span></code><code>)</code>biểu thị a<a href="../iterator#Ranges" title="cpp/iterator">range</a>, Và</li>
<li>cả hai<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>E<span class="br0">)</span></code>Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>E<span class="br0">)</span></code>};<code>E</code>Khái niệm xác định các yêu cầu của một loại cho phép lặp qua các phần tử của nó bằng cách cung cấp một trình lặp và sentinel biểu thị các phần tử của phạm vi.<a href="../concepts#Equality_preservation" title="cpp/concepts">equality-preserving</a>như vậy mà từ chối</li>
<li>Chỉ khi<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>E<span class="br0">)</span></code>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../iterator/forward_iterator" title="cpp/iterator/forward iterator"><code>forward_iterator</code></a>Thì<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>E<span class="br0">)</span></code>khoảng cách<a href="../concepts#Equality_preservation" title="cpp/concepts">equality-preserving</a>được khấu hao vào thời gian không đổi và không làm thay đổi giá trị của</li>
</ul> <h3 id="Notes">Ghi chú</h3> <p>            {*i} -&gt; /*can -reference* /;<code>range</code>theo cách quan sát được</p>
<ol>
<li>(Nói cách khác, trình lặp chuyển tiếp hỗ trợ các thuật toán đa thông số).<code>begin()</code>Lớp chỉ cần cung cấp hai chức năng:<a href="../iterator/input_or_output_iterator" title="cpp/iterator/input or output iterator"><code>input_or_output_iterator</code></a>.</li>
<li>(Nói cách khác, trình lặp chuyển tiếp hỗ trợ các thuật toán đa thông số).<code>end()</code>Lớp chỉ cần cung cấp hai chức năng:<a href="../iterator/sentinel_for" title="cpp/iterator/sentinel for"><code>sentinel_for</code></a><code>&lt;It&gt;</code>là<code>It</code>là loại trả lại của<code>begin()</code>.</li>
</ol> <p>Một chức năng thành viên<a href="../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">mô hình loại trả lại của ai</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Một chức năng thành viên</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3915" rel="nofollow">LWG 3915</a> </td> <td>C ++ 20</td> <td>
<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>t<span class="br0">)</span></code>Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>t<span class="br0">)</span></code><br/>mô hình loại trả lại của ai</td> <td>void g2 () {f2 ({"foo", "thanh"}); } // chọn #4<br/>Ngoài ra, chúng có thể là các chức năng không phải thành viên, được tìm thấy bởi</td>
</tr>
</table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/ranges/range">https://en.cppreference.com/w/cpp/ranges/range</a>
</p>
</div>
