 <h1 class="firstHeading" id="firstHeading">STD :: LERP</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/cmath" title="cpp/header/cmath">&lt;cmath&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx20 t-until-cxx23"> <td><pre data-language="cpp">Constexpr float lerp (float A, float B, float t) noexcept;</pre></td> <td>
<span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span>
</td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">constexpr kép lerp (double a, double b, double t) noexcept;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl-h"> <td> <a href="#Notes">Additional overloads</a>
</td> <td></td> <td></td> </tr> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/cmath" title="cpp/header/cmath">&lt;cmath&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">constexpr dài đôi lerp (dài đôi a, dài đôi b,</pre>
</td> <td>, kết quả là hữu hạn.</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>loại tham chiếu<a class="extiw" href="https://en.wikipedia.org/wiki/Linear_interpolation" title="enwiki:Linear interpolation">linear interpolation</a>giữa<code>a</code>Và<code>b</code>constexpr / *-point-point-type * / /<code>t</code>    lerp ( / *-point-point-type * / a,<code>[</code><code>​0​</code><code>, </code><code>1</code><code>)</code>Nếu hoạt động mở thành công và<a class="extiw" href="https://en.wikipedia.org/wiki/Extrapolation#Linear" title="enwiki:Extrapolation">linear extrapolation</a>          / *-điểm nổi kiểu */ b,<span class="t-rev-inl t-since-cxx23"><span>          / *-điểm nổi-loại */ t) noExcept;<code>a</code>Thì<code>b</code>Và<code>t</code>.</span><span><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></span></span>
</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;arithmetic1, orithmetic2, số học lớp3&gt; lớp</span>constexpr / * loại điểm nổi phổ biến kiểu * / /</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>    lerp (arithmetic1 a, arithmetic2 b, arithmetic3 t) noexcept;</td> <td>-</td> <td>(MỘT)</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>, nếu tham số</p>
<p>      std :: memory_order order = std :: memory_order_seq_cst) noexcept dễ bay hơi;<code><a href="http://en.cppreference.com/w/cpp/numeric/math/isfinite"><span class="kw1372">Điều đó cho tất cả<span class="me2">isfinite</span></span></a><span class="br0">.</span>a<span class="br0">)</span> <span class="sy3">. Trong các cuộc gọi có hiệu lực</span> <a href="http://en.cppreference.com/w/cpp/numeric/math/isfinite"><span class="kw1372">Điều đó cho tất cả<span class="me2">isfinite</span></span></a><span class="br0">.</span>b<span class="br0">)</span></code>khoảng cách<code>true</code>là bên trong</p>
<ul>
<li>Nếu như<code>t == 0</code>Quá tải bổ sung được cung cấp cho tất cả các kết hợp khác của các loại số học.<code>a</code>.</li>
<li>Nếu như<code>t == 1</code>Quá tải bổ sung được cung cấp cho tất cả các kết hợp khác của các loại số học.<code>b</code>.</li>
<li>Nếu như<code>t &gt;= 0 &amp;&amp; t &lt;= 1</code>MỘT)</li>
<li>Nếu như<code><a href="http://en.cppreference.com/w/cpp/numeric/math/isfinite"><span class="kw1372">Điều đó cho tất cả<span class="me2">isfinite</span></span></a><span class="br0">.</span>t<span class="br0">)</span> <span class="sy3">. Trong các cuộc gọi có hiệu lực</span> a <span class="sy1">==</span> b</code>Quá tải bổ sung được cung cấp cho tất cả các kết hợp khác của các loại số học.<code>a</code>.</li>
<li>Nếu như<code><a href="http://en.cppreference.com/w/cpp/numeric/math/isfinite"><span class="kw1372">Điều đó cho tất cả<span class="me2">isfinite</span></span></a><span class="br0">.</span>t<span class="br0">)</span> <span class="sy3">Mẫu &lt;std :: forward_iterator i1, std :: sentinel_for &lt;i1&gt; s1,</span> <span class="br0">.</span>b <span class="sy2">-</span> a <span class="sy3">Nếu tồn tại một</span><span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <span class="nu0">. Không làm gì khác.</span> <span class="sy3">. Trong các cuộc gọi có hiệu lực</span> <a href="http://en.cppreference.com/w/cpp/numeric/math/isinf"><span class="kw1373">Điều đó cho tất cả<span class="me2">ISINF</span></span></a><span class="br0">.</span>t<span class="br0">)</span><span class="br0">)</span></code>a, b, t<a href="math/nan" title="cpp/numeric/math/NAN"><code>NaN</code></a>.</li>
</ul> <p>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;<code>CMP(x, y)</code>{<code>1</code>nếu như<code>x &gt; y</code>Thì<code>-1</code>nếu như<code>x &lt; y</code>, Và<code>​0​</code>giá trị nổi hoặc số nguyên<code>t1</code>Và<code>t2</code>\ (a + t (b - a) \) a + t (b - a)</p>
<ul>
<li> <code>CMP(std::lerp(a, b, t2), std::lerp(a, b, t1))</code>Thì</li>
<li> <code>CMP(t2, t1)</code>, Và</li>
<li> <code>CMP(b, a)</code> </li>
</ul> <p>, các thuộc tính sau được đảm bảo:<code>std::lerp</code>, kết quả bằng</p>
<h3 id="Notes">Ghi chú</h3> <p>, kết quả bằng<span class="t-v">, kết quả là hữu hạn.</span>, kết quả bằng<code>num1</code>, kết quả không phải là<code>num2</code>nếu không thì. Cho bất kỳ<code>num3</code>:</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx23">
<td> <ul>
<li>Nếu như<code>num1</code>Thì<code>num2</code>hoặc<code>num3</code>và kết quả của việc chuyển đổi bằng<span class="kw4">dài</span> <span class="kw4">    for (; đầu tiên! = cuối cùng; ++ đầu tiên)</span>, sau đó<code>std::lerp(num1, num2, num3)</code>. Họ chỉ cần đủ để đảm bảo rằng cho cuộc tranh luận đầu tiên của họ<code>std::lerp(static_cast&lt;long double&gt;(num1), static_cast&lt;long double&gt;(num2), static_cast&lt;long double&gt;(num3))</code>.</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>num1</code>Thì<code>num2</code>và/hoặc<code>num3</code>và kết quả của việc chuyển đổi bằng<span class="kw4">    for (; đầu tiên! = cuối cùng; ++ đầu tiên)</span>là không âm tính. (Đó là,<code>std::lerp(num1, num2, num3)</code>. Họ chỉ cần đủ để đảm bảo rằng cho cuộc tranh luận đầu tiên của họ<code>std::lerp(static_cast&lt;double&gt;(num1), static_cast&lt;double&gt;(num2), static_cast&lt;double&gt;(num3))</code>.</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>num1</code>Thì<code>num2</code>hoặc<code>num3</code>và kết quả của việc chuyển đổi bằng<span class="kw4">trôi nổi</span>, sau đó<code>std::lerp(num1, num2, num3)</code>. Họ chỉ cần đủ để đảm bảo rằng cho cuộc tranh luận đầu tiên của họ<code>std::lerp(static_cast&lt;float&gt;(num1), static_cast&lt;float&gt;(num2), static_cast&lt;float&gt;(num3))</code>.</li>
</ul> </td> <td><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></td>
</tr> <tr class="t-rev t-since-cxx23">
<td> <p>Nếu như<code>num1</code>Thì<code>num2</code>Và<code>num3</code>(MỘT)<code>std::lerp(num1, num2, num3)</code>. Họ chỉ cần đủ để đảm bảo rằng cho cuộc tranh luận đầu tiên của họ<code>std::lerp(static_cast&lt;/* common-floating-point-type */&gt;(num1), static_cast&lt;/* common-floating-point-type */&gt;(num2), static_cast&lt;/* common-floating-point-type */&gt;(num3))</code>là<span class="coMULTI">, Đối số thứ hai</span>và lập luận thứ ba<a href="../language/usual_arithmetic_conversions#Floating-point_conversion_rank" title="cpp/language/usual arithmetic conversions">floating-point conversion rank</a>và lớn nhất<a href="../language/usual_arithmetic_conversions#Floating-point_conversion_subrank" title="cpp/language/usual arithmetic conversions">floating-point conversion subrank</a>có tác dụng tương tự như<code>num1</code>Thì<code>num2</code>Và<code>num3</code>hoặc một loại số nguyên, sau đó<span class="kw4">    for (; đầu tiên! = cuối cùng; ++ đầu tiên)</span>.</p>
<p>có tác dụng tương tự như<a href="../language/overload_resolution" title="cpp/language/overload resolution">overload resolution</a>có tác dụng tương tự như</p>
</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../feature_test#cpp_lib_interpolate" title="cpp/feature test"><code>__cpp_lib_interpolate</code></a></td> <td><span class="nu0">Chính sách thực thi</span></td> <td><span class="t-mark">Phạm vi :: Construct_at</span></td> <td>
<code>std::lerp</code>Thì<code><a href="midpoint" title="cpp/numeric/midpoint">std::midpoint</a></code> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">có các loại số học, sau đó</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">có tác dụng tương tự như</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="midpoint" title="cpp/numeric/midpoint"> <span class="t-lines"><span>Điểm giữa</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>điểm giữa giữa hai số hoặc con trỏ<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/numeric/lerp">https://en.cppreference.com/w/cpp/numeric/lerp</a>
</p>
</div>
