 <h1 class="firstHeading" id="firstHeading">STD :: FMA, STD :: FMAF, STD :: FMAL</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/cmath" title="cpp/header/cmath">&lt;cmath&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx23"> <td><pre data-language="cpp">FMA FMA (Float X, Float Y, Float Z);</pre></td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span>
</td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">Double FMA (Double X, Double Y, Double Z);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">FMA gấp đôi (dài đôi x, dài đôi y, đôi dài z);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark">(Constexpr kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">constexpr / *-point-point-type * / /</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark">(Constexpr kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">            FMA ( / *-điểm thả nổi * / x,</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">                  / *-điểm nổi-kiểu */ y,</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">                  / *-điểm nổi kiểu */ z);</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl-h"> <td> <a href="#Notes">Additional overloads</a>
</td> <td></td> <td></td> </tr> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/cmath" title="cpp/header/cmath">&lt;cmath&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">FLOAT FMAF (Float X, Float Y, Float Z);</pre>
</td> <td>, kết quả là hữu hạn.</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark">(Constexpr kể từ C ++ 23)</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">Chuyển đổi danh tính. Trả lại</span>fmal gấp đôi (dài đôi x, dài đôi y, đôi dài z);<code>x * y + z</code>#Define fp_fast_fma / * đã xác định * /<span class="t-rev-inl t-since-cxx23"><span>Double Double Acosl (Double Num dài);<code>std::fma</code>#define fp_fast_fmaf / * đã xác định triển khai * / /<code>x</code>Thì<code>y</code>Và<code>z</code>.</span><span><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></span></span>
</div> <div class="t-li1">
<span class="t-li">          lớp T,</span>#Define fp_fast_fmal / * thực hiện được xác định * / /<code>FP_FAST_FMA</code>Thì<code>FP_FAST_FMAF</code>, hoặc<code>FP_FAST_FMAL</code>Mẫu &lt;arithmetic1, orithmetic2, số học lớp3&gt; lớp<code>std::fma</code>/ * loại điểm phổ biến-loại *//<code>x * y + z</code>vì<code>float</code>Thì<code>double</code>, Và<code>long double</code>    FMA (arithmetic1 x, arithmetic2 y, arithmetic3 z);<code>1</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;arithmetic1, orithmetic2, số học lớp3&gt; lớp</span>constexpr / * loại điểm nổi phổ biến kiểu * / /</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Tính toán</td> <td>-</td> <td>(MỘT)</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>như thể độ chính xác vô hạn và chỉ tròn một lần để phù hợp với loại kết quả.<code>x * y + z</code>Đối với tất cả các loại dấu phẩy động CV-UNTQUEDED là loại tham số</p>
<p>Tính toán cosin hyperbol của<code><a href="huge_val" title="cpp/numeric/math/HUGE VAL">±HUGE_VAL</a></code>Thì<code>±HUGE_VALF</code>, hoặc<code>±HUGE_VALL</code>bất kể</p>
<p>gấp đôi fdim (số nguyên x, số nguyên y);</p>
<h3 id="Error_handling">Xử lý lỗi</h3> <p>Nếu không có lỗi xảy ra, cosin hồ quang của<code><a href="math_errhandling" title="cpp/numeric/math/math errhandling">math_errhandling</a></code>.</p>
<p>Nếu một lỗi phạm vi xảy ra do dòng chảy, kết quả chính xác (sau khi làm tròn) được trả về.</p>
<ul>
<li>Nếu như<code>x</code>là không và<code>y</code>Nếu các hằng số vĩ mô<code>x</code>được xác định, chức năng<code>y</code>đánh giá nhanh hơn (ngoài chính xác hơn)<ul>
<li>nếu như<code>z</code>lập luận, tương ứng. Nếu được xác định, các macro này đánh giá thành số nguyên<code><a href="../fenv/fe_exceptions" title="cpp/numeric/fenv/FE exceptions">FE_INVALID</a></code>T* Toán tử+(STD :: PTRDIFF_T, T*)</li>
<li>nếu như<code>z</code>x, y, z<code><a href="../fenv/fe_exceptions" title="cpp/numeric/fenv/FE exceptions">FE_INVALID</a></code>.</li>
</ul> </li>
<li>Nếu như<code>x * y</code>Nếu thành công, hãy trả về giá trị của<code>z</code>như thể được tính toán theo độ chính xác vô hạn và làm tròn một lần để phù hợp với loại kết quả (hoặc, thay vào đó, được tính là một hoạt động dấu phẩy nổi duy nhất).<code><a href="../fenv/fe_exceptions" title="cpp/numeric/fenv/FE exceptions">FE_INVALID</a></code>T* Toán tử+(STD :: PTRDIFF_T, T*)</li>
<li>Nếu như<code>x</code>hoặc<code>y</code>là vô hạn hoặc nếu</li>
<li>Nếu như<code>z</code>là vô hạn và<code>x * y</code>bằng không, và<code><a href="../fenv/fe_exceptions" title="cpp/numeric/fenv/FE exceptions">FE_INVALID</a></code>).</li>
</ul> <h3 id="Notes">Ghi chú</h3> <p>không phải là một nan, sau đó nan được trả lại và<a class="extiw" href="https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation" title="enwiki:Multiply–accumulate operation">fused multiply-add</a>là một nan, sau đó nan được trả lại và<code>FP_FAST_FMA?</code>là vô cùng chính xác và</p>
<p>Posix<a class="external text" href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/fma.html" rel="nofollow">(<code>fma</code>, <code>fmaf</code>, <code>fmal</code>)</a>là một vô cùng với dấu hiệu ngược lại, Nan được trả lại và<code><a href="../fenv/fe_exceptions" title="cpp/numeric/fenv/FE exceptions">FE_INVALID</a></code>là Nan, Nan được trả lại.</p>
<p>là nan, và<code>std::fma</code>không phải là 0 * inf hoặc inf * 0, sau đó nan được trả về (không có<code><a href="sqrt" title="cpp/numeric/math/sqrt">std::sqrt</a></code>Hoạt động này thường được thực hiện trong phần cứng như<a class="extiw" href="https://en.wikipedia.org/wiki/Itanium" title="enwiki:Itanium">Itanium</a>).</p>
<p>Hướng dẫn CPU. Nếu được hỗ trợ bởi phần cứng, thích hợp<code>x * y + z</code>Các macro dự kiến ​​sẽ được xác định, nhưng nhiều triển khai sử dụng hướng dẫn CPU ngay cả khi các macro không được xác định.<a href="../../preprocessor/impl" title="cpp/preprocessor/impl"><code> #pragma</code></a> <code>STDC FP_CONTRACT</code>Ngoài ra chỉ định rằng các tình huống được chỉ định để trả về</p>
<p>, kết quả bằng<span class="t-v">, kết quả là hữu hạn.</span>, kết quả bằng<code>num1</code>, kết quả không phải là<code>num2</code>nếu không thì. Cho bất kỳ<code>num3</code>:</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx23">
<td> <ul>
<li>Nếu như<code>num1</code>Thì<code>num2</code>hoặc<code>num3</code>và kết quả của việc chuyển đổi bằng<span class="kw4">dài</span> <span class="kw4">    for (; đầu tiên! = cuối cùng; ++ đầu tiên)</span>, sau đó<code>std::fma(num1, num2, num3)</code>. Họ chỉ cần đủ để đảm bảo rằng cho cuộc tranh luận đầu tiên của họ<code>std::fma(static_cast&lt;long double&gt;(num1), static_cast&lt;long double&gt;(num2), static_cast&lt;long double&gt;(num3))</code>.</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>num1</code>Thì<code>num2</code>và/hoặc<code>num3</code>và kết quả của việc chuyển đổi bằng<span class="kw4">    for (; đầu tiên! = cuối cùng; ++ đầu tiên)</span>là không âm tính. (Đó là,<code>std::fma(num1, num2, num3)</code>. Họ chỉ cần đủ để đảm bảo rằng cho cuộc tranh luận đầu tiên của họ<code>std::fma(static_cast&lt;double&gt;(num1), static_cast&lt;double&gt;(num2), static_cast&lt;double&gt;(num3))</code>.</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>num1</code>Thì<code>num2</code>hoặc<code>num3</code>và kết quả của việc chuyển đổi bằng<span class="kw4">trôi nổi</span>, sau đó<code>std::fma(num1, num2, num3)</code>. Họ chỉ cần đủ để đảm bảo rằng cho cuộc tranh luận đầu tiên của họ<code>std::fma(static_cast&lt;float&gt;(num1), static_cast&lt;float&gt;(num2), static_cast&lt;float&gt;(num3))</code>.</li>
</ul> </td> <td><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></td>
</tr> <tr class="t-rev t-since-cxx23">
<td> <p>Nếu như<code>num1</code>Thì<code>num2</code>Và<code>num3</code>(MỘT)<code>std::fma(num1, num2, num3)</code>. Họ chỉ cần đủ để đảm bảo rằng cho cuộc tranh luận đầu tiên của họ<code>std::fma(static_cast&lt;/* common-floating-point-type */&gt;(num1), static_cast&lt;/* common-floating-point-type */&gt;(num2), static_cast&lt;/* common-floating-point-type */&gt;(num3))</code>là<span class="coMULTI">, Đối số thứ hai</span>và lập luận thứ ba<a href="../../language/usual_arithmetic_conversions#Floating-point_conversion_rank" title="cpp/language/usual arithmetic conversions">floating-point conversion rank</a>và lớn nhất<a href="../../language/usual_arithmetic_conversions#Floating-point_conversion_subrank" title="cpp/language/usual arithmetic conversions">floating-point conversion subrank</a>có tác dụng tương tự như<code>num1</code>Thì<code>num2</code>Và<code>num3</code>hoặc một loại số nguyên, sau đó<span class="kw4">    for (; đầu tiên! = cuối cùng; ++ đầu tiên)</span>.</p>
<p>có tác dụng tương tự như<a href="../../language/overload_resolution" title="cpp/language/overload resolution">overload resolution</a>có tác dụng tương tự như</p>
</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">là lỗi miền.</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">Do độ chính xác trung gian vô hạn của nó,</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="remainder" title="cpp/numeric/math/remainder"> <span class="t-lines"><span>phần còn lại</span><span>phần còn lại</span><span>phần còn lại</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>đã ký còn lại của hoạt động bộ phận<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="remquo" title="cpp/numeric/math/remquo"> <span class="t-lines"><span>Lấy còn lại</span><span>Lemquof</span><span>Tổ chức tua rẽ</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>đã ký còn lại cũng như ba bit cuối cùng của hoạt động phân chia<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/numeric/math/fma" title="c/numeric/math/fma">C documentation</a></span>vì<code>fma</code> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/numeric/math/fma">https://en.cppreference.com/w/cpp/numeric/math/fma</a>
</p>
</div>
