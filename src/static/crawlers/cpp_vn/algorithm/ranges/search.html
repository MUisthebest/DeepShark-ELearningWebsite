 <h1 class="firstHeading" id="firstHeading">STD :: Phạm vi :: Tìm kiếm</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;std :: forward_iterator i1, std :: sentinel_for &lt;i1&gt; s1,</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          std :: forward_iterator i2, std :: sentinel_for &lt;i2&gt; s2,</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>          lớp pre = phạm vi :: carm_to,<i>đến phạm vi bắt đầu tại</i>          lớp pre = phạm vi :: carm_to,<code>[</code><code>first2</code><code>, </code><code>last2</code><code>)</code>theo thứ tự.<code>[</code><code>first1</code><code>, </code><code>last1</code><code>)</code>          lớp proj1 = std :: danh tính,<code>pred</code>          lớp proj2 = std :: danh tính&gt;<code>proj2</code>Và<code>proj1</code>Yêu cầu STD :: Inone</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>Sử dụng<code>r1</code>                                        const t*&gt;<code>r2</code>Consexpr bool chứa (r &amp;&amp; r, const t &amp; value, proj proj = {});<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r1<span class="br0">)</span></code>(1,3)<code>first1</code>Thì<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r1<span class="br0">)</span></code>(1,3)<code>last1</code>Thì<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r2<span class="br0">)</span></code>(1,3)<code>first2</code>, Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r2<span class="br0">)</span></code>(1,3)<code>last2</code>.</div> <p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Mẫu &lt;class execPolicy, class forwardit1, class forwardit2&gt;</td> <td>-</td> <td>          lớp pre = phạm vi :: carm_to,<i>          lớp proj1 = std :: danh tính,</i>)</td>
</tr> <tr class="t-par"> <td>            Forwardit1 first1, forwardit1 last1,</td> <td>-</td> <td>          lớp proj2 = std :: danh tính&gt;<i>Yêu cầu STD :: Inone</i>)</td>
</tr> <tr class="t-par"> <td>          lớp pre = phạm vi :: carm_to,</td> <td>-</td> <td>          lớp pre = phạm vi :: carm_to,<i>          lớp proj1 = std :: danh tính,</i>)</td>
</tr> <tr class="t-par"> <td>Yêu cầu (phạm vi :: forward_range &lt;r1&gt; |</td> <td>-</td> <td>          lớp proj2 = std :: danh tính&gt;<i>Yêu cầu STD :: Inone</i>)</td>
</tr> <tr class="t-par"> <td>Sao chép các yếu tố, nhưng được thực thi theo</td> <td>-</td> <td>ConstExPR Phạm vi :: Subrange &lt;I1&gt;</td>
</tr> <tr class="t-par"> <td>                                    Phạm vi :: iterator_t &lt;r2&gt;,</td> <td>-</td> <td>                                    Pred, Proj1, Proj2&gt;</td>
</tr> <tr class="t-par"> <td>constexpr bool ends_with (r1 &amp;&amp; r1, r2 &amp;&amp; r2, pred = {},</td> <td>-</td> <td>Phạm vi constexpr :: mượn_subrange_t &lt;r1&gt;</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">1)</span>    Tìm kiếm (I1 First1, S1 Last1, I2 First2, S2 Last2, Pred = {},<code><a href="http://en.cppreference.com/w/cpp/ranges/subrange"><span class="kw2910">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    find_end (r1 &amp;&amp; r1, r2 &amp;&amp; r2, pre pre = {},</span></span></a></code>            Proj1 proj1 = {}, proj2 proj2 = {});<code>[</code><code>first2</code><code>, </code><code>last2</code><code>)</code>          lớp proj1 = std :: danh tính,<i>Yêu cầu STD :: Inone</i>          lớp pre = phạm vi :: carm_to,<code>[</code><code>first1</code><code>, </code><code>last1</code><code>)</code>          lớp proj1 = std :: danh tính,<i>          lớp proj1 = std :: danh tính,</i>          lớp proj2 = std :: danh tính&gt;<code>proj1</code>Và<code>proj2</code>Yêu cầu STD :: Inone<code>pred</code>                                    Phạm vi :: iterator_t &lt;r2&gt;, pre, proj1, proj2&gt;<p>Phạm vi constexpr :: mượn_subrange_t &lt;r1&gt;<code><a href="http://en.cppreference.com/w/cpp/ranges/subrange"><span class="kw2910">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    find_end (r1 &amp;&amp; r1, r2 &amp;&amp; r2, pre pre = {},</span></span></a><span class="br0">danh tính</span>last1, last1<span class="br0">{</span></code>    Tìm kiếm (r1 &amp;&amp; r1, r2 &amp;&amp; r2, pre pre = {}, proj1 proj1 = {}, proj2 proj2 = {});</p>
<i>Yêu cầu STD :: Inone</i>Sự xuất hiện của chuỗi các yếu tố<code>first2 == last2</code>. Các yếu tố được so sánh bằng cách sử dụng vị từ nhị phân<code><a href="http://en.cppreference.com/w/cpp/ranges/subrange"><span class="kw2910">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    find_end (r1 &amp;&amp; r1, r2 &amp;&amp; r2, pre pre = {},</span></span></a><span class="br0">danh tính</span>first1, first1<span class="br0">{</span></code>bất kể</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>    find_last_if (tôi đầu tiên, s cuối cùng, pred, proj proj = {});<code><a href="http://en.cppreference.com/w/cpp/ranges/borrowed_iterator_t"><span class="kw2897">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">HANGSTACK</span></span></a><span class="sy1">is_trivently_destructible_v</span>R1<span class="sy1">&lt;</span></code>.</div> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Nếu phạm vi trống.<code>S * N</code>Sau khi được chiếu với<br/> <span class="t-v">(1)</span> <code>S <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3141">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first2, last2<span class="br0">)</span></code>Và<code>N <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3141">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first1, last1<span class="br0">)</span></code>Số lượng các yếu tố để sao chép<br/> <span class="t-v">(2)</span> <code>S <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3141">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>r2<span class="br0">)</span></code>Và<code>N <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3141">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>r1<span class="br0">)</span></code>.</p>
<h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">, tương ứng.</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">vị từ nhị phân để áp dụng cho các yếu tố dự kiến</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Trả lại a</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="adjacent_find" title="cpp/algorithm/ranges/adjacent find"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="find" title="cpp/algorithm/ranges/find"> <span class="t-lines"><span>(Mẫu chức năng)</span><span>Phạm vi :: Tìm</span><span>Phạm vi :: find_if</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="find_end" title="cpp/algorithm/ranges/find end"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="find_first_of" title="cpp/algorithm/ranges/find first of"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="contains" title="cpp/algorithm/ranges/contains"> <span class="t-lines"><span>(Niebloid)</span><span>Phạm vi :: chứa</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td>(C ++ 23)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="includes" title="cpp/algorithm/ranges/includes"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<code>true</code>trả lại<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="mismatch" title="cpp/algorithm/ranges/mismatch"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="search_n" title="cpp/algorithm/ranges/search n"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../search" title="cpp/algorithm/search"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/search">https://en.cppreference.com/w/cpp/algorithm/ranges/search</a>
</p>
</div>
