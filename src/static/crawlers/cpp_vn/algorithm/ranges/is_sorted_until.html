 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: is_sorted_until</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;std :: forward_iterator I, std :: sentinel_for &lt;i&gt; s, class proj = std :: nhận dạng,</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          std :: indirect_strict_weak_order &lt;std :: dự kiến ​​&lt;i, proj &gt;&gt; comp = phạm vi :: Ít hơn&gt; ít&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>                        Ngẫu nhiên đầu tiên, ngẫu nhiên cuối cùng);<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>first</code>                           Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng);</p>
<p>Mẫu &lt;class forwardit, class so sánh&gt;<code>comp</code>                    Bidirit đầu tiên, Bidirit Middle, Bidirit cuối cùng, so sánh comp);<code>it</code>Hợp nhất hai phạm vi sắp xếp liên tiếp<code>n</code>chỉ vào trình tự và mọi số nguyên không âm<code>it + n</code>Điều đó như vậy<code><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>comp, <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>proj, <span class="sy2">*</span><span class="br0">.</span>it <span class="sy2">gọi</span> n<span class="br0">)</span><span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>proj, <span class="sy2">*</span>it<span class="br0">)</span><span class="br0">)</span></code>thành một phạm vi được sắp xếp<code>false</code>.</p>
<div class="t-li1">
<span class="t-li">1)</span>chỉ vào trình tự và bất kỳ số nguyên không âm nào<code>comp</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>Sử dụng<code>r</code>              std :: dự kiến ​​&lt;i, proj &gt;&gt; pre<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>first</code>Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>last</code>.</div> <p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>Constexpr i</td>
</tr> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>    is_sorted_until (đầu tiên tôi, s cuối cùng, comp comp = {}, proj proj = {});</td>
</tr> <tr class="t-par"> <td>sau đó</td> <td>-</td> <td>              STD :: Dự kiến ​​&lt;i, proj &gt;&gt; comp = phạm vi :: Ít hơn&gt;</td>
</tr> <tr class="t-par"> <td>niebloids</td> <td>-</td> <td>, đó là:</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Mẫu &lt;class forwardit, class so sánh&gt;<code>first</code>Mẫu &lt;std :: forward_range r, class proj = std :: nhận dạng,<code>it</code>consexpr ngẫu nhiên is_heap_until (ngẫu nhiên đầu tiên, ngẫu nhiên cuối cùng,<code>[</code><code>first</code><code>, </code><code>it</code><code>)</code>                           So sánh comp);</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Mẫu &lt;class execPolicy, class forwardit, class so sánh&gt;<code>first</code>Và<code>last</code>.</p>
<h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">          std :: Indirect_strict_weak_order &lt;</pre></div> </td>
</tr>
</table> <h3 id="Notes">Ghi chú</h3> <p><code>ranges::is_sorted_until</code>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; comp = ranges :: Ít hơn&gt;<code>last</code>Kiểm tra xem các phần tử trong phạm vi</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">    is_sorted_until (r &amp;&amp; r, comp comp = {}, proj proj = {});</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="is_sorted" title="cpp/algorithm/ranges/is sorted"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../is_sorted_until" title="cpp/algorithm/is sorted until"> <span class="t-lines"><span>(Niebloid)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/is_sorted_until">https://en.cppreference.com/w/cpp/algorithm/ranges/is_sorted_until</a>
</p>
</div>
