 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: nth_element</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;std :: Random_access_iterator I, std :: sentinel_for &lt;i&gt; s,</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          Lớp comp = phạm vi :: Ít hơn, lớp proj = std :: nhận dạng&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Yêu cầu STD :: Sắp xếp &lt;i, comp, proj&gt;<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Mẫu &lt;Class Randomit, Class So sánh&gt;</p>
<ul>
<li>void nth_element (ngẫu nhiên đầu tiên, ngẫu nhiên nth, ngẫu nhiên cuối cùng,<code>nth</code>                  So sánh comp);<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Constexpr i<code>comp</code>Và<code>proj</code>.</li>
<li>void nth_element (execPolicy &amp;&amp; chính sách,<code>nth</code>    nth_element (i đầu tiên, i nth, s cuối cùng, comp comp = {}, proj proj = {});<i>Mẫu &lt;phạm vi :: ngẫu nhiên_access_range r,</i>          Lớp comp = phạm vi :: Ít hơn, lớp proj = std :: nhận dạng&gt;<code>nth</code>Yêu cầu STD :: Sắp xếp &lt;iterator_t &lt;r&gt;, comp, proj&gt;<i>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</i>Thì<i>    nth_element (r &amp;&amp; r, iterator_t &lt;r&gt; nth, comp comp = {}, proj proj = {});</i>Sắp xếp lại các yếu tố trong<code>[</code><code>first</code><code>, </code><code>nth</code><code>)</code>Thì<code>[</code><code>nth</code><code>, </code><code>last</code><code>)</code>đã được sắp xếp theo<code><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>comp, <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>proj, <span class="sy2">*</span>j<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>proj, <span class="sy2">*</span>i<span class="br0">)</span><span class="br0">)</span></code>thành một phạm vi được sắp xếp<code>false</code>.</li>
<li>Nếu như<code>nth == last</code>yếu tố là</li>
</ul> <div class="t-li1">
<span class="t-li">1)</span>nhỏ hơn hoặc bằng<code>comp</code>                 Comp comp = {}, proj proj = {});<code>proj</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>Sử dụng<code>r</code>Mẫu &lt;class R, std :: copy_constructable f&gt;<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>first</code>Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>last</code>.</div> <p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>                     Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng, p không có ý nghĩa p);</td>
</tr> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>                     Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng, p không có ý nghĩa p);</td>
</tr> <tr class="t-par"> <td>Sắp xếp một phần phạm vi</td> <td>-</td> <td>các yếu tố sau khi mới</td>
</tr> <tr class="t-par"> <td>sau đó</td> <td>-</td> <td>yếu tố. Nghĩa là, đối với mọi trình lặp lại</td>
</tr> <tr class="t-par"> <td>niebloids</td> <td>-</td> <td>, đó là:</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">1)</span>không được phép tạo các bản sao của các yếu tố trong chuỗi ngay cả khi chúng có thể sao chép tầm thường.<code>last</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>nếu như<code>r</code>Tôi<a href="../../ranges/borrowed_range" title="cpp/ranges/borrowed range"><code>borrowed_range</code></a>j<code><a href="../../ranges/dangling" title="cpp/ranges/dangling">std::ranges::dangling</a></code>.</div> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>bool is_heap (execPolicy &amp;&amp; chính sách,<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3141">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>Điều kiện sau được đáp ứng:</p>
<h3 id="Notes">Ghi chú</h3> <p>Vị trí chính xác là phần tử sẽ xảy ra ở vị trí này nếu phạm vi được sắp xếp đầy đủ.<a class="extiw" href="https://en.wikipedia.org/wiki/Introselect" title="enwiki:Introselect">introselect</a>Có thể là người lặp cuối, trong trường hợp này chức năng không có tác dụng.<a class="extiw" href="https://en.wikipedia.org/wiki/Selection_algorithm" title="enwiki:Selection algorithm">selection algorithms</a>Truy cập ngẫu nhiên các trình lặp lại xác định loại phạm vi</p>
<h3 id="Possible_implementation">. ​</h3> <p>N<a class="external text" href="https://github.com/microsoft/STL/blob/e97bb2b50a12816ce68cc5147b7a3a21fb68bfa3/stl/inc/algorithm#L8896-L8969" rel="nofollow">msvc stl</a>Thì<a class="external text" href="https://github.com/gcc-mirror/gcc/blob/a87819b8f1b890d36a3f05bd9de80be20e9525dd/libstdc%2B%2B-v3/include/bits/ranges_algo.h#L2016-L2044" rel="nofollow">libstdc++</a>trong phạm vi<a class="external text" href="https://github.com/llvm/llvm-project/blob/ed2d3644abee9535eb07333beb1562a651001281/libcxx/include/__algorithm/ranges_nth_element.h" rel="nofollow">(1)</a>/<a class="external text" href="https://github.com/llvm/llvm-project/blob/ed2d364/libcxx/include/__algorithm/nth_element.h" rel="nofollow">(2)</a>.</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">tương ứng, biểu thức</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Sau đó, chức năng không có tác dụng.</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="max_element" title="cpp/algorithm/ranges/max element"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="min_element" title="cpp/algorithm/ranges/min element"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="partition" title="cpp/algorithm/ranges/partition"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="partial_sort" title="cpp/algorithm/ranges/partial sort"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../nth_element" title="cpp/algorithm/nth element"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/nth_element">https://en.cppreference.com/w/cpp/algorithm/ranges/nth_element</a>
</p>
</div>
