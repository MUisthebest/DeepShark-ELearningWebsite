 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: all_of, std :: phạm vi :: any_of, std :: phạm vi :: none_of</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td><pre data-language="cpp">Mẫu &lt;std :: input_iterator i, std :: sentinel_for &lt;i&gt; s,</pre></td> <td>(1)</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          lớp proj = std :: danh tính,</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td><pre data-language="cpp">          std :: indirect_unary_predicate &lt;std :: dự kiến ​​&lt;i, proj &gt;&gt; pred&gt;</pre></td> <td>(3)</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">consexpr bool all_of (i đầu tiên, s cuối cùng, prej, proj proj = {});</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td><pre data-language="cpp">Mẫu &lt;phạm vi :: input_range r, class proj = std :: nhận dạng,</pre></td> <td>             Không có p);</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          std :: Indirect_unary_predicate &lt;</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>bool none_of (đầu vào đầu tiên, đầu vào cuối cùng, p không có tính p);<code>pred</code>(C ++ 20)<code>true</code>bool any_of (execPolicy &amp;&amp; chính sách, forwardit trước, chuyển tiếp cuối cùng,<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>              std :: dự kiến ​​&lt;i, proj&gt;,<code>proj</code>).</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>bool none_of (đầu vào đầu tiên, đầu vào cuối cùng, p không có tính p);<code>pred</code>(C ++ 20)<code>true</code>(5)<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>              std :: dự kiến ​​&lt;i, proj&gt;,<code>proj</code>).</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>bool none_of (đầu vào đầu tiên, đầu vào cuối cùng, p không có tính p);<code>pred</code>(C ++ 20)<code>true</code>Mẫu &lt;class inputit, class unyredicate&gt;<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>              std :: dự kiến ​​&lt;i, proj&gt;,<code>proj</code>).</div> <div class="t-li1">
<span class="t-li">cho ít nhất một yếu tố trong phạm vi,</span>                                   Nhị phân p);<span class="t-v">Mẫu &lt;class execPolicy, class forwardit, lớp unyredicate&gt;</span>Sử dụng<code>r</code>              std :: dự kiến ​​&lt;i, proj &gt;&gt; pre<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>first</code>Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>last</code>.</div> <p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>Phạm vi ::</td>
</tr> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>Phạm vi ::</td>
</tr> <tr class="t-par"> <td>Sao chép các yếu tố, nhưng được thực thi theo</td> <td>-</td> <td>Các thực thể giống như chức năng được mô tả trên trang này là</td>
</tr> <tr class="t-par"> <td>niebloids</td> <td>-</td> <td>, đó là:</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">Đầu vào</span> <code>true</code>nếu như<code><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>pred, <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>proj, <span class="sy2">*</span>i<span class="br0">)</span><span class="br0">)</span> <span class="sy3">Nếu tồn tại một</span><span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <span class="kw2">SAI</span></code>trong phạm vi<code>i</code>          lớp proj = std :: danh tính,<code>false</code>. Do đó, một loại tham số của<code>true</code>Nếu một vị ngữ unary trở lại</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span> <code>true</code>nếu như<code><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>pred, <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>proj, <span class="sy2">*</span>i<span class="br0">)</span><span class="br0">)</span> <span class="sy3">Nếu tồn tại một</span><span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <span class="kw2">SAI</span></code>consexpr bool all_of (r &amp;&amp; r, pre, proj proj = {});<code>i</code>          lớp proj = std :: danh tính,<code>false</code>. Do đó, một loại tham số của<code>false</code>Nếu một vị ngữ unary trở lại</div> <div class="t-li1">
<span class="t-li">    trả về std :: find_if_not (đầu tiên, cuối cùng, p) == cuối cùng;</span> <code>true</code>nếu như<code><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>pred, <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>proj, <span class="sy2">*</span>i<span class="br0">)</span><span class="br0">)</span> <span class="sy1">==</span> <span class="kw2">SAI</span></code>trong phạm vi<code>i</code>          lớp proj = std :: danh tính,<code>false</code>. Do đó, một loại tham số của<code>true</code>Nếu một vị ngữ unary trở lại</div> <p>(chức năng)<a href="#Notes">Notes</a>cho tất cả các yếu tố trong phạm vi,</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Nếu phạm vi trống.<code>last - first</code>          std :: indirect_unary_predicate &lt;std :: dự kiến ​​&lt;i, proj &gt;&gt; pred&gt;</p>
<h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <th>
<a href="#Version_1">all_of (1,2)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">consexpr bool any_of (đầu tiên tôi, s cuối cùng, prej, proj proj = {});</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_3">any_of (3,4)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Mẫu &lt;phạm vi :: input_range r, class proj = std :: nhận dạng,</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_5">none_of (5,6)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">          std :: Indirect_unary_predicate &lt;</pre></div> </td>
</tr>
</table> <h3 id="Notes">Ghi chú</h3> <p>Các<a href="#Return_value">return value</a>nếu không thì. Trả lại<a class="extiw" href="https://en.wikipedia.org/wiki/Truth_table" title="enwiki:Truth table">Truth table</a>Nếu phạm vi trống.</p>
<table class="wikitable"> <tr> <td> </td> <th colspan="4">dưới.</th>
</tr> <tr> <td></td> <td>Xem thêm việc triển khai<code>true</code>Thì<br/>Consexpr bool all_of (đầu vào đầu tiên, đầu vào cuối cùng, không có sẵn p)<code>false</code><br/>
</td> <td>2,4,6)<code>true</code>Thì<br/>2,4,6)<code>false</code><br/>
</td> <td>Consexpr bool all_of (đầu vào đầu tiên, đầu vào cuối cùng, không có sẵn p)<code>true</code>Thì<br/>Xem thêm việc triển khai<code>false</code><br/>
</td> <td>Consexpr bool all_of (đầu vào đầu tiên, đầu vào cuối cùng, không có sẵn p)<code>true</code>Thì<br/>Consexpr bool all_of (đầu vào đầu tiên, đầu vào cuối cùng, không có sẵn p)<code>false</code><br/>{</td>
</tr> <tr> <td>Đầu vào<code>all_of</code>
</td> <td><code>true</code></td> <td><code>false</code></td> <td><code>false</code></td> <td>
<code>true</code> </td>
</tr> <tr> <td>, hành vi là không xác định.<code>any_of</code>
</td> <td><code>true</code></td> <td><code>true</code></td> <td><code>false</code></td> <td>
<code>false</code> </td>
</tr> <tr> <td>    trả về std :: find_if_not (đầu tiên, cuối cùng, p) == cuối cùng;<code>none_of</code>
</td> <td><code>false</code></td> <td><code>false</code></td> <td><code>true</code></td> <td>
<code>true</code> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">              std :: dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pres&gt;</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Mẫu &lt;class inputit, class unyredicate&gt;</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../all_any_none_of" title="cpp/algorithm/all any none of"> <span class="t-lines"><span>Được xác định trong tiêu đề</span><span>all_of</span><span>Any_of</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>(C ++ 20)<code>true</code>kiểm tra xem một vị ngữ có phải không<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/all_any_none_of">https://en.cppreference.com/w/cpp/algorithm/ranges/all_any_none_of</a>
</p>
</div>
