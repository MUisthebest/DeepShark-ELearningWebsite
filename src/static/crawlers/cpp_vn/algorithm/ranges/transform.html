 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: biến đổi, std :: phạm vi :: unary_transform_result, std :: phạm vi :: binary_transform_result</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;std :: input_iterator I, std :: sentinel_for &lt;i&gt; s, std :: meally_incrementable o,</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          std :: copy_constructable f, class proj = std :: nhận dạng&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Yêu cầu STD :: gián tiếp_writable &lt;o,</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">                                  std :: indirect_result_t &lt;f &amp;, std :: dự kiến ​​&lt;i, proj &gt;&gt;&gt;</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-h"> <td>Mẫu &lt;phạm vi :: input_range r, std :: meally_incrementable o&gt;</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Consexpr unary_transform_result &lt;i, o&gt;</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">    biến đổi (i First1, s Last1, o result, f op, proj proj = {});</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Mẫu &lt;phạm vi :: input_range r, std :: meally_incrementable o,<code>result</code>.</p>
<div class="t-li1">
<span class="t-li">1)</span>          Lớp chuyển tiếp 2, lớp không có lớp&gt;<code>op</code>ForwardItIt -Transform (execPolicy &amp;&amp; chính sách, chính sách,<code>[</code><code>first1</code><code>, </code><code>last1</code><code>)</code>              std :: dự kiến ​​&lt;i, proj&gt;,<code>proj</code>).</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>Sử dụng<code>r</code>              std :: dự kiến ​​&lt;i, proj &gt;&gt; pre<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>first</code>Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>last</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>                      Forwardit1 first1, forwardit1 last1,<code>binary_op</code>                      Forwardit2 d_first, unanyeration unary_op);<code>[</code><code>first1</code><code>, </code><code>last1</code><code>)</code>          std :: copy_constructable f, class proj = std :: nhận dạng&gt;<code>[</code><code>first2</code><code>, </code><code>last2</code><code>)</code>Yêu cầu STD :: gián tiếp_writable &lt;o,<code>proj1</code>Và<code>proj2</code>).</div> <div class="t-li1">
<span class="t-li">là trong</span>                                   Nhị phân p);<span class="t-v">(3)</span>Sử dụng<code>r1</code>             std :: indirect_result_t &lt;f &amp;, std :: được chiếu &lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt;&gt;<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r1<span class="br0">)</span></code>(1,3)<code>first1</code>Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r1<span class="br0">)</span></code>(1,3)<code>last1</code>consexpr unary_transform_result &lt;phạm vi :: rayed_iterator_t &lt;r&gt;, o&gt;<code>r2</code>.</div> <p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Mẫu &lt;class execPolicy, class forwardit1, class forwardit2&gt;</td> <td>-</td> <td>Biến đổi đầu ra (đầu vào đầu tiên1, đầu vào1 Last1, Inputit2 First2,</td>
</tr> <tr class="t-par"> <td>    biến đổi (r &amp;&amp; r, o result, f op, proj proj = {});</td> <td>-</td> <td>Biến đổi đầu ra (đầu vào đầu tiên1, đầu vào1 Last1, Inputit2 First2,</td>
</tr> <tr class="t-par"> <td>            Forwardit1 first1, forwardit1 last1,</td> <td>-</td> <td>          std :: input_iterator i2, std :: sentinel_for &lt;i2&gt; s2,</td>
</tr> <tr class="t-par"> <td>Yêu cầu (phạm vi :: forward_range &lt;r1&gt; |</td> <td>-</td> <td>          std :: input_iterator i2, std :: sentinel_for &lt;i2&gt; s2,</td>
</tr> <tr class="t-par"> <td>. Sự chồng chéo của phạm vi được chính thức được phép, nhưng dẫn đến thứ tự không thể đoán trước của kết quả.</td> <td>-</td> <td>Mẫu &lt;class inputit1, class inputit2,<code>first1</code>hoặc<code>first2</code> </td>
</tr> <tr class="t-par"> <td>          std :: yếu_incrementable o,</td> <td>-</td> <td>          std :: copy_constructable f,</td>
</tr> <tr class="t-par"> <td>                                    Phạm vi :: iterator_t &lt;r2&gt;,</td> <td>-</td> <td>                                    Pred, Proj1, Proj2&gt;</td>
</tr> <tr class="t-par"> <td>constexpr bool ends_with (r1 &amp;&amp; r1, r2 &amp;&amp; r2, pred = {},</td> <td>-</td> <td>Phạm vi constexpr :: mượn_subrange_t &lt;r1&gt;</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">Đầu vào</span>MỘT<code>unary_transform_result</code>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;<code>last</code>Yêu cầu STD :: gián tiếp_writable &lt;o,</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>MỘT<code>binary_transform_result</code>             std :: indirect_result_t &lt;f &amp;,<code>[</code><code>first1</code><code>, </code><code>last1</code><code>)</code>Và<code>[</code><code>first2</code><code>, </code><code>last2</code><code>)</code>(1,3)<code>in1</code>Và<code>in2</code>                                    std :: dự kiến ​​&lt;i1, proj1&gt;,<code>out</code>.</div> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <div class="t-li1">
<span class="t-li">Đầu vào</span>không được phép<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3139">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first1, last1<span class="br0">)</span></code>Ứng dụng của<code>op</code>Và<code>proj</code>.</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>không được phép<code><a href="http://en.cppreference.com/w/cpp/algorithm/ranges/min"><span class="kw3009">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">(Niebloid)</span></span></a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3139">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first1, last1<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3139">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first2, last2<span class="br0">)</span><span class="br0">)</span></code>Ứng dụng của<code>binary_op</code>                                    std :: dự kiến ​​&lt;i2, proj2 &gt;&gt;&gt;</div> <h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">consexpr binary_transform_result &lt;i1, i2, o&gt;</pre></div> </td>
</tr>
</table> <h3 id="Notes">Ghi chú</h3> <p><code>ranges::transform</code>                      Forwardit1 first1, forwardIt1 last1, forwardIt2 first2,<code>op</code>hoặc<code>binary_op</code>                      Forwardit3 d_first, BinaryOperation Binary_op);<code><a href="for_each" title="cpp/algorithm/ranges/for each">ranges::for_each</a></code>.</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example">
<p>Trong thực tế, việc triển khai<code>ranges::transform</code>Áp dụng chức năng đã cho vào một phạm vi và lưu trữ kết quả trong một phạm vi khác, giữ cho thứ tự các yếu tố ban đầu và bắt đầu tại<code><a href="http://en.cppreference.com/w/cpp/string/byte/toupper"><span class="kw3516">Điều đó cho tất cả<span class="me2">TOUPPER</span></span></a></code>Hoạt động đơn<code>char</code>    Biến đổi (I1 First1, S1 Last1, I2 First2, S2 Last2, O Kết quả,<code>ranges::transform</code>               F Binary_op, proj1 proj1 = {}, proj2 proj2 = {});<code><a href="http://en.cppreference.com/w/cpp/container/vector"><span class="kw1272">Điều đó cho tất cả<span class="me2">Vector</span></span></a><span class="sy1">is_trivently_destructible_v</span>Foo<span class="sy1">&lt;</span></code>Mẫu &lt;phạm vi :: input_range r1,<code><a href="../../string/basic_string" title="cpp/string/basic string">std::string</a></code>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">          Phạm vi :: input_range r2,</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">          std :: yếu_incrementable o,</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="for_each" title="cpp/algorithm/ranges/for each"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../ranges/transform_view" title="cpp/ranges/transform view"> <span class="t-lines"><span>thỏa mãn một vị ngữ</span><span>(Đối tượng bộ điều hợp phạm vi)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Một<a href="../../ranges/view" title="cpp/ranges/view"><code>view</code></a>Phạm vi :: Transform_View<br/><span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> <span class="t-mark">bao gồm các yếu tố của người khác</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../transform" title="cpp/algorithm/transform"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>biến đổi<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/transform">https://en.cppreference.com/w/cpp/algorithm/ranges/transform</a>
</p>
</div>
