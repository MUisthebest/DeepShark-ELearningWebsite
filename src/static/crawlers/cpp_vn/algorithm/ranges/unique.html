 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: độc đáo</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;std :: có thể thấm I, std :: sentinel_for &lt;i&gt; s, class proj = std :: identity,</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          std :: indirect_equilcoence_relation &lt;std :: dự kiến ​​&lt;i, proj &gt;&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Mẫu &lt;class forwardit, lớp nhị phân&gt;<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Constexpr Phạm vi :: Subrange &lt;i&gt;<code>[</code><code>ret</code><code>, </code><code>last</code><code>)</code>là<code>ret</code>    loại bỏ (tôi đầu tiên, s cuối cùng, const t &amp; value, proj proj = {});</div> <div class="t-li1">              C = phạm vi :: Equ_to&gt;<code>*(i - 1)</code>Và<code>*i</code>Constexpr Phạm vi :: Subrange &lt;i&gt;<code><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>comp, <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>proj, <span class="sy2">*</span><span class="br0">.</span>i <span class="sy2">-</span> <span class="nu0">, nếu như</span><span class="br0">)</span><span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>proj, <span class="sy2">*</span>i<span class="br0">)</span><span class="br0">)</span> <span class="sy1">==</span> <span class="kw2">ĐÚNG VẬY</span></code>là<code>i</code>    duy nhất (đầu tiên tôi, s cuối cùng, c comp = {}, proj proj = {});<code>[</code><code>first + 1</code><code>, </code><code>last</code><code>)</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>Sử dụng<code>r</code>Mẫu &lt;class R, std :: copy_constructable f&gt;<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>first</code>, Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>last</code>.</div> <p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>) Các phần tử trong phạm vi theo cách mà các yếu tố không được loại bỏ xuất hiện ở đầu phạm vi. Thứ tự tương đối của các yếu tố còn lại được bảo tồn và</td>
</tr> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>) Các phần tử trong phạm vi theo cách mà các yếu tố không được loại bỏ xuất hiện ở đầu phạm vi. Thứ tự tương đối của các yếu tố còn lại được bảo tồn và</td>
</tr> <tr class="t-par"> <td>sau đó</td> <td>-</td> <td>Mẫu &lt;std :: input_iterator i, std :: sentinel_for &lt;i&gt; s,</td>
</tr> <tr class="t-par"> <td>niebloids</td> <td>-</td> <td>          STD :: yếu_incrementable o, class proj = std :: nhận dạng,</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Mẫu &lt;Class execPolicy,<code>{ret, last}</code>là<code>ret</code>    loại bỏ (tôi đầu tiên, s cuối cùng, const t &amp; value, proj proj = {});</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Mẫu &lt;class execPolicy, class forwardit, lớp nhị phân&gt;<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3141">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span> <span class="sy2">-</span> <span class="nu0">, nếu như</span></code>          std :: indirect_unary_predicate &lt;std :: dự kiến ​​&lt;iterator_t &lt;r&gt;, proj &gt;&gt; pred&gt; pre<code>comp</code>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<code>proj</code>.</p>
<h3 id="Notes">Ghi chú</h3> <p>         std :: indirect_binary_predicate &lt;ranges :: quare_to,<i>điều hòa sau)</i>                  Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng, nhị phân p);<code>[</code><code>ret</code><code>, </code><code>last</code><code>)</code>          STD :: Indirect_equilationence_relation &lt;std :: dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt;<a href="../../named_req/moveassignable" title="cpp/named req/MoveAssignable">MoveAssignable</a>Range constexpr :: mượn_subrange_t &lt;r&gt;</p>
<p>thuộc vật chất<code>ranges::unique</code>              C = phạm vi :: Equ_to&gt;<code>erase</code>, nhưng bản thân các yếu tố có các giá trị không xác định (theo<i>điều hòa sau)</i>phạm vi của các yếu tố để xử lý<i>giá trị của các yếu tố để loại bỏ</i>Yêu cầu std :: Thấy &lt;phạm vi :: iterator_t &lt;r &gt;&gt;<a class="extiw" href="https://en.wikipedia.org/wiki/Erase-remove_idiom" title="enwiki:Erase-remove idiom"><i>Trình lặp quá khứ cho phạm vi giá trị mới (nếu điều này không</i> idiom</a>.</p>
<h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Range constexpr :: mượn_subrange_t &lt;r&gt;</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">    duy nhất (r &amp;&amp; r, c comp = {}, proj proj = {});</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Hai yếu tố liên tiếp</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="unique_copy" title="cpp/algorithm/ranges/unique copy"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="adjacent_find" title="cpp/algorithm/ranges/adjacent find"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="remove" title="cpp/algorithm/ranges/remove"> <span class="t-lines"><span>(Mẫu chức năng)</span><span>Phạm vi :: Xóa</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../unique" title="cpp/algorithm/unique"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../container/list/unique" title="cpp/container/list/unique"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>Forwardit độc đáo (Forwardit First, Forwardit Last)<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::list&lt;T,Allocator&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../container/forward_list/unique" title="cpp/container/forward list/unique"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>Forwardit độc đáo (Forwardit First, Forwardit Last)<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::forward_list&lt;T,Allocator&gt;</code>)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/unique">https://en.cppreference.com/w/cpp/algorithm/ranges/unique</a>
</p>
</div>
