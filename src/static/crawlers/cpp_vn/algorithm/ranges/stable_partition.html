 <h1 class="firstHeading" id="firstHeading">STD :: Phạm vi :: Stable_Partition</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;std :: bidIrectional_iterator i, std :: sentinel_for &lt;i&gt; s,</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark-rev t-since-cxx26">Void inplace_merge (execPolicy &amp;&amp; chính sách,</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          lớp proj = std :: danh tính,</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark-rev t-since-cxx26">Void inplace_merge (execPolicy &amp;&amp; chính sách,</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Phân vùng chuyển tiếp của Const<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Constexpr Phạm vi :: Subrange &lt;i&gt;<code>proj</code>    phân vùng (tôi đầu tiên, s cuối cùng, pred, proj proj = {});<code>pred</code>(C ++ 20)<code>true</code>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<code>proj</code>          std :: Indirect_unary_predicate &lt;<code>pred</code>(C ++ 20)<code>false</code>          std :: indirect_unary_predicate &lt;std :: dự kiến ​​&lt;i, proj &gt;&gt; pred&gt;<i>sắp xếp</i>Yêu cầu STD :: Thấy &lt;i&gt;<i>Phạm vi :: Subrange &lt;i&gt;</i>.</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>Sử dụng<code>r</code>Mẫu &lt;class R, std :: copy_constructable f&gt;<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>first</code>Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>last</code>.</div> <p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>                     Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng, p không có ý nghĩa p);</td>
</tr> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>                     Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng, p không có ý nghĩa p);</td>
</tr> <tr class="t-par"> <td>Sao chép các yếu tố, nhưng được thực thi theo</td> <td>-</td> <td>Các thực thể giống như chức năng được mô tả trên trang này là</td>
</tr> <tr class="t-par"> <td>niebloids</td> <td>-</td> <td>, đó là:</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">1)</span>Mẫu &lt;Class I, Class O&gt;<code>{pivot, last}</code>là<code>pivot</code>    stable_partition (tôi đầu tiên, s cuối cùng, pred, proj proj = {});</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>nếu như<code>r</code>Tôi<a href="../../ranges/borrowed_range" title="cpp/ranges/borrowed range"><code>borrowed_range</code></a>j<code><a href="../../ranges/dangling" title="cpp/ranges/dangling">std::ranges::dangling</a></code>.</div> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Cho quá tải<code>N <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3141">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>Mẫu &lt;phạm vi :: bid -<code>pred</code>cho một bộ so sánh<code>proj</code>.</p>
<h3 id="Notes">Ghi chú</h3> <p>Phần cuối của phạm vi được sắp xếp thứ hai</p>
<table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../../feature_test#cpp_lib_constexpr_algorithms" title="cpp/feature test"><code>__cpp_lib_constexpr_algorithms</code></a></td> <td><span class="nu0">202306L</span></td> <td></td> <td>
<code>constexpr</code>Các loại Type1 và Type2 phải sao cho một đối tượng của loại bidirit có thể được báo cáo và sau đó được chuyển đổi hoàn toàn thành cả hai. ​</td>
</tr>
</table> <h3 id="Possible_implementation">. ​</h3> <p>          std :: Indirect_unary_predicate &lt;<a class="external text" href="https://github.com/microsoft/STL/blob/e745bad3b1d05b5b19ec652d68abb37865ffa454/stl/inc/algorithm#L5358-L5555" rel="nofollow">MSVC STL</a>Và<a class="external text" href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/ranges_algo.h#L2365-L2394" rel="nofollow">libstdc++</a>.</p>
<table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Yêu cầu std :: Thấy &lt;phạm vi :: iterator_t &lt;r &gt;&gt;</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">Phạm vi :: mượn_subrange_t &lt;r&gt;</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="partition" title="cpp/algorithm/ranges/partition"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="partition_copy" title="cpp/algorithm/ranges/partition copy"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="is_partitioned" title="cpp/algorithm/ranges/is partitioned"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../stable_partition" title="cpp/algorithm/stable partition"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/stable_partition">https://en.cppreference.com/w/cpp/algorithm/ranges/stable_partition</a>
</p>
</div>
