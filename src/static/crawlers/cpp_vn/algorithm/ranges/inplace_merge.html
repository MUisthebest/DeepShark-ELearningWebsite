 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: inplace_merge</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;std :: bidIrectional_iterator i, std :: sentinel_for &lt;i&gt; s,</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark-rev t-since-cxx26">Void inplace_merge (execPolicy &amp;&amp; chính sách,</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          Lớp comp = phạm vi :: Ít hơn, lớp proj = std :: nhận dạng&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark-rev t-since-cxx26">Void inplace_merge (execPolicy &amp;&amp; chính sách,</span> </td> </tr> </table> <p>Yêu cầu STD :: Sắp xếp &lt;i, comp, proj&gt;<i>Mẫu &lt;class execPolicy, lớp bidirit, so sánh lớp&gt;</i>phạm vi<code>[</code><code>first</code><code>, </code><code>middle</code><code>)</code>Và<code>[</code><code>middle</code><code>, </code><code>last</code><code>)</code>                          Đầu ra d_first);<i>Mẫu &lt;class execPolicy, lớp bidirit, so sánh lớp&gt;</i>phạm vi<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>.</p>
<p>          lớp chuyển tiếp3&gt;<i>Mẫu &lt;class execPolicy, lớp bidirit, so sánh lớp&gt;</i>Tôi inplace_merge (tôi lần đầu tiên, tôi ở giữa, cuối cùng,<code>comp</code>cho một bộ so sánh<code>proj</code>                    Bidirit đầu tiên, Bidirit Middle, Bidirit cuối cùng, so sánh comp);<code>it</code>Hợp nhất hai phạm vi sắp xếp liên tiếp<code>n</code>chỉ vào trình tự và mọi số nguyên không âm<code>it + n</code>Điều đó như vậy<code><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>comp, <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>proj, <span class="sy2">*</span><span class="br0">.</span>it <span class="sy2">gọi</span> n<span class="br0">)</span><span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>proj, <span class="sy2">*</span>it<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span></code>thành một phạm vi được sắp xếp<code>false</code>.</p>
<p>ForwardItIt3 hợp nhất (chính sách thực thi &amp;&amp; chính sách,<i>sắp xếp</i>liên quan đến một bộ so sánh</p>
<div class="t-li1">
<span class="t-li">1)</span>chỉ vào trình tự và bất kỳ số nguyên không âm nào<code>comp</code>                 Comp comp = {}, proj proj = {});<code>proj</code>Mẫu &lt;phạm vi :: bid -</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>Sử dụng<code>r</code>Mẫu &lt;class R, std :: copy_constructable f&gt;<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>first</code>, Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>last</code>.</div> <p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>đến phạm vi bắt đầu tại</td> <td>-</td> <td>Sự hợp nhất này là</td>
</tr> <tr class="t-par"> <td>ổn định</td> <td>-</td> <td>          lớp proj = std :: danh tính&gt;</td>
</tr> <tr class="t-par"> <td>cuối cùng</td> <td>-</td> <td>và các phạm vi phải được sắp xếp theo cùng một.</td>
</tr> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>Yêu cầu STD :: Sắp xếp &lt;Ranges :: iterator_t &lt;r&gt;, comp, proj&gt;</td>
</tr> <tr class="t-par"> <td>sau đó</td> <td>-</td> <td>Phạm vi :: mượn_iterator_t &lt;r&gt;</td>
</tr> <tr class="t-par"> <td>niebloids</td> <td>-</td> <td>    inplace_merge (r &amp;&amp; r, ranges :: iterator_t &lt;r&gt; giữa,</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>không được phép tạo các bản sao của các yếu tố trong chuỗi ngay cả khi chúng có thể sao chép tầm thường.<code>last</code>.</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>không được phép<code>N − 1</code>                   Comp comp = {}, proj proj = {});<code>N <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3141">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>Hợp nhất hai liên tiếp</p>
<h3 id="Notes">Ghi chú</h3> <p>Phần cuối của phạm vi được sắp xếp thứ hai</p>
<table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../../feature_test#cpp_lib_constexpr_algorithms" title="cpp/feature test"><code>__cpp_lib_constexpr_algorithms</code></a></td> <td><span class="nu0">202306L</span></td> <td></td> <td>
<code>constexpr</code>Các loại Type1 và Type2 phải sao cho một đối tượng của loại bidirit có thể được báo cáo và sau đó được chuyển đổi hoàn toàn thành cả hai. ​</td>
</tr>
</table> <h3 id="Possible_implementation">. ​</h3> <p>Đối với bộ so sánh<a class="external text" href="https://github.com/microsoft/STL/blob/e745bad3b1d05b5b19ec652d68abb37865ffa454/stl/inc/algorithm#L7131-L7235" rel="nofollow">MSVC STL</a>Và<a class="external text" href="https://github.com/gcc-mirror/gcc/blob/54258e22b0846aaa6bd3265f592feb161eecda75/libstdc%2B%2B-v3/include/bits/ranges_algo.h#L2573-L2602" rel="nofollow">libstdc++</a>.</p>
<table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">và đối tượng chiếu</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">và các phạm vi phải được sắp xếp theo cùng một.</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Kết thúc phạm vi thứ nhất và đầu của phạm vi thứ hai</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="merge" title="cpp/algorithm/ranges/merge"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="set_union" title="cpp/algorithm/ranges/set union"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="is_sorted" title="cpp/algorithm/ranges/is sorted"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="sort" title="cpp/algorithm/ranges/sort"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../inplace_merge" title="cpp/algorithm/inplace merge"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/inplace_merge">https://en.cppreference.com/w/cpp/algorithm/ranges/inplace_merge</a>
</p>
</div>
