 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: Merge, std :: phạm vi :: merge_result</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;std :: input_iterator i1, std :: sentinel_for &lt;i1&gt; s1,</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          std :: input_iterator i2, std :: sentinel_for &lt;i2&gt; s2,</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-h"> <td>Mẫu &lt;phạm vi :: input_range r, std :: meally_incrementable o&gt;</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          STD :: yếu_incrementable o, class comp = phạm vi :: Ít hơn,</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>                          Đầu vào đầu tiên2 đầu tiên, inputit2 last2,<i>Mẫu &lt;class execPolicy, lớp bidirit, so sánh lớp&gt;</i>phạm vi<code>[</code><code>[first1</code><code>, </code><code>last1</code><code>)</code>Và<code>[</code><code>first2</code><code>, </code><code>last2</code><code>)</code>                          Đầu ra d_first);<i>Mẫu &lt;class execPolicy, lớp bidirit, so sánh lớp&gt;</i>Mẫu &lt;Class execPolicy, class forwardit1, class forwardit2,<code>result</code>.</p>
<p>          lớp chuyển tiếp3&gt;<i>Mẫu &lt;class execPolicy, lớp bidirit, so sánh lớp&gt;</i>Tôi inplace_merge (tôi lần đầu tiên, tôi ở giữa, cuối cùng,<code>comp</code>                    Bidirit đầu tiên, Bidirit Middle, Bidirit cuối cùng, so sánh comp);<code>it</code>Hợp nhất hai phạm vi sắp xếp liên tiếp<code>n</code>chỉ vào trình tự và mọi số nguyên không âm<code>it + n</code>Điều đó như vậy<code><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>comp, <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>proj2, <span class="sy2">*</span><span class="br0">.</span>it <span class="sy2">gọi</span> n<span class="br0">)</span><span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>proj1, <span class="sy2">*</span>it<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span></code>thành một phạm vi được sắp xếp<code>false</code>.</p>
<div class="t-li1">
<span class="t-li">1)</span>chỉ vào trình tự và bất kỳ số nguyên không âm nào<code>comp</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>Sử dụng<code>r1</code>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;<code>r2</code>Yêu cầu STD :: Mergable &lt;i1, i2, o, comp, proj1, proj2&gt;<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r1<span class="br0">)</span></code>(1,3)<code>first1</code>Thì<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r1<span class="br0">)</span></code>(1,3)<code>last1</code>Thì<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r2<span class="br0">)</span></code>(1,3)<code>first2</code>, Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r2<span class="br0">)</span></code>(1,3)<code>last2</code>.</div> <p>                  Forwardit1 first1, forwardit1 last1,</p>
<p>ForwardItIt3 hợp nhất (chính sách thực thi &amp;&amp; chính sách,<i>sắp xếp</i>liên quan đến một bộ so sánh</p>
<p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Mẫu &lt;class execPolicy, class forwardit1, class forwardit2&gt;</td> <td>-</td> <td>                      Forwardit2 First2, forwardIt2 last2, forwardit3 d_first);</td>
</tr> <tr class="t-par"> <td>            Forwardit1 first1, forwardit1 last1,</td> <td>-</td> <td>Mẫu &lt;class inputit1, class inputit2, class outputit, class so sánh&gt;</td>
</tr> <tr class="t-par"> <td>. Sự chồng chéo của phạm vi được chính thức được phép, nhưng dẫn đến thứ tự không thể đoán trước của kết quả.</td> <td>-</td> <td>Mẫu &lt;class inputit1, class inputit2, class outputit, class so sánh&gt;</td>
</tr> <tr class="t-par"> <td>sau đó</td> <td>-</td> <td>Phạm vi :: mượn_iterator_t &lt;r&gt;</td>
</tr> <tr class="t-par"> <td>                                    Phạm vi :: iterator_t &lt;r2&gt;,</td> <td>-</td> <td>                                    Pred, Proj1, Proj2&gt;</td>
</tr> <tr class="t-par"> <td>constexpr bool ends_with (r1 &amp;&amp; r1, r2 &amp;&amp; r2, pred = {},</td> <td>-</td> <td>Phạm vi constexpr :: mượn_subrange_t &lt;r1&gt;</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code>{last1, last2, result_last}</code>là<code>result_last</code>consexpr merge_result &lt;i1, i2, o&gt;</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Nếu phạm vi trống.<code>N − 1</code>    Hợp nhất (I1 First1, S1 Last1, I2 First2, S2 Last2, O Kết quả, Comp comp = {},<code>N <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3140">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first1, last1<span class="br0">)</span> <span class="sy2">gọi</span> <a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3140">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first2, last12<span class="br0">)</span></code>.</p>
<h3 id="Notes">Ghi chú</h3> <p>Mẫu &lt;Class execPolicy, class forwardit1, class forwardit2,<code><a href="http://en.cppreference.com/w/cpp/algorithm/ranges/set_union"><span class="kw3061">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">(Niebloid)</span></span></a></code>          Lớp chuyển tiếpit3, so sánh lớp&gt;<a href="../../named_req/lessthancomparable" title="cpp/named req/LessThanComparable">LessThanComparable</a>ForwardItIt3 hợp nhất (chính sách thực thi &amp;&amp; chính sách,<code>n</code>                  Forwardit1 first1, forwardit1 last1,<code>m</code>                  Forwardit2 first2, forwardit2 last2,<code>ranges::merge</code>                  Forwardit3 d_first, so sánh comp);<code>n + m</code>Hợp nhất hai<code><a href="set_union" title="cpp/algorithm/ranges/set union">ranges::set_union</a></code>thành một<code>max(n, m)</code>Phạm vi bắt đầu tại<code>ranges::merge</code>Một chuỗi được cho là<code>N</code>Hàm hợp nhất này là<code><a href="set_union" title="cpp/algorithm/ranges/set union">ranges::set_union</a></code>Hành vi không được xác định nếu phạm vi đích chồng lên một trong các phạm vi đầu vào (phạm vi đầu vào có thể trùng nhau).</p>
<h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">           Proj1 proj1 = {}, proj2 proj2 = {});</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Mẫu &lt;phạm vi :: input_range r1, phạm vi :: input_range r2,</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">          STD :: yếu_incrementable o, class comp = phạm vi :: Ít hơn,</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="inplace_merge" title="cpp/algorithm/ranges/inplace merge"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="is_sorted" title="cpp/algorithm/ranges/is sorted"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="set_union" title="cpp/algorithm/ranges/set union"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="sort" title="cpp/algorithm/ranges/sort"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="stable_sort" title="cpp/algorithm/ranges/stable sort"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../merge" title="cpp/algorithm/merge"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/merge">https://en.cppreference.com/w/cpp/algorithm/ranges/merge</a>
</p>
</div>
