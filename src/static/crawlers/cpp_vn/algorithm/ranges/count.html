 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: đếm, std :: phạm vi :: Count_if</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td><pre data-language="cpp">Mẫu &lt;std :: input_iterator i, std :: sentinel_for &lt;i&gt; s,</pre></td> <td>(1)</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          Lớp T, Class Proj = std :: Nhận dạng&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td><pre data-language="cpp">Yêu cầu STD :: Indirect_Binary_Predicate &lt;</pre></td> <td>(3)</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">             Phạm vi :: Equ_to, std :: Dự kiến ​​&lt;i, proj&gt;, const t*&gt;</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Mẫu &lt;class execPolicy, class forwardit, class t&gt;<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Typename iterator_traits &lt;TromentIt&gt; :: argen_type</p>
<div class="t-li1">
<span class="t-li">1)</span>    đếm (thực thipolicy &amp;&amp; chính sách,<code>value</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Mẫu &lt;class inputit, class unyredicate&gt;<code>p</code>(C ++ 20)<code>true</code>.</div> <div class="t-li1">
<span class="t-li">Một động thái tương đương với một bản sao</span>                                   Nhị phân p);<span class="t-v">*(d_first + 2) = val2 - std :: di chuyển (acc);</span>Sử dụng<code>r</code>              std :: dự kiến ​​&lt;i, proj &gt;&gt; pre<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>first</code>Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>last</code>.</div> <p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>Giống như</td>
</tr> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>Phạm vi ::</td>
</tr> <tr class="t-par"> <td>được phân vùng liên quan đến</td> <td>-</td> <td>Typename iterator_traits &lt;buputit&gt; :: argen_type</td>
</tr> <tr class="t-par"> <td>Sao chép các yếu tố, nhưng được thực thi theo</td> <td>-</td> <td>Các thực thể giống như chức năng được mô tả trên trang này là</td>
</tr> <tr class="t-par"> <td>niebloids</td> <td>-</td> <td>, đó là:</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Consexpr std :: iter_difference_t &lt;i&gt;</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>không được phép<code>last - first</code>    Đếm (Tôi đầu tiên, s cuối cùng, const t &amp; value, proj proj = {});</p>
<h3 id="Notes">Ghi chú</h3> <p>Mẫu &lt;phạm vi :: input_range r, class t, class proj = std :: nhận dạng&gt;<code>std::ranges::distance</code>.</p>
<h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <th>
<a href="#Version_1">count</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Yêu cầu STD :: Indirect_Binary_Predicate &lt;</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_3">count_if</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">             Phạm vi :: Equal_to, std :: Dự án &lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;, const t*&gt;</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Range constexpr :: Range_Difference_T &lt;R&gt;</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">    đếm (r &amp;&amp; r, const t &amp; value, proj proj = {});</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../../iterator/ranges/distance" title="cpp/iterator/ranges/distance"> <span class="t-lines"><span>Phạm vi :: Khoảng cách</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Trả về khoảng cách giữa một trình lặp và một sentinel, hoặc giữa đầu và cuối phạm vi<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../ranges/view_counted" title="cpp/ranges/view counted"> <span class="t-lines"><span>sử dụng một dấu phân cách</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(Đối tượng bộ điều hợp phạm vi)<br/><span class="t-mark">(Đối tượng điểm tùy chỉnh)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../ranges/filter_view" title="cpp/ranges/filter view"> <span class="t-lines"><span>Phạm vi :: Sở hữu_view</span><span>với quyền sở hữu duy nhất của một số</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Một<a href="../../ranges/view" title="cpp/ranges/view"><code>view</code></a>Phạm vi :: Filter_View<a href="../../ranges/range" title="cpp/ranges/range"><code>range</code></a>Lượt xem :: Bộ lọc<br/><span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> <span class="t-mark">bao gồm các yếu tố của người khác</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../count" title="cpp/algorithm/count"> <span class="t-lines"><span>(Niebloid)</span><span>đếm</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/count">https://en.cppreference.com/w/cpp/algorithm/ranges/count</a>
</p>
</div>
