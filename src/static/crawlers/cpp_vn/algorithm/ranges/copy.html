 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: Sao chép, std :: phạm vi :: copy_if, std :: ranges :: copy_result, std :: ranges :: copy_if_result</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td><pre data-language="cpp">Mẫu &lt;std :: input_iterator I, std :: sentinel_for &lt;i&gt; s, std :: meally_incrementable o&gt;</pre></td> <td>(1)</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Yêu cầu std :: gián tiếp_copyable &lt;i, o&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td><pre data-language="cpp">Consexpr copy_result &lt;i, o&gt;</pre></td> <td>(3)</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">    sao chép (tôi đầu tiên, s cuối cùng, o kết quả);</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-h"> <td>Mẫu &lt;phạm vi :: input_range r, std :: meally_incrementable o&gt;</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Yêu cầu STD :: InoneTHER_Copyable &lt;Ranges :: iterator_t &lt;r&gt;, o&gt;</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Consexpr copy_result &lt;phạm vi :: mượn_iterator_t &lt;r&gt;, o&gt;</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Mẫu &lt;class inputit, class outputit, lớp unyredicate&gt;<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Outputit copy_if (đầu vào đầu tiên, đầu vào cuối cùng, đầu ra d_first,<code>result</code>.</p>
<div class="t-li1">
<span class="t-li">1)</span>(Constexpr kể từ C ++ 20)<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Mẫu &lt;Class execPolicy,<code>first</code>          lớp chuyển tiếp1, class forwardit2, lớp unyredicate&gt;<code>last - 1</code>    sao chép (r &amp;&amp; r, o kết quả);<code>result</code>Mẫu &lt;std :: input_iterator I, std :: sentinel_for &lt;i&gt; s, std :: meally_incrementable o,<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>          lớp proj = std :: danh tính,<code><a href="copy_backward" title="cpp/algorithm/ranges/copy backward">ranges::copy_backward</a></code>                    Không có dự đoán);</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Bản sao tất cả các yếu tố trong phạm vi<code>pred</code>(C ++ 20)<code>true</code>          std :: indirect_unary_predicate &lt;std :: dự kiến ​​&lt;i, proj &gt;&gt; pred&gt;</div> <div class="t-li1">
<span class="t-li">Một động thái tương đương với một bản sao</span>                                   Nhị phân p);<span class="t-v">*(d_first + 2) = val2 - std :: di chuyển (acc);</span>Sử dụng<code>r</code>              std :: dự kiến ​​&lt;i, proj &gt;&gt; pre<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>first</code>Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>last</code>.</div> <p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>có thể được sử dụng thay thế.</td>
</tr> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>có thể được sử dụng thay thế.</td>
</tr> <tr class="t-par"> <td>. Sự chồng chéo của phạm vi được chính thức được phép, nhưng dẫn đến thứ tự không thể đoán trước của kết quả.</td> <td>-</td> <td>Yêu cầu std :: gián tiếp_copyable &lt;i, o&gt;</td>
</tr> <tr class="t-par"> <td>Sao chép các yếu tố, nhưng được thực thi theo</td> <td>-</td> <td>Các thực thể giống như chức năng được mô tả trên trang này là</td>
</tr> <tr class="t-par"> <td>niebloids</td> <td>-</td> <td>, đó là:</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>MỘT<code><a href="return_types/in_out_result" title="cpp/algorithm/ranges/return types/in out result">ranges::in_out_result</a></code>Consexpr copy_if_result &lt;i, o&gt;<code>last</code>    copy_if (đầu tiên tôi, s cuối cùng, o kết quả, pred, proj proj = {});</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <div class="t-li1">
<span class="t-li">Đầu vào</span>không được phép<code>last - first</code>Phần cuối của phạm vi đích</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>không được phép<code>last - first</code>Mẫu &lt;phạm vi :: input_range r, std :: meally_incrementable o,<code>​0​</code>Và<code>last - first</code>          lớp proj = std :: danh tính,<code>true</code>          std :: Indirect_unary_predicate &lt;</div> <h3 id="Notes">Ghi chú</h3> <p>cho các yếu tố cần thiết.<code>ranges::copy</code>Đầu ra tererator vào phần tử trong phạm vi đích, một qua phần tử cuối cùng được sao chép.<code><a href="../../string/byte/memmove" title="cpp/string/byte/memmove">std::memmove</a></code>Cho \ (\ scriptsize n \) n như<a href="../../named_req/triviallycopyable" title="cpp/named req/TriviallyCopyable">TriviallyCopyable</a>Chính xác là \ (\ scriptsize n \) n.<a href="../../iterator/contiguous_iterator" title="cpp/iterator/contiguous iterator"><code>contiguous_iterator</code></a>.</p>
<p>Chính xác \ (\ scriptsize n \) n ứng dụng của vị ngữ<code>ranges::copy</code>, và nhiều nhất là các bài tập NN.<a href="copy_backward" title="cpp/algorithm/ranges/copy backward"><code>ranges::copy_backward</code></a>Cho quá tải với một</p>
<h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <th>
<a href="#Version_1">copy</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_3">copy_if</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Yêu cầu STD :: InoneTHER_Copyable &lt;Ranges :: iterator_t &lt;r&gt;, o&gt;</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example">
<p>Trong thực tế, việc triển khai<code>ranges::copy</code>Tránh nhiều bài tập và sử dụng các chức năng bản sao hàng loạt như<code><a href="../../container/vector" title="cpp/container/vector">std::vector</a></code>Nếu loại giá trị là<code>std::vector</code>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">Consexpr copy_if_result &lt;phạm vi :: mượn_iterator_t &lt;r&gt;, o&gt;</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">    copy_if (r &amp;&amp; r, o result, pred, proj proj = {});</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="copy_backward" title="cpp/algorithm/ranges/copy backward"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="reverse_copy" title="cpp/algorithm/ranges/reverse copy"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="copy_n" title="cpp/algorithm/ranges/copy n"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="fill" title="cpp/algorithm/ranges/fill"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="remove_copy" title="cpp/algorithm/ranges/remove copy"> <span class="t-lines"><span>(Mẫu chức năng)</span><span>Phạm vi :: remove_copy</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../copy" title="cpp/algorithm/copy"> <span class="t-lines"><span>Được xác định trong tiêu đề</span><span>sao chép</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/copy">https://en.cppreference.com/w/cpp/algorithm/ranges/copy</a>
</p>
</div>
