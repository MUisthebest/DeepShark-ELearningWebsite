 <h1 class="firstHeading" id="firstHeading">STD :: Phạm vi :: Equal_range</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;std :: forward_iterator i, std :: sentinel_for &lt;i&gt; s,</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          Lớp T, Class Proj = std :: Nhận dạng,</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>          std :: Indirect_strict_weak_order &lt;<code>value</code>theo thứ tự.<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>.</div> <p>    Equal_range (Forwardit First, Forwardit Last, Const T &amp; Value);<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Mẫu &lt;class forwardit, class t, class so sánh&gt;<code>value</code>Consexpr Bool Binary_Search (ForwardIT đầu tiên, ForwardIt Last,</p>
<ul>
<li>Vì<code>element &lt; value</code>hoặc<code>comp(element, value)</code>Kiểm tra xem một phần tử tương đương với<code>true</code>Mẫu &lt;class forwardit, class t, class so sánh&gt;<code>false</code>).</li>
<li>Vì<code>!(value &lt; element)</code>hoặc<code>!comp(value, element)</code>.</li>
<li>thành công, phạm vi<code>element &lt; value</code>hoặc<code>comp(element, value)</code>khoảng cách<code>true</code>phải ít nhất được đặt hàng một phần đối với<code>!(value &lt; element)</code>hoặc<code>!comp(value, element)</code>, tức là nó phải đáp ứng tất cả các yêu cầu sau:<code>true</code>.</li>
</ul> <p>được phân vùng liên quan đến</p>
<p>              const t*,<i>Trả một trình lặp lại cho phần tử đầu tiên</i>hơn<code>value</code>                 const t &amp; value, so sánh comp);<i>Trả một trình lặp lại cho phần tử đầu tiên</i>hơn<code>value</code>Consexpr std :: cặp &lt;forwardit, forwardit&gt; <code>std::ranges::lower_bound()</code>    Equ_range (Forwardit First, Forwardit Last,<code>std::ranges::upper_bound()</code>.</p>
<div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>Sử dụng<code>r</code>              STD :: Dự kiến ​​&lt;i, proj &gt;&gt; comp = phạm vi :: Ít hơn&gt;<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>first</code>Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>last</code>.</div> <p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>Giống như</td>
</tr> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>Phạm vi ::</td>
</tr> <tr class="t-par"> <td>được phân vùng liên quan đến</td> <td>-</td> <td>cho tất cả các yếu tố, nếu</td>
</tr> <tr class="t-par"> <td>sau đó</td> <td>-</td> <td>cũng là<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>Constexpr Phạm vi :: Subrange &lt;i&gt;</td>
</tr> <tr class="t-par"> <td>niebloids</td> <td>-</td> <td>, đó là:</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code><a href="../../ranges/subrange" title="cpp/ranges/subrange">std::ranges::subrange</a></code>    Equal_range (I First, S Last, Const T &amp; Value, Comp comp = {}, proj proj = {});<i>Trả một trình lặp lại cho phần tử đầu tiên</i>hơn<code>value</code>Phạm vi<i>Trả một trình lặp lại cho phần tử đầu tiên</i>hơn<code>value</code>.</p>
<p>Phạm vi trả về được xác định bởi hai trình lặp, một chỉ vào phần tử đầu tiên đó là<i>Trả một trình lặp lại cho phần tử đầu tiên</i>hơn<code>value</code>Mẫu &lt;phạm vi :: forward_range r, class t, class proj = std :: identity,<code>last</code>hoặc<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>          std :: Indirect_strict_weak_order &lt;<i>Trả một trình lặp lại cho phần tử đầu tiên</i>hơn<code>value</code>              const t*,</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>ít hơn<code>first</code>Và<code>last</code>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; comp = ranges :: Ít hơn&gt;<sub class="t-su t-su-b">    return (! (đầu tiên == cuối cùng) và! (giá trị &lt; *đầu tiên));</sub>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../../iterator/random_access_iterator" title="cpp/iterator/random access iterator"><code>random_access_iterator</code></a>    Equal_range (r &amp;&amp; r, const t &amp; value, comp comp = {}, proj proj = {});</p>
<h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Trả về một chế độ xem chứa tất cả các yếu tố tương đương với</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Chế độ xem trả về được xây dựng từ hai trình lặp, một chỉ vào phần tử đầu tiên đó là</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">như phạm vi nguồn, như thể sử dụng phạm vi</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="lower_bound" title="cpp/algorithm/ranges/lower bound"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<i>Trả một trình lặp lại cho phần tử đầu tiên</i>không ít hơn<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="upper_bound" title="cpp/algorithm/ranges/upper bound"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<i>Trả một trình lặp lại cho phần tử đầu tiên</i>lớn hơn<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="binary_search" title="cpp/algorithm/ranges/binary search"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="partition" title="cpp/algorithm/ranges/partition"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="equal" title="cpp/algorithm/ranges/equal"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../equal_range" title="cpp/algorithm/equal range"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/equal_range">https://en.cppreference.com/w/cpp/algorithm/ranges/equal_range</a>
</p>
</div>
