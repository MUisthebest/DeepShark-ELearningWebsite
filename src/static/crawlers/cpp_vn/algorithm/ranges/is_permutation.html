 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: is_permuting</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;std :: forward_iterator i1, std :: sentinel_for &lt;i1&gt; s1,</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          std :: forward_iterator i2, std :: sentinel_for &lt;i2&gt; s2,</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Mẫu &lt;Class execPolicy,<code>true</code>                     Forwardit2 First2, nhị phân p);<a class="extiw" href="https://en.wikipedia.org/wiki/permutation" title="enwiki:permutation">permutation</a>          Lớp Proj1 = std :: Nhận dạng, lớp proj2 = std :: Nhận dạng,<code>[</code><code>first1</code><code>, </code><code>last1</code><code>)</code>          STD :: Indirect_equilcity_Relation &lt;std :: dự kiến ​​&lt;i1, proj1&gt;,<i>(Niebloid)</i>ĐẾN<code>[</code><code>first2</code><code>, </code><code>last2</code><code>)</code>                                             std :: dự kiến ​​&lt;i2, proj2 &gt;&gt;<code>Proj1</code>Thì<code>Proj2</code>                                                 Pre<code>Pred</code>Consexpr bool is_permuting (I1 First1, S1 Last1, I2 First2, S2 Last2,<code>false</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>Sử dụng<code>r1</code>                                        const t*&gt;<code>r2</code>Consexpr bool chứa (r &amp;&amp; r, const t &amp; value, proj proj = {});<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r1<span class="br0">)</span></code>(1,3)<code>first1</code>Thì<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r1<span class="br0">)</span></code>(1,3)<code>last1</code>Thì<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r2<span class="br0">)</span></code>(1,3)<code>first2</code>, Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r2<span class="br0">)</span></code>(1,3)<code>last2</code>.</div> <p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Mẫu &lt;class execPolicy, class forwardit1, class forwardit2&gt;</td> <td>-</td> <td>ConsExPR STD :: Cặp &lt;Inputit1, Inputit2&gt;</td>
</tr> <tr class="t-par"> <td>            Forwardit1 first1, forwardit1 last1,</td> <td>-</td> <td>              không phù hợp (Inputit1 First1, Inputit1 Last1,</td>
</tr> <tr class="t-par"> <td>          lớp pre = phạm vi :: carm_to,</td> <td>-</td> <td>ConsExPR STD :: Cặp &lt;Inputit1, Inputit2&gt;</td>
</tr> <tr class="t-par"> <td>Yêu cầu (phạm vi :: forward_range &lt;r1&gt; |</td> <td>-</td> <td>              không phù hợp (Inputit1 First1, Inputit1 Last1,</td>
</tr> <tr class="t-par"> <td>Sao chép các yếu tố, nhưng được thực thi theo</td> <td>-</td> <td>Các thực thể giống như chức năng được mô tả trên trang này là</td>
</tr> <tr class="t-par"> <td>                                    Phạm vi :: iterator_t &lt;r2&gt;,</td> <td>-</td> <td>                                    Pred, Proj1, Proj2&gt;</td>
</tr> <tr class="t-par"> <td>constexpr bool ends_with (r1 &amp;&amp; r1, r2 &amp;&amp; r2, pred = {},</td> <td>-</td> <td>Phạm vi constexpr :: mượn_subrange_t &lt;r1&gt;</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code>true</code>          lớp chuyển tiếp1, lớp forwardit2, lớp nhị phân&gt;<code>[</code><code>first1</code><code>, </code><code>last1</code><code>)</code>Mẫu &lt;class forwardit1, class forwardit2, lớp nhị phân&gt;<code>[</code><code>first2</code><code>, </code><code>last2</code><code>)</code>.</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>consexpr bool is_permuting (forwardit1 first1, forwardIt1 last1,<sup>    return (! (đầu tiên == cuối cùng) và! (giá trị &lt; *đầu tiên));</sup>                               PROD PRED = {}, proj1 proj1 = {}, proj2 proj2 = {});<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3141">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first1, last1<span class="br0">)</span></code>Mẫu &lt;phạm vi :: forward_range r1, phạm vi :: forward_range r2,<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3141">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first1, last1<span class="br0">)</span> <span class="sy3">Nếu tồn tại một</span><span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3141">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first2, last2<span class="br0">)</span></code>          Lớp Proj1 = std :: Nhận dạng, lớp proj2 = std :: Nhận dạng,</p>
<h3 id="Notes">Ghi chú</h3> <p>Các<i>          STD :: Indirect_equilationence_relation &lt;std :: Dự án &lt;phạm vi :: iterator_t &lt;r1&gt;, proj1&gt;,</i>                                             std :: dự kiến ​​&lt;phạm vi :: iterator_t &lt;r2&gt;, proj2 &gt;&gt;<a class="extiw" href="https://en.wikipedia.org/wiki/equivalence_relation" title="enwiki:equivalence relation">equivalence relation</a>.</p>
<p>Các<strong class="selflink"><code>ranges::is_permutation</code></strong>có thể được sử dụng trong<i>biểu thị</i>Nếu nó không được đưa ra.<code>x</code>. Hành vi không xác định nếu nó không phải là<code>y</code>Điều đó như vậy<i>. Hành vi không được xác định nếu nó không phải là một mối quan hệ tương đương.</i>phạm vi của các yếu tố để so sánh<code>ranges::is_permutation(x, y) == true</code>Phạm vi thứ hai để so sánh<code>y</code>vị từ nhị phân trả về<i>nên là loại giá trị của cả hai</i>. Chữ ký không cần phải có</p>
<h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">                                                 Pre</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Constexpr bool is_permuting (r1 &amp;&amp; r1, r2 &amp;&amp; r2, pre pre = {},</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">                               Proj1 proj1 = {}, proj2 proj2 = {});</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="next_permutation" title="cpp/algorithm/ranges/next permutation"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="prev_permutation" title="cpp/algorithm/ranges/prev permutation"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../is_permutation" title="cpp/algorithm/is permutation"> <span class="t-lines"><span>(Niebloid)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../next_permutation" title="cpp/algorithm/next permutation"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../prev_permutation" title="cpp/algorithm/prev permutation"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../concepts/equivalence_relation" title="cpp/concepts/equivalence relation"> <span class="t-lines"><span>Boolean-testable</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Chỉ định toán tử đó<a href="../../concepts/relation" title="cpp/concepts/relation"><code>relation</code></a>Khái niệm chỉ giải thích*<br/> <span class="t-mark">(ý tưởng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/is_permutation">https://en.cppreference.com/w/cpp/algorithm/ranges/is_permutation</a>
</p>
</div>
