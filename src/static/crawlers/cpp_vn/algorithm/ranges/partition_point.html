 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: phân vùng_point</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;std :: forward_iterator i, std :: sentinel_for &lt;i&gt; s,</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          lớp proj = std :: danh tính,</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Mẫu &lt;class forwardit, lớp unyrepreicate&gt;<code><a href="partition" title="cpp/algorithm/ranges/partition">ranges::partition</a></code>ConstExpr chuyển tiếp phân vùng_point (ForwardIt đầu tiên, chuyển tiếp cuối cùng, không được tính p);<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>hoặc<code>r</code>          std :: indirect_unary_predicate &lt;std :: dự kiến ​​&lt;i, proj &gt;&gt; pred&gt;<code>pred</code>hoặc<code>last</code>          lớp proj = std :: danh tính,<code>pred</code>.</p>
<p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>    phân vùng_point (tôi đầu tiên, s cuối cùng, pred, proj proj = {});</td>
</tr> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>    Lower_bound (I First, S Last, Const T &amp; Value, Comp comp = {}, proj proj = {});</td>
</tr> <tr class="t-par"> <td>Sao chép các yếu tố, nhưng được thực thi theo</td> <td>-</td> <td>Các thực thể giống như chức năng được mô tả trên trang này là</td>
</tr> <tr class="t-par"> <td>niebloids</td> <td>-</td> <td>, đó là:</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Phạm vi phân vùng của các yếu tố để kiểm tra<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Mẫu &lt;phạm vi :: forward_range r,<code>last</code>          lớp proj = std :: danh tính,<code>pred</code>.</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Cho quá tải<code>N <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3141">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>Người lặp qua cuối phân vùng đầu tiên trong<code>pred</code>cho một bộ so sánh<code>proj</code>.</p>
<p>          std :: Indirect_unary_predicate &lt;<code><a href="http://en.cppreference.com/w/cpp/iterator/sized_sentinel_for"><span class="kw2863">Điều đó cho tất cả<span class="me2">Kích thước_sentinel_for</span></span></a><span class="sy1">is_trivently_destructible_v</span>I<span class="sy1">&lt;</span></code>, thực hiện các ứng dụng O (log n) của vị ngữ</p>
<h3 id="Notes">Ghi chú</h3> <p>Tuy nhiên, đối với không<code>ranges::lower_bound</code>, số lượng số lặp gia tăng là O (n).<code>ranges::partition_point</code>Thuật toán này là một hình thức chung hơn của<code><span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span><span class="sy3">Không có giá trị</span><span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span><span class="br0">.</span><span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span> <span class="kw4">hằng số</span><span class="sy3">Không có giá trị</span> e<span class="br0">)</span> <span class="br0">danh tính</span> <span class="kw1">Không chính thức,</span> <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>pred, e, value<span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span> <span class="br0">{</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>.</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">và định vị sự kết thúc của phân vùng đầu tiên, nghĩa là phần tử dự kiến ​​không thỏa mãn</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">Nếu tất cả các yếu tố dự kiến ​​thỏa mãn</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="is_sorted" title="cpp/algorithm/ranges/is sorted"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="lower_bound" title="cpp/algorithm/ranges/lower bound"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<i>Trả một trình lặp lại cho phần tử đầu tiên</i>không ít hơn<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../partition_point" title="cpp/algorithm/partition point"> <span class="t-lines"><span>(Niebloid)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/partition_point">https://en.cppreference.com/w/cpp/algorithm/ranges/partition_point</a>
</p>
</div>
