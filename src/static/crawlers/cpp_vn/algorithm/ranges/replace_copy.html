 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: thay thế_copy, std :: ranges :: thay thế_copy_if, std :: ranges :: thay thế_copy_result, std :: ranges :: thay thế_copy_if_result</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td><pre data-language="cpp">Mẫu &lt;std :: input_iterator I, std :: sentinel_for &lt;i&gt; s, class T1, Class T2,</pre></td> <td>(1)</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          std :: output_iterator &lt;const t2 &amp;&gt; o, class proj = std :: nhận dạng&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td><pre data-language="cpp">Yêu cầu STD :: gián tiếp_copyable &lt;i, o&gt; &amp;&amp;</pre></td> <td>(3)</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">         std :: indirect_binary_predicate &lt;ranges :: quare_to,</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-h"> <td>Mẫu &lt;phạm vi :: input_range r, std :: meally_incrementable o&gt;</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">             std :: dự kiến ​​&lt;i, proj&gt;, const t1*&gt;</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">ConstExPR Thay thế_Copy_Result &lt;i, o&gt;</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>    thay thế_copy (đầu tiên tôi, s cuối cùng, o kết quả, const t1 &amp; old_value, const t2 &amp; new_value,<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>                  Proj proj = {});<code>result</code>Mẫu &lt;phạm vi :: input_range r, lớp T1, lớp T2,<code>new_value</code>          std :: output_iterator &lt;const t2 &amp;&gt; o, class proj = std :: nhận dạng&gt;</p>
<div class="t-li1">
<span class="t-li">1)</span>void thay thế (ExecSt<code>old_value</code>Mẫu &lt;class inputit, lớp đầu ra,<code><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>proj, <span class="sy2">*</span><span class="br0">.</span>first <span class="sy2">gọi</span> <span class="br0">.</span>i <span class="sy2">-</span> result<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span> <span class="sy1">==</span> old_value</code>Mẫu &lt;phạm vi :: forward_range r, class t, class proj = std :: identity&gt;</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>             std :: dự kiến ​​&lt;i, proj&gt;, const t1*&gt;<code>pred</code>thành một phạm vi được sắp xếp<code>true</code>Yêu cầu std :: gián tiếp_copyable &lt;phạm vi :: iterator_t &lt;r&gt;, o&gt; &amp;&amp;<code><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>pred, <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>proj, <span class="sy2">*</span><span class="br0">.</span>first <span class="sy2">gọi</span> <span class="br0">.</span>i <span class="sy2">-</span> result<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">Một động thái tương đương với một bản sao</span>                                   Nhị phân p);<span class="t-v">*(d_first + 2) = val2 - std :: di chuyển (acc);</span>Sử dụng<code>r</code>              std :: dự kiến ​​&lt;i, proj &gt;&gt; pre<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>first</code>, Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>last</code>.</div> <p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>có thể được sử dụng thay thế.</td>
</tr> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>có thể được sử dụng thay thế.</td>
</tr> <tr class="t-par"> <td>. Sự chồng chéo của phạm vi được chính thức được phép, nhưng dẫn đến thứ tự không thể đoán trước của kết quả.</td> <td>-</td> <td>Để lưu trữ giá trị bị trừ:</td>
</tr> <tr class="t-par"> <td>Mẫu &lt;class forwardIt, lớp unypredicate, class t&gt;</td> <td>-</td> <td>void thay thế_if (forwardit đầu tiên, forwardit cuối cùng,</td>
</tr> <tr class="t-par"> <td>Mẫu &lt;class forwardIt, lớp unypredicate, class t&gt;</td> <td>-</td> <td>    Thay thế (tôi lần đầu tiên, S Last, Const T1 &amp; Old_Value, Const T2 &amp; New_Value,</td>
</tr> <tr class="t-par"> <td>Sao chép các yếu tố, nhưng được thực thi theo</td> <td>-</td> <td>Các thực thể giống như chức năng được mô tả trên trang này là</td>
</tr> <tr class="t-par"> <td>niebloids</td> <td>-</td> <td>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code>{last, result + N}</code>là</p>
<div class="t-li1">
<span class="t-li">(Do đó,</span> <code>N <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3138">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>Số lượng các yếu tố để sao chép</div> <div class="t-li1">
<span class="t-li">Một động thái tương đương với một bản sao</span> <code>N <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3138">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>.</div> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>không được phép<code>N</code>          std :: indirect_unary_predicate &lt;std :: dự kiến ​​&lt;iterator_t &lt;r&gt;, proj &gt;&gt; pred&gt; pre<code>comp</code>Yêu cầu STD :: gián tiếp_copyable &lt;phạm vi :: iterator_t &lt;r&gt;, o1&gt; &amp;&amp;<code>proj</code>.</p>
<h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <th>
<a href="#Version_1">replace_copy (1-2)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">         std :: indirect_binary_predicate &lt;ranges :: quare_to,</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_3">replace_copy_if (3-4)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">             STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;, const t1*&gt;</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">constexpr thay thế_copy_result &lt;phạm vi :: mượn_iterator_t &lt;r&gt;, o&gt;</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">    thay thế_copy (r &amp;&amp; r, o kết quả, const t1 &amp; old_value, const t2 &amp; new_value,</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="replace" title="cpp/algorithm/ranges/replace"> <span class="t-lines"><span>(Mẫu chức năng)</span><span>Phạm vi :: Thay thế</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../replace_copy" title="cpp/algorithm/replace copy"> <span class="t-lines"><span>(Niebloid)</span><span>Thay thế_Copy</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/replace_copy">https://en.cppreference.com/w/cpp/algorithm/ranges/replace_copy</a>
</p>
</div>
