 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: Fold_right_last</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">Mẫu &lt;std :: bidIrectional_iterator i, std :: sentinel_for &lt;i&gt; s,</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">          __Indirectly_binary_right_foldable &lt;std :: iter_value_t &lt;i&gt;, i&gt; f&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl-h"> <td>    trả về std :: tuple &lt;std :: indoke_result_t &lt;f &amp;, ts&gt; ...&gt; (</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">ConstExpr Auto Fold_left (I First, S Last, T init, F F);</pre>
</td> <td>(3)</td> <td> <span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">ConstExpr Auto Fold_Right (I First, S Last, T init, F F);</pre>
</td> <td>(4)</td> <td> <span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> </table> <p>Mẫu &lt;phạm vi :: bid -<a class="extiw" href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)" title="enwiki:Fold (higher-order function)">folds</a>          A<br/><code>f(x<sub>, nếu như</sub>, f(x<sub>    return (! (đầu tiên == cuối cùng) và! (giá trị &lt; *đầu tiên));</sub>, ...f(x<sub>Yêu cầu STD :: Constructible_From &lt;</sub>, x<sub>Trả về một kết quả, kết quả được bỏ qua. Nếu như</sub>)))</code>là<code>x<sub>, nếu như</sub></code>Thì<code>x<sub>    return (! (đầu tiên == cuối cùng) và! (giá trị &lt; *đầu tiên));</sub></code>ConstExpr Auto Fold_left (r &amp;&amp; r, t init, f f);<code>x<sub>Trả về một kết quả, kết quả được bỏ qua. Nếu như</sub></code>Mẫu &lt;Class F, Class T, Class I&gt;</p>
<p>Khái niệm __Indirectly_binary_left_foldable = / * Xem Mô tả * /;<code>ranges::fold_right_last</code>giá trị ban đầu của tổng tổng quát<code>std<span class="sy4">::</span><span class="me2">             Phạm vi :: Range_Value_T &lt;R&gt;, phạm vi :: Range_Reference_T &lt;R &gt;&gt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/algorithm/ranges/reverse"><span class="kw3050">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">Được xác định trong tiêu đề</span></span></a><span class="br0">.</span>r<span class="br0">)</span>, <span class="sy2">             std :: iter_value_t &lt;i&gt;, std :: iter_reference_t &lt;i &gt;&gt;</span>last, __flipped<span class="br0">.</span>f<span class="br0">)</span><span class="br0">)</span></code>ConstExpr Auto Fold_right_Last (đầu tiên tôi, s cuối cùng, f f);</p>
<p>đến một phạm vi khác kết thúc tại<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Các yếu tố của phạm vi đã cho, nghĩa là trả về kết quả đánh giá biểu thức chuỗi:</p>
<div class="t-li1">
<span class="t-li">1)</span>, ...,<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Mẫu &lt;phạm vi :: bid -<code>U</code>(1,3)<code>decltype<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/algorithm/ranges/fold_right"><span class="kw3562">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">phạm vi của các yếu tố để gấp</span></span></a><span class="br0">.</span>first, last, <a href="http://en.cppreference.com/w/cpp/iterator/iter_t"><span class="kw2872">Điều đó cho tất cả<span class="me2">ITER_VALUE_T</span></span></a><span class="sy1">is_trivently_destructible_v</span>I<span class="sy1">&lt;</span><span class="br0">.</span><span class="sy2">*</span>first<span class="br0">)</span>, f<span class="br0">)</span><span class="br0">)</span></code>          __Indirectly_binary_right_foldable &lt;<div class="cpp source-cpp"><pre data-language="cpp">              Phạm vi :: Range_Value_T &lt;R&gt;, phạm vi :: iterator_t &lt;r&gt;&gt; f&gt;</pre></div>
</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>không phải là một phạm vi hợp lệ.<code>r</code>Phạm vi là<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>first</code>Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r<span class="br0">)</span></code>(1,3)<code>last</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>                                                  Inputit2 First2, Inputit2 Last2);<table class="t-dcl-begin"> <tr class="t-dcl-h"> <td>    trả về std :: tuple &lt;std :: indoke_result_t &lt;f &amp;, ts&gt; ...&gt; (</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">. Tương đương với</pre>
</td> <td>trở lại</td> <td> <span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Fold_left_with_iter</pre>
</td> <td>, ngoại trừ việc sử dụng</td> <td> <span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> </table>
</div> <div class="t-li1">
<span class="t-li">là trong</span>                                                  Inputit2 First2, Inputit2 Last2);<table class="t-dcl-begin"> <tr class="t-dcl-h"> <td>    trả về std :: tuple &lt;std :: indoke_result_t &lt;f &amp;, ts&gt; ...&gt; (</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">          A</pre>
</td> <td>ConstExpr Auto Fold_Right (R &amp;&amp; R, T init, F F);</td> <td> <span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> <tr class="t-dcl-h"> <td>Mẫu &lt;Class F, Class T, Class I&gt;</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Khái niệm __Indirectly_binary_right_foldable = / * Xem Mô tả * /;</pre>
</td> <td>Phải-</td> <td> <span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> </table>
</div> <p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>Mẫu &lt;Class F, Class T, Class I, Class U&gt;</td>
</tr> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>Mẫu &lt;Class F, Class T, Class I, Class U&gt;</td>
</tr> <tr class="t-par"> <td>có thể sửa đổi các phần tử của phạm vi thông qua trình lặp được thu hút. Nếu như</td> <td>-</td> <td>  std :: di chuyển &lt;t&gt; &amp;&amp;</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>  std :: di chuyển &lt;u&gt; &amp;&amp;<code><a href="http://en.cppreference.com/w/cpp/utility/optional"><span class="kw1077">Điều đó cho tất cả<span class="me2">không mở-cache</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">&lt;</span></code>Mẫu &lt;Class F, Class T, Class I&gt;<a class="extiw" href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)" title="enwiki:Fold (higher-order function)">fold</a>  std :: có thể gọi &lt;f &amp;, u, std :: iter_reference_t &lt;i &gt;&gt; &amp;&amp;<code>f</code>.</p>
<p>, ...<code><a href="http://en.cppreference.com/w/cpp/utility/optional"><span class="kw1077">Điều đó cho tất cả<span class="me2">không mở-cache</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">&lt;</span><span class="br0">.</span><span class="br0">)</span></code>bất kể</p>
<h3 id="Possible_implementations">(3a)</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Yêu cầu STD :: Constructible_From &lt;</pre></div> </td>
</tr>
</table> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>không được phép<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3142">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>Khái niệm /*gián tiếp nhị phân-bên trái có thể gấp* / =<code>f</code>.</p>
<h3 id="Notes">Ghi chú</h3> <p>  std :: copy_constructible &lt;f&gt; &amp;&amp;</p>
<table class="wikitable"> <tr> <th>  std :: gián tiếp_readable &lt;i&gt; &amp;&amp;</th> <th>  std :: có thể gọi &lt;f &amp;, t, std :: iter_reference_t &lt;i &gt;&gt; &amp;&amp;</th> <th>  STD :: mui trần_to &lt;std :: indoke_result_t &lt;f &amp;, t, std :: iter_reference_t &lt;i &gt;&gt;,</th> <th>    std :: decay_t &lt;std :: indoke_result_t &lt;f &amp;, t, std :: iter_reference_t &lt;i &gt;&gt;&gt;&gt; &amp;&amp;&amp;&amp;</th>
</tr> <tr> <td><code><a href="http://en.cppreference.com/w/cpp/algorithm/ranges/fold_left"><span class="kw3558">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">             Phạm vi :: Range_Value_T &lt;R&gt;, phạm vi :: Range_Reference_T &lt;R &gt;&gt;</span></span></a></code></td> <td>    Mẫu &lt;std :: input_iterator I, std :: sentinel_for &lt;i&gt; s, class T,</td> <td><code>init</code></td> <td>
<code>U</code> </td>
</tr> <tr> <td><code><a href="http://en.cppreference.com/w/cpp/algorithm/ranges/fold_left_first"><span class="kw3559">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">      std :: decay_t &lt;std :: indoke_result_t &lt;f &amp;, t, std :: iter_reference_t &lt;i &gt;&gt;&gt;&gt;&gt;;</span></span></a></code></td> <td>    Mẫu &lt;std :: input_iterator I, std :: sentinel_for &lt;i&gt; s, class T,</td> <td>             __Indirectly_binary_left_foldable &lt;t, i&gt; f&gt;</td> <td>
<code><a href="http://en.cppreference.com/w/cpp/utility/optional"><span class="kw1077">Điều đó cho tất cả<span class="me2">không mở-cache</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">&lt;</span></code> </td>
</tr> <tr> <td><code><a href="http://en.cppreference.com/w/cpp/algorithm/ranges/fold_right"><span class="kw3562">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">phạm vi của các yếu tố để gấp</span></span></a></code></td> <td>Một đối tượng của loại</td> <td><code>init</code></td> <td>
<code>U</code> </td>
</tr> <tr> <td><code>ranges::fold_right_last</code></td> <td>Một đối tượng của loại</td> <td>chứa kết quả của trái-</td> <td>
<code><a href="http://en.cppreference.com/w/cpp/utility/optional"><span class="kw1077">Điều đó cho tất cả<span class="me2">không mở-cache</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">&lt;</span></code> </td>
</tr> <tr> <td><code><a href="http://en.cppreference.com/w/cpp/algorithm/ranges/fold_left_with_iter"><span class="kw3561">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">của phạm vi đã cho</span></span></a></code></td> <td>    Mẫu &lt;std :: input_iterator I, std :: sentinel_for &lt;i&gt; s, class T,</td> <td><code>init</code></td> <td> <p>(1)<code><a href="http://en.cppreference.com/w/cpp/algorithm/ranges/return_types/in_value_result"><span class="kw3565">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    {</span></span></a><span class="sy1">is_trivently_destructible_v</span>I, U<span class="sy1">&lt;</span></code></p>
<p>(2)<code><a href="http://en.cppreference.com/w/cpp/algorithm/ranges/return_types/in_value_result"><span class="kw3565">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    {</span></span></a><span class="sy1">is_trivently_destructible_v</span>BR, U<span class="sy1">&lt;</span></code>Thì</p>
<p>Ở đâu<code>BR</code>khoảng cách<code><a href="http://en.cppreference.com/w/cpp/ranges/borrowed_iterator_t"><span class="kw2855">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">        sử dụng u = std :: decay_t &lt;std :: indoke_result_t &lt;f &amp;, t, std :: iter_reference_t &lt;i &gt;&gt;&gt;;</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">&lt;</span></code></p>
</td>
</tr> <tr> <td><code><a href="http://en.cppreference.com/w/cpp/algorithm/ranges/fold_left_first_with_iter"><span class="kw3560">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">{</span></span></a></code></td> <td>    Mẫu &lt;std :: input_iterator I, std :: sentinel_for &lt;i&gt; s, class T,</td> <td>             __Indirectly_binary_left_foldable &lt;t, i&gt; f&gt;</td> <td> <p>(1)<code><a href="http://en.cppreference.com/w/cpp/algorithm/ranges/return_types/in_value_result"><span class="kw3565">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    {</span></span></a><span class="sy1">is_trivently_destructible_v</span>I, <a href="http://en.cppreference.com/w/cpp/utility/optional"><span class="kw1077">Điều đó cho tất cả<span class="me2">không mở-cache</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">2,4)</span></code></p>
<p>(2)<code><a href="http://en.cppreference.com/w/cpp/algorithm/ranges/return_types/in_value_result"><span class="kw3565">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">    {</span></span></a><span class="sy1">is_trivently_destructible_v</span>BR, <a href="http://en.cppreference.com/w/cpp/utility/optional"><span class="kw1077">Điều đó cho tất cả<span class="me2">không mở-cache</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">2,4)</span></code></p>
<p>Ở đâu<code>BR</code>khoảng cách<code><a href="http://en.cppreference.com/w/cpp/ranges/borrowed_iterator_t"><span class="kw2855">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">        sử dụng u = std :: decay_t &lt;std :: indoke_result_t &lt;f &amp;, t, std :: iter_reference_t &lt;i &gt;&gt;&gt;;</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">&lt;</span></code></p>
</td>
</tr>
</table> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../../feature_test#cpp_lib_ranges_fold" title="cpp/feature test"><code>__cpp_lib_ranges_fold</code></a></td> <td><span class="nu0">202207L</span></td> <td><span class="t-mark">Phạm vi :: IOTA</span></td> <td>
<code>std::ranges</code> <a href="../ranges#Constrained_fold_operations" title="cpp/algorithm/ranges">fold algorithms</a> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">             Phạm vi :: Range_Value_T &lt;R&gt;, phạm vi :: Range_Reference_T &lt;R &gt;&gt;</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">ConstExpr Auto Fold_right_Last (R &amp;&amp; R, F F);</pre></div> </div> <h3 id="References">Tài liệu tham khảo</h3> <ul>
<li>C ++ 23 Tiêu chuẩn (ISO/IEC 14882: 2023):</li>
<ul><li>        U accum = std :: gọi (f, std :: di chuyển (init), *đầu tiên);</li></ul>
</ul> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="fold_right" title="cpp/algorithm/ranges/fold right"> <span class="t-lines"><span>(Niebloid)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td>(C ++ 23)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="fold_left" title="cpp/algorithm/ranges/fold left"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td>(C ++ 23)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="fold_left_first" title="cpp/algorithm/ranges/fold left first"> <span class="t-lines"><span>(Niebloid)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td>(C ++ 23)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="fold_left_with_iter" title="cpp/algorithm/ranges/fold left with iter"> <span class="t-lines"><span>(Niebloid)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td>(C ++ 23)<a href="return_types/in_value_result" title="cpp/algorithm/ranges/return types/in value result">pair</a>bên trái một loạt các yếu tố và trả về một<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="fold_left_first_with_iter" title="cpp/algorithm/ranges/fold left first with iter"> <span class="t-lines"><span>(Niebloid)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td>(C ++ 23)<a href="return_types/in_value_result" title="cpp/algorithm/ranges/return types/in value result">pair</a>bên trái, một loạt các phần tử bằng cách sử dụng phần tử đầu tiên làm giá trị ban đầu và trả về một<a href="../../utility/optional" title="cpp/utility/optional">optional</a>)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../accumulate" title="cpp/algorithm/accumulate"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>tích lũy<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../reduce" title="cpp/algorithm/reduce"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>(C ++ 17)<code><a href="../accumulate" title="cpp/algorithm/accumulate">std::accumulate</a></code>Tương tự như<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/fold_right_last">https://en.cppreference.com/w/cpp/algorithm/ranges/fold_right_last</a>
</p>
</div>
