 <h1 class="firstHeading" id="firstHeading">std :: phạm vi :: set_union, std :: phạm vi :: set_union_result</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;std :: input_iterator i1, std :: sentinel_for &lt;i1&gt; s1,</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          std :: input_iterator i2, std :: sentinel_for &lt;i2&gt; s2,</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-h"> <td>Mẫu &lt;phạm vi :: input_range r, std :: meally_incrementable o&gt;</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          STD :: yếu_incrementable o, class comp = phạm vi :: Ít hơn,</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>                              Đầu ra d_first);<code>result</code>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;<code>[</code><code>first1</code><code>, </code><code>last1</code><code>)</code>Và<code>[</code><code>first2</code><code>, </code><code>last2</code><code>)</code>.</p>
<p>Yêu cầu STD :: Mergable &lt;i1, i2, o, comp, proj1, proj2&gt;<code>m</code>    set_intersection (I1 First1, S1 Last1, I2 First2, S2 Last2,<code>[</code><code>first1</code><code>, </code><code>last1</code><code>)</code>Và<code>n</code>    set_intersection (I1 First1, S1 Last1, I2 First2, S2 Last2,<code>[</code><code>first2</code><code>, </code><code>last2</code><code>)</code>Yêu cầu STD :: Mergable &lt;i1, i2, o, comp, proj1, proj2&gt;<code>m</code>Mẫu &lt;class inputit1, class inputit2, class outputit, class so sánh&gt;<code>[</code><code>first1</code><code>, </code><code>last1</code><code>)</code>ĐẾN<code>result</code>consexpr set_union_result &lt;i1, i2, o&gt;<code>max(n - m, 0)</code>Mẫu &lt;class inputit1, class inputit2, class outputit, class so sánh&gt;<code>[</code><code>first2</code><code>, </code><code>last2</code><code>)</code>ĐẾN<code>result</code>    set_union (I1 First1, S1 Last1, I2 First2, S2 Last2,</p>
<p>đến một phạm vi khác kết thúc tại</p>
<ul>
<li>    set_diferference (I1 First1, S1 Last1, I2 First2, S2 Last2,<code>comp</code>Và<code>proj1</code>hoặc<code>proj2</code>                    O Kết quả, comp comp = {},</li>
<li>                    Proj1 proj1 = {}, proj2 proj2 = {});</li>
</ul> <div class="t-li1">
<span class="t-li">1)</span>chỉ vào trình tự và bất kỳ số nguyên không âm nào<code>comp</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>Sử dụng<code>r1</code>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;<code>r2</code>Yêu cầu STD :: Mergable &lt;i1, i2, o, comp, proj1, proj2&gt;<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r1<span class="br0">)</span></code>(1,3)<code>first1</code>Thì<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r1<span class="br0">)</span></code>(1,3)<code>last1</code>Thì<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/begin"><span class="kw2882">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">bắt đầu</span></span></a><span class="br0">.</span>r2<span class="br0">)</span></code>(1,3)<code>first2</code>, Và<code><a href="http://en.cppreference.com/w/cpp/ranges-ranges-placeholder/end"><span class="kw2884">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">kết thúc</span></span></a><span class="br0">.</span>r2<span class="br0">)</span></code>(1,3)<code>last2</code>.</div> <p>Mẫu &lt;phạm vi :: forward_range r, class proj = std :: nhận dạng,<i>          std :: Indirect_binary_predicate &lt;</i>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj&gt;,</p>
<ul>
<li>              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; pre = ranges :: arem_to&gt;</li>
<li>Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>.</li>
<li>    adjacent_find (r &amp;&amp; r, pre pre = {}, proj proj = {});<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">normal unqualified lookup</a>(Sau khi chiếu với phép chiếu<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>như phạm vi nguồn, như thể đang sử dụng</li>
</ul> <p>Phạm vi ::</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Mẫu &lt;class execPolicy, class forwardit1, class forwardit2&gt;</td> <td>-</td> <td>          STD :: yếu_incrementable o, class comp = phạm vi :: Ít hơn,</td>
</tr> <tr class="t-par"> <td>            Forwardit1 first1, forwardit1 last1,</td> <td>-</td> <td>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;</td>
</tr> <tr class="t-par"> <td>          lớp pre = phạm vi :: carm_to,</td> <td>-</td> <td>                      Forwardit2 First2, forwardIt2 last2, forwardit3 d_first);</td>
</tr> <tr class="t-par"> <td>Yêu cầu (phạm vi :: forward_range &lt;r1&gt; |</td> <td>-</td> <td>Mẫu &lt;class inputit1, class inputit2, class outputit, class so sánh&gt;</td>
</tr> <tr class="t-par"> <td>. Sự chồng chéo của phạm vi được chính thức được phép, nhưng dẫn đến thứ tự không thể đoán trước của kết quả.</td> <td>-</td> <td>Mẫu &lt;class inputit1, class inputit2, class outputit, class so sánh&gt;</td>
</tr> <tr class="t-par"> <td>sau đó</td> <td>-</td> <td>Phạm vi :: mượn_iterator_t &lt;r&gt;</td>
</tr> <tr class="t-par"> <td>                                    Phạm vi :: iterator_t &lt;r2&gt;,</td> <td>-</td> <td>                                    Pred, Proj1, Proj2&gt;</td>
</tr> <tr class="t-par"> <td>constexpr bool ends_with (r1 &amp;&amp; r1, r2 &amp;&amp; r2, pred = {},</td> <td>-</td> <td>Phạm vi constexpr :: mượn_subrange_t &lt;r1&gt;</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code>{last1, last2, result_last}</code>là<code>result_last</code>consexpr merge_result &lt;i1, i2, o&gt;</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>                        O, comp, proj1, proj2&gt;<sub class="t-su t-su-b">, nếu như</sub>trước<sub class="t-su t-su-b">    return (! (đầu tiên == cuối cùng) và! (giá trị &lt; *đầu tiên));</sub>Consexpr set_difference_result &lt;phạm vi :: mượn_iterator_t &lt;r1&gt;, o&gt;<sub class="t-su t-su-b">, nếu như</sub>Cả hai phạm vi phải được sắp xếp với hàm so sánh đã cho<sub class="t-su t-su-b">    return (! (đầu tiên == cuối cùng) và! (giá trị &lt; *đầu tiên));</sub>&gt;<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3140">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first1, last1<span class="br0">)</span></code>Và<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3140">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>first2, last2<span class="br0">)</span></code>Yêu cầu STD :: Inone</p>
<h3 id="Notes">Ghi chú</h3> <p>Mẫu &lt;Class execPolicy, class forwardit1, class forwardit2,<code><a href="merge" title="cpp/algorithm/ranges/merge">ranges::merge</a></code>          Lớp chuyển tiếpit3, so sánh lớp&gt;<a href="../../named_req/lessthancomparable" title="cpp/named req/LessThanComparable">LessThanComparable</a>ForwardItIt3 hợp nhất (chính sách thực thi &amp;&amp; chính sách,<code>n</code>                  Forwardit1 first1, forwardit1 last1,<code>m</code>                  Forwardit2 first2, forwardit2 last2,<code><a href="merge" title="cpp/algorithm/ranges/merge">ranges::merge</a></code>                  Forwardit3 d_first, so sánh comp);<code>n+m</code>Hợp nhất hai<code>ranges::set_union</code>thành một<code><a href="http://en.cppreference.com/w/cpp/algorithm/max"><span class="kw1644">Điều đó cho tất cả<span class="me2">Được xác định trong tiêu đề</span></span></a><span class="br0">.</span>n, m<span class="br0">)</span></code>Phạm vi bắt đầu tại<code><a href="merge" title="cpp/algorithm/ranges/merge">ranges::merge</a></code>               O Kết quả, comp comp = {},<sub class="t-su t-su-b">, nếu như</sub>trước<sub class="t-su t-su-b">    return (! (đầu tiên == cuối cùng) và! (giá trị &lt; *đầu tiên));</sub>               Proj1 proj1 = {}, proj2 proj2 = {});<code>ranges::set_union</code>Mẫu &lt;phạm vi :: input_range r1, phạm vi :: input_range r2,</p>
<h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">          STD :: yếu_incrementable o, class comp = phạm vi :: Ít hơn,</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Yêu cầu STD :: Mergable &lt;Ranges :: iterator_t &lt;r1&gt;, phạm vi :: iterator_t &lt;r2&gt;,</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="set_difference" title="cpp/algorithm/ranges/set difference"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="set_intersection" title="cpp/algorithm/ranges/set intersection"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="set_symmetric_difference" title="cpp/algorithm/ranges/set symmetric difference"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="merge" title="cpp/algorithm/ranges/merge"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="includes" title="cpp/algorithm/ranges/includes"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<code>true</code>trả lại<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../set_union" title="cpp/algorithm/set union"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/ranges/set_union">https://en.cppreference.com/w/cpp/algorithm/ranges/set_union</a>
</p>
</div>
