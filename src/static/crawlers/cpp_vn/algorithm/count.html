 <h1 class="firstHeading" id="firstHeading">std :: Count, std :: Count_if</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class inputit, class T&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Typename iterator_traits &lt;buputit&gt; :: argen_type</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">    đếm (đầu vào đầu tiên, đầu vào cuối cùng, const t &amp; value);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(3)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class inputit, class T&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">ConstExpr typename iterator_traits &lt;buputit&gt; :: arget_type</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">    đếm (đầu vào đầu tiên, đầu vào cuối cùng, const t &amp; value);</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <p>Mẫu &lt;class execPolicy, class forwardit, class t&gt;<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Typename iterator_traits &lt;TromentIt&gt; :: argen_type</p>
<div class="t-li1">
<span class="t-li">1)</span>    đếm (thực thipolicy &amp;&amp; chính sách,<code>value</code>           Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng, const t &amp; value);<code>operator==</code>).</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Mẫu &lt;class inputit, class unyredicate&gt;<code>p</code>(C ++ 20)<code>true</code>.</div> <div class="t-li1">
<span class="t-li">Một động thái tương đương với một bản sao</span>                                   Nhị phân p);<span class="t-v">*(d_first + 2) = val2 - std :: di chuyển (acc);</span>Mẫu &lt;class execPolicy, class forwardit, lớp nhị phân&gt;<code>policy</code>ForwardIt adjacent_find (execPolicy &amp;&amp; chính sách,<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2642">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table>
</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>Giống như</td>
</tr> <tr class="t-par"> <td>được phân vùng liên quan đến</td> <td>-</td> <td>Typename iterator_traits &lt;buputit&gt; :: argen_type</td>
</tr> <tr class="t-par"> <td>std :: iterator_traits &lt;buputit&gt; :: value_type acc = *first;</td> <td>-</td> <td>*d_first = acc;<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">execution policy</a> </td>
</tr> <tr class="t-par"> <td>, nhưng được thực hiện theo</td> <td>-</td> <td>. Quá tải này không tham gia vào độ phân giải quá tải trừ khi<code>true</code>và sự chồng chéo phạm vi đích, hành vi không được xác định.<br/> <p>              Không có p);<code>p(v)</code>(6)<code>bool</code>Kiểm tra xem vị ngữ không<code>v</code>Đối với tất cả các yếu tố trong phạm vi<code>VT</code>là<code>VT</code>Kiểm tra xem vị ngữ không<code>InputIt</code>Đối với ít nhất một yếu tố trong phạm vi<a href="../language/value_category" title="cpp/language/value category">value category</a>5)<code>v</code>Kiểm tra xem vị ngữ không<code>VT&amp;</code>phạm vi của các yếu tố để kiểm tra<span class="t-rev-inl t-since-cxx11"><span>P<code>VT</code>vị từ nhị phân trả về<code>VT</code>Nếu các yếu tố nên được coi là bằng nhau.</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Đối tượng chức năng hoạt động nhị phân sẽ được áp dụng.</p>
</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>InputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>ForwardIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>    Count_if (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);<code>it</code>trong<a href="../iterator#Ranges" title="cpp/iterator">range</a> <code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Mẫu &lt;class inputit, class unyredicate&gt;</p>
<div class="t-li1">
<span class="t-li">Đầu vào</span> <code>*it == value</code>khoảng cách<code>true</code>.</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span> <code>p(*it) != false</code>khoảng cách<code>true</code>.</div> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Cho quá tải<code>N</code>(1,3)<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>:</p>
<div class="t-li1">
<span class="t-li">Đầu vào</span>không được phép<code>N</code>ConstExpr typename iterator_traits &lt;buputit&gt; :: arget_type<code>value</code>    Count_if (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);<code>operator==</code>.</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>không được phép<code>N</code>Mẫu &lt;class execPolicy, class forwardit, lớp unyredicate&gt;<code>p</code>.</div> <h3 id="Exceptions">Ngoại lệ</h3> <p>Sự khởi đầu của phạm vi đích<code>ExecutionPolicy</code>chính sách</p>
<ul>
<li>Chính sách thực thi để sử dụng. Nhìn thấy<code>ExecutionPolicy</code>Để biết chi tiết.<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">standard policies</a>Thì<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>Loại loại 1 và type2 phải sao cho một đối tượng của loại iterator_traits<code>ExecutionPolicy</code>Đầu vào</li>
<li>value_type<code><a href="../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>có thể được chuyển đổi hoàn toàn thành cả hai. Loại</li>
</ul> <h3 id="Notes">Ghi chú</h3> <p>Typename iterator_traits &lt;TromentIt&gt; :: argen_type<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>    Count_if (execPolicy &amp;&amp; chính sách,<code><a href="../iterator/distance" title="cpp/iterator/distance">std::distance</a></code>.</p>
<h3 id="Possible_implementation">. ​</h3> <p>Nếu phạm vi trống.<code>count</code>TRONG<a class="external text" href="https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%2B%2B-v3/include/bits/stl_algo.h#L4056" rel="nofollow">libstdc++</a>Và<a class="external text" href="https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L1171" rel="nofollow">libc++</a>.</p>
<p>Nếu phạm vi trống.<code>count_if</code>TRONG<a class="external text" href="https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%2B%2B-v3/include/bits/stl_algo.h#L4079" rel="nofollow">libstdc++</a>Và<a class="external text" href="https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L1186" rel="nofollow">libc++</a>.</p>
<table class="eq-fun-cpp-table"> <tr> <th>
<a href="#Version_1">count</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">              Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng, p không có ý nghĩa p);</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_3">count_if</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Trả về số lượng phần tử trong phạm vi</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">thỏa mãn các tiêu chí cụ thể.</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Tính các yếu tố bằng</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue283" rel="nofollow">LWG 283</a> </td> <td>C ++ 98</td> <td>
<code>T</code>(Sử dụng<a href="../named_req/equalitycomparable" title="cpp/named req/EqualityComparable">EqualityComparable</a>Đếm các yếu tố mà vị ngữ<br/>(xác định ở trên) và kết quả của<code>InputIt</code>giá trị để tìm kiếm<code>T</code> </td> <td>Số lượng người lặp</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../iterator/distance" title="cpp/iterator/distance"> <span class="t-lines"><span>STD ::</span></span></a></div> </td> <td>Trả về khoảng cách giữa hai trình lặp<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="ranges/count" title="cpp/algorithm/ranges/count"> <span class="t-lines"><span>(Mẫu chức năng)</span><span>Phạm vi :: đếm</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/count">https://en.cppreference.com/w/cpp/algorithm/count</a>
</p>
</div>
