 <h1 class="firstHeading" id="firstHeading">std :: fill_n</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;lớp đầu ra, kích thước lớp, lớp T&gt;</pre>
</td> <td> <span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Outputit fill_n (đầu ra đầu tiên, số lượng kích thước, const t &amp; value);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;lớp đầu ra, kích thước lớp, lớp T&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>ConstExpr void fill (forwardit đầu tiên, forwardit cuối cùng, const t &amp; value);<code>value</code>ConstExpr đầu ra fill_n (đầu ra đầu tiên, số lượng kích thước, const t &amp; value);<code>count</code>Mẫu &lt;Class execPolicy, lớp chuyển tiếp, kích thước lớp, lớp T&gt;<code>first</code>nếu như<code>count &gt; 0</code>ForwardIt fill_N (chính sách thực thi &amp;&amp;</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>Mẫu &lt;class execPolicy, class forwardit, lớp nhị phân&gt;<code>policy</code>, hành vi là không xác định. Trong trường hợp này,<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2643">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table>
</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>đến phạm vi bắt đầu tại</td> <td>-</td> <td>                  Chuyển tiếp đầu tiên, số lượng kích thước, const t &amp; value);</td>
</tr> <tr class="t-par"> <td>(Niebloid)</td> <td>-</td> <td>đến đầu tiên</td>
</tr> <tr class="t-par"> <td>được phân vùng liên quan đến</td> <td>-</td> <td>           Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng, const t &amp; value);</td>
</tr> <tr class="t-par"> <td>std :: iterator_traits &lt;buputit&gt; :: value_type acc = *first;</td> <td>-</td> <td>*d_first = acc;<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">execution policy</a> </td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>OutputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/outputiterator" title="cpp/named req/OutputIterator">LegacyOutputIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>ForwardIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>value</code>// thực hiện đầu tiên<a href="../iterator#Types_and_writability" title="cpp/iterator">writable</a>ĐẾN<code>first</code>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>Size</code>// thực hiện đầu tiên<a class="mw-redirect" href="../language/implicit_cast" title="cpp/language/implicit cast">convertible</a>ĐẾN<a href="../language/type" title="cpp/language/type">integral type</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>các yếu tố trong phạm vi bắt đầu tại<code>count &gt; 0</code>Thì<code>first</code>Nếu đối số đầu tiên là</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>không được phép<code><a href="http://en.cppreference.com/w/cpp/algorithm/max"><span class="kw1643">Điều đó cho tất cả<span class="me2">Được xác định trong tiêu đề</span></span></a><span class="br0">.</span><span class="nu0">. Không làm gì khác.</span>, count<span class="br0">)</span></code>Phần cuối của phạm vi đích</p>
<h3 id="Exceptions">Ngoại lệ</h3> <p>Trình lặp trong phạm vi đích, chỉ qua phần tử cuối cùng được sao chép nếu<code>ExecutionPolicy</code>Bài tập bằng không nếu</p>
<ul>
<li>Chính sách thực thi để sử dụng. Nhìn thấy<code>ExecutionPolicy</code>Để biết chi tiết.<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">standard policies</a>Thì<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>Loại loại 1 và type2 phải sao cho một đối tượng của loại iterator_traits<code>ExecutionPolicy</code>Đầu vào</li>
<li>value_type<code><a href="../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>có thể được chuyển đổi hoàn toàn thành cả hai. Loại</li>
</ul> <h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">sự khởi đầu của phạm vi của các yếu tố để sửa đổi</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example">
<p>Trong thực tế, việc triển khai<code>fill_n()</code>Số lượng các yếu tố để sửa đổi<code>-1</code>Tererator một qua phần tử cuối cùng được gán nếu</p>
<div class="cpp source-cpp"><pre data-language="cpp">0</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Mẫu &lt;lớp đầu ra, kích thước lớp, lớp T&gt;</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue283" rel="nofollow">LWG 283</a> </td> <td>C ++ 98</td> <td>
<code>T</code>(Sử dụng<a href="../named_req/copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a>Đếm các yếu tố mà vị ngữ<br/><code>T</code>Mẫu &lt;class forwardit, class t&gt;<code>OutputIt</code> </td> <td>void fill (forwardIt đầu tiên, forwardit cuối cùng, const t &amp; value)</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue426" rel="nofollow">LWG 426</a> </td> <td>C ++ 98</td> <td>Outputit fill_n (đầu ra đầu tiên, số lượng kích thước, const t &amp; value)<code>count</code><br/>{<code>count</code>    for (kích thước i = 0; i &lt;đếm; i ++)</td> <td>        *Đầu tiên ++ = giá trị;<br/><code>count</code>    trả lại trước;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue865" rel="nofollow">LWG 865</a> </td> <td>C ++ 98</td> <td>}<br/>để gán</td> <td>đến nửa đầu của một vectơ số nguyên:</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="fill" title="cpp/algorithm/fill"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>đổ đầy<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="ranges/fill_n" title="cpp/algorithm/ranges/fill n"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/fill_n">https://en.cppreference.com/w/cpp/algorithm/fill_n</a>
</p>
</div>
