 <h1 class="firstHeading" id="firstHeading">STD :: Reverse_Copy</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;Class Bidirit, Class Outputit&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Outputit Reverse_Copy (bidirit đầu tiên, bidirit cuối cùng, ouffputit d_first);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;Class Bidirit, Class Outputit&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>. Thuật toán bản sao này ổn định: Thứ tự tương đối của các yếu tố được sao chép được bảo tồn.<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>Constexpr Outputit Reverse_Copy (Bidirit First, Bidirit Last,<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>                                 Đầu ra d_first);<code>d_first</code>Mẫu &lt;class execPolicy, lớp bidirit, class forwardit&gt;</div> <div class="t-li1">ForwardIt Reverse_Copy (Chính sách thực thi &amp;&amp;<code>*(d_first + N - 1 - i) = *(first + i)</code><sup class="reference" id="cite_ref-plusminus_1-0"><a href="#cite_note-plusminus-1">[1]</a></sup>                        Bidirit đầu tiên, bidirit cuối cùng, chuyển tiếp d_first);<code>i</code>TRONG<code>[</code><code>​0​</code><code>, </code><code>N</code><code>)</code>.</div> <div class="t-li1">Nếu như<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>. Sao chép các yếu tố từ phạm vi</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>Mẫu &lt;class execPolicy, class forwardit, lớp nhị phân&gt;<code>policy</code>, hành vi là không xác định. Trong trường hợp này,<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2643">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table>
</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>có thể được sử dụng thay thế.</td>
</tr> <tr class="t-par"> <td>không trống, sử dụng bộ tích lũy</td> <td>-</td> <td>Để lưu trữ giá trị bị trừ:</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>BidirIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/bidirectionaliterator" title="cpp/named req/BidirectionalIterator">LegacyBidirectionalIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>OutputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/outputiterator" title="cpp/named req/OutputIterator">LegacyOutputIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>ForwardIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>đến một phạm vi khác của các phần tử \ (\ scriptsize n \) n bắt đầu</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>và sự chồng chéo phạm vi đích, hành vi không được xác định.</p>
<h3 id="Exceptions">Ngoại lệ</h3> <p>Trình lặp trong phạm vi đích, chỉ qua phần tử cuối cùng được sao chép nếu<code>ExecutionPolicy</code>Bài tập bằng không nếu</p>
<ul>
<li>Chính sách thực thi để sử dụng. Nhìn thấy<code>ExecutionPolicy</code>Để biết chi tiết.<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">standard policies</a>Thì<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>Loại loại 1 và type2 phải sao cho một đối tượng của loại iterator_traits<code>ExecutionPolicy</code>Đầu vào</li>
<li>value_type<code><a href="../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>có thể được chuyển đổi hoàn toàn thành cả hai. Loại</li>
</ul> <h3 id="Notes">Ghi chú</h3> <p>Nếu lần thực hiện hoán vị cuối cùng và phạm vi được đặt lại về hoán vị đầu tiên.<a class="external text" href="https://github.com/microsoft/STL/blob/main/stl/src/vector_algorithms.cpp" rel="nofollow">MSVC STL</a>(phạm vi đích) theo cách sao cho các phần tử trong phạm vi đích theo thứ tự ngược lại.<a href="../named_req/contiguousiterator" title="cpp/named req/ContiguousIterator">LegacyContiguousIterator</a>Hoạt động như thể bằng cách thực hiện bài tập<a href="../named_req/triviallycopyable" title="cpp/named req/TriviallyCopyable">TriviallyCopyable</a>.</p>
<h3 id="Possible_implementation">. ​</h3> <p>được tìm thấy,<a class="external text" href="https://github.com/gcc-mirror/gcc/blob/14d8a5ae472ca5743016f37da2dd4770d83dea21/libstdc%2B%2B-v3/include/bits/stl_algo.h#L1170-L1190" rel="nofollow">libstdc++</a>Thì<a class="external text" href="https://github.com/llvm/llvm-project/tree/134723edd5bf06ff6ec8aca7b87c56e5bd70ccae/libcxx/include/__algorithm/reverse_copy.h" rel="nofollow">libc++</a>, Và<a class="external text" href="https://github.com/microsoft/STL/blob/472161105d596192194d4715ccad307c6c163b4a/stl/inc/algorithm#L4184-L4229" rel="nofollow">MSVC STL</a>.</p>
<table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Một lần cho mỗi số nguyên</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">và sự chồng chéo phạm vi đích, hành vi không được xác định.</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Đầu ra lặp lại cho phần tử qua phần tử cuối cùng được sao chép.</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2074" rel="nofollow">LWG 2074</a> </td> <td>C ++ 98</td> <td>) có thể cho phép vector hóa khi cả hai loại iterator thỏa mãn<code>i</code>và có cùng loại giá trị và loại giá trị là<br/><code>*(d_first + N - i) = *(first + i)</code><sup class="reference" id="cite_ref-plusminus_1-1"><a href="#cite_note-plusminus-1">[1]</a></sup> </td> <td>, số lượng tăng số lặp là tuyến tính. Đáng chú ý,<br/><code>*(d_first + N - 1 - i) = *(first + i)</code><sup class="reference" id="cite_ref-plusminus_1-2"><a href="#cite_note-plusminus-1">[1]</a></sup> </td>
</tr>
</table> <ol class="references"> <li id="cite_note-plusminus-1"> <span class="reference-text"><a href="../named_req/outputiterator" title="cpp/named req/OutputIterator">LegacyOutputIterator</a>Mẫu &lt;Class Bidirit, Class Outputit&gt;<code>+</code>Và<code>-</code>constexpr // kể từ C ++ 20<code>+</code>Và<code>-</code>Outputit Reverse_Copy (Bidirit First, Bidirit Last, Outputit D_First)</span> </li> </ol> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="reverse" title="cpp/algorithm/reverse"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="ranges/reverse_copy" title="cpp/algorithm/ranges/reverse copy"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/reverse_copy">https://en.cppreference.com/w/cpp/algorithm/reverse_copy</a>
</p>
</div>
