 <h1 class="firstHeading" id="firstHeading">std :: độc quyền_scan</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/numeric" title="cpp/header/numeric">&lt;numeric&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class inputit, class outputit, class T&gt;</pre></td> <td>
<span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Outputit Exclusive_scan (đầu vào đầu tiên, đầu vào cuối cùng,</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">                         Outputit d_First, t init);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(3)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class inputit, class outputit, class T&gt;</pre></td> <td>
<span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">constexpr outputit exclusive_scan (đầu vào đầu tiên, đầu vào cuối cùng,</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">                                   Outputit d_First, t init);</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <p>Mẫu &lt;class execPolicy, class forwardit1, class forwardit2, class t&gt;<code>binary_op</code>ForwardItIT2 exclusive_scan (execPolicy &amp;&amp; chính sách,<code><a href="http://en.cppreference.com/w/cpp/utility/functional/plus"><span class="kw1034">Điều đó cho tất cả<span class="me2">                           Forwardit1 đầu tiên, forwardit1 cuối cùng,</span></span></a><span class="sy1">&lt;&gt;</span><span class="br0">.</span><span class="br0">)</span></code>BẰNG<span class="t-v">Outputit adjacent_difference (đầu vào đầu tiên, đầu vào cuối cùng, </span>                           Forwardit2 d_first, t init);<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Mẫu &lt;class inputit, lớp đầu ra,<code>init</code>          Lớp T, Lớp BinaryOperation&gt;<code>d_first</code>Outputit Exclusive_scan (đầu vào đầu tiên, đầu vào cuối cùng,<sup>phần tử đầu vào trong I</sup>                         Outputit D_First, T init,<sup>phần tử đầu vào trong I</sup>                         Binary Binary_op);</p>
<p>Mẫu &lt;class inputit, lớp đầu ra,<code>i</code>TRONG<code>[</code><code>d_first</code><code>, </code><code>d_first + (last - first)</code><code>)</code>          Lớp T, Lớp BinaryOperation&gt;<code>init, *j...</code>constexpr outputit exclusive_scan (đầu vào đầu tiên, đầu vào cuối cùng,<code>j</code>TRONG<code>[</code><code>first</code><code>, </code><code>first + (i - d_first)</code><code>)</code>                                   Outputit D_First, T init,<code>binary_op</code>Thì</p>
<p>                                   Binary Binary_op);<sub class="t-su t-su-b">, nếu như</sub>Tính toán một hoạt động tổng tiền tố độc quyền bằng cách sử dụng<sub class="t-su t-su-b">N</sub>          Lớp T, Lớp BinaryOperation&gt;</p>
<ul>
<li>ForwardItIT2 exclusive_scan (execPolicy &amp;&amp; chính sách,<sub class="t-su t-su-b">, nếu như</sub> </li>
<li>                           Forwardit1 đầu tiên, forwardit1 cuối cùng,<sub class="t-su t-su-b">, nếu như</sub>Tính toán một hoạt động tổng tiền tố độc quyền bằng cách sử dụng<sub class="t-su t-su-b">K</sub>                           Binary Binary_op);<sub class="t-su t-su-b">M</sub>Tính toán một hoạt động tổng tiền tố độc quyền bằng cách sử dụng<sub class="t-su t-su-b">N</sub>(hoặc</li>
</ul> <p>Thêm vào đó<code>binary_op</code>) cho phạm vi</p>
<span class="t-v">1</span>, sử dụng<code>policy</code>ForwardIt adjacent_find (execPolicy &amp;&amp; chính sách,<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2643">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <p><code>binary_op</code>là giá trị ban đầu và ghi kết quả vào phạm vi bắt đầu tại<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>hoặc<code>[</code><code>d_first</code><code>, </code><code>d_first + (last - first)</code><code>)</code>. "Độc quyền" có nghĩa là tôi</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>Đối với mỗi lần lặp</td>
</tr> <tr class="t-par"> <td>không trống, sử dụng bộ tích lũy</td> <td>-</td> <td>Phần tử đầu vào không được bao gồm trong I<code>first</code> </td>
</tr> <tr class="t-par"> <td>std :: iterator_traits &lt;buputit&gt; :: value_type acc = *first;</td> <td>-</td> <td>*d_first = acc;<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">execution policy</a> </td>
</tr> <tr class="t-par"> <td>trong phạm vi</td> <td>-</td> <td>tổng.</td>
</tr> <tr class="t-par"> <td>Chính thức, gán thông qua từng trình lặp</td> <td>-</td> <td>giá trị của tổng số không chung chung của<a href="../named_req/functionobject" title="cpp/named req/FunctionObject">FunctionObject</a>cho mỗi<code>binary_op</code>, Và<code>init</code> </td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>InputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>OutputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/outputiterator" title="cpp/named req/OutputIterator">LegacyOutputIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>ForwardIt1, ForwardIt2</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>qua<code>binary_op(init, *first)</code>Thì<code>binary_op(init, init)</code>, Và<code>binary_op(*first, *first)</code>(6)<code>T</code>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>trong đó tổng số tổng hợp không chung GNSUM (OP, A</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>, ..., Một</p>
<h3 id="Exceptions">Ngoại lệ</h3> <p>Sự khởi đầu của phạm vi đích<code>ExecutionPolicy</code>chính sách</p>
<ul>
<li>Chính sách thực thi để sử dụng. Nhìn thấy<code>ExecutionPolicy</code>Để biết chi tiết.<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">standard policies</a>Thì<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>Loại loại 1 và type2 phải sao cho một đối tượng của loại iterator_traits<code>ExecutionPolicy</code>Đầu vào</li>
<li>value_type<code><a href="../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>có thể được chuyển đổi hoàn toàn thành cả hai. Loại</li>
</ul> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">) được định nghĩa như sau:</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Nếu n = 1, a</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="adjacent_difference" title="cpp/algorithm/adjacent difference"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div> </td> <td>liền kề_diferference<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="accumulate" title="cpp/algorithm/accumulate"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>tích lũy<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="partial_sum" title="cpp/algorithm/partial sum"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div> </td> <td>Partial_sum<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="transform_exclusive_scan" title="cpp/algorithm/transform exclusive scan"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>(C ++ 17)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="inclusive_scan" title="cpp/algorithm/inclusive scan"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>(C ++ 17)<code><a href="partial_sum" title="cpp/algorithm/partial sum">std::partial_sum</a></code>Tương tự như<sup>phần tử đầu vào trong I</sup>th<sup>phần tử đầu vào trong I</sup>th<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/exclusive_scan">https://en.cppreference.com/w/cpp/algorithm/exclusive_scan</a>
</p>
</div>
