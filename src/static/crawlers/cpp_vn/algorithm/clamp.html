 <h1 class="firstHeading" id="firstHeading">STD :: Kẹp</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx17"> <td><pre data-language="cpp">Mẫu &lt;Class T&gt;</pre></td> <td>(1)</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td> </tr> <tr class="t-dcl t-since-cxx17"> <td><pre data-language="cpp">constexpr const t &amp; kẹp (const t &amp; v, const t &amp; lo, const t &amp; hi);</pre></td> <td>(2)</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Nếu như<code>v</code>, trả lại<code>lo</code>; Nếu không nếu<code>lo</code>So sánh ít hơn<code>hi</code>, trả lại<code>v</code>; Nếu không nếu<code>hi</code>So sánh ít hơn<code>v</code>.</div> <div class="t-li1">, trả lại<code>operator&lt;</code>Để so sánh các giá trị.</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>Sử dụng<code>comp</code>Để so sánh các giá trị.</div> <p>, nhưng sử dụng<code>lo</code>Để so sánh các giá trị.<code>hi</code>.</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Hành vi không được xác định nếu giá trị của</td> <td>-</td> <td>là lớn hơn</td>
</tr> <tr class="t-par"> <td>v</td> <td>-</td> <td>giá trị để kẹp<code>v</code>ĐẾN</td>
</tr> <tr class="t-par"> <td>sau đó</td> <td>-</td> <td>LO, xin chào<a href="../named_req/compare" title="cpp/named req/Compare">Compare</a>ranh giới để kẹp<code>true</code>cũng là<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>đối tượng hàm so sánh (nghĩa là một đối tượng thỏa mãn các yêu cầu của<br/> <p>Hàm so sánh trả về giá trị số nguyên âm nếu đối số đầu tiên là</p>
<p><span class="t-cc"><code>bool cmp(const Type1&amp; a, const Type2&amp; b);</code></span></p>
<p>&gt;&gt;<code>const&amp;</code>is_execut_policy_v<code>Type1</code>Và<code>Type2</code>Remove_cvref_t<a href="../language/value_category" title="cpp/language/value category">value category</a>&gt;&gt;<code>Type1&amp;</code>phạm vi của các yếu tố để kiểm tra<span class="t-rev-inl t-since-cxx11"><span>P<code>Type1</code>vị từ nhị phân trả về<code>Type1</code>Nếu các yếu tố nên được coi là bằng nhau.</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>).<br/>) mà trở lại</p>
</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/lessthancomparable" title="cpp/named req/LessThanComparable">LessThanComparable</a>hơn thứ hai.<code>NaN</code>Các loại Type1 và Type2 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành cả hai.<code>T</code>Để sử dụng quá tải (1). Tuy nhiên, nếu</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>được tránh,<code>lo</code>nếu như<code>v</code>là ít hơn<code>lo</code>Tham chiếu đến<code>hi</code>nếu như<code>hi</code>là ít hơn<code>v</code>, tham khảo<code>v</code>.</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>là ít hơn</p>
<h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <th>
<a href="#Version_1">clamp (1)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">, nếu không tham chiếu đến</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_2">clamp (2)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Nhiều nhất là hai so sánh.</pre></div> </td>
</tr>
</table> <h3 id="Notes">Ghi chú</h3>Mẫu &lt;Class T&gt;<code>std::clamp</code>Constexpr Const T &amp; Kẹp (Const T &amp; V, Const T &amp; Lo, Const T &amp; Hi)<div class="cpp source-cpp"><pre data-language="cpp">{</pre></div> <p>Nếu như<code>v</code>    Trả về kẹp (v, lo, hi, ít {});<code>v</code>}</p>
<table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../feature_test#cpp_lib_clamp" title="cpp/feature test"><code>__cpp_lib_clamp</code></a></td> <td><span class="nu0">Thuật toán song song</span></td> <td><span class="t-mark">Dest_at</span></td> <td>
<a href="#top"><code>std::clamp</code></a> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Mẫu &lt;class T, class so sánh&gt;</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Constexpr Const T &amp; Kẹp (Const T &amp; V, Const T &amp; Lo, Const T &amp; Hi, So sánh Comp)</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="min" title="cpp/algorithm/min"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="max" title="cpp/algorithm/max"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/in_range" title="cpp/utility/in range"> <span class="t-lines"><span>in_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>kiểm tra xem giá trị số nguyên nằm trong phạm vi của một loại số nguyên nhất định<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="ranges/clamp" title="cpp/algorithm/ranges/clamp"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/clamp">https://en.cppreference.com/w/cpp/algorithm/clamp</a>
</p>
</div>
