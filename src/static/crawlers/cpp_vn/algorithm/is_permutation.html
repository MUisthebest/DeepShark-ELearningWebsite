 <h1 class="firstHeading" id="firstHeading">std :: is_permuting</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class forwardit1, class forwardit2&gt;</pre></td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">bool is_permuting (forwardit1 first1, forwardIt1 last1,</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(2)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx20"> <td><pre data-language="cpp">                     Chuyển tiếp 2 First2);</pre></td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;class forwardit1, class forwardit2&gt;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(3)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx14 t-until-cxx20"> <td><pre data-language="cpp">consexpr bool is_permuting (forwardit1 first1, forwardIt1 last1,</pre></td> <td>
<span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">                               Chuyển tiếp 2 First2);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(4)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx14 t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class forwardit1, class forwardit2, lớp nhị phân&gt;</pre></td> <td>
<span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">bool is_permuting (forwardit1 first1, forwardIt1 last1,</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Mẫu &lt;Class execPolicy,<code>true</code>                     Forwardit2 First2, nhị phân p);<a class="extiw" href="https://en.wikipedia.org/wiki/permutation" title="enwiki:permutation">permutation</a>Mẫu &lt;class forwardit1, class forwardit2, lớp nhị phân&gt;<code>[</code><code>first1</code><code>, </code><code>last1</code><code>)</code>consexpr bool is_permuting (forwardit1 first1, forwardIt1 last1,<code>[</code><code>first2</code><code>, </code><code>last2</code><code>)</code>là<code>last2</code>                               Forwardit2 First2, nhị phân p);<code>first2 + (last1 - first1)</code>Mẫu &lt;class forwardit1, class forwardit2&gt;</p>
<div class="t-li1">
<span class="t-li">(Do đó,</span>Chuyển tiếp adjacent_find (forwardit first, forwardit cuối cùng, nhị phân p);<code>operator==</code>bool is_permuting (forwardit1 first1, forwardIt1 last1,<a class="extiw" href="https://en.wikipedia.org/wiki/equivalence_relation" title="enwiki:equivalence relation">equivalence relation</a>.</div> <div class="t-li1">
<span class="t-li">Một động thái tương đương với một bản sao</span>Mẫu &lt;class forwardit, lớp nhị phân&gt;<code>p</code>                     Forwardit2 first2, forwardit2 last2);</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Mẫu &lt;class execPolicy, class forwardit1, class forwardit2&gt;</td> <td>-</td> <td>Mẫu &lt;class forwardit1, class forwardit2&gt;</td>
</tr> <tr class="t-par"> <td>            Forwardit1 first1, forwardit1 last1,</td> <td>-</td> <td>consexpr bool is_permuting (forwardit1 first1, forwardIt1 last1,</td>
</tr> <tr class="t-par"> <td>, nhưng được thực hiện theo</td> <td>-</td> <td>                               Forwardit2 first2, forwardit2 last2);<code>true</code>is_execut_policy_v<br/> <p>Decay_t</p>
<p><span class="t-cc"><code>bool pred(const Type &amp;a, const Type &amp;b);</code></span></p>
<p><code>Type</code>Mẫu &lt;class forwardit1, class forwardit2, lớp nhị phân&gt;<code>ForwardIt1</code>Và<code>ForwardIt2</code>bool is_permuting (forwardit1 first1, forwardIt1 last1,<code>const &amp;</code>                     Forwardit2 first2, forwardit2 last2,</p>
</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>ForwardIt1, ForwardIt2</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>ForwardIt1, ForwardIt2</code>                     Nhị phân p);</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code>true</code>          lớp chuyển tiếp1, lớp forwardit2, lớp nhị phân&gt;<code>[</code><code>first1</code><code>, </code><code>last1</code><code>)</code>Mẫu &lt;class forwardit1, class forwardit2, lớp nhị phân&gt;<code>[</code><code>first2</code><code>, </code><code>last2</code><code>)</code>.</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>consexpr bool is_permuting (forwardit1 first1, forwardIt1 last1,<sup>    return (! (đầu tiên == cuối cùng) và! (giá trị &lt; *đầu tiên));</sup>                               Forwardit2 first2, forwardit2 last2,<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first1, last1<span class="br0">)</span></code>.</p>
<p>                               Nhị phân p);<code>ForwardIt1</code>Và<code>ForwardIt2</code>            Nhị phân p);<a href="../named_req/randomaccessiterator" title="cpp/named req/RandomAccessIterator">LegacyRandomAccessIterator</a>Và<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first1, last1<span class="br0">)</span> <span class="sy3">Nếu tồn tại một</span><span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first2, last2<span class="br0">)</span></code>của các yếu tố trong phạm vi</p>
<h3 id="Note">điều đó làm cho phạm vi đó bằng phạm vi</h3> <p>Các<code>std::is_permutation</code>có thể được sử dụng trong<i>biểu thị</i>Nếu nó không được đưa ra.<code>x</code>. Hành vi không xác định nếu nó không phải là<code>y</code>Điều đó như vậy<i>. Hành vi không được xác định nếu nó không phải là một mối quan hệ tương đương.</i>phạm vi của các yếu tố để so sánh<code>std::is_permutation(x, y) == true</code>Phạm vi thứ hai để so sánh<code>y</code>vị từ nhị phân trả về<i>nên là loại giá trị của cả hai</i>. Chữ ký không cần phải có</p>
<h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">, nhưng chức năng không được sửa đổi các đối tượng được truyền cho nó.</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Phải có cùng loại giá trị.</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">là hoán vị của phạm vi</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="next_permutation" title="cpp/algorithm/next permutation"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="prev_permutation" title="cpp/algorithm/prev permutation"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../concepts/equivalence_relation" title="cpp/concepts/equivalence relation"> <span class="t-lines"><span>Boolean-testable</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Chỉ định toán tử đó<a href="../concepts/relation" title="cpp/concepts/relation"><code>relation</code></a>Khái niệm chỉ giải thích*<br/> <span class="t-mark">(ý tưởng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="ranges/is_permutation" title="cpp/algorithm/ranges/is permutation"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/is_permutation">https://en.cppreference.com/w/cpp/algorithm/is_permutation</a>
</p>
</div>
