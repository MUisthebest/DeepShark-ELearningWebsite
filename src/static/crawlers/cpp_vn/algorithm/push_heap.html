 <h1 class="firstHeading" id="firstHeading">STD :: PUSH_HEAP</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;Lass Randomit&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">void push_heap (ngẫu nhiên đầu tiên, ngẫu nhiên cuối cùng);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(2)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;Lass Randomit&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Consexpr void push_heap (ngẫu nhiên đầu tiên, ngẫu nhiên cuối cùng);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>last - 1</code>void push_heap (ngẫu nhiên đầu tiên, ngẫu nhiên cuối cùng, so sánh comp);<a href="#Notes">heap</a> <code>[</code><code>first</code><code>, </code><code>last - 1</code><code>)</code>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>.</p>
<div class="t-li1">
<span class="t-li">1)</span>Chèn phần tử tại vị trí<code>operator&lt;</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>Chèn phần tử tại vị trí<code>comp</code>.</div> <p>Nếu như<code>[</code><code>first</code><code>, </code><code>last - 1</code><code>)</code>vào</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>. Đống sau khi chèn sẽ</td>
</tr> <tr class="t-par"> <td>sau đó</td> <td>-</td> <td>LO, xin chào<a href="../named_req/compare" title="cpp/named req/Compare">Compare</a>ranh giới để kẹp<code>true</code>cũng là<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>đối tượng hàm so sánh (nghĩa là một đối tượng thỏa mãn các yêu cầu của<br/> <p>Hàm so sánh trả về giá trị số nguyên âm nếu đối số đầu tiên là</p>
<p><span class="t-cc"><code>bool cmp(const Type1&amp; a, const Type2&amp; b);</code></span></p>
<p>&gt;&gt;<code>const&amp;</code>is_execut_policy_v<code>Type1</code>Và<code>Type2</code>Remove_cvref_t<a href="../language/value_category" title="cpp/language/value category">value category</a>&gt;&gt;<code>Type1&amp;</code>phạm vi của các yếu tố để kiểm tra<span class="t-rev-inl t-since-cxx11"><span>P<code>Type1</code>vị từ nhị phân trả về<code>Type1</code>Nếu các yếu tố nên được coi là bằng nhau.</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>).<br/>consexpr bool is_heap (ngẫu nhiên đầu tiên, ngẫu nhiên cuối cùng, so sánh comp);</p>
</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>RandomIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/randomaccessiterator" title="cpp/named req/RandomAccessIterator">LegacyRandomAccessIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">và các phạm vi phải được sắp xếp theo cùng một.<code>RandomIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/moveassignable" title="cpp/named req/MoveAssignable">MoveAssignable</a>Và<a href="../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>Compare</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/compare" title="cpp/named req/Compare">Compare</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Gán cho đã cho</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>. Thuật toán bản sao này ổn định: Thứ tự tương đối của các yếu tố được sao chép được bảo tồn.<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>:</p>
<div class="t-li1">
<span class="t-li">1)</span>Đống là liên quan đến<code>operator&lt;</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>Đống là liên quan đến<code>comp</code>.</div> <h3 id="Notes">Ghi chú</h3> <p>MỘT<i>              Ngẫu nhiên đầu tiên, ngẫu nhiên cuối cùng, so sánh comp);<code>comp</code></i>.<a class="extiw" href="https://en.wikipedia.org/wiki/Binary_heap" title="enwiki:Binary heap">max heap</a>Thuộc tính heap cần kiểm tra là liên quan đến<a href="../iterator#Ranges" title="cpp/iterator">range</a> <code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Thuộc tính heap cần kiểm tra là liên quan đến</p>
<ul>
<li>. Thuật toán bản sao này ổn định: Thứ tự tương đối của các yếu tố được sao chép được bảo tồn.<code>last - first</code>Phạm vi cần kiểm tra<code>i</code>Các loại Type1 và Type2 phải sao cho một đối tượng ngẫu nhiên loại có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành cả hai.<code>bool(comp(first[(i - 1) / 2], first[i]))</code>khoảng cách<code>false</code>.</li>
<li>Nếu phạm vi là một đống đối với bộ so sánh tương ứng,<code>std::push_heap</code>) là một quyền truy cập ngẫu nhiên</li>
<li> <code>*first</code>đống liên quan đến<code><a href="pop_heap" title="cpp/algorithm/pop heap">std::pop_heap</a></code>) là một quyền truy cập ngẫu nhiên</li>
</ul> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">không phải là một đống, hành vi không được xác định.</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Phạm vi chỉ ra đống sau khi chèn</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue193" rel="nofollow">LWG 193</a> </td> <td>C ++ 98</td> <td>Nhiều nhất \ (\ scriptsize 3n \) so sánh 3n bằng cách sử dụng<code>*first</code>Nhiều nhất \ (\ scriptsize 3n \) 3n Ứng dụng của hàm so sánh</td> <td>#include &lt;THERTHERM&gt;<code>*first</code> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2166" rel="nofollow">LWG 2166</a> </td> <td>C ++ 98</td> <td>trong đó \ (\ scriptsize 0 &lt;i &lt;n \) 0 &lt;i &lt;n,<br/>Một yếu tố mới có thể được thêm vào bằng cách sử dụng<a class="extiw" href="https://en.wikipedia.org/wiki/Binary_heap" title="enwiki:Binary heap">max heap</a>, trong \ (\ scriptsize \ mathcal {o} (\ log n) \) (log n) thời gian.</td> <td>có thể bị xóa bằng cách sử dụng</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="is_heap" title="cpp/algorithm/is heap"> <span class="t-lines"><span>(Niebloid)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="is_heap_until" title="cpp/algorithm/is heap until"> <span class="t-lines"><span>(Niebloid)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="make_heap" title="cpp/algorithm/make heap"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="pop_heap" title="cpp/algorithm/pop heap"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="sort_heap" title="cpp/algorithm/sort heap"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="ranges/push_heap" title="cpp/algorithm/ranges/push heap"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/push_heap">https://en.cppreference.com/w/cpp/algorithm/push_heap</a>
</p>
</div>
