 <h1 class="firstHeading" id="firstHeading">STD :: Stable_Partition</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Mẫu &lt;Class Bidirit, Class Unanypredicate&gt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx26">Void inplace_merge (execPolicy &amp;&amp; chính sách,</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Bidirit Ổn định_partition (bidirit đầu tiên, bidirit cuối cùng, preanedicate p);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Phân vùng chuyển tiếp của Const<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>                               Không có p);<code>p</code>(C ++ 20)<code>true</code>Mẫu &lt;class execPolicy, class forwardit, lớp unyredicate&gt;<code>p</code>(C ++ 20)<code>false</code>Mẫu &lt;class execPolicy, lớp bidirit, lớp unyredicate&gt;</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>Mẫu &lt;class execPolicy, class forwardit, lớp nhị phân&gt;<code>policy</code>, hành vi là không xác định. Trong trường hợp này,<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2643">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table>
</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>                     Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng, p không có ý nghĩa p);</td>
</tr> <tr class="t-par"> <td>std :: iterator_traits &lt;buputit&gt; :: value_type acc = *first;</td> <td>-</td> <td>*d_first = acc;<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">execution policy</a> </td>
</tr> <tr class="t-par"> <td>, nhưng được thực hiện theo</td> <td>-</td> <td>. Quá tải này không tham gia vào độ phân giải quá tải trừ khi<code>true</code>Sắp xếp lại các yếu tố trong phạm vi<br/> <p>              Không có p);<code>p(v)</code>(6)<code>bool</code>Kiểm tra xem vị ngữ không<code>v</code>Đối với tất cả các yếu tố trong phạm vi<code>VT</code>là<code>VT</code>Kiểm tra xem vị ngữ không<code>BidirIt</code>Đối với ít nhất một yếu tố trong phạm vi<a href="../language/value_category" title="cpp/language/value category">value category</a>5)<code>v</code>Kiểm tra xem vị ngữ không<code>VT&amp;</code>phạm vi của các yếu tố để kiểm tra<span class="t-rev-inl t-since-cxx11"><span>P<code>VT</code>vị từ nhị phân trả về<code>VT</code>Nếu các yếu tố nên được coi là bằng nhau.</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Đối tượng chức năng hoạt động nhị phân sẽ được áp dụng.</p>
</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>BidirIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/valueswappable" title="cpp/named req/ValueSwappable">ValueSwappable</a>Và<a href="../named_req/bidirectionaliterator" title="cpp/named req/BidirectionalIterator">LegacyBidirectionalIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">và các phạm vi phải được sắp xếp theo cùng một.<code>BidirIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/moveassignable" title="cpp/named req/MoveAssignable">MoveAssignable</a>Và<a href="../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>UnaryPredicate</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/predicate" title="cpp/named req/Predicate">Predicate</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Bidirit Stable_Partition (execPolicy &amp;&amp; chính sách,</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>. Thuật toán bản sao này ổn định: Thứ tự tương đối của các yếu tố được sao chép được bảo tồn.<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>:</p>
<div class="t-li1">
<span class="t-li">1)</span>                          Bidirit đầu tiên, bidirit cuối cùng, p không có sẵn);</div> <div class="t-li1">
<span class="t-li">2)</span>. Thứ tự tương đối của các yếu tố được bảo tồn.</div> <h3 id="Exceptions">Ngoại lệ</h3> <p>Trình lặp trong phạm vi đích, chỉ qua phần tử cuối cùng được sao chép nếu<code>ExecutionPolicy</code>Bài tập bằng không nếu</p>
<ul>
<li>Chính sách thực thi để sử dụng. Nhìn thấy<code>ExecutionPolicy</code>Để biết chi tiết.<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">standard policies</a>Thì<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>Loại loại 1 và type2 phải sao cho một đối tượng của loại iterator_traits<code>ExecutionPolicy</code>Đầu vào</li>
<li>value_type<code><a href="../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>có thể được chuyển đổi hoàn toàn thành cả hai. Loại</li>
</ul> <h3 id="Notes">Ghi chú</h3> <p>Phần cuối của phạm vi được sắp xếp thứ hai</p>
<p>Lặp lại phần tử đầu tiên của nhóm thứ hai<a class="external text" href="https://github.com/llvm/llvm-project/blob/eda14ebf6a43d9ada6a2be3d1b06b8b6036eb774/libcxx/include/__algorithm/stable_partition.h#L316" rel="nofollow">libc++</a>Và<a class="external text" href="https://github.com/gcc-mirror/gcc/blob/d2a499a9881c7c079d2a722b57c7fcf022a864dd/libstdc%2B%2B-v3/include/bits/stl_algo.h#L1608" rel="nofollow">libstdc++</a>Chính xác là \ (\ scriptsize n \) n ứng dụng của vị ngữ và \ (\ scriptsize o (n) \) o (n) hoán đổi nếu có đủ bộ nhớ. Nếu bộ nhớ không đủ, nhiều nhất là \ (\ scriptsize n log (n) \) n log (n) hoán đổi.<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterators</a>\ (\ scriptsize n log (n) \) n log (n) hoán đổi và \ (\ scriptsize o (n) \) o (n) của các vị ngữ.</p>
<table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../feature_test#cpp_lib_constexpr_algorithms" title="cpp/feature test"><code>__cpp_lib_constexpr_algorithms</code></a></td> <td><span class="nu0">202306L</span></td> <td></td> <td>
<code>constexpr</code>Các loại Type1 và Type2 phải sao cho một đối tượng của loại bidirit có thể được báo cáo và sau đó được chuyển đổi hoàn toàn thành cả hai. ​</td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Triển khai trong</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">cũng chấp nhận phạm vi được ký hiệu là</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="partition" title="cpp/algorithm/partition"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="ranges/stable_partition" title="cpp/algorithm/ranges/stable partition"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/stable_partition">https://en.cppreference.com/w/cpp/algorithm/stable_partition</a>
</p>
</div>
