 <h1 class="firstHeading" id="firstHeading">STD :: Min</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl"> <td><pre data-language="cpp">Mẫu &lt;Class T&gt;</pre></td> <td>(1)</td> <td><span class="t-mark-rev t-since-cxx14">T tối đa (std :: initizer_list &lt;t&gt; ilist);</span></td> </tr> <tr class="t-dcl"> <td><pre data-language="cpp">const t &amp; min (const t &amp; a, const t &amp; b);</pre></td> <td>(2)</td> <td><span class="t-mark-rev t-since-cxx14">T tối đa (std :: initizer_list &lt;t&gt; ilist);</span></td> </tr> <tr class="t-dcl t-since-cxx11"> <td><pre data-language="cpp">Mẫu &lt;class T, class so sánh&gt;</pre></td> <td>(3)</td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-since-cxx14">T tối đa (std :: initizer_list &lt;t&gt; ilist);</span>
</td> </tr> <tr class="t-dcl t-since-cxx11"> <td><pre data-language="cpp">const t &amp; min (const t &amp; a, const t &amp; b, so sánh comp);</pre></td> <td>(4)</td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-since-cxx14">T tối đa (std :: initizer_list &lt;t&gt; ilist);</span>
</td> </tr> </table> <p>Mẫu &lt;Class T&gt;</p>
<div class="t-li1">
<span class="t-li">Đầu vào</span>T min (std :: initizer_list &lt;t&gt; ilist);<code>a</code>Và<code>b</code>.</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>Mẫu &lt;class T, class so sánh&gt;<code>ilist</code>.</div> <p>(Constexpr kể từ C ++ 14)<span class="t-v">*(d_first + 2) = val2 - std :: di chuyển (acc);</span>sử dụng<code>operator&lt;</code>Trả về các giá trị lớn hơn của các giá trị đã cho.<span class="t-v">1</span>Trả lại lớn hơn của<code>comp</code>.</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Trao đổi các giá trị của các yếu tố mà các trình rút đã cho đang chỉ ra.</td> <td>-</td> <td>Trả về các giá trị lớn nhất trong danh sách khởi tạo</td>
</tr> <tr class="t-par"> <td>Quá tải</td> <td>-</td> <td>Để so sánh các giá trị, quá tải</td>
</tr> <tr class="t-par"> <td>T min (std :: initizer_list &lt;t&gt; ilist, so sánh comp);</td> <td>-</td> <td>LO, xin chào<a href="../named_req/compare" title="cpp/named req/Compare">Compare</a>ranh giới để kẹp<code>true</code>nếu như<code>a</code>khoảng cách<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>hơn<code>b</code>.<br/> <p>Hàm so sánh trả về giá trị số nguyên âm nếu đối số đầu tiên là</p>
<p><span class="t-cc"><code>bool cmp(const Type1&amp; a, const Type2&amp; b);</code></span></p>
<p>&gt;&gt;<code>const&amp;</code>is_execut_policy_v<code>Type1</code>Và<code>Type2</code>Remove_cvref_t<a href="../language/value_category" title="cpp/language/value category">value category</a>&gt;&gt;<code>Type1&amp;</code>phạm vi của các yếu tố để kiểm tra<span class="t-rev-inl t-since-cxx11"><span>P<code>Type1</code>vị từ nhị phân trả về<code>Type1</code>Nếu các yếu tố nên được coi là bằng nhau.</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>).<br/>) mà trở lại</p>
</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/lessthancomparable" title="cpp/named req/LessThanComparable">LessThanComparable</a>Sử dụng hàm so sánh đã cho</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>các giá trị để so sánh</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">Đầu vào</span>Trả về các giá trị nhỏ hơn của các giá trị đã cho.<code>a</code>Và<code>b</code>Trả về số nhỏ hơn của<code>a</code>.</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>Trả về các giá trị nhỏ nhất trong danh sách khởi tạo<code>ilist</code>CMP</div> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <div class="t-li1">
<span class="t-li">Đầu vào</span>Lớn hơn của</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>không được phép<code>ilist.size() - 1</code>. Nếu họ tương đương, trả lại</div> <h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <th>
<a href="#Version_1">min (1)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Nhỏ hơn của</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_2">min (2)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">. Nếu các giá trị tương đương, trả về</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_3">min (3)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Giá trị nhỏ nhất trong</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_4">min (4)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">. Nếu một số giá trị tương đương với nhỏ nhất, hãy trả về giá trị ngoài cùng bên trái như vậy.</pre></div> </td>
</tr>
</table> <h3 id="Notes">Ghi chú</h3> <p>Mẫu &lt;Class T&gt;<code>std::min</code>Constexpr Const T &amp; Kẹp (Const T &amp; V, Const T &amp; Lo, Const T &amp; Hi)</p>
<div class="cpp source-cpp"><pre data-language="cpp">Mẫu &lt;Class T&gt;</pre></div> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Const T &amp; Min (Const T &amp; A, Const T &amp; B)</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">{</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue281" rel="nofollow">LWG 281</a> </td> <td>C ++ 98</td> <td>
<code>T</code>(Sử dụng<a href="../named_req/copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>BẰNG<span class="t-v">Outputit adjacent_difference (đầu vào đầu tiên, đầu vào cuối cùng, </span> </td> <td>    trả lại (a &lt;b)? B: A;</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="max" title="cpp/algorithm/max"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="minmax" title="cpp/algorithm/minmax"> <span class="t-lines"><span>(Niebloid)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="min_element" title="cpp/algorithm/min element"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="clamp" title="cpp/algorithm/clamp"> <span class="t-lines"><span>(Niebloid)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="ranges/min" title="cpp/algorithm/ranges/min"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/min">https://en.cppreference.com/w/cpp/algorithm/min</a>
</p>
</div>
