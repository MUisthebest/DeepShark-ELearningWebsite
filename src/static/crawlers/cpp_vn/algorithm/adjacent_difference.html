 <h1 class="firstHeading" id="firstHeading">STD :: Adjacent_difference</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/numeric" title="cpp/header/numeric">&lt;numeric&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class inputit, class outputit&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Outputit adjacent_difference (Inputit First, Inputit Last, Outputit D_First);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;class inputit, class outputit&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(3)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">ConstExpr Outputit Adjacent_Difference (Inputit First, Inputit Last,</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">                                        Đầu ra d_first);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;class execPolicy, class forwardit1, class forwardit2&gt;</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <p>Nếu như<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>ForwardItIt2 adjacent_difference (execPolicy &amp;&amp; chính sách,<code>d_first + 1</code>                                Forwardit1 đầu tiên, forwardit1 cuối cùng,<code>*first</code>                                Forwardit2 d_first);<code>*d_first</code>Mẫu &lt;class inputit, class outputit, lớp BinaryOperation&gt;<span class="t-v">Outputit adjacent_difference (đầu vào đầu tiên, đầu vào cuối cùng, </span>                              Outputit D_First, BinaryOperation op);<span class="sy2">-</span>Mẫu &lt;class inputit, class outputit, lớp BinaryOperation&gt;<span class="t-v">ConstExpr Outputit Adjacent_Difference (Inputit First, Inputit Last, </span>                                        Outputit D_First,<code>op</code><span class="t-rev-inl t-since-cxx11"><span>                                        OP nhị phân op);<a href="../utility/move" title="cpp/utility/move"><code>std::move</code></a>Mẫu &lt;Class execPolicy,</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>.</p>
<p>. Một bản sao không biến đổi của<span class="t-v">(1)</span>Sử dụng chức năng nhị phân đã cho<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>                                Forwardit1 đầu tiên, forwardit1 cuối cùng, <code>acc</code>                                Forwardit2 d_first, binaryoperation op);</p>
<div class="cpp source-cpp"><pre data-language="cpp">không trống, tính toán sự khác biệt giữa phần thứ hai và thứ nhất của mỗi cặp phần tử liền kề và ghi sự khác biệt cho phạm vi bắt đầu tại</pre></div> <p>. Một bản sao không biến đổi của<span class="t-v">(3)</span>Sử dụng chức năng nhị phân đã cho<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>. Quá tải</p>
<div class="cpp source-cpp"><pre data-language="cpp">(1,2)</pre></div> <p>Nếu như<code>op</code>Sử dụng toán tử</p>
<p>Để tính toán sự khác biệt, quá tải<span class="t-v">*(d_first + 2) = val2 - std :: di chuyển (acc);</span>Sử dụng chức năng nhị phân đã cho<a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw654">Điều đó cho tất cả<span class="me2">iterator_traits</span></span></a><span class="sy1">is_trivently_destructible_v</span>*(d_first + 1) = val1 - std :: di chuyển (acc);<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">// hoặc *(d_first + 1) = op (val1, std :: di chuyển (acc)); cho quá tải (2)</span># Elif __has_include (&lt;thử nghiệm/tùy chọn&gt;) // Kiểm tra phiên bản thử nghiệm<span class="t-rev-inl t-until-cxx11"><span><a href="../named_req/copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a></span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span><a href="../named_req/moveassignable" title="cpp/named req/MoveAssignable">MoveAssignable</a></span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Hoạt động tương đương cho quá tải</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>, nếu như</td>
</tr> <tr class="t-par"> <td>không trống, sử dụng bộ tích lũy</td> <td>-</td> <td>Để lưu trữ giá trị bị trừ:</td>
</tr> <tr class="t-par"> <td>std :: iterator_traits &lt;buputit&gt; :: value_type acc = *first;</td> <td>-</td> <td>*d_first = acc;<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">execution policy</a> </td>
</tr> <tr class="t-par"> <td>Không hợp lệ bất kỳ trình lặp nào (bao gồm cả bộ lặp cuối) hoặc sửa đổi bất kỳ yếu tố nào của phạm vi liên quan, hành vi không được xác định.</td> <td>-</td> <td>Tham số<br/> <p>Đầu tiên, cuối cùng</p>
<p><span class="t-cc"><code> Ret fun(const Type1 &amp;a, const Type2 &amp;b);</code></span></p>
<p>phạm vi của các phần tử để tổng<code>const &amp;</code>.<br/>std :: iterator_traits &lt;buputit&gt; :: value_type val1 = *(đầu tiên + 1);<span class="sy1">is_trivently_destructible_v</span>*(d_first + 1) = val1 - std :: di chuyển (acc);<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">// hoặc *(d_first + 1) = op (val1, std :: di chuyển (acc)); cho quá tải (2)</span>acc = std :: di chuyển (val1);<code>Ret</code>Giá trị ban đầu của tổng<code>OutputIt</code> <code>Ret</code>Đối tượng chức năng hoạt động nhị phân sẽ được áp dụng.</p>
</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>InputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>STD :: iterator_traits &lt;inputit&gt; :: value_type val2 = *(đầu tiên + 2);<span class="t-v">*(d_first + 2) = val2 - std :: di chuyển (acc);</span>acc = std :: di chuyển (val2);<a href="../iterator#Types_and_writability" title="cpp/iterator">value type</a> <code>*first</code>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>OutputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/outputiterator" title="cpp/named req/OutputIterator">LegacyOutputIterator</a>.<code>acc</code>STD :: iterator_traits &lt;inputit&gt; :: value_type val3 = *(đầu tiên + 3);<span class="t-rev-inl t-until-cxx11"><span><code>val - acc</code>// hoặc *(d_first + 1) = op ( *(đầu tiên + 1), *(đầu tiên)); cho quá tải (4)<span class="t-v">(1)</span>*(d_first + 1) = *(đầu tiên + 1) - *(đầu tiên);<code>op(val, acc)</code>// hoặc *(d_first + 1) = op ( *(đầu tiên + 1), *(đầu tiên)); cho quá tải (4)<span class="t-v">(3)</span>)</span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span><code>val - std::move(acc)</code>// hoặc *(d_first + 1) = op ( *(đầu tiên + 1), *(đầu tiên)); cho quá tải (4)<span class="t-v">(1)</span>*(d_first + 1) = *(đầu tiên + 1) - *(đầu tiên);<code>op(val, std::move(acc))</code>// hoặc *(d_first + 1) = op ( *(đầu tiên + 1), *(đầu tiên)); cho quá tải (4)<span class="t-v">(3)</span>)</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>// thực hiện đầu tiên<a href="../iterator#Types_and_writability" title="cpp/iterator">writable</a>ĐẾN<code>d_first</code>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>ForwardIt1, ForwardIt2</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>*d_first = *Đầu tiên;<code>*first</code> <code>*first - *first</code>// hoặc *(d_first + 1) = op ( *(đầu tiên + 1), *(đầu tiên)); cho quá tải (4)<span class="t-v">(2)</span>*(d_first + 1) = *(đầu tiên + 1) - *(đầu tiên);<code>op(*first, *first)</code>// hoặc *(d_first + 1) = op ( *(đầu tiên + 1), *(đầu tiên)); cho quá tải (4)<span class="t-v">(4)</span>*(d_first + 2) = *(đầu tiên + 2) - *(đầu tiên + 1);<a href="../iterator#Types_and_writability" title="cpp/iterator">writable</a>ĐẾN<code>d_first</code>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>*(d_first + 3) = *(đầu tiên + 3) - *(đầu tiên + 2);<code>d_first</code>nếu như<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>...</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Cho quá tải<code>N</code>(1,3)<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span> <span class="sy2">-</span> <span class="nu0">, nếu như</span></code>:</p>
<div class="t-li1">
<span class="t-li">Đầu vào</span>Phạm vi của các yếu tố<code>N</code>Ứng dụng của<code>operator-</code>
</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>Phạm vi của các yếu tố<code>N</code>d_first<code>op</code>
</div> <h3 id="Exceptions">Ngoại lệ</h3> <p>Sự khởi đầu của phạm vi đích<code>ExecutionPolicy</code>chính sách</p>
<ul>
<li>Chính sách thực thi để sử dụng. Nhìn thấy<code>ExecutionPolicy</code>Để biết chi tiết.<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">standard policies</a>Thì<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>Loại loại 1 và type2 phải sao cho một đối tượng của loại iterator_traits<code>ExecutionPolicy</code>Đầu vào</li>
<li>value_type<code><a href="../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>có thể được chuyển đổi hoàn toàn thành cả hai. Loại</li>
</ul> <h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <th>
<a href="#Version_1">adjacent_difference (1)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">có thể được lưu ý và được gán một giá trị của loại</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_3">adjacent_difference (3)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">. Cho quá tải</pre></div> </td>
</tr>
</table> <h3 id="Notes">Ghi chú</h3> <p><code>acc</code>(1,3)<a class="external text" href="https://cplusplus.github.io/LWG/issue539" rel="nofollow">LWG issue 539</a>, của nó<code>acc</code>phải được xây dựng từ</p>
<ul>
<li>(xác định ở trên) và kết quả của<code>InputIt</code> </li>
<li>(vì<code>OutputIt</code> </li>
<li>) hoặc<span class="sy2">-</span>hoặc<code>op</code> </li>
<li>(vì<span class="sy2">-</span>hoặc<code>op</code> </li>
</ul> <p><code>acc</code>(vì</p>
<ul>
<li>) hoặc<code>InputIt</code> </li>
<li>(vì<code>d_first</code>Phải là<span class="sy2">-</span>hoặc<code>op</code>. Kết quả của</li>
<li>và kết quả của<span class="sy2">-</span>hoặc<code>op</code> </li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">(vì</pre></div> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">) hoặc</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">(vì</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue242" rel="nofollow">LWG 242</a> </td> <td>C ++ 98</td> <td>
<code>op</code>    trả lại init;</td> <td>) phải được<br/>Người lặp lại phần tử qua phần tử cuối cùng được viết hoặc</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue539" rel="nofollow">LWG 539</a> </td> <td>C ++ 98</td> <td>trống rỗng.<br/>Sự phức tạp</td> <td>Được cho</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2055" rel="nofollow">LWG 2055</a><br/>.<a class="external text" href="https://wg21.link/P0616R0" rel="nofollow">P0616R0</a>)</td> <td>C ++ 11</td> <td>
<code>acc</code>Mẫu &lt;class inputit, lớp T, lớp BinaryOperation&gt;</td> <td>constexpr // kể từ C ++ 20</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3058" rel="nofollow">LWG 3058</a> </td> <td>C ++ 17</td> <td>BẰNG<span class="t-v">1</span>1,2)<br/>chính xác<span class="sy2">-</span>hoặc<code>op</code>3,4)<br/>chính xác</td> <td>các ứng dụng của hàm nhị phân<br/>Quá tải với tham số mẫu được đặt tên<br/>Báo cáo lỗi như sau:</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="partial_sum" title="cpp/algorithm/partial sum"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div> </td> <td>Partial_sum<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="accumulate" title="cpp/algorithm/accumulate"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>tích lũy<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/adjacent_difference">https://en.cppreference.com/w/cpp/algorithm/adjacent_difference</a>
</p>
</div>
