 <h1 class="firstHeading" id="firstHeading">std :: all_of, std :: any_of, std :: none_of</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class inputit, class unyredicate&gt;</pre></td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">bool all_of (đầu vào đầu tiên, inputit cuối cùng, p không có tính p);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;class inputit, class unyredicate&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(3)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx20"> <td><pre data-language="cpp">consexpr bool all_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</pre></td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;class execPolicy, class forwardit, lớp unyredicate&gt;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">bool all_of (execPolicy &amp;&amp; chính sách, forwardit trước, chuyển tiếp cuối cùng,</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">             Không có p);</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class inputit, class unyredicate&gt;</pre></td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, p không có tính p);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;class inputit, class unyredicate&gt;</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>bool none_of (đầu vào đầu tiên, đầu vào cuối cùng, p không có tính p);<code>p</code>(C ++ 20)<code>true</code>bool any_of (execPolicy &amp;&amp; chính sách, forwardit trước, chuyển tiếp cuối cùng,<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>bool none_of (đầu vào đầu tiên, đầu vào cuối cùng, p không có tính p);<code>p</code>(C ++ 20)<code>true</code>(5)<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>bool none_of (đầu vào đầu tiên, đầu vào cuối cùng, p không có tính p);<code>p</code>(C ++ 20)<code>true</code>Mẫu &lt;class inputit, class unyredicate&gt;<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>.</div> <div class="t-li1">
<span class="t-li">cho ít nhất một yếu tố trong phạm vi,</span>                                   Nhị phân p);<span class="t-v">Mẫu &lt;class execPolicy, class forwardit, lớp unyredicate&gt;</span>Mẫu &lt;class execPolicy, class forwardit, lớp nhị phân&gt;<code>policy</code>ForwardIt adjacent_find (execPolicy &amp;&amp; chính sách,<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2641">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table>
</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>Giống như</td>
</tr> <tr class="t-par"> <td>std :: iterator_traits &lt;buputit&gt; :: value_type acc = *first;</td> <td>-</td> <td>*d_first = acc;<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">execution policy</a> </td>
</tr> <tr class="t-par"> <td>, nhưng được thực hiện theo</td> <td>-</td> <td>bool none_of (execPolicy &amp;&amp; chính sách, forwardit trước, chuyển tiếp cuối cùng,<br/> <p>              Không có p);<code>p(v)</code>(6)<code>bool</code>Kiểm tra xem vị ngữ không<code>v</code>Đối với tất cả các yếu tố trong phạm vi<code>VT</code>là<code>VT</code>Kiểm tra xem vị ngữ không<code>InputIt</code>Đối với ít nhất một yếu tố trong phạm vi<a href="../language/value_category" title="cpp/language/value category">value category</a>5)<code>v</code>Kiểm tra xem vị ngữ không<code>VT&amp;</code>phạm vi của các yếu tố để kiểm tra<span class="t-rev-inl t-since-cxx11"><span>P<code>VT</code>vị từ nhị phân trả về<code>VT</code>Nếu các yếu tố nên được coi là bằng nhau.</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>Đối tượng chức năng hoạt động nhị phân sẽ được áp dụng.</p>
</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>InputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>ForwardIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>UnaryPredicate</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/predicate" title="cpp/named req/Predicate">Predicate</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">Đầu vào</span> <code>true</code>, bất kể<code>true</code>2,4,6)<code>false</code>. Do đó, một loại tham số của<code>true</code>Nếu một vị ngữ unary trở lại</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span> <code>true</code>, bất kể<code>true</code>phải được chuyển đổi thành<code>false</code>. Do đó, một loại tham số của<code>false</code>Nếu một vị ngữ unary trở lại</div> <div class="t-li1">
<span class="t-li">    trả về std :: find_if_not (đầu tiên, cuối cùng, p) == cuối cùng;</span> <code>true</code>, bất kể<code>true</code>và không được sửa đổi<code>false</code>. Do đó, một loại tham số của<code>true</code>Nếu một vị ngữ unary trở lại</div> <p>(chức năng)<a href="#Notes">Notes</a>cho tất cả các yếu tố trong phạm vi,</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <div class="t-li1">
<span class="t-li">nếu không thì. Trả lại</span>Nếu phạm vi trống.<code>last</code>-<code>first</code>nếu không thì. Trả lại</div> <div class="t-li1">
<span class="t-li">cho ít nhất một yếu tố trong phạm vi,</span> <code>O(last - first)</code>nếu không thì. Trả lại</div> <h3 id="Exceptions">Ngoại lệ</h3> <p>Sự khởi đầu của phạm vi đích<code>ExecutionPolicy</code>chính sách</p>
<ul>
<li>Chính sách thực thi để sử dụng. Nhìn thấy<code>ExecutionPolicy</code>Để biết chi tiết.<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">standard policies</a>Thì<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>Loại loại 1 và type2 phải sao cho một đối tượng của loại iterator_traits<code>ExecutionPolicy</code>Đầu vào</li>
<li>value_type<code><a href="../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>có thể được chuyển đổi hoàn toàn thành cả hai. Loại</li>
</ul> <h3 id="Possible_implementation">. ​</h3> <p>Nếu phạm vi trống.</p>
<ul>
<li> <code>all_of</code>TRONG<a class="external text" href="https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%2B%2B-v3/include/bits/stl_algo.h#L508" rel="nofollow">libstdc++</a>Và<a class="external text" href="https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L838" rel="nofollow">libc++</a>.</li>
<li> <code>any_of</code>TRONG<a class="external text" href="https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%2B%2B-v3/include/bits/stl_algo.h#L541" rel="nofollow">libstdc++</a>Và<a class="external text" href="https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L852" rel="nofollow">libc++</a>.</li>
<li> <code>none_of</code>TRONG<a class="external text" href="https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%2B%2B-v3/include/bits/stl_algo.h#L523" rel="nofollow">libstdc++</a>Và<a class="external text" href="https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L866" rel="nofollow">libc++</a>.</li>
</ul> <table class="eq-fun-cpp-table"> <tr> <th>
<a href="#Version_1">all_of</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">5,6)</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_3">any_of</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Nếu một vị ngữ unary trở lại</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_5">none_of</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Không có yếu tố nào trong phạm vi,</pre></div> </td>
</tr>
</table> <h3 id="Notes">Ghi chú</h3> <p>Các<a href="#Return_value">return value</a>nếu không thì. Trả lại<a class="extiw" href="https://en.wikipedia.org/wiki/Truth_table" title="enwiki:Truth table">Truth table</a>Nếu phạm vi trống.</p>
<table class="wikitable"> <tr> <td> </td> <th colspan="4">dưới.</th>
</tr> <tr> <td></td> <td>Xem thêm việc triển khai<code>true</code>Thì<br/>Consexpr bool all_of (đầu vào đầu tiên, đầu vào cuối cùng, không có sẵn p)<code>false</code><br/>
</td> <td>2,4,6)<code>true</code>Thì<br/>2,4,6)<code>false</code><br/>
</td> <td>Consexpr bool all_of (đầu vào đầu tiên, đầu vào cuối cùng, không có sẵn p)<code>true</code>Thì<br/>Xem thêm việc triển khai<code>false</code><br/>
</td> <td>Consexpr bool all_of (đầu vào đầu tiên, đầu vào cuối cùng, không có sẵn p)<code>true</code>Thì<br/>Consexpr bool all_of (đầu vào đầu tiên, đầu vào cuối cùng, không có sẵn p)<code>false</code><br/>{</td>
</tr> <tr> <td>Đầu vào<code>all_of</code>
</td> <td><code>true</code></td> <td><code>false</code></td> <td><code>false</code></td> <td>
<code>true</code> </td>
</tr> <tr> <td>, hành vi là không xác định.<code>any_of</code>
</td> <td><code>true</code></td> <td><code>true</code></td> <td><code>false</code></td> <td>
<code>false</code> </td>
</tr> <tr> <td>    trả về std :: find_if_not (đầu tiên, cuối cùng, p) == cuối cùng;<code>none_of</code>
</td> <td><code>false</code></td> <td><code>false</code></td> <td><code>true</code></td> <td>
<code>true</code> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">}</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Mẫu &lt;class inputit, class unyredicate&gt;</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="ranges/all_any_none_of" title="cpp/algorithm/ranges/all any none of"> <span class="t-lines"><span>(Mẫu chức năng)</span><span>Phạm vi :: all_of</span><span>Phạm vi :: Any_of</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<code>true</code>kiểm tra xem một vị ngữ có phải không<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/all_any_none_of">https://en.cppreference.com/w/cpp/algorithm/all_any_none_of</a>
</p>
</div>
