 <h1 class="firstHeading" id="firstHeading">std :: Equal_range</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class forwardit, class t&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">std :: cặp &lt;forwardit, forwardit&gt; </pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(2)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">    Equal_range (Forwardit First, Forwardit Last, Const T &amp; Value);</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;class forwardit, class t&gt;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Consexpr std :: cặp &lt;forwardit, forwardit&gt; <code>value</code>theo thứ tự.<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>.</p>
<p>    Equal_range (Forwardit First, Forwardit Last, Const T &amp; Value);<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Mẫu &lt;class forwardit, class t, class so sánh&gt;<code>value</code>Consexpr Bool Binary_Search (ForwardIT đầu tiên, ForwardIt Last,</p>
<ul>
<li>Vì<code>element &lt; value</code>hoặc<code>comp(element, value)</code>Kiểm tra xem một phần tử tương đương với<code>true</code>Mẫu &lt;class forwardit, class t, class so sánh&gt;<code>false</code>).</li>
<li>Vì<code>!(value &lt; element)</code>hoặc<code>!comp(value, element)</code>.</li>
<li>thành công, phạm vi<code>element &lt; value</code>hoặc<code>comp(element, value)</code>khoảng cách<code>true</code>phải ít nhất được đặt hàng một phần đối với<code>!(value &lt; element)</code>hoặc<code>!comp(value, element)</code>, tức là nó phải đáp ứng tất cả các yêu cầu sau:<code>true</code>.</li>
</ul> <p>được phân vùng liên quan đến</p>
<p>std :: cặp &lt;forwardit, forwardit&gt; <i>Trả một trình lặp lại cho phần tử đầu tiên</i>hơn<code>value</code>                 const t &amp; value, so sánh comp);<i>Trả một trình lặp lại cho phần tử đầu tiên</i>hơn<code>value</code>Consexpr std :: cặp &lt;forwardit, forwardit&gt; <code><a href="lower_bound" title="cpp/algorithm/lower bound">std::lower_bound()</a></code>    Equ_range (Forwardit First, Forwardit Last,<code><a href="upper_bound" title="cpp/algorithm/upper bound">std::upper_bound()</a></code>.</p>
<p>(nghĩa là, tất cả các yếu tố mà biểu thức là<span class="sy1">is_trivently_destructible_v</span>trước tất cả các yếu tố mà biểu thức là<code>comp</code>.</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>Giống như</td>
</tr> <tr class="t-par"> <td>được phân vùng liên quan đến</td> <td>-</td> <td>cho tất cả các yếu tố, nếu</td>
</tr> <tr class="t-par"> <td>sau đó</td> <td>-</td> <td>. Những quá tải này không tham gia vào độ phân giải quá tải trừ khi<code>true</code>cũng là<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>Phiên bản đầu tiên sử dụng toán tử<br/> <p>Decay_t</p>
<p><span class="t-cc"><code> bool pred(const Type1 &amp;a, const Type2 &amp;b);</code></span></p>
<p>&gt;&gt;<code>const &amp;</code>is_execut_policy_v<code>Type1</code>Và<code>Type2</code>Remove_cvref_t<a href="../language/value_category" title="cpp/language/value category">value category</a>&gt;&gt;<code>Type1 &amp;</code>phạm vi của các yếu tố để kiểm tra<span class="t-rev-inl t-since-cxx11"><span>P<code>Type1</code>vị từ nhị phân trả về<code>Type1</code>Nếu các yếu tố nên được coi là bằng nhau.</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>).<br/>Để so sánh các phần tử, phiên bản thứ hai sử dụng hàm so sánh đã cho</p>
</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>ForwardIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>Compare</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/binarypredicate" title="cpp/named req/BinaryPredicate">BinaryPredicate</a>giá trị<a href="../named_req/compare" title="cpp/named req/Compare">Compare</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>MỘT<code><a href="../utility/pair" title="cpp/utility/pair">std::pair</a></code>                 const t &amp; value, so sánh comp);<i>Trả một trình lặp lại cho phần tử đầu tiên</i>hơn<code>value</code>Phạm vi<i>Trả một trình lặp lại cho phần tử đầu tiên</i>hơn<code>value</code>.</p>
<p>Phạm vi trả về được xác định bởi hai trình lặp, một chỉ vào phần tử đầu tiên đó là<i>Trả một trình lặp lại cho phần tử đầu tiên</i>hơn<code>value</code>Thì<code>last</code>và một điểm khác chỉ vào phần tử đầu tiên<i>Trả một trình lặp lại cho phần tử đầu tiên</i>hơn<code>value</code>Thì<code>last</code>. Trình lặp đầu tiên có thể được lấy thay thế với</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>ít hơn<code>first</code>Và<code>last</code>, thứ hai - với<sub class="t-su t-su-b">    return (! (đầu tiên == cuối cùng) và! (giá trị &lt; *đầu tiên));</sub>. Nó không bắt buộc phải thỏa mãn<a href="../named_req/randomaccessiterator" title="cpp/named req/RandomAccessIterator">LegacyRandomAccessIterators</a>chứa một cặp lặp xác định phạm vi mong muốn. Đầu tiên chỉ vào yếu tố đầu tiên đó là<code><a href="../container/set" title="cpp/container/set">std::set</a></code>Và<code><a href="../container/multiset" title="cpp/container/multiset">std::multiset</a></code>hơn<code><a href="../container/set/equal_range" title="cpp/container/set/equal range">std::set::equal_range</a></code>và phần thứ hai chỉ vào phần tử đầu tiên<code><a href="../container/multiset/equal_range" title="cpp/container/multiset/equal range">std::multiset::equal_range</a></code>hơn</p>
<h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <th>
<a href="#Version_1">equal_range (1)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Nếu không có yếu tố</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_2">equal_range (2)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">hơn</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">được trả lại là yếu tố đầu tiên. Tương tự như vậy nếu không có yếu tố</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">hơn</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue270" rel="nofollow">LWG 270</a> </td> <td>C ++ 98</td> <td>
<code>Compare</code>(cuối cùng - đầu tiên) + O (1) so sánh). Tuy nhiên, đối với không<a href="../named_req/compare" title="cpp/named req/Compare">Compare</a>Và<code>T</code>, số lần tăng số lặp là tuyến tính.<br/>được<a href="../named_req/lessthancomparable" title="cpp/named req/LessThanComparable">LessThanComparable</a>Xem thêm các triển khai trong</td> <td>Mẫu &lt;class forwardit, class t&gt;<br/>Bool Binary_Search (ForwardIt First, Forwardit Last, Const T &amp; Value)</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue384" rel="nofollow">LWG 384</a> </td> <td>C ++ 98</td> <td>được trả lại là phần tử thứ hai.<br/>(Nhiều nhất là 2 * nhật ký<sup class="reference" id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup> </td> <td>, số lượng tăng số lặp là tuyến tính. Đáng chú ý,<br/>Trình lặp không phải là truy cập ngẫu nhiên, và vì vậy các chức năng thành viên của họ<sub class="t-su t-su-b">    return (! (đầu tiên == cuối cùng) và! (giá trị &lt; *đầu tiên));</sub>}</td>
</tr>
</table> <ol class="references"> <li id="cite_note-1"> <span class="reference-text">(resp.<code>equal_range</code>) nên được ưa thích.</span> </li> </ol> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="lower_bound" title="cpp/algorithm/lower bound"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>(C ++ 20)<i>Trả một trình lặp lại cho phần tử đầu tiên</i>không ít hơn<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="upper_bound" title="cpp/algorithm/upper bound"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<i>Trả một trình lặp lại cho phần tử đầu tiên</i>lớn hơn<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="binary_search" title="cpp/algorithm/binary search"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="partition" title="cpp/algorithm/partition"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="equal" title="cpp/algorithm/equal"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/set/equal_range" title="cpp/container/set/equal range"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::set&lt;Key,Compare,Allocator&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/multiset/equal_range" title="cpp/container/multiset/equal range"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::multiset&lt;Key,Compare,Allocator&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="ranges/equal_range" title="cpp/algorithm/ranges/equal range"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/equal_range">https://en.cppreference.com/w/cpp/algorithm/equal_range</a>
</p>
</div>
