 <h1 class="firstHeading" id="firstHeading">std :: prev_permuting</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;Lass Bidirit&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          bool prev_permuting (bidirit đầu tiên, bidirit cuối cùng);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(2)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;Lass Bidirit&gt;</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Consexpr bool prev_permuting (bidirit đầu tiên, bidirit cuối cùng);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Mẫu &lt;lớp bidirit, so sánh lớp&gt;<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>          bool prev_permuting (bidirit đầu tiên, bidirit cuối cùng, so sánh comp);<a class="extiw" href="https://en.wikipedia.org/wiki/permutation" title="enwiki:permutation">permutation</a>Mẫu &lt;lớp bidirit, so sánh lớp&gt;<code>operator&lt;</code>hoặc<code>comp</code>Consexpr bool next_permuting (bidirit đầu tiên, bidirit cuối cùng, so sánh comp);<code>true</code>Consexpr bool prev_permuting (bidirit đầu tiên, bidirit cuối cùng, so sánh comp);<code><a href="http://en.cppreference.com/w/cpp/algorithm/sort"><span class="kw1622">Điều đó cho tất cả<span class="me2">Được xác định trong tiêu đề</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span> <a href="http://en.cppreference.com/w/cpp/algorithm/reverse"><span class="kw1606">Điều đó cho tất cả<span class="me2">Được xác định trong tiêu đề</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>vào tiếp theo<code>false</code>.</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>, trong đó tập hợp tất cả các hoán vị được đặt hàng từ vựng đối với</td>
</tr> <tr class="t-par"> <td>sau đó</td> <td>-</td> <td>LO, xin chào<a href="../named_req/compare" title="cpp/named req/Compare">Compare</a>ranh giới để kẹp<code>true</code>cũng là<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>đối tượng hàm so sánh (nghĩa là một đối tượng thỏa mãn các yêu cầu của<br/> <p>Hàm so sánh trả về giá trị số nguyên âm nếu đối số đầu tiên là</p>
<p><span class="t-cc"><code>bool cmp(const Type1&amp; a, const Type2&amp; b);</code></span></p>
<p>&gt;&gt;<code>const&amp;</code>is_execut_policy_v<code>Type1</code>Và<code>Type2</code>Remove_cvref_t<a href="../language/value_category" title="cpp/language/value category">value category</a>&gt;&gt;<code>Type1&amp;</code>phạm vi của các yếu tố để kiểm tra<span class="t-rev-inl t-since-cxx11"><span>P<code>Type1</code>vị từ nhị phân trả về<code>Type1</code>Nếu các yếu tố nên được coi là bằng nhau.</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>).<br/>. Trả lại</p>
</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>BidirIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/valueswappable" title="cpp/named req/ValueSwappable">ValueSwappable</a>Và<a href="../named_req/bidirectionaliterator" title="cpp/named req/BidirectionalIterator">LegacyBidirectionalIterator</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code>true</code>Biến đổi phạm vi<code>false</code>vào trước</p>
<h3 id="Exceptions">Ngoại lệ</h3> <p>phạm vi của các yếu tố để hoán vị</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Nếu phạm vi trống.<code>(last - first) / 2</code>từ tập hợp tất cả các hoán vị được đặt hàng từ vựng đối với</p>
<h3 id="Notes">Ghi chú</h3> <p>Nếu lần thực hiện hoán vị cuối cùng và phạm vi được đặt lại về hoán vị đầu tiên.<a class="external text" href="https://github.com/microsoft/STL/blob/main/stl/src/vector_algorithms.cpp" rel="nofollow">MSVC STL</a>Bất kỳ trường hợp ngoại lệ nào được ném từ các hoạt động lặp lại hoặc hoán đổi phần tử.<a href="../named_req/contiguousiterator" title="cpp/named req/ContiguousIterator">LegacyContiguousIterator</a>Nhiều nhất là hoán đổi n/2, trong đó<a href="../language/adl" title="cpp/language/adl">ADL</a>. Tính trung bình trên toàn bộ chuỗi hoán vị, các triển khai điển hình sử dụng khoảng 3 so sánh và 1,5 giao dịch hoán đổi mỗi cuộc gọi.<code>swap</code>.</p>
<h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Nếu hoán vị đó tồn tại, nếu không sẽ biến phạm vi thành hoán vị cuối cùng (như thể bằng cách</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example">
<p>Nếu hoán vị mới đi trước người cũ theo thứ tự từ vựng.<span class="st0">Nếu đã đạt được hoán vị đầu tiên và phạm vi được đặt lại về hoán vị cuối cùng.</span>hoán đổi. Tính trung bình trên toàn bộ chuỗi hoán vị, các triển khai điển hình sử dụng khoảng 3 so sánh và 1,5 giao dịch hoán đổi mỗi cuộc gọi.</p>
<div class="cpp source-cpp"><pre data-language="cpp">Mẫu &lt;Class Bidirit&gt;</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">bool prev_permuting (bidirit đầu tiên, bidirit cuối cùng)</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="is_permutation" title="cpp/algorithm/is permutation"> <span class="t-lines"><span>(Niebloid)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="next_permutation" title="cpp/algorithm/next permutation"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="ranges/prev_permutation" title="cpp/algorithm/ranges/prev permutation"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/prev_permutation">https://en.cppreference.com/w/cpp/algorithm/prev_permutation</a>
</p>
</div>
