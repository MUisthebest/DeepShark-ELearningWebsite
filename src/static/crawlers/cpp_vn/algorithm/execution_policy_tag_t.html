 <h1 class="firstHeading" id="firstHeading">STD :: Thực thi :: SERECENCED_POLICY, STD :: Thực thi :: song song_policy, std :: thực thi :: song song</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/execution" title="cpp/header/execution">&lt;execution&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">lớp giải trình tự_policy { / * không xác định * /};</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">lớp song song_policy { / * không xác định * /};</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">lớp song song_unsingerence_policy { / * không xác định * /};</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">lớp Underence_policy { / * không xác định * /};</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Loại chính sách thực thi được sử dụng như một loại duy nhất để phân loại quá tải thuật toán song song và yêu cầu thực thi thuật toán song song có thể không được song song. Các yêu cầu của các hàm truy cập phần tử trong các thuật toán song song được gọi với chính sách này (thường được chỉ định là<code><a href="execution_policy_tag" title="cpp/algorithm/execution policy tag">std::execution::seq</a></code>) được giải trình tự không rõ ràng trong chuỗi gọi.</div> <div class="t-li1">
<span class="t-li">2)</span>Loại chính sách thực thi được sử dụng như một loại duy nhất để phân loại quá tải thuật toán song song và chỉ ra rằng việc thực thi thuật toán song song có thể được song song. Các yêu cầu của các hàm truy cập phần tử trong các thuật toán song song được gọi với chính sách này (thường được chỉ định là<code><a href="execution_policy_tag" title="cpp/algorithm/execution policy tag">std::execution::par</a></code>) được phép thực thi trong chuỗi gọi hoặc trong một luồng được tạo bởi thư viện để hỗ trợ thực thi thuật toán song song. Bất kỳ lời mời nào như vậy thực hiện trong cùng một luồng đều được giải trình tự không rõ ràng với nhau.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Loại chính sách thực thi được sử dụng như một loại duy nhất để phân loại quá tải thuật toán song song và chỉ ra rằng việc thực thi thuật toán song song có thể được song song, vector hóa hoặc di chuyển qua các luồng (chẳng hạn như lịch lập lịch ăn của cha mẹ). Các yêu cầu của các hàm truy cập phần tử trong các thuật toán song song được gọi với chính sách này được phép thực thi theo kiểu không có thứ tự trong các luồng không xác định và không có liên quan đến nhau trong mỗi luồng.</div> <div class="t-li1">
<span class="t-li">là trong</span>Loại chính sách thực thi được sử dụng như một loại duy nhất để phân loại quá tải thuật toán song song và chỉ ra rằng việc thực thi thuật toán song song có thể được vector hóa, ví dụ, được thực thi trên một luồng bằng cách sử dụng các hướng dẫn hoạt động trên nhiều mục dữ liệu.</div> <p>Trong quá trình thực hiện một thuật toán song song với bất kỳ chính sách thực thi nào trong số này, nếu việc gọi hàm truy cập phần tử thoát ra ngoài ngoại lệ chưa bị bắt,<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>được gọi, nhưng việc triển khai có thể xác định các chính sách thực thi bổ sung xử lý các ngoại lệ khác nhau.</p>
<h3 id="Notes">Ghi chú</h3> <p>Khi sử dụng chính sách thực thi song song, trách nhiệm của lập trình viên là tránh các cuộc đua dữ liệu và bế tắc:</p>
<div class="cpp source-cpp"><pre data-language="cpp">int a [] = {0, 1};</pre></div> <div class="cpp source-cpp"><pre data-language="cpp">STD :: Vector &lt;Int&gt; V;</pre></div> <div class="cpp source-cpp"><pre data-language="cpp">std :: for_each (std :: thực thi :: par, std :: start</pre></div> <p>{<i>    v.push_back (i * 2 + 1); // Lỗi: Cuộc đua dữ liệu</i>});<a href="../language/eval_order" title="cpp/language/eval order">indeterminately-sequenced</a>std :: Atomic &lt;Int&gt; x {0};<code><a href="../atomic/atomic" title="cpp/atomic/atomic">std::atomic</a></code>int a [] = {1, 2};<i>std :: for_each (std :: thực thi :: par, std :: start</i>{<code><a href="../thread/mutex/unlock" title="cpp/thread/mutex/unlock">std::mutex::unlock</a></code>    x.fetch_add (1, std :: memory_order_relaxed);<code><a href="../thread/mutex/lock" title="cpp/thread/mutex/lock">std::mutex::lock</a></code>).</p>
<div class="cpp source-cpp"><pre data-language="cpp">    while (x.load (std :: memory_order_relaxed) == 1) {} // error: giả sử thứ tự thực thi</pre></div> <p>});</p>
<h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="execution_policy_tag" title="cpp/algorithm/execution policy tag"> <span class="t-lines"><span>(lớp học)</span><span>SEQ</span><span>mệnh</span><span>par_unseq</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">Các đối tượng chính sách thực thi toàn cầu</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t">https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t</a>
</p>
</div>
