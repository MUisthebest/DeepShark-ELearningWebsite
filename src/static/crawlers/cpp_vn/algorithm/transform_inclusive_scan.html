 <h1 class="firstHeading" id="firstHeading">STD :: Transform_inclusive_scan</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/numeric" title="cpp/header/numeric">&lt;numeric&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class inputit, lớp đầu ra,</pre></td> <td>
<span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">          lớp nhị phân, lớp học không có lớp&gt;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Outputit Transform_inclusive_scan (đầu vào đầu tiên, đầu vào cuối cùng,</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(3)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td><pre data-language="cpp">                                   Outputit D_First,</pre></td> <td>
<span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">                                   Binaryoperation Binary_op,</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">                                   Unanyeration unary_op);</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <p>                                   BinaryOperation Binary_op, Undanoperation unary_op);<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>với<code>unary_op</code>Mẫu &lt;class inputit, lớp đầu ra,<code>binary_op</code>          lớp nhị phân, lớp học không có lớp&gt;<code>init</code>          Lớp T, Lớp BinaryOperation&gt;<code>d_first</code>.<i>Constexpr Outputit Transform_inclusive_scan (đầu vào đầu tiên, đầu vào cuối cùng,</i>                                             Outputit D_First,<sup>phần tử đầu vào trong I</sup>                                             Binaryoperation Binary_op,<sup>phần tử đầu vào trong I</sup>                         Binary Binary_op);</p>
<p>Mẫu &lt;class inputit, lớp đầu ra,<code>i</code>TRONG<code>[</code><code>d_first</code><code>, </code><code>d_first + (last - first)</code><code>)</code>                                             Unanyeration unary_op);</p>
<ul>
<li>BẰNG<span class="t-v">Outputit adjacent_difference (đầu vào đầu tiên, đầu vào cuối cùng, </span>          Lớp học nhị phân&gt;<code>unary_op(*j)...</code>constexpr outputit exclusive_scan (đầu vào đầu tiên, đầu vào cuối cùng,<code>j</code>TRONG<code>[</code><code>first</code><code>, </code><code>first + (i - d_first + 1)</code><code>)</code>                                   Outputit D_First, T init,<code>binary_op</code>Thì</li>
<li>BẰNG<span class="t-v">ConstExpr Outputit Adjacent_Difference (Inputit First, Inputit Last, </span>          Lớp học nhị phân&gt;<code>init, unary_op(*j)...</code>constexpr outputit exclusive_scan (đầu vào đầu tiên, đầu vào cuối cùng,<code>j</code>TRONG<code>[</code><code>first</code><code>, </code><code>first + (i - d_first + 1)</code><code>)</code>                                   Outputit D_First, T init,<code>binary_op</code>Thì</li>
</ul> <p>                                   Binary Binary_op);<sub class="t-su t-su-b">, nếu như</sub>Tính toán một hoạt động tổng tiền tố độc quyền bằng cách sử dụng<sub class="t-su t-su-b">N</sub>          Lớp T, Lớp BinaryOperation&gt;</p>
<ul>
<li>ForwardItIT2 exclusive_scan (execPolicy &amp;&amp; chính sách,<sub class="t-su t-su-b">, nếu như</sub> </li>
<li>                           Forwardit1 đầu tiên, forwardit1 cuối cùng,<sub class="t-su t-su-b">, nếu như</sub>Tính toán một hoạt động tổng tiền tố độc quyền bằng cách sử dụng<sub class="t-su t-su-b">K</sub>                           Binary Binary_op);<sub class="t-su t-su-b">M</sub>Tính toán một hoạt động tổng tiền tố độc quyền bằng cách sử dụng<sub class="t-su t-su-b">N</sub>Mẫu &lt;Class execPolicy, class forwardit1, class forwardit2,</li>
</ul> <p>Thêm vào đó<code>binary_op</code>) cho phạm vi</p>
<span class="t-v">1</span>, sử dụng<code>policy</code>ForwardIt adjacent_find (execPolicy &amp;&amp; chính sách,<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1568">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2643">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <p><code>unary_op</code>Và<code>binary_op</code>là giá trị ban đầu và ghi kết quả vào phạm vi bắt đầu tại<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>hoặc<code>[</code><code>d_first</code><code>, </code><code>d_first + (last - first)</code><code>)</code>. "Độc quyền" có nghĩa là tôi</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>Đối với mỗi lần lặp</td>
</tr> <tr class="t-par"> <td>không trống, sử dụng bộ tích lũy</td> <td>-</td> <td>Phần tử đầu vào không được bao gồm trong I<code>first</code> </td>
</tr> <tr class="t-par"> <td>std :: iterator_traits &lt;buputit&gt; :: value_type acc = *first;</td> <td>-</td> <td>*d_first = acc;<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">execution policy</a> </td>
</tr> <tr class="t-par"> <td>trong phạm vi</td> <td>-</td> <td>tổng.</td>
</tr> <tr class="t-par"> <td>          Lớp đầu ra, lớp BinaryOperation&gt;</td> <td>-</td> <td>Mẫu &lt;Class execPolicy,<a href="../named_req/functionobject" title="cpp/named req/FunctionObject">FunctionObject</a>          lớp chuyển tiếp1, lớp chuyển tiếp2,<code>binary_op</code>.</td>
</tr> <tr class="t-par"> <td>Chính thức, gán thông qua từng trình lặp</td> <td>-</td> <td>giá trị của tổng số không chung chung của<a href="../named_req/functionobject" title="cpp/named req/FunctionObject">FunctionObject</a>          Lớp T, Lớp BinaryOperation, lớp không có lớp&gt;<code>unary_op</code>ForwardItIt2 biến đổi_exclusive_scan (execPolicy &amp;&amp; chính sách,<code>binary_op</code>, Và<code>init</code>          lớp nhị phân, lớp học không có lớp&gt;</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>InputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>OutputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/outputiterator" title="cpp/named req/OutputIterator">LegacyOutputIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>ForwardIt1</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>ForwardIt2</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">Mẫu &lt;class inputit, class outputit, lớp BinaryOperation, lớp T&gt;<code>init</code>Outputit bao gồm_scan (đầu vào đầu tiên, đầu vào cuối cùng, đầu ra d_first,<code>decltype(first)</code>ForwardItIt2 biến đổi_inclusive_scan (execPolicy &amp;&amp; chính sách,<a href="../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>Và<code>binary_op(unary_op(*first), unary_op(*first))</code>(6)<code>decltype(first)</code>Mẫu &lt;class inputit, class outputit, lớp BinaryOperation, lớp T&gt;</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T (if init is provided)</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>Constexpr Outputit bao gồm_scan (đầu vào đầu tiên, đầu vào cuối cùng, đầu ra d_first,<code>binary_op(init, unary_op(*first))</code>Thì<code>binary_op(init, init)</code>, Và<code>binary_op(unary_op(*first), unary_op(*first))</code>                                   Binaryoperation Binary_op, T init);</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>trong đó tổng số tổng hợp không chung GNSUM (OP, A</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>                                     Forwardit1 đầu tiên, forwardit1 cuối cùng,<code>binary_op</code>Và<code>unary_op</code>.</p>
<h3 id="Exceptions">Ngoại lệ</h3> <p>Sự khởi đầu của phạm vi đích<code>ExecutionPolicy</code>chính sách</p>
<ul>
<li>Chính sách thực thi để sử dụng. Nhìn thấy<code>ExecutionPolicy</code>Để biết chi tiết.<a href="execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">standard policies</a>Thì<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>Loại loại 1 và type2 phải sao cho một đối tượng của loại iterator_traits<code>ExecutionPolicy</code>Đầu vào</li>
<li>value_type<code><a href="../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>có thể được chuyển đổi hoàn toàn thành cả hai. Loại</li>
</ul> <h3 id="Notes">Ghi chú</h3> <p><code>unary_op</code>                                     Forwardit2 d_first, t init,<code>init</code>.</p>
<p>                                     Forwardit1 đầu tiên, forwardit1 cuối cùng,<code>init</code>                                     Forwardit2 d_first,<code><a href="transform_exclusive_scan" title="cpp/algorithm/transform exclusive scan">std::transform_exclusive_scan</a></code>                                     Binaryoperation Binary_op,</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">                                     BinaryOperation Binary_op, Undanoperation unary_op);</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Biến đổi từng phần tử trong phạm vi</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="partial_sum" title="cpp/algorithm/partial sum"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div> </td> <td>Partial_sum<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="transform" title="cpp/algorithm/transform"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>biến đổi<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="inclusive_scan" title="cpp/algorithm/inclusive scan"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>(C ++ 17)<code><a href="partial_sum" title="cpp/algorithm/partial sum">std::partial_sum</a></code>Tương tự như<sup>phần tử đầu vào trong I</sup>th<sup>phần tử đầu vào trong I</sup>th<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="transform_exclusive_scan" title="cpp/algorithm/transform exclusive scan"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>(C ++ 17)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/algorithm/transform_inclusive_scan">https://en.cppreference.com/w/cpp/algorithm/transform_inclusive_scan</a>
</p>
</div>
