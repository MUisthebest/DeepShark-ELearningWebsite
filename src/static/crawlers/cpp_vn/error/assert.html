 <h1 class="firstHeading" id="firstHeading">khẳng định</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/cassert" title="cpp/header/cassert">&lt;cassert&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td>Khẳng định vô hiệu hóa</td> <td></td> <td></td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx26"> <td> <pre data-language="cpp">#Define ASPERT (điều kiện) ((void) 0)</pre>
</td> <td> <span class="t-mark-rev t-until-cxx26">(Cho đến C ++ 26)</span> </td> </tr> <tr class="t-dcl t-since-cxx26"> <td> <pre data-language="cpp">#Define Assert (...) ((void) 0)</pre>
</td> <td> <span class="t-mark-rev t-since-cxx26">(kể từ C ++ 26)</span> </td> </tr> <tr class="t-dcl-h"> <td>Khẳng định kích hoạt</td> <td></td> <td></td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(2)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx26"> <td> <pre data-language="cpp">#Define ASPERT (điều kiện) / * không xác định * / /</pre>
</td> <td> <span class="t-mark-rev t-until-cxx26">(Cho đến C ++ 26)</span> </td> </tr> <tr class="t-dcl t-since-cxx26"> <td> <pre data-language="cpp">#Define ASSERT (...) / * không xác định * / /</pre>
</td> <td> <span class="t-mark-rev t-since-cxx26">(kể từ C ++ 26)</span> </td> </tr> </table> <p>Định nghĩa của macro<code>assert</code>phụ thuộc vào macro khác,<code>NDEBUG</code>, không được xác định bởi thư viện tiêu chuẩn.</p>
<div class="t-li1">
<span class="t-li">1)</span>Nếu như<code>NDEBUG</code>được định nghĩa là tên macro tại điểm trong mã nguồn trong đó<a href="../header/cassert" title="cpp/header/cassert"><code>&lt;cassert&gt;</code></a>hoặc<a href="../header/cassert" title="cpp/header/cassert">&lt;assert.h&gt;</a>được bao gồm, khẳng định bị vô hiệu hóa:<code>assert</code>Không làm gì cả.</div> <div class="t-li1">
<span class="t-li">2)</span>Nếu không, khẳng định được bật:<table class="t-rev-begin"> <tr class="t-rev t-until-cxx26">
<td> <p><code>assert</code>Kiểm tra nếu đối số của nó (phải có loại vô hướng) so sánh bằng 0. Nếu nó làm,<code>assert</code>Đầu ra Thông tin chẩn đoán cụ thể thực hiện về đầu ra và cuộc gọi lỗi tiêu chuẩn<code><a href="../utility/program/abort" title="cpp/utility/program/abort">std::abort</a></code>. Thông tin chẩn đoán được yêu cầu bao gồm văn bản của<code>condition</code>, cũng như các giá trị của<span class="t-rev-inl t-since-cxx11"><span>các<a href="../language/function#func" title="cpp/language/function">predefined variable <code>__func__</code></a>Và</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>các<a href="../preprocessor/replace" title="cpp/preprocessor/replace">predefined macros</a> <code>__FILE__</code>Và<code>__LINE__</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx26">(Cho đến C ++ 26)</span></td>
</tr> <tr class="t-rev t-since-cxx26">
<td> <p><code>assert</code>Đặt xét nghiệm chẩn đoán vào các chương trình và mở rộng thành biểu hiện của loại<span class="kw4">Vô hiệu</span>.<code>__VA_ARGS__</code>được đánh giá và<a href="../language/implicit_conversion#Contextual_conversions" title="cpp/language/implicit conversion">contextually converted to <span class="kw4">bool</span></a>:</p>
<ul>
<li>Nếu sản lượng đánh giá<code>true</code>, không có tác dụng nữa.</li>
<li>Mặt khác, biểu thức Macro khẳng định tạo ra chẩn đoán trên luồng lỗi tiêu chuẩn theo định dạng và cuộc gọi được xác định theo thực hiện<code><a href="../utility/program/abort" title="cpp/utility/program/abort">std::abort()</a></code>. Chẩn đoán chứa<code>#__VA_ARGS__</code>và thông tin về tên tệp nguồn, số dòng nguồn và tên của hàm bao quanh (như được cung cấp bởi<a href="../utility/source_location/current" title="cpp/utility/source location/current"><code>std::source_location::current()</code></a>).</li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx26">(kể từ C ++ 26)</span></td>
</tr> </table>
</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>              Không có p);<code>assert(E)</code>được đảm bảo là một<a href="../language/constant_expression" title="cpp/language/constant expression">constant subexpression</a>, nếu một trong hai</p>
<ul>
<li> <code>NDEBUG</code>được xác định tại điểm mà<code>assert</code>được xác định hoặc xác định lại lần cuối, hoặc</li>
<li> <code>E</code>Thì<a href="../language/implicit_conversion#Contextual_conversions" title="cpp/language/implicit conversion">contextually converted to <span class="kw4">bool</span></a>, là một biểu hiện phụ liên tục đánh giá<code>true</code>.</li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>tình trạng</td> <td>-</td> <td>Biểu hiện của loại vô hướng</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Gán cho đã cho</p>
<h3 id="Notes">Ghi chú</h3> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx26">
<td> <p>container tiêu chuẩn<code>assert</code>Điều đó như vậy<a href="../preprocessor/replace" title="cpp/preprocessor/replace">function-like macro</a>, dấu phẩy ở bất cứ đâu trong đối số không được bảo vệ bởi dấu ngoặc đơn được hiểu là phân tách đối số vĩ mô. Những dấu phẩy như vậy thường được tìm thấy trong danh sách đối số mẫu và danh sách-khởi tạo:</p>
<div class="cpp source-cpp"><pre data-language="cpp">Assert (std :: is_same_v &lt;int, int&gt;);        // Lỗi: Assert không lấy hai đối số</pre></div> </td> <td><span class="t-mark-rev t-until-cxx26">(Cho đến C ++ 26)</span></td>
</tr> </table> <p>Assert ((std :: is_same_v &lt;int, int&gt;));      // ok: một đối số<code>assert</code>static_assert (std :: is_same_v &lt;int, int&gt;); // ok: không phải là một macro<a href="../language/operator_other#Built-in_comma_operator" title="cpp/language/operator other">comma operator</a> <a href="../language/operators" title="cpp/language/operators">overloaded</a>std :: phức tạp &lt;Uluble&gt; c;<code>&amp;&amp;</code>Assert (c == std :: phức tạp &lt;double&gt; {0, 0});   // lỗi</p>
<div class="cpp source-cpp"><pre data-language="cpp">Assert ((c == std :: phức tạp &lt;double&gt; {0, 0})); // ĐƯỢC RỒI</pre></div> <p>Không có giao diện được tiêu chuẩn hóa để thêm một thông báo bổ sung vào<code>assert</code>TRONG<a class="external text" href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/assert-macro-assert-wassert?view=msvc-160" rel="nofollow">Microsoft CRT</a>lỗi. Một cách di động để bao gồm một là sử dụng<code>_wassert</code>miễn là nó chưa được<code>__func__</code>hoặc sử dụng</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">với một chuỗi theo nghĩa đen:</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">khẳng định (("có năm đèn", 2 + 2 == 5));</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <a href="../language/static_assert" title="cpp/language/static assert"><code>static_assert</code> declaration</a><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span> </td> <td>Thực hiện kiểm tra xác nhận thời gian biên dịch</td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/program/abort" title="cpp/utility/program/abort"> <span class="t-lines"><span>khẳng định ((2 + 2 == 5) &amp;&amp; "Có năm đèn");</span></span></a></div> </td> <td>Việc thực hiện<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/error/assert" title="c/error/assert">C documentation</a></span>vì<code>assert</code> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/error/assert">https://en.cppreference.com/w/cpp/error/assert</a>
</p>
</div>
