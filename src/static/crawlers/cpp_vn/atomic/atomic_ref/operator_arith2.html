 <h1 class="firstHeading" id="firstHeading">STD :: ATOMIC_REF &lt;T&gt; :: Toán tử+=,-=, &amp; =, | =,^=</h1> <table class="t-dcl-begin"> <tr class="t-dcl-h"> <td>T fetch_add (t arg, std :: memory_order order =<code>atomic_ref&lt;<i>được xác định, tương ứng.</i>&gt;</code>Và<code>atomic_ref&lt;<i>là tùy chọn trong việc thực hiện độc lập.</i>&gt;</code>chuyên môn mẫu</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Toán tử t+= (t arg) const noexcept;</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl-h"> <td>T fetch_add (t arg, std :: memory_order order =<code>atomic_ref&lt;T*&gt;</code>Chuyên môn hóa mẫu</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Toán tử t*+= (std :: ptrdiff_t arg) const noexcept;</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl-h"> <td>T fetch_add (t arg, std :: memory_order order =<code>atomic_ref&lt;<i>được xác định, tương ứng.</i>&gt;</code>Và<code>atomic_ref&lt;<i>là tùy chọn trong việc thực hiện độc lập.</i>&gt;</code>chuyên môn mẫu</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Toán tử t-= (t arg) const noexcept;</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl-h"> <td>T fetch_add (t arg, std :: memory_order order =<code>atomic_ref&lt;T*&gt;</code>Chuyên môn hóa mẫu</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Toán tử t*-= (std :: ptrdiff_t arg) const noexcept;</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl-h"> <td>T fetch_add (t arg, std :: memory_order order =<code>atomic_ref&lt;<i>được xác định, tương ứng.</i>&gt;</code>Chuyên môn hóa mẫu</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Toán tử t &amp; = (t arg) const noexcept;</pre>
</td> <td>(3)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Toán tử t | = (t arg) const noexcept;</pre>
</td> <td>(4)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Toán tử t^= (t arg) const noexcept;</pre>
</td> <td>             Không có p);</td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Thay thế nguyên tử giá trị hiện tại của đối tượng được tham chiếu bằng kết quả của tính toán liên quan đến giá trị trước đó và<code>arg</code>. Các hoạt động này là các hoạt động đọc biến đổi.</p>
<div class="t-li1">
<span class="t-li">1)</span>Thực hiện bổ sung nguyên tử. Tương đương với<code>return fetch_add(arg) + arg;</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>Thực hiện phép trừ nguyên tử. Tương đương với<code>return fetch_sub(arg) - arg;</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Thực hiện nguyên tử bitwise và. Tương đương với<code>return fetch_and(arg) &amp; arg;</code>.</div> <div class="t-li1">
<span class="t-li">là trong</span>Thực hiện nguyên tử bitwise hoặc. Tương đương với<code>return fetch_or(arg) | arg;</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Thực hiện độc quyền nguyên tử bitwise hoặc. Tương đương với<code>return fetch_xor(arg) ^ arg;</code>.</div> <p>                  std :: memory_order_seq_cst) noExcept;</p>
<p>T* fetch_add (std :: ptrdiff_t arg, <a href="../../numeric/fenv" title="cpp/numeric/fenv">floating-point environment</a>                  std :: memory_order_seq_cst) noExcept;<code><a href="../../types/numeric_limits" title="cpp/types/numeric limits">std::numeric_limits</a></code>                  std :: memory_order_seq_cst) NoExcept biến động;</p>
<p>Bool Binary_Search (Forwardit First, Forwardit Last,<code>T*</code>Các loại, kết quả có thể là một địa chỉ không xác định, nhưng các hoạt động khác không có hành vi không xác định. Chương trình không được hình thành nếu<code>T</code>Các loại, kết quả có thể là một địa chỉ không xác định, nhưng hoạt động khác không có hành vi không xác định. Chương trình không được hình thành nếu</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>T ATOMIC_FETCH_ADD_EXPLICIT (STD :: ATOMIC &lt;T&gt;* OBJ,</td> <td>-</td> <td>đối số cho hoạt động số học</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Giá trị kết quả (nghĩa là kết quả của việc áp dụng toán tử nhị phân tương ứng vào giá trị ngay trước các hiệu ứng của hàm thành viên tương ứng).</p>
<h3 id="Notes">Ghi chú</h3> <p>Không giống như hầu hết các toán tử gán hợp chất, các toán tử gán hợp chất cho<code>atomic_ref</code>Không trả lại một tham chiếu đến các đối số bên trái của họ. Họ trả lại một bản sao của giá trị được lưu trữ thay thế.</p>
<h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="operator_arith" title="cpp/atomic/atomic ref/operator arith"> <span class="t-lines"><span>fetch_or</span><span>fetch_or<span class="t-dsc-small">toán tử ++</span></span><span>thực hiện nguyên tử Bitwise XOR giữa đối số và giá trị của đối tượng nguyên tử và có được giá trị được giữ trước đó</span><span>thực hiện nguyên tử Bitwise XOR giữa đối số và giá trị của đối tượng nguyên tử và có được giá trị được giữ trước đó<span class="t-dsc-small">toán tử ++</span></span></span></a></div> </td> <td>trừ về mặt nguyên tử đối số từ giá trị được lưu trữ trong đối tượng được tham chiếu và có được giá trị được giữ trước đó<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/atomic/atomic_ref/operator_arith2">https://en.cppreference.com/w/cpp/atomic/atomic_ref/operator_arith2</a>
</p>
</div>
