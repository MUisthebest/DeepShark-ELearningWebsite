 <h1 class="firstHeading" id="firstHeading">std :: Variant &lt;type ...&gt; :: Toán tử =</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Biến thể &amp; Toán tử ConstExPR = (Biến thể Const &amp; RHS);</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Biến thể &amp; Toán tử ConstExpr = (Variant &amp;&amp; rhs) NoExcept (/ * Xem bên dưới */);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(3)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;Class T&gt; </pre></td> <td>
<span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Biến thể &amp; toán tử = (t &amp;&amp; t) noExcept (/ * xem bên dưới */);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>ConsExPR mong đợi &amp; toán tử = (const bất ngờ &lt;g&gt; &amp; other);<code>variant</code>Giống như các tài liệu tham khảo ngôn ngữ, sự ổn định là nông cạn đối với</p>
<span class="t-li">1)</span>Mẫu &lt;Class T&gt; <ul>
<li>Nếu chỉ khi mọi yếu tố trong phạm vi<code>*this</code>Và<code>rhs</code>. Quá tải này là tầm thường nếu</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>rhs</code>Định thiết di chuyển:<code>*this</code>là vô giá trị bởi ngoại lệ, không làm gì cả.<code>*this</code>là vô giá trị, nhưng</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>rhs</code>không phải, phá hủy giá trị có trong<code>*this</code>ConstExPR mong đợi &amp; toán tử = (không mong muốn &lt;g&gt; &amp;&amp; khác);<code>rhs</code>có giá trị đối với một số biến được phát minh<code>*this</code>là một con trỏ đến đối tượng và<code>*this</code>giữ sự thay thế tương tự như</li>
<li>đến giá trị có trong<code>rhs</code>Không trở thành vô giá trị: giá trị phụ thuộc vào bảo đảm an toàn ngoại lệ của nhiệm vụ bản sao của thay thế.<i>không</i>Nếu không, nếu sự thay thế được tổ chức bởi<code><a href="../../types/is_copy_constructible" title="cpp/types/is copy constructible">std::is_nothrow_copy_constructible</a></code>Và<code><a href="../../types/is_move_constructible" title="cpp/types/is move constructible">std::is_nothrow_move_constructible</a></code>có thể xây dựng bản sao không có thể xây dựng hoặc<code>this<span class="sy2">-</span><span class="sy1">&lt;</span>emplace<span class="sy1">is_trivently_destructible_v</span>rhs.<span class="me1">Chỉ mục</span><span class="br0">.</span><span class="br0">)</span><span class="sy1">&lt;</span><span class="br0">.</span><span class="sy2">*</span><a href="http://en.cppreference.com/w/cpp/utility/variant/get_if"><span class="kw1091">Điều đó cho tất cả<span class="me2">get_if</span></span></a><span class="sy1">is_trivently_destructible_v</span>rhs.<span class="me1">Chỉ mục</span><span class="br0">.</span><span class="br0">)</span><span class="sy1">&lt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw759">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span>rhs<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span></code>.<code>*this</code>là chỉ số dựa trên không<a href="valueless_by_exception" title="cpp/utility/variant/valueless by exception"><code>valueless_by_exception</code></a>Nothrow di chuyển có thể xây dựng (như được xác định bởi<a href="emplace" title="cpp/utility/variant/emplace"><code>emplace</code></a>.</li>
<li>Hành vi không được xác định nếu cơ bản<code>this-&gt;operator=(variant(rhs))</code>.</li>
</ul> <div class="t-li1">Consexpr Const Tuple &amp; Toán tử = (STD :: Cặp &lt;E1, E2&gt; &amp;&amp; P) Const;<code><a href="http://en.cppreference.com/w/cpp/types/is_copy_constructible"><span class="kw540">Điều đó cho tất cả<span class="me2">(c)</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_i<span class="sy1">&lt;</span></code>Và<code><a href="http://en.cppreference.com/w/cpp/types/is_copy_assignable"><span class="kw558">Điều đó cho tất cả<span class="me2">Nếu không có ngoại lệ nào bị ném, sau khi chuyển nhượng,</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_i<span class="sy1">&lt;</span></code>, và sau đó thêm 1.<code>true</code>cho tất cả<code>T_i</code>TRONG<code>Types...</code>. Nếu một ngoại lệ được ném bởi<code><a href="http://en.cppreference.com/w/cpp/types/is_copy_constructible"><span class="kw542">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_i<span class="sy1">&lt;</span></code>Thì<code><a href="http://en.cppreference.com/w/cpp/types/is_copy_assignable"><span class="kw560">Điều đó cho tất cả<span class="me2">chứa một giá trị, sau đó tùy thuộc vào việc</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_i<span class="sy1">&lt;</span></code>Và<code><a href="http://en.cppreference.com/w/cpp/types/is_destructible"><span class="kw572">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_i<span class="sy1">&lt;</span></code>. Nó là tầm thường nếu<code>true</code>cho tất cả<code>T_i</code>TRONG<code>Types...</code>.</div> <span class="t-li">2)</span>Nếu một ngoại lệ được ném vào việc xây dựng bản sao bên trong<ul>
<li>Nếu chỉ khi mọi yếu tố trong phạm vi<code>*this</code>Và<code>rhs</code>. Quá tải này là tầm thường nếu</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>rhs</code>Định thiết di chuyển:<code>*this</code>là vô giá trị bởi ngoại lệ, không làm gì cả.<code>*this</code>là vô giá trị, nhưng</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>rhs</code>không phải, phá hủy giá trị có trong<code>*this</code>, gán<code>std<span class="sy4">::</span><span class="me2">(Niebloid)</span><span class="br0">.</span><span class="sy2">*</span><a href="http://en.cppreference.com/w/cpp/utility/variant/get_if"><span class="kw1091">Điều đó cho tất cả<span class="me2">get_if</span></span></a><span class="sy1">is_trivently_destructible_v</span>j<span class="sy1">&lt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw759">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span>rhs<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span></code>có giá trị đối với một số biến được phát minh<code>*this</code>    mẫu &lt;<code>j</code>hiện tại<code>index()</code>là một con trỏ đến đối tượng và<code>*this</code>giữ sự thay thế tương tự như</li>
<li>Nếu không (nếu<code>rhs</code>Và<code>*this</code>đến giá trị có trong<code>this<span class="sy2">-</span><span class="sy1">&lt;</span>emplace<span class="sy1">is_trivently_destructible_v</span>rhs.<span class="me1">Chỉ mục</span><span class="br0">.</span><span class="br0">)</span><span class="sy1">&lt;</span><span class="br0">.</span>std<span class="sy4">::</span><span class="me2">(Niebloid)</span><span class="br0">.</span><span class="sy2">*</span><a href="http://en.cppreference.com/w/cpp/utility/variant/get_if"><span class="kw1091">Điều đó cho tất cả<span class="me2">get_if</span></span></a><span class="sy1">is_trivently_destructible_v</span>rhs.<span class="me1">Chỉ mục</span><span class="br0">.</span><span class="br0">)</span><span class="sy1">&lt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw759">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span>rhs<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span></code>Không trở thành vô giá trị: giá trị phụ thuộc vào sự đảm bảo an toàn ngoại lệ của nhiệm vụ di chuyển của thay thế.<code>T_i</code>giữ các lựa chọn thay thế khác nhau), tương đương với<code>*this</code>trở thành<a href="valueless_by_exception" title="cpp/utility/variant/valueless by exception"><code>valueless_by_exception</code></a>.</li>
</ul> <div class="t-li1">                const std :: chrono :: sys_time &lt;thời gian&gt; &amp; tp);<code><a href="http://en.cppreference.com/w/cpp/types/is_move_constructible"><span class="kw546">Điều đó cho tất cả<span class="me2">hoán đổi void (t2 (&amp; a) [n], t2 (&amp; b) [n]) noExcept ( / * xem bên dưới * /);</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_i<span class="sy1">&lt;</span></code>Và<code><a href="http://en.cppreference.com/w/cpp/types/is_move_assignable"><span class="kw564">Điều đó cho tất cả<span class="me2">Constexpr void hoán đổi (t2 (&amp; a) [n], t2 (&amp; b) [n]) noexcept ( / * xem bên dưới * /);</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_i<span class="sy1">&lt;</span></code>, và sau đó thêm 1.<code>true</code>cho tất cả<code>T_i</code>TRONG<code>Types...</code>. Nếu một ngoại lệ được ném bởi<code><a href="http://en.cppreference.com/w/cpp/types/is_move_constructible"><span class="kw548">Điều đó cho tất cả<span class="me2">Hàm tạo mặc định. Nếu như</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_i<span class="sy1">&lt;</span></code>Thì<code><a href="http://en.cppreference.com/w/cpp/types/is_move_assignable"><span class="kw566">Điều đó cho tất cả<span class="me2">bị xóa khi một trong hai</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_i<span class="sy1">&lt;</span></code>, Và<code><a href="http://en.cppreference.com/w/cpp/types/is_destructible"><span class="kw572">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_i<span class="sy1">&lt;</span></code>. Nó là tầm thường nếu<code>true</code>cho tất cả<code>T_i</code>TRONG<code>Types...</code>.</div> <span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Trình xây dựng di chuyển,<ul>
<li>. Quá tải này là tầm thường nếu<code>T_j</code>Chuyển đổi bài tập.<code>F<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="br0">.</span>t<span class="br0">)</span><span class="br0">)</span></code>Xác định loại thay thế<code>F(T_i)</code>constexpr outputit exclusive_scan (đầu vào đầu tiên, đầu vào cuối cùng,<code>T_i</code>từ<code>Types...</code>sẽ được chọn bởi độ phân giải quá tải cho biểu thức</li>
<ul><li>Nếu có quá tải chức năng tưởng tượng<code>F(T_i)</code>trong phạm vi cùng một lúc, ngoại trừ điều đó:<code>T_i x<span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span><span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span> <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <span class="br0">danh tính</span> <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="br0">.</span>t<span class="br0">)</span> <span class="br0">{</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>Một quá tải<code>x</code>Số lượng các yếu tố để sao chép</li></ul>
<li>Nếu như<code>*this</code>chỉ được xem xét nếu tuyên bố<code>T_j</code>, gán<code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="br0">.</span>t<span class="br0">)</span></code>có giá trị đối với một số biến được phát minh<code>*this</code>là một con trỏ đến đối tượng và<code>*this</code>đã giữ a</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw532">Điều đó cho tất cả<span class="me2">là một gói tham số sao cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_j, T<span class="sy1">&lt;</span> <span class="sy3">Mẫu &lt;std :: forward_iterator i1, std :: sentinel_for &lt;i1&gt; s1,</span> <span class="sy3">Nếu tồn tại một</span><a href="http://en.cppreference.com/w/cpp/types/is_move_constructible"><span class="kw550">Điều đó cho tất cả<span class="me2">    lớp accessorpolicy = std :: default_accessor &lt;t&gt;</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_j<span class="sy1">&lt;</span></code>khoảng cách<code>true</code>So sánh nội dung của<code>this<span class="sy2">-</span><span class="sy1">&lt;</span>emplace<span class="sy1">is_trivently_destructible_v</span>j<span class="sy1">&lt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="br0">.</span>t<span class="br0">)</span><span class="br0">)</span></code>.<code>*this</code>là chỉ số dựa trên không<a href="valueless_by_exception" title="cpp/utility/variant/valueless by exception"><code>valueless_by_exception</code></a>đến giá trị có trong<a href="emplace" title="cpp/utility/variant/emplace"><code>emplace</code></a>.</li>
<li>Hành vi không được xác định nếu cơ bản<code>this<span class="sy2">-</span><span class="sy1">&lt;</span>emplace<span class="sy1">is_trivently_destructible_v</span>j<span class="sy1">&lt;</span><span class="br0">.</span>T_j<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="br0">.</span>t<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span></code>.</li>
</ul> <p>                const std :: chrono :: sys_time &lt;thời gian&gt; &amp; tp);<span class="t-rev-inl t-until-cxx20"><span><code><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code></span><span><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></span></span><span class="t-rev-inl t-since-cxx20"><span><code><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2644">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code></span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>Một bản đồ phẳng hỗ trợ nhiều nhất<code>variant</code>Và<code><a href="http://en.cppreference.com/w/cpp/types/is_assignable"><span class="kw552">Điều đó cho tất cả<span class="me2">tương ứng với khóa</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_j<span class="sy3">Không có giá trị</span>, T<span class="sy1">&lt;</span></code>khoảng cách<code>true</code>Và<code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw528">Điều đó cho tất cả<span class="me2">, sao chép-khởi tạo phần tử tương ứng của kết quả với</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_j, T<span class="sy1">&lt;</span></code>khoảng cách<code>true</code>Xây dựng một trình bao bọc tham khảo mới.<code>F<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="br0">.</span>t<span class="br0">)</span><span class="br0">)</span></code>Không trở thành vô giá trị: Giá trị phụ thuộc vào bảo đảm an toàn ngoại lệ của nhiệm vụ được gọi là.</p>
<div class="cpp source-cpp"><pre data-language="cpp">Nếu một ngoại lệ được ném vào việc khởi tạo bên trong</pre></div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>RHS</td> <td>-</td> <td>khác<code>variant</code> </td>
</tr> <tr class="t-par"> <td>Chuyển đổi đối số</td> <td>-</td> <td>(với F là tập hợp các chức năng tưởng tượng ở trên) được hình thành tốt.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code>*this</code></p>
<h3 id="Exceptions">Ngoại lệ</h3> <div class="t-li1">
<span class="t-li">1)</span>std :: biến thể &lt;std :: chuỗi&gt; v1;</div> <div class="t-li1">
<span class="t-li">2)</span> <div class="t-noexcept-full">
<a href="../../language/noexcept_spec" title="cpp/language/noexcept spec"><code>noexcept</code></a>Đặc điểm kỹ thuật:<div class="t-noexcept-box"><span class="t-cc"><code><span class="kw1">Noexcept</span><span class="br0">.</span><span class="br0">.</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/types/is_move_constructible"><span class="kw550">Điều đó cho tất cả<span class="me2">    lớp accessorpolicy = std :: default_accessor &lt;t&gt;</span></span></a><span class="sy1">is_trivently_destructible_v</span>Types<span class="sy1">&lt;</span> <span class="sy3">. Trong các cuộc gọi có hiệu lực</span><br/> <a href="http://en.cppreference.com/w/cpp/types/is_move_assignable"><span class="kw568">Điều đó cho tất cả<span class="me2">&gt; lớp MDSPAN;</span></span></a><span class="sy1">is_trivently_destructible_v</span>Types<span class="sy1">&lt;</span><span class="br0">)</span> <span class="sy3">. Trong các cuộc gọi có hiệu lực</span> ...<span class="br0">)</span><span class="br0">)</span></code></span></div>
</div>
</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span> <div class="t-noexcept-full">
<a href="../../language/noexcept_spec" title="cpp/language/noexcept spec"><code>noexcept</code></a>Đặc điểm kỹ thuật:<div class="t-noexcept-box"><span class="t-cc"><code><span class="kw1">Noexcept</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/types/is_assignable"><span class="kw556">Điều đó cho tất cả<span class="me2">. Ngoài ra, phải có thể chuyển các đối tượng thuộc loại</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_j<span class="sy3">Không có giá trị</span>, T<span class="sy1">&lt;</span> <span class="sy3">. Trong các cuộc gọi có hiệu lực</span> <a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw532">Điều đó cho tất cả<span class="me2">là một gói tham số sao cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>T_j, T<span class="sy1">&lt;</span><span class="br0">)</span></code></span></div>
</div>
</div> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">v1 = "ABC"; // ĐƯỢC RỒI</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">std :: biến thể &lt;std :: chuỗi, std :: chuỗi&gt; v2;</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3024" rel="nofollow">LWG 3024</a> </td> <td>C ++ 17</td> <td>v2 = "ABC"; // Lỗi<br/>std :: biến thể &lt;std :: chuỗi, bool&gt; v3;</td> <td>v3 = "ABC"; // OK, chọn chuỗi; Bool không phải là ứng cử viên</td>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/P0602R4" rel="nofollow">P0602R4</a> </td> <td>C ++ 17</td> <td>std :: biến thể &lt;float, dài, double&gt; v4; // giữ phao<br/>có thể được biến thành một tùy chọn trống với cả hai</td> <td>. Biểu thức đầu tiên xây dựng một trống</td>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/P0608R3" rel="nofollow">P0608R3</a> </td> <td>C ++ 17</td> <td>v4 = 0; // OK, giữ lâu; Float và Double không phải là ứng cử viên<br/>một giá trị có thể chuyển đổi thành một trong các lựa chọn thay thế của biến thể</td> <td>Có thể ném bất kỳ ngoại lệ nào được ném bằng cách chuyển nhượng và sao chép/di chuyển khởi tạo của bất kỳ sự thay thế nào.<br/>/di chuyển</td>
</tr> <tr> <td>
<a class="external text" href="https://wg21.link/P2231R1" rel="nofollow">P2231R1</a> </td> <td>C ++ 20</td> <td>#include &lt;iomanip&gt;<br/>#include &lt;Istream&gt;</td> <td>xây dựng giá trị chứa tại chỗ</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3585" rel="nofollow">LWG 3585</a> </td> <td>C ++ 17</td> <td>#include &lt;Istream&gt;<br/>#include &lt;chuỗi&gt;</td> <td>Không giống như với</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="emplace" title="cpp/utility/variant/emplace"> <span class="t-lines"><span>Giảm sử dụng bộ nhớ bằng cách giải phóng bộ nhớ không sử dụng</span></span></a></div> </td> <td>kiểm tra xem biến thể ở trạng thái không hợp lệ<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/utility/variant/operator%3D">https://en.cppreference.com/w/cpp/utility/variant/operator%3D</a>
</p>
</div>
