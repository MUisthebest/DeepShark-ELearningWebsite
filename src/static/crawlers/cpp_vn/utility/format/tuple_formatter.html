 <h1 class="firstHeading" id="firstHeading">STD :: Formatter &lt;<i>Cặp hoặc-Tuple</i>&lt;</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/format" title="cpp/header/format">&lt;format&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">Mẫu &lt;biểu đồ lớp, std :: formattable &lt;plart&gt; ... ts&gt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> </table> <p>Chuyên môn hóa mẫu của<code><a href="formatter" title="cpp/utility/format/formatter">std::formatter</a></code>Yêu cầu std :: gián tiếp_comparable &lt;i, const t*, pre, proj&gt;<code><a href="../pair" title="cpp/utility/pair">std::pair</a></code>Và<code><a href="../tuple" title="cpp/utility/tuple">std::tuple</a></code>struct formatter &lt;/*cặp-hoặc-tuple*/&lt;ts ...&gt;, biểu đồ&gt;;<a href="../format" title="cpp/utility/format">formatting functions</a>.</p>
<p>Cho phép người dùng chuyển đổi một cặp hoặc một tuple thành biểu diễn văn bản của nó như một tập hợp các yếu tố sử dụng<code>/*pair-or-tuple*/</code>Tên chỉ dành cho giải trình<code>std::pair</code>hoặc<code>std::tuple</code>.</p>
<h3 id="Format_specification">chuyên môn hóa thường không được truy cập trực tiếp, nhưng được sử dụng thông qua</h3> <p>Đối với các loại phạm vi cho phép người dùng chuyển đổi một phạm vi thành biểu diễn văn bản của nó như một tập hợp các phần tử hoặc một chuỗi bằng cách sử dụng<span class="t-spar">Tuple-loại</span>Nếu phạm vi trống.</p>
<table class="t-sdsc-begin"> <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <span class="t-spar">Tuple-fill-and-align</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">điền và liên kết</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> <span class="t-spar">và mỗi phần tử phạm vi phải được định dạng như thể</span>﻿<span class="t-mark">ATOMIC_INTPTR_T</span> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr>
</table> <p>Các<span class="t-spar">Tuple-fill-and-align</span>chuyên môn cho các loại phạm vi.<span class="t-spar">Chrono-Spec</span>Đặc điểm kỹ thuật định dạng phạm vi<span class="t-spar">Được xác định trong tiêu đề</span>TRONG<span class="t-spar">Tuple-fill-and-align</span>được giải thích theo cách tương tự như một<code>{</code>Thì<code>}</code>, hoặc<code>:</code>.</p>
<p>Các<span class="t-spar">điền và liên kết</span>        std :: input_or_output_iterator &lt;i&gt; &amp;&amp;<a href="formatter#Width_and_precision" title="cpp/utility/format/formatter">standard format width specification</a>.</p>
<p>Các<span class="t-spar">và mỗi phần tử phạm vi phải được định dạng như thể</span>Tuple-fill-and-align</p>
<p>Thay đổi cách một tuple được định dạng, với một số tùy chọn nhất định chỉ hợp lệ với các loại đối số nhất định.</p>
<ul>
<li> <code>m</code>Các loại trình bày tuple có sẵn là:<code>""</code>: Chỉ ra rằng cả hai dấu ngoặc mở và đóng nên<code>": "</code>.</li>
<ul><li>Nếu như<code>m</code>: Chỉ ra rằng phạm vi nên được định dạng thành một chuỗi.<span class="t-spar">và mỗi phần tử phạm vi phải được định dạng như thể</span>Tuple-format-spec<code>sizeof...(Ts) == 2</code>khoảng cách<code>true</code>.</li></ul>
<li> <code>n</code>Trong khi phân tách nên<code>""</code>.</li>
</ul> <h3 id="Member_objects">Đối tượng thành viên</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>key_type</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code><i>không phải là một chuyên môn do chương trình xác định.</i></code> <span class="t-mark">Tên thành viên</span> </td> <td>: Chỉ ra rằng dấu tách, mở và đóng dấu ngoặc nên được<code><a href="http://en.cppreference.com/w/cpp/utility/tuple"><span class="kw1101">Điều đó cho tất cả<span class="me2">Tuple</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/utility/format/formatter"><span class="kw3154">Điều đó cho tất cả<span class="me2">định hình</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2644">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>Ts<span class="sy1">&lt;</span>, CharT<span class="sy1">&lt;</span>...<span class="sy1">&lt;</span></code><br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">(riêng tư)</span>)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><i>Nếu không, nó viết những điều sau đây vào</i></code> <span class="t-mark">Tên thành viên</span> </td> <td>Tuple của các loại định dạng cơ bản của loại<code>", "</code>)<br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">(riêng tư)</span>)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><i>Định dạng tự động (r &amp;&amp; r, formatContext &amp; ctx) const -&gt; typename formatcontext :: iterator;</i></code> <span class="t-mark">Tên thành viên</span> </td> <td>Một chuỗi biểu thị bộ phân tách của kết quả được định dạng tuple (giá trị mặc định là<code>"("</code>)<br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">(riêng tư)</span>)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><i>, theo thứ tự:</i></code> <span class="t-mark">Tên thành viên</span> </td> <td>Một chuỗi biểu thị khung mở của kết quả được định dạng tuple (giá trị mặc định là<code>")"</code>)<br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">(riêng tư)</span>)</span> </td>
</tr> </table> <h3 id="Member_functions">nếu không thì</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>đóng khung đóng cửa_</span></span></div> </td> <td>Một chuỗi đại diện cho khung đóng của kết quả được định dạng tuple (giá trị mặc định là<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>set_separator</span></span></div> </td> <td>Đặt một bộ phân tách được chỉ định cho kết quả được định dạng tuple<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>phân tích cú pháp</span></span></div> </td> <td>cơ bản<span class="t-spar">Tuple-loại</span> <br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>định dạng</span></span></div> </td> <td>Đặt dấu ngoặc mở và đóng được chỉ định cho kết quả được định dạng tuple<span class="t-spar">Tuple-loại</span> <br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <div class="t-member"> <h2 id="std::formatter.3Cpair-or-tuple.3E::set_separator">STD :: Formatter &lt;<i>Cặp hoặc-Tuple</i>ghi đầu ra được định dạng tuple theo quy định của</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">ghi phạm vi đầu ra được định dạng theo quy định của</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Chỉ định<code>sep</code>ĐẾN<code><i>Nếu không, nó viết những điều sau đây vào</i></code>.</p>
</div> <div class="t-member"> <h2 id="std::formatter.3Cpair-or-tuple.3E::set_brackets">STD :: Formatter &lt;<i>Cặp hoặc-Tuple</i>&gt; :: set_separator</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">phân tách_</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Chỉ định<code>opening</code>Và<code>closing</code>ĐẾN<code><i>Định dạng tự động (r &amp;&amp; r, formatContext &amp; ctx) const -&gt; typename formatcontext :: iterator;</i></code>Và<code><i>, theo thứ tự:</i></code>Yêu cầu STD :: Inone</p>
</div> <div class="t-member"> <h2 id="std::formatter.3Cpair-or-tuple.3E::parse">STD :: Formatter &lt;<i>Cặp hoặc-Tuple</i>&gt; :: set_brackets</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">constexpr const std :: formatter &lt;t, biểu đồ&gt; &amp; bên dưới () const;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>, định dạng cơ bản.<span class="t-spar">Tuple-loại</span>STD :: Range_Formatter :: Parse</p>
<p>Nếu như<span class="t-spar">và mỗi phần tử phạm vi phải được định dạng như thể</span>phải là bất kỳ trình lặp có thể phân tách được trong phạm vi<code>n</code>Phân tích các định dạng định dạng như một<code><i>và lưu trữ các nhà xác định phân tích cú pháp trong đối tượng hiện tại.</i></code>Thì<code><i>để phân tích cú pháp</i></code>, Và<code><i>hoặc, nếu cái sau không có mặt, một trống rỗng</i></code>tùy chọn có mặt, các giá trị của</p>
<p>&gt; :: Parse<code>e</code>TRONG<code>underlying_</code>là một con trỏ null hoặc nếu không có ký tự nào được đưa vào<code>e.parse(ctx)</code>Cho mỗi yếu tố<span class="t-spar">có giá trị được sử dụng để định dạng; Nếu nó bị bỏ qua, các đối số được sử dụng theo thứ tự.</span>Cho đến khi một trong các điều kiện sau đây được đáp ứng:<code>e.set_debug_format()</code>Để phân tích một cách trống<code>e.set_debug_format()</code>.</p>
<p>được sửa đổi theo yêu cầu.<span class="t-spar">Tuple-loại</span>.</p>
</div> <h2 id="std::formatter.3Cpair-or-tuple.3E::format">STD :: Formatter &lt;<i>Cặp hoặc-Tuple</i>là một biểu thức hợp lệ, các cuộc gọi</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">&gt; :: Định dạng</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Nếu như<code>(std::formattable&lt;const Ts, CharT&gt; &amp;&amp; ...)</code>khoảng cách<code>true</code>Mẫu &lt;Trass FormatContext&gt;<code>elems</code>khoảng cách<code>const /*pair-or-tuple*/&lt;Ts...&gt;&amp;</code>Định dạng tự động ( / * Xem bên dưới * /&amp; ELEMS, FormatContext &amp; CTX) const <code>/*pair-or-tuple*/&lt;Ts...&gt;&amp;</code>.</p>
<p>    -&gt; Định dạng typenameContext :: iterator;<code>ctx.out()</code>  Yêu cầu STD :: Formattable &lt;Ranges :: Range_Reference_T &lt;R&gt;, Biểu đồ&gt; &amp;&amp;<span class="t-spar">Tuple-loại</span>           std :: more_as &lt;std :: remove_cvref_t &lt;phạm vi :: range_reference_t &lt;r&gt;&gt;, t&gt;</p>
<ul>
<li> <code><i>Định dạng tự động (r &amp;&amp; r, formatContext &amp; ctx) const -&gt; typename formatcontext :: iterator;</i></code>Thì</li>
<li>, sau đó là loại của<code>I</code>. Nếu không, loại là<code>[0, sizeof...(Ts))</code>:</li>
<ul>
<li>nếu như<code>I != 0</code>Thì<code><i>Nếu không, nó viết những điều sau đây vào</i></code>Thì</li>
<li>như một chuỗi hoặc một chuỗi thoát, tương ứng, vào<code>get&lt;I&gt;(elems)</code>thông qua<code>get&lt;I&gt;(underlying_)</code>, Và</li>
</ul>
<li> <code><i>, theo thứ tự:</i></code>.</li>
</ul> <p>Khung mở cửa_</p>
<h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3892" rel="nofollow">LWG 3892</a> </td> <td>C ++ 23</td> <td>Đối với mỗi phần tử có thể tạo thành</td> <td>#include &lt;CstDint&gt;</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="formatter" title="cpp/utility/format/formatter"> <span class="t-lines"><span>định hình</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Xác định quy tắc định dạng cho một loại đã cho<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/utility/format/tuple_formatter">https://en.cppreference.com/w/cpp/utility/format/tuple_formatter</a>
</p>
</div>
