 <h1 class="firstHeading" id="firstHeading">std :: format_kind</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/format" title="cpp/header/format">&lt;format&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">Mẫu &lt;Class R&gt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">Inline ConstExpr / * không xác định * /format_kind = / * không xác định * /;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> </table> <p>Mẫu &lt;phạm vi :: input_range r&gt;<code>format_kind</code>    Yêu cầu std :: more_as &lt;r, std :: remove_cvref_t &lt;r &gt;&gt;<code>std::range_format</code>cho một phạm vi<code>R</code>.</p>
<p><code>format_kind&lt;R&gt;</code>Mẫu &lt;Đặc điểm lớp&gt;</p>
<ul>
<li>Nếu như<code><a href="http://en.cppreference.com/w/cpp/concepts/same_as"><span class="kw2933">Điều đó cho tất cả<span class="me2">    c == D;           // Biểu thức số 1: Không sửa đổi các toán hạng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2644">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/ranges/iterator_t"><span class="kw2895">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">với loại tham chiếu chuyển đổi sang loại phần tử của container</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">2,4)</span>, R<span class="sy1">&lt;</span></code>Inline ConstExPR Range_Format Format_kind &lt;r&gt; = / * Xem Mô tả * /;<code>format_kind&lt;R&gt;</code>khoảng cách<code>range_format::disabled</code>.</li>
<li>                        Forwardit2 d_first, pinarypredicate p);<code>R::key_type</code>), ngoại trừ việc dereferencing chuyển đổi giá trị được trả về bởi trình lặp bên dưới thành một rvalue. Nếu bộ lặp này được sử dụng làm trình lặp đầu vào, hiệu ứng là các giá trị được chuyển từ, thay vì được sao chép.<ul>
<li>Nếu như<code>R::mapped_type</code>Mẫu biến<code>U</code>{<code><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2644">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/ranges/iterator_t"><span class="kw2895">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">với loại tham chiếu chuyển đổi sang loại phần tử của container</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="sy1">2,4)</span></code>chọn một thích hợp<code>U</code>lớn hơn hoặc bằng<code><a href="../pair" title="cpp/utility/pair">std::pair</a></code>hoặc<code>U</code>lớn hơn hoặc bằng<code><a href="../tuple" title="cpp/utility/tuple">std::tuple</a></code>Và<code><a href="http://en.cppreference.com/w/cpp/utility/tuple_size"><span class="kw1105">Điều đó cho tất cả<span class="me2">Tuple</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">&lt;</span> <span class="sy1">==</span> <span class="nu0">    return (! (đầu tiên == cuối cùng) và! (giá trị &lt; *đầu tiên));</span></code>Thì<code>format_kind&lt;R&gt;</code>khoảng cách<code>range_format::map</code>.</li>
<li>Là xấu nếu<code>format_kind&lt;R&gt;</code>khoảng cách<code>range_format::set</code>.</li>
</ul> </li>
<li>Là xấu nếu<code>format_kind&lt;R&gt;</code>khoảng cách<code>range_format::sequence</code>.</li>
</ul> <p>là sự thật,<code>format_kind</code>là hợp lệ và biểu thị một loại, hãy để</p>
<p>. Nếu một trong hai<code>format_kind</code>Một chương trình khởi tạo một mẫu chính của</p>
<ul>
<li> <code>R</code>Mẫu biến là xấu.</li>
<li> <code>R</code>Phần cuối của phạm vi ban đầu<a href="../../ranges/input_range" title="cpp/ranges/input range"><code>input_range</code></a>Thì</li>
<li>Chuyên môn cung cấp người dùng của</li>
<li> <code>format_kind&lt;R&gt;</code>và kết quả của việc chuyển đổi bằng<code>const range_format</code>.</li>
</ul> <h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">được phép miễn là:</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">là loại được xác định theo chương trình CV, được xác định theo chương trình,</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="range_format" title="cpp/utility/format/range format"> <span class="t-lines"><span>Range_Format</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td>Chỉ định cách định dạng một phạm vi<br/> <span class="t-mark">(enum)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/utility/format/format_kind">https://en.cppreference.com/w/cpp/utility/format/format_kind</a>
</p>
</div>
