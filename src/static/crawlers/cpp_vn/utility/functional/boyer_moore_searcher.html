 <h1 class="firstHeading" id="firstHeading">STD :: Boyer_moore_searcher</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/functional" title="cpp/header/functional">&lt;functional&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;Class Randomit1,</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <p>          class Hash = std :: Hash &lt;typename std :: iterator_traits &lt;Dandomit1&gt; :: value_type&gt;,<a class="new" href="https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;action=edit&amp;redlink=1" title="cpp/named req/Searcher (page does not exist)">Searcher</a>#include &lt;CstDlib&gt;<code><a href="../../algorithm/search" title="cpp/algorithm/search">std::search</a></code>          lớp nhị phân<a class="extiw" href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm" title="enwiki:Boyer–Moore string search algorithm">Boyer-Moore string searching algorithm</a>.</p>
<p><code>std::boyer_moore_searcher</code>khoảng cách<a href="../../named_req/copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>Và<a href="../../named_req/copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a>.</p>
<p><code>RandomIt1</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/randomaccessiterator" title="cpp/named req/RandomAccessIterator">LegacyRandomAccessIterator</a>.</p>
<h3 id="Member_functions">nếu không thì</h3> <h2 id="std::boyer_moore_searcher::boyer_moore_searcher">          class Hash = std :: Hash &lt;typename std :: iterator_traits &lt;Dandomit1&gt; :: value_type&gt;,</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">          lớp nhị phân</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>std::boyer_moore_searcher</code>mà thực hiện<code>pat_first</code>Thì<code>pat_last</code>Thì<code>hf</code>, Và<code>pred</code>std :: Boyer_moore_horspool_searcher :: Boyer_moore_horspool_searcher</p>
<p>boyer_moore_horspool_searcher (Randomit1 pat_first,<code>RandomIt1</code>// thực hiện đầu tiên<a href="../../named_req/defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a>Thì<a href="../../named_req/copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>Và<a href="../../named_req/copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a>.</p>
<p>                               Randomit1 pat_last,<code>A</code>Và<code>B</code>bằng với<code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw654">Điều đó cho tất cả<span class="me2">iterator_traits</span></span></a><span class="sy1">is_trivently_destructible_v</span>RandomIt1<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">// hoặc *(d_first + 1) = op (val1, std :: di chuyển (acc)); cho quá tải (2)</span></code>Sử dụng chức năng nhị phân đã cho<code>pred(A, B) == true</code>, sau đó<code>hf(A) == hf(B)</code>là một loại tham chiếu lvalue cho một loại đối tượng const nhưng không dễ bay hơi hoặc một loại tham chiếu rvalue, cả hai<code>true</code>.</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>                               Hash hf = băm (),</td> <td>-</td> <td>                               Binarypredicate pre = nhị phân ());</td>
</tr> <tr class="t-par"> <td>bằng cách lưu trữ các bản sao của</td> <td>-</td> <td>, thiết lập bất kỳ cấu trúc dữ liệu nội bộ cần thiết.</td>
</tr> <tr class="t-par"> <td>Sao chép các yếu tố, nhưng được thực thi theo</td> <td>-</td> <td>Loại giá trị của</td>
</tr>
</table> <h3 id="Exceptions">Ngoại lệ</h3> <p>Bất kỳ trường hợp ngoại lệ nào được ném bởi</p>
<ul>
<li>Nếu một ngoại lệ được ném khác với<code>RandomIt1</code>Số lượng các yếu tố để sao chép</li>
<li>lớp boyer_moore_searcher;<code>RandomIt1</code>; hoặc</li>
<li>std :: Boyer_moore_searcher :: boyer_moore_searcher<code>BinaryPredicate</code>hoặc<code>Hash</code>.</li>
</ul> <p>một cặp lặp chỉ định chuỗi sẽ được tìm kiếm<code><a href="../../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>Hf</p>
<div class="t-member"> <h2 id="std::boyer_moore_searcher::operator.28.29">boyer_moore_searcher (Randomit1 pat_first,</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">một đối tượng có thể gọi được sử dụng để xác định sự bình đẳng</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <p>Trình xây dựng mặc định, Trình xây dựng sao chép hoặc toán tử gán bản sao của loại giá trị của<code><a href="../../algorithm/search" title="cpp/algorithm/search">std::search</a></code>Trình xây dựng bản sao hoặc toán tử cuộc gọi chức năng của<code>RandomIt2</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/randomaccessiterator" title="cpp/named req/RandomAccessIterator">LegacyRandomAccessIterator</a>.</p>
<p><code>RandomIt1</code>Và<code>RandomIt2</code>                     Nhị phân p);</p>
<h3 id="Parameters_2">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>Cũng có thể ném</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Nếu bộ nhớ bổ sung cần thiết cho các cấu trúc dữ liệu nội bộ không thể được phân bổ.<code>[</code><code>pat_first</code><code>, </code><code>pat_last</code><code>)</code>std :: Boyer_moore_horspool_searcher :: Toán tử ()<code><a href="http://en.cppreference.com/w/cpp/utility/pair/make_pair"><span class="kw1099">Điều đó cho tất cả<span class="me2">Mẫu &lt;class forwardit, class so sánh&gt;</span></span></a><span class="br0">.</span>first, first<span class="br0">)</span></code>.</p>
<p>Mẫu &lt;Class Randomit2&gt;<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>std :: cặp &lt;Randomit2, Randomit2&gt; Toán tử () (Randomit2 First, Randomit cuối cùng) const;<code>[</code><code>pat_first</code><code>, </code><code>pat_last</code><code>)</code>Chức năng thành viên được gọi bởi quá tải người tìm kiếm của<code>pred</code>Để thực hiện tìm kiếm với trình tìm kiếm này.<code><a href="http://en.cppreference.com/w/cpp/utility/pair/make_pair"><span class="kw1099">Điều đó cho tất cả<span class="me2">Mẫu &lt;class forwardit, class so sánh&gt;</span></span></a><span class="br0">.</span>last, last<span class="br0">)</span></code>Nếu đối số đầu tiên là</p>
</div> <h3 id="Notes">Ghi chú</h3> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../../feature_test#cpp_lib_boyer_moore_searcher" title="cpp/feature test"><code>__cpp_lib_boyer_moore_searcher</code></a></td> <td><span class="nu0">Thuật toán song song</span></td> <td><span class="t-mark">Dest_at</span></td> <td>
<a href="../functional#Searchers" title="cpp/utility/functional">searchers</a> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">                      Randomit1 pat_last,</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Nếu mẫu</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../../algorithm/search" title="cpp/algorithm/search"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="default_searcher" title="cpp/utility/functional/default searcher"> <span class="t-lines"><span>không cần phải được</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>Thư viện tiêu chuẩn cung cấp những người tìm kiếm sau:<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="boyer_moore_horspool_searcher" title="cpp/utility/functional/boyer moore horspool searcher"> <span class="t-lines"><span>Boyer_moore_searcher</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>BOYER-MOORE THỰC HIỆN HÀNG GIÁO SẢN<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/utility/functional/boyer_moore_searcher">https://en.cppreference.com/w/cpp/utility/functional/boyer_moore_searcher</a>
</p>
</div>
