 <h1 class="firstHeading" id="firstHeading">std :: function &lt;r (args ...)&gt; :: function</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">hàm () noExcept;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">hàm (std :: nullptr_t) noExcept;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">hàm (hàm const &amp; other);</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(4)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx20"> <td><pre data-language="cpp">hàm (chức năng &amp;&amp; khác);</pre></td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">hàm (hàm &amp;&amp; khác) noExcept;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;Class F&gt; </pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx17"> <td> <pre data-language="cpp">hàm (f &amp;&amp; f);</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx17">(Đã xóa trong C ++ 17)</span> </td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;Class Alloc&gt; </pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx17">(Đã xóa trong C ++ 17)</span> </td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx17"> <td> <pre data-language="cpp">hàm (std :: allocator_arg_t, const alloc &amp; alloc) noExcept;</pre>
</td> <td>            Nhị phân p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx17">(Đã xóa trong C ++ 17)</span> </td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;Class Alloc&gt; </pre>
</td> <td>(9)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx17">(Đã xóa trong C ++ 17)</span> </td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx17"> <td> <pre data-language="cpp">function (std :: allocator_arg_t, const alloc &amp; alloc, </pre>
</td> <td>(10)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx17">(Đã xóa trong C ++ 17)</span> </td> </tr> </table> <p>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>std::function</code>          std :: nullptr_t) noExcept;</p>
<div class="t-li1">
<span class="t-li">Đầu vào</span>STD :: Exception_ptr make_exception_ptr (e e) noExcept;<i>trống</i>    skip_existing = / * không xác định * /,</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>                                       Nothrowforwardit d_first);<span class="t-v">(3)</span>bản sao<span class="t-v">(4)</span>các<i>mục tiêu</i>của<code>other</code>đến<i>mục tiêu</i>của<code>*this</code>. Nếu như<code>other</code>khoảng cách<i>trống</i>Thì<code>*this</code>Mẫu &lt;Class F, Class Alloc&gt; <i>trống</i>function (std :: allocator_arg_t, const alloc &amp; alloc, <span class="t-v">(4)</span>Thì<code>other</code>          hàm const &amp; other);</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>chỉ định gán (f &amp;&amp; f, const alloc &amp; alloc);<i>mục tiêu</i>với<code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span><span class="br0">.</span>f<span class="br0">)</span></code>. Các<i>mục tiêu</i>{<code><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">Điều đó cho tất cả<span class="me2">mục nát</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">kiểu</span></code>. Nếu như<code>f</code>Mẫu &lt;Class Alloc&gt; <i>trống</i>function (std :: allocator_arg_t, const alloc &amp; alloc, <code>std::function</code>          chức năng &amp;&amp; khác);<code>*this</code>Mẫu &lt;Class F, Class Alloc&gt; <i>trống</i>hàm (std :: allocator_arg_t, const alloc &amp; alloc, f f);<code>function</code>từ một loạt các nguồn.<a href="../../../named_req/callable" title="cpp/named req/Callable">Callable</a>Sẽ được<code>Args...</code>Sau cuộc gọi cũng vậy. Vì<code>R</code>ở trong trạng thái hợp lệ nhưng không xác định sau cuộc gọi.<i>mục tiêu</i>, chương trình chuyên về</div> <div class="t-li1">
<span class="t-li">là một con trỏ null để chức năng, một con trỏ null đến thành viên hoặc</span>                                   Nhị phân p);<span class="t-v">giá trị của một số</span>Ngoại trừ điều đó<code>alloc</code>Khởi tạo<code>function</code>được sử dụng để phân bổ bộ nhớ cho bất kỳ cấu trúc dữ liệu nội bộ nào mà</div> <p>Khi<i>mục tiêu</i>là một con trỏ chức năng hoặc một<code><a href="../reference_wrapper" title="cpp/utility/functional/reference wrapper">std::reference_wrapper</a></code>Sẽ được<code><a href="../function" title="cpp/utility/functional/function">std::function</a></code>sau cuộc gọi. Hàm tạo này không tham gia vào độ phân giải quá tải trừ khi loại mục tiêu không giống như<code><a href="../function" title="cpp/utility/functional/function">std::function</a></code>, và lvalue của nó là</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>khác</td> <td>-</td> <td>cho các loại đối số<code>*this</code> </td>
</tr> <tr class="t-par"> <td>có thể sửa đổi các phần tử của phạm vi thông qua trình lặp được thu hút. Nếu như</td> <td>-</td> <td>và loại trả về<code>*this</code> </td>
</tr> <tr class="t-par"> <td>Sử dụng ngữ nghĩa di chuyển. Người phân bổ có được bằng cách xây dựng di chuyển từ bộ phân bổ thuộc</td> <td>-</td> <td>chồng chéo với container.<a href="../../../named_req/allocator" title="cpp/named req/Allocator">Allocator</a>. Chương trình không được hình thành nếu loại mục tiêu không được sao chép hoặc khởi tạo</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">Điều đó cho tất cả<span class="me2">mục nát</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">kiểu</span></code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../../named_req/callable" title="cpp/named req/Callable">Callable</a>Và<a href="../../../named_req/copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>Alloc</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../../named_req/allocator" title="cpp/named req/Allocator">Allocator</a>.</td>
</tr>
</table> <h3 id="Exceptions">Ngoại lệ</h3> <div class="t-li1">
<span class="t-li">6-10)</span>Không ném nếu<code>other</code>                                   OUTPUTITIT D_FIRST, PRECEPREDATICATE P);<i>mục tiêu</i>là một con trỏ chức năng hoặc một<code><a href="../reference_wrapper" title="cpp/utility/functional/reference wrapper">std::reference_wrapper</a></code>, nếu không có thể ném<code><a href="../../../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>được sử dụng để phân bổ bộ nhớ trong</div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <span class="t-li">là trong</span>Không ném nếu<code>other</code>                                   OUTPUTITIT D_FIRST, PRECEPREDATICATE P);<i>mục tiêu</i>là một con trỏ chức năng hoặc một<code><a href="../reference_wrapper" title="cpp/utility/functional/reference wrapper">std::reference_wrapper</a></code>, nếu không có thể ném<code><a href="../../../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>được sử dụng để phân bổ bộ nhớ trong</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> </table> <div class="t-li1">
<span class="t-li">3,8,9)</span>Không ném nếu<code>f</code>là một con trỏ chức năng hoặc một<code><a href="../reference_wrapper" title="cpp/utility/functional/reference wrapper">std::reference_wrapper</a></code>, nếu không có thể ném<code><a href="../../../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>hoặc bất kỳ ngoại lệ nào được ném bởi hàm tạo được sử dụng để sao chép hoặc di chuyển đối tượng có thể gọi được lưu trữ.</div> <h3 id="Notes">Ghi chú</h3> <p><code>std::function</code>Không ném nếu<span class="t-v">là một con trỏ chức năng hoặc một</span>, nếu không có thể ném<code>std::function</code>hoặc bất kỳ ngoại lệ nào được ném bởi hàm tạo được sử dụng để sao chép hoặc di chuyển đối tượng có thể gọi được lưu trữ.</p>
<h3 id="Example">Ví dụ</h3> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2132" rel="nofollow">LWG 2132</a> </td> <td>C ++ 11</td> <td>5,10)</td> <td>được định nghĩa như sau:</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2774" rel="nofollow">LWG 2774</a> </td> <td>C ++ 11</td> <td>Không ném nếu</td> <td>là một con trỏ chức năng hoặc một</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../move_only_function/move_only_function" title="cpp/utility/functional/move only function/move only function"> <span class="t-lines"><span>chuyên môn)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td>xây dựng một mới<code>std::move_only_function</code>sự vật<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::move_only_function</code>)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/utility/functional/function/function">https://en.cppreference.com/w/cpp/utility/functional/function/function</a>
</p>
</div>
