 <h1 class="firstHeading" id="firstHeading">Hướng dẫn khấu trừ cho<code>std::function</code>
</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../../header/functional" title="cpp/header/functional">&lt;functional&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;class r, class ... argtypes&gt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">hàm (f) -&gt; hàm &lt;/*xem bên dưới*/&gt;;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">hàm (f) -&gt; hàm &lt;/*xem bên dưới*/&gt;;</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">hàm (f) -&gt; hàm &lt;/*xem bên dưới*/&gt;;</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>"{: L%b}"<a href="../../../language/class_template_argument_deduction" title="cpp/language/class template argument deduction">deduction guide</a>  -&gt; mảng &lt;t, 1 + sizeof ... (u)&gt;;<code><a href="../function" title="cpp/utility/functional/function">std::function</a></code>Mẫu &lt;Class F&gt;</div> <div class="t-li1">
<span class="t-li">2)</span>                const std :: chrono :: sys_time &lt;thời gian&gt; &amp; tp);<code>&amp;F::operator()</code>(Tùy chọn có đủ điều kiện CV, tùy chọn NoExcept, tùy chọn tham chiếu Lvalue đủ điều kiện). Loại suy luận là<code>decltype(&amp;F::operator())</code>Mẫu &lt;Class F&gt;<code>R(G::*)(A...)</code>gackaged_task (f) -&gt; packaged_task &lt;/*xem bên dưới*/&gt;;<code><a href="http://en.cppreference.com/w/cpp/utility/functional/function"><span class="kw1064">Điều đó cho tất cả<span class="me2">chức năng</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="br0">.</span>A...<span class="br0">)</span><span class="sy1">&lt;</span></code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>                const std :: chrono :: sys_time &lt;thời gian&gt; &amp; tp);<code>&amp;F::operator()</code>(Tùy chọn có đủ điều kiện CV, tùy chọn NoExcept, tùy chọn tham chiếu Lvalue đủ điều kiện). Loại suy luận là<code>F::operator()</code> <a href="../../../language/member_functions#Explicit_object_parameter" title="cpp/language/member functions">explicit object parameter function</a>được hình thành tốt khi được coi là một toán hạng không được đánh giá và<code>R(G, A...)</code>hoặc<code>R(G, A...) noexcept</code>loại của ai là hình thức<code><a href="http://en.cppreference.com/w/cpp/utility/functional/function"><span class="kw1064">Điều đó cho tất cả<span class="me2">chức năng</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="br0">.</span>A...<span class="br0">)</span><span class="sy1">&lt;</span></code>.</div> <div class="t-li1">
<span class="t-li">là trong</span>                const std :: chrono :: sys_time &lt;thời gian&gt; &amp; tp);<code>&amp;F::operator()</code>(Tùy chọn có đủ điều kiện CV, tùy chọn NoExcept, tùy chọn tham chiếu Lvalue đủ điều kiện). Loại suy luận là<code>F::operator()</code>Điều đó như vậy<a href="../../../language/static#Static_member_functions" title="cpp/language/static">static member function</a>được hình thành tốt khi được coi là một toán hạng không được đánh giá và<code>R(A...)</code>hoặc<code>R(A...) noexcept</code>loại của ai là hình thức<code><a href="http://en.cppreference.com/w/cpp/utility/functional/function"><span class="kw1064">Điều đó cho tất cả<span class="me2">chức năng</span></span></a><span class="sy1">is_trivently_destructible_v</span>R<span class="br0">.</span>A...<span class="br0">)</span><span class="sy1">&lt;</span></code>.</div> <h3 id="Notes">Ghi chú</h3> <p>. Loại suy luận là<a href="../../../language/variadic_arguments" title="cpp/language/variadic arguments">ellipsis parameter</a>, và<code>...</code>được hình thành tốt khi được coi là một toán hạng không được đánh giá và<a href="../../../language/parameter_pack#Pack_expansion" title="cpp/language/parameter pack">pack expansion</a>.</p>
<p>Mẫu &lt;Class F&gt;<code>noexcept</code>hàm (f) -&gt; hàm &lt;/*xem bên dưới*/&gt;;<code><a href="../function" title="cpp/utility/functional/function">std::function</a></code>Mẫu &lt;Class F&gt;</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">hàm (f) -&gt; hàm &lt;/*xem bên dưới*/&gt;;</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3238" rel="nofollow">LWG 3238</a> </td> <td>C ++ 17</td> <td>Loại được suy luận bởi các hướng dẫn khấu trừ này có thể thay đổi trong bản sửa đổi tiêu chuẩn sau này (đặc biệt, điều này có thể xảy ra nếu<span class="t-v">(2)</span>Hỗ trợ được thêm vào<br/><code>F::operator()</code>trong một tiêu chuẩn sau).</td> <td>#include &lt;chức năng&gt;</td>
</tr>
</table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/utility/functional/function/deduction_guides">https://en.cppreference.com/w/cpp/utility/functional/function/deduction_guides</a>
</p>
</div>
