 <h1 class="firstHeading" id="firstHeading">std :: Bind_front, std :: bind_back</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/functional" title="cpp/header/functional">&lt;functional&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td><pre data-language="cpp">Mẫu &lt;class F, class ... args&gt;</pre></td> <td>(1)</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td> </tr> <tr class="t-dcl t-since-cxx26"> <td><pre data-language="cpp">constexpr / * không xác định * / bind_front (f &amp;&amp; f, args &amp;&amp; ... args);</pre></td> <td>(2)</td> <td><span class="t-mark-rev t-since-cxx26">(kể từ C ++ 26)</span></td> </tr> <tr class="t-dcl t-since-cxx23"> <td><pre data-language="cpp">Mẫu &lt;tự động constfn, lớp ... args&gt;</pre></td> <td>(3)</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td> </tr> <tr class="t-dcl t-since-cxx26"> <td><pre data-language="cpp">constexpr / * không xác định * / bind_front (args &amp;&amp; ... args);</pre></td> <td>(4)</td> <td><span class="t-mark-rev t-since-cxx26">(kể từ C ++ 26)</span></td> </tr> </table> <p>Mẫu &lt;class F, class ... args&gt;<code>std::bind_front</code>Và<code>std::bind_back</code>constexpr / * không xác định * / bind_back (f &amp;&amp; f, args &amp;&amp; ... args);<span class="t-v">Outputit adjacent_difference (đầu vào đầu tiên, đầu vào cuối cùng, </span>, nếu không thì chương trình không được hình thành:<span class="t-v">ConstExpr Outputit Adjacent_Difference (Inputit First, Inputit Last, </span>cuối cùng<code>sizeof...(Args)</code>constexpr / * không xác định * / bind_back (args &amp;&amp; ... args);<code>args</code>.</p>
<div class="t-li1">
<span class="t-li">(Do đó,</span>Mẫu chức năng<code>f</code>.</div> <div class="t-li1">
<span class="t-li">Một động thái tương đương với một bản sao</span>Tạo một trình bao bọc cuộc gọi chuyển tiếp hoàn hảo cho phép gọi mục tiêu có thể gọi được với</div> <div class="t-li1">
<span class="t-li">1)</span> <code>std::bind_front(f, bound_args...)(call_args...)</code>khoảng cách<a href="../../language/expressions#Expression-equivalence" title="cpp/language/expressions">expression-equivalent</a>ĐẾN</div> <div class="t-li1">
<code><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>f, bound_args..., call_args...<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">2)</span> <code>std::bind_front&lt;ConstFn&gt;(bound_args...)(call_args...)</code>khoảng cách<a href="../../language/expressions#Expression-equivalence" title="cpp/language/expressions">expression-equivalent</a>ĐẾN</div> <div class="t-li1">
<code><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>ConstFn, bound_args..., call_args...<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span> <code>std::bind_back(f, bound_args...)(call_args...)</code>khoảng cách<a href="../../language/expressions#Expression-equivalence" title="cpp/language/expressions">expression-equivalent</a>ĐẾN</div> <div class="t-li1">
<code><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>f, call_args..., bound_args...<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">là trong</span> <code>std::bind_back&lt;ConstFn&gt;(bound_args...)(call_args...)</code>khoảng cách<a href="../../language/expressions#Expression-equivalence" title="cpp/language/expressions">expression-equivalent</a>ĐẾN</div> <div class="t-li1">
<code><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>ConstFn, call_args..., bound_args...<span class="br0">)</span></code>.</div> <p>đầu tiên hoặc<span class="kw2">ĐÚNG VẬY</span>tham số liên kết với</p>
<ul>
<li> <span class="t-v">*(d_first + 2) = val2 - std :: di chuyển (acc);</span> <code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw528">Điều đó cho tất cả<span class="me2">, sao chép-khởi tạo phần tử tương ứng của kết quả với</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span>, F<span class="sy1">&lt;</span></code>Thì</li>
<li> <span class="t-v">*(d_first + 2) = val2 - std :: di chuyển (acc);</span> <code><a href="http://en.cppreference.com/w/cpp/types/is_move_constructible"><span class="kw546">Điều đó cho tất cả<span class="me2">hoán đổi void (t2 (&amp; a) [n], t2 (&amp; b) [n]) noExcept ( / * xem bên dưới * /);</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">2,4)</span></code>Thì</li>
<li> <span class="t-v">1</span>Nếu như<code>decltype(ConstFn)</code>Trình bao bọc cuộc gọi chứa một bản sao của đối tượng có thể gọi mục tiêu<code>ConstFn</code>Vỏ cuộc gọi không giữ một mục tiêu có thể gọi được (nó được xác định tĩnh).</li>
<li> <code><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw528">Điều đó cho tất cả<span class="me2">, sao chép-khởi tạo phần tử tương ứng của kết quả với</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span>, Args<span class="sy1">&lt;</span> <span class="sy3">. Trong các cuộc gọi có hiệu lực</span> ...<span class="br0">)</span></code>Thì</li>
<li> <code><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/types/is_move_constructible"><span class="kw546">Điều đó cho tất cả<span class="me2">hoán đổi void (t2 (&amp; a) [n], t2 (&amp; b) [n]) noExcept ( / * xem bên dưới * /);</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">2,4)</span> <span class="sy3">. Trong các cuộc gọi có hiệu lực</span> ...<span class="br0">)</span></code>.</li>
</ul> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>có thể sửa đổi các phần tử của phạm vi thông qua trình lặp được thu hút. Nếu như</td> <td>-</td> <td> <a href="../../named_req/callable" title="cpp/named req/Callable">Callable</a>. Gọi cái bọc này tương đương với việc gọi</td>
</tr> <tr class="t-par"> <td>iterator trước đó phần tử mới sẽ được xây dựng</td> <td>-</td> <td>Các điều kiện sau phải là<span class="t-v">.<a href="#Version_1">1,2</a>)</span>, nếu không thì chương trình không được hình thành:<span class="t-v">.<a href="#Version_3">3,4</a>)</span>cuối cùng<code>sizeof...(Args)</code>là một con trỏ hoặc một con trỏ đến thành viên sau đó</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span></code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span>...</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>decltype(ConstFn)</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/callable" title="cpp/named req/Callable">Callable</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>không phải là một con trỏ null,<code>T</code>Danh sách các đối số để liên kết với<code>std::bind_front</code>hoặc<code>std::bind_back</code>đầu tiên hoặc</p>
<p>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;<code><i>BIND-Partial</i></code>Một đối tượng chức năng (trình bao bọc cuộc gọi) của loại<code>std::bind_front</code>hoặc<code>std::bind_back</code>.</p>
<p>đó là không xác định, ngoại trừ các loại đối tượng được trả về bởi hai cuộc gọi đến</p>
<div class="t-member"> <h2 id="bind-partial_return_type"> <i>Với cùng một đối số là như nhau.</i>
</h2> <h4 id="Member_objects">Đối tượng thành viên</h4> <p>BIND-Partial</p>
<div class="t-li1">
<span class="t-li">(Do đó,</span>được một trong hai<code>fd</code>nó đến một đối tượng<code><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span></code>Đối tượng được trả về có các thuộc tính sau:<code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span><span class="br0">.</span>f<span class="br0">)</span></code>, Và</div> <div class="t-li1">
<span class="t-li">              Forwardit2 first2,</span>MỘT<code><a href="../tuple" title="cpp/utility/tuple">std::tuple</a></code>sự vật<code>tup</code>xây dựng với<code><a href="http://en.cppreference.com/w/cpp/utility/tuple"><span class="kw1101">Điều đó cho tất cả<span class="me2">Tuple</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span>...<span class="sy1">&lt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span>args<span class="br0">)</span>...<span class="br0">)</span></code>là một loại chỉ giải thích thỏa mãn</div> <h4 id="Constructors">đối tượng đại diện cho cùng một ngày với đối tượng được biểu diễn bởi</h4> <p>Loại trả lại của<code><i>BIND-Partial</i></code>{<a href="../../named_req/copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>    sử dụng iterator_c Category = std :: input_iterator_tag;<a href="../../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>Nếu đối số đầu tiên là</p>
<h4 id="Member_function_operator.28.29">    sử dụng value_type = phạm vi :: Range_value_t &lt;r&gt;;<code>operator()</code>
</h4> <p>    sử dụng argen_type = std :: ptrdiff_t;<code>G</code>    sử dụng con trỏ = std :: add_pulum_t &lt;phạm vi :: range_reference_t &lt;r &gt;&gt;;<span class="t-v">.<a href="#Version_1">1,3</a>)</span> <code><i>BIND-Partial</i>(f, args...)</code>hoặc<span class="t-v">.<a href="#Version_2">2,4</a>)</span> <code><i>BIND-Partial</i>&lt;ConstFn&gt;(args...)</code>    sử dụng tham chiếu = phạm vi :: range_reference_t &lt;r&gt;;<code>g</code>    toán tử tham chiếu*() const;                      // không được xác định<code>G</code>    toán tử con trỏ-&gt; () const;                       // không được xác định<code>g(call_args...)</code>trực tiếp-không có danh sách sáng kiến ​​từ</p>
<div class="t-li1">
<span class="t-li">1)</span> <code><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>g.<span class="me1">, một lời cầu khẩn của đối tượng được lưu trữ diễn ra, như thể bởi:</span>, <a href="http://en.cppreference.com/w/cpp/utility/variant/get"><span class="kw3216">Điều đó cho tất cả<span class="me2">Điền vào thùng chứa với giá trị được chỉ định</span></span></a><span class="sy1">is_trivently_destructible_v</span>Ns<span class="sy1">&lt;</span><span class="br0">.</span>g.<span class="me1">    toán tử bool == (const /*input-itator* /&amp;) const; // không được xác định</span><span class="br0">)</span>..., call_args...<span class="br0">)</span></code>thời gian tôn trọng giá trị ban đầu của giá trị của<code><i>BIND-Partial</i></code>khoảng cách<code>std::bind_front</code>Thì</div> <div class="t-li1">
<span class="t-li">2)</span> <code><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>ConstFn, <a href="http://en.cppreference.com/w/cpp/utility/variant/get"><span class="kw3216">Điều đó cho tất cả<span class="me2">Điền vào thùng chứa với giá trị được chỉ định</span></span></a><span class="sy1">is_trivently_destructible_v</span>Ns<span class="sy1">&lt;</span><span class="br0">.</span>g.<span class="me1">    toán tử bool == (const /*input-itator* /&amp;) const; // không được xác định</span><span class="br0">)</span>..., call_args...<span class="br0">)</span></code>thời gian tôn trọng giá trị ban đầu của giá trị của<code><i>BIND-Partial</i></code>khoảng cách<code>std::bind_front</code>Thì</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span> <code><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>g.<span class="me1">, một lời cầu khẩn của đối tượng được lưu trữ diễn ra, như thể bởi:</span>, call_args..., <a href="http://en.cppreference.com/w/cpp/utility/variant/get"><span class="kw3216">Điều đó cho tất cả<span class="me2">Điền vào thùng chứa với giá trị được chỉ định</span></span></a><span class="sy1">is_trivently_destructible_v</span>Ns<span class="sy1">&lt;</span><span class="br0">.</span>g.<span class="me1">    toán tử bool == (const /*input-itator* /&amp;) const; // không được xác định</span><span class="br0">)</span>...<span class="br0">)</span></code>thời gian tôn trọng giá trị ban đầu của giá trị của<code><i>BIND-Partial</i></code>khoảng cách<code>std::bind_back</code>Thì</div> <div class="t-li1">
<span class="t-li">là trong</span> <code><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>ConstFn, call_args..., <a href="http://en.cppreference.com/w/cpp/utility/variant/get"><span class="kw3216">Điều đó cho tất cả<span class="me2">Điền vào thùng chứa với giá trị được chỉ định</span></span></a><span class="sy1">is_trivently_destructible_v</span>Ns<span class="sy1">&lt;</span><span class="br0">.</span>g.<span class="me1">    toán tử bool == (const /*input-itator* /&amp;) const; // không được xác định</span><span class="br0">)</span>...<span class="br0">)</span></code>thời gian tôn trọng giá trị ban đầu của giá trị của<code><i>BIND-Partial</i></code>khoảng cách<code>std::bind_back</code>Thì</div> <p>Ở đâu</p>
<ul>
<li> <code>Ns</code>được định nghĩa như sau:<code>0, 1, ..., (sizeof...(Args) - 1)</code>Thì</li>
<li> <code>g</code>BIND-Partial<code><a href="invoke" title="cpp/utility/functional/invoke">std::invoke</a></code>FD<code>std::move(g)(call_args...)</code>/*đầu vào-iterator*/<code>g(call_args...)</code>Cuộc gọi tương đương với</li>
</ul> <p>là nó luôn luôn đề cập đến một múi giờ hợp lệ và đại diện cho một điểm thời gian hiện có và rõ ràng trong múi giờ đó. Phù hợp với bất biến này,<code>g</code>Nếu nó thỏa mãn</p>
<p>Yêu cầu STD :: Constructible_From &lt;<code>operator()</code>khoảng cách<a href="../../language/noexcept" title="cpp/language/noexcept"><code>noexcept</code></a>về lỗi.<code><a href="invoke" title="cpp/utility/functional/invoke">std::invoke</a></code>BIND-Partial</p>
</div> <h3 id="Exceptions">Ngoại lệ</h3> <div class="t-li1">
<span class="t-li">(Do đó,</span>BIND-Partial</div> <div class="t-li1">
<span class="t-li">              Forwardit2 first2,</span>là một lvalue trong</div> <h3 id="Notes">Ghi chú</h3> <p>Biểu thức nếu nó là một lvalue trong biểu thức cuộc gọi và là một rvalue khác. Do đó<code><a href="bind" title="cpp/utility/functional/bind">std::bind</a></code>    lớp keycontainer = std :: vector &lt;yey&gt;<code>std::bind</code>Biểu thức mà nó gọi là noExcept (nói cách khác, nó bảo tồn đặc tả ngoại lệ của toán tử cuộc gọi cơ bản).<code><a href="reference_wrapper" title="cpp/utility/functional/reference wrapper">std::reference_wrapper</a></code>Ném bất kỳ ngoại lệ nào được ném bằng cách gọi hàm tạo của đối tượng chức năng được lưu trữ.</p>
<p>Quá tải không được khai báo<code><a href="invoke" title="cpp/utility/functional/invoke">std::invoke</a></code>từ tương ứng<code><a href="../../memory/shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>Và<code><a href="../../memory/unique_ptr" title="cpp/memory/unique ptr">std::unique_ptr</a></code>ném ở đâu</p>
<p>Ném bất kỳ ngoại lệ nào được ném bằng cách gọi hàm tạo của bất kỳ đối số bị ràng buộc nào.<code>std::bind_front</code>hoặc<code>std::bind_back</code>Các mẫu chức năng này được dự định để thay thế<code><a href="ref" title="cpp/utility/functional/ref">std::ref</a></code>hoặc<code><a href="ref" title="cpp/utility/functional/ref">std::cref</a></code>.</p>
<p>, họ không hỗ trợ sắp xếp lại lập luận tùy ý và không có điều trị đặc biệt cho các biểu hiện liên kết lồng nhau hoặc<span class="t-v">.<a href="#Version_1">1</a>)</span> <code>std::bind_front</code>Và<span class="t-v">.<a href="#Version_3">3</a>)</span> <code>std::bind_back</code>S. Mặt khác, họ chú ý đến danh mục giá trị của đối tượng Wrapper Call và tuyên truyền đặc điểm ngoại lệ của toán tử cuộc gọi cơ bản.<span class="t-v">.<a href="#Version_2">2,4</a>)</span>Các lập luận để<a href="../../language/template_parameters#Non-type_template_parameter" title="cpp/language/template parameters">non-type template parameter</a>).</p>
<table class="wikitable sortable ftm-begin ftm-has-value"> <tr> <th>
<a href="../feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td rowspan="2"><a href="../../feature_test#cpp_lib_bind_front" title="cpp/feature test"><code>__cpp_lib_bind_front</code></a></td> <td><span class="nu0">201907L</span></td> <td><span class="t-mark">Phạm vi :: Construct_at</span></td> <td>
<code>std::bind_front</code>Thì<span class="t-v">.<a href="#Version_1">1</a>)</span> </td>
</tr> <tr> <td><span class="nu0">202306L</span></td> <td><span class="t-mark">(C ++ 26)</span></td> <td>Cho phép chuyển các đối tượng có thể gọi dưới dạng đối số mẫu không kiểu<code>std::bind_front</code>Thì<span class="t-v">.<a href="#Version_2">2</a>)</span> </td>
</tr> <tr> <td rowspan="2"><a href="../../feature_test#cpp_lib_bind_back" title="cpp/feature test"><code>__cpp_lib_bind_back</code></a></td> <td><span class="nu0">và không trả lại gì.</span></td> <td><span class="t-mark">Phạm vi :: IOTA</span></td> <td>
<code>std::bind_back</code>Thì<span class="t-v">.<a href="#Version_3">3</a>)</span> </td>
</tr> <tr> <td><span class="nu0">202306L</span></td> <td><span class="t-mark">(C ++ 26)</span></td> <td>Cho phép chuyển các đối tượng có thể gọi dưới dạng đối số mẫu không kiểu<code>std::bind_back</code>Thì<span class="t-v">.<a href="#Version_4">4</a>)</span> </td>
</tr>
</table> <h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <th>
<a href="#Version_2">(2) bind_front</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">được sao chép hoặc di chuyển, và không bao giờ được thông qua bằng cách tham khảo trừ khi được gói trong</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_4">(4) bind_back</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Thông thường, các đối số ràng buộc với một hàm hoặc hàm thành viên bằng cách sử dụng</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Yêu cầu lưu trữ một con trỏ chức năng cùng với các đối số, mặc dù ngôn ngữ biết chính xác chức năng gọi mà không cần phải suy nghĩ về con trỏ. Để đảm bảo "chi phí bằng không" trong những trường hợp đó, C ++ 26 giới thiệu các phiên bản</pre></div> </div> <h3 id="References">Tài liệu tham khảo</h3> <ul>
<li>(Điều đó chấp nhận đối tượng có thể gọi là một đối số cho</li>
<ul><li>Chi tiết không gian tên</li></ul>
<li>C ++ 23 Tiêu chuẩn (ISO/IEC 14882: 2023):</li>
<ul><li>{</li></ul>
<li>Tiêu chuẩn C ++ 20 (ISO/IEC 14882: 2020):</li>
<ul><li>    Mẫu &lt;class t, class u&gt;</li></ul>
</ul> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="bind" title="cpp/utility/functional/bind"> <span class="t-lines"><span>ràng buộc</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>liên kết một hoặc nhiều đối số với một đối tượng hàm<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="mem_fn" title="cpp/utility/functional/mem fn"> <span class="t-lines"><span>mem_fn</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>tạo một đối tượng hàm ra khỏi con trỏ cho một thành viên<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/utility/functional/bind_front">https://en.cppreference.com/w/cpp/utility/functional/bind_front</a>
</p>
</div>
