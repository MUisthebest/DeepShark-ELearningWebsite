 <h1 class="firstHeading" id="firstHeading">Hướng dẫn khấu trừ cho<code>std::function_ref</code>
</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../../header/functional" title="cpp/header/functional">&lt;functional&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx26"> <td> <pre data-language="cpp">Mẫu &lt;Class F&gt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx26">(kể từ C ++ 26)</span> </td> </tr> <tr class="t-dcl t-since-cxx26"> <td> <pre data-language="cpp">function_ref (f*) -&gt; function_ref &lt;f&gt;;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx26">(kể từ C ++ 26)</span> </td> </tr> <tr class="t-dcl t-since-cxx26"> <td> <pre data-language="cpp">Mẫu &lt;Auto F&gt;</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx26">(kể từ C ++ 26)</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>                const std :: chrono :: sys_time &lt;thời gian&gt; &amp; tp);<code><a href="http://en.cppreference.com/w/cpp/types/is_function"><span class="kw486">Điều đó cho tất cả<span class="me2">Mẫu &lt;Auto F, Class T&gt;</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span></code>khoảng cách<code>true</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>chứa hai loại<code>F</code>{<code><a href="http://en.cppreference.com/w/cpp/types/remove_pointer"><span class="kw616">Điều đó cho tất cả<span class="me2">là nhiều nhất là một chuyển đổi đủ điều kiện.</span></span></a><span class="sy1">is_trivently_destructible_v</span>decltype<span class="br0">.</span>f<span class="br0">)</span><span class="sy1">&lt;</span></code>Thực hiện các hoạt động số học cơ bản giữa hai thời lượng hoặc giữa thời lượng và số lượng đánh dấu.<code><a href="http://en.cppreference.com/w/cpp/types/is_function"><span class="kw486">Điều đó cho tất cả<span class="me2">Mẫu &lt;Auto F, Class T&gt;</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span></code>khoảng cách<code>true</code>loại của ai là hình thức<code>std::function_ref&lt;F&gt;</code>.</div> <span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>chứa hai loại<code>F</code>{<code>decltype(f)</code>function_ref (std :: nontype_t &lt;f&gt;, t &amp;&amp;) -&gt; function_ref &lt;/*Xem bên dưới*/&gt;;<ul>
<li> <code>F</code>Mẫu &lt;Class F&gt;<code>R(G::*)(A...) noexcept(E)</code>is_function_v<code>G</code>, hoặc</li>
<li> <code>F</code>Mẫu &lt;Class F&gt;<code>M G::*</code>, trong trường hợp đó cho phép<code>G</code>. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu:<code>M</code>.<code>R</code>{<code><a href="http://en.cppreference.com/w/cpp/types/result_of"><span class="kw3219">Điều đó cho tất cả<span class="me2">  STD :: gertable_from &lt;u &amp;,</span></span></a><span class="sy1">is_trivently_destructible_v</span>F, T<span class="sy3">Không có giá trị</span><span class="sy1">&lt;</span></code>Thì<code>A...</code>cho một loại<code>E</code>và một loại đối tượng</li>
<li> <code>F</code>Mẫu &lt;Class F&gt;<code>R(*)(G, A...) noexcept(E)</code>, trong trường hợp đó cho phép<code>G</code>.</li>
</ul>là một gói trống, và<code>std::function_ref&lt;R(A...) noexcept(E)&gt;</code>.<h3 id="Example">Ví dụ</h3> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/utility/functional/function_ref/deduction_guides">https://en.cppreference.com/w/cpp/utility/functional/function_ref/deduction_guides</a>
</p>
</div>
