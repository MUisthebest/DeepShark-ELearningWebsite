 <h1 class="firstHeading" id="firstHeading">toán tử ==, toán tử &lt;=&gt;<small>Thuật toán</small>
</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">Mẫu &lt;Class AlleCator2&gt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">Người bạn của Bool Toán tử == (Const BASIC_STACKTRACE &amp; LHS,</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Mẫu &lt;class T, std :: size_t n&gt;<code>lhs</code>Và<code>rhs</code>Toán tử bool &lt;(const std :: mảng &lt;t, n&gt; &amp; lhs,<code>lhs</code>                const std :: mảng &lt;t, n&gt; &amp; rhs);<code>rhs</code>Mẫu &lt;class T, std :: size_t n&gt;</div> <div class="t-li1">Mẫu &lt;class inputit1, class inputit2,<code><span class="kw1">Không chính thức,</span> <a href="http://en.cppreference.com/w/cpp/algorithm/equal"><span class="kw1577">Điều đó cho tất cả<span class="me2">(Niebloid)</span></span></a><span class="br0">.</span>lhs.<span class="me1">bắt đầu</span><span class="br0">.</span><span class="br0">)</span>, lhs.<span class="me1">kết thúc</span><span class="br0">.</span><span class="br0">)</span>, rhs.<span class="me1">bắt đầu</span><span class="br0">.</span><span class="br0">)</span>, rhs.<span class="me1">kết thúc</span><span class="br0">.</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>.</div> <div class="t-li1">
<span class="t-li">2)</span>                        const basic_stacktrace &lt;allocator2&gt; &amp; rhs) noExcept;<code>lhs</code>Và<code>rhs</code>Mẫu &lt;Class AlleCator2&gt;<code>lhs</code>Và<code>rhs</code>bạn bè std :: strong_ordering<code>lhs</code>Và<code>rhs</code>.</div> <div class="t-li1">Mẫu &lt;class inputit1, class inputit2,<br/><code><span class="kw1">nếu như</span> <span class="br0">.</span><span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span> cmp <span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> lhs.<span class="me1">kích cỡ</span><span class="br0">.</span><span class="br0">)</span> <span class="sy1">&lt;=&gt;</span> rhs.<span class="me1">kích cỡ</span><span class="br0">.</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span> cmp <span class="sy3">Nếu tồn tại một</span><span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <span class="nu0">. Không làm gì khác.</span><span class="br0">)</span><br/> <p><span class="kw1">Không chính thức,</span>T min (std :: initizer_list &lt;t&gt; ilist, so sánh comp);<span class="sy4">Số lượng các yếu tố để sao chép</span><br/> <span class="kw1">&gt; =</span><br/> <span class="kw1">Không chính thức,</span> <a href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare_three_way"><span class="kw3240">Điều đó cho tất cả<span class="me2">(Niebloid)</span></span></a><span class="br0">.</span>    toán tử &lt;=&gt; (const basic_stacktrace &amp; lhs,<span class="me1">bắt đầu</span><span class="br0">.</span><span class="br0">)</span>                 const basic_stacktrace &lt;allocator2&gt; &amp; rhs) noExcept;<span class="me1">kết thúc</span><span class="br0">.</span><span class="br0">)</span>Thì<br/>Trả về thứ tự tương đối của số lượng các mục nhập StackTrace trong</p>
<span class="me1">bắt đầu</span><span class="br0">.</span><span class="br0">)</span>, rhs.<span class="me1">kết thúc</span><span class="br0">.</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>.</div> <p>(tức là cả hai<a href="../../language/unqualified_lookup" title="cpp/language/unqualified lookup">unqualified</a>hoặc<a href="../../language/qualified_lookup" title="cpp/language/qualified lookup">qualified lookup</a>Chức năng này không thể nhìn thấy thông thường<a href="../../language/adl" title="cpp/language/adl">argument-dependent lookup</a>Chuyển đổi danh tính:<code>std::basic_stacktrace&lt;Allocator&gt;</code>Hương hiệu nút</p>
<p>Các<code>&lt;</code>Thì<code>&lt;=</code>Thì<code>&gt;</code>Thì<code>&gt;=</code>, Và<code>!=</code>Người vận hành là<a href="../../language/operators#Comparison_operators" title="cpp/language/operators">synthesized</a>từ nhà điều hành<span class="sy1">&lt;=&gt;</span>và vận hành<span class="sy1">==</span>tương ứng.</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>E lvalues</td> <td>-</td> <td> <code>basic_stacktrace</code>như toán hạng tay trái và toán hạng tay phải tương ứng (trong đó</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">1)</span> <code>true</code>Nếu họ không bằng nhau. Nếu không (nếu số lượng các yếu tố của<code>lhs</code>Và<code>rhs</code>phạm vi có giá trị để so sánh<code>false</code>Nếu đối số đầu tiên là</div> <div class="t-li1">
<span class="t-li">2)</span> <code>lhs.size() &lt;=&gt; rhs.size()</code>bằng nhau), trả về thứ tự từ vựng của các yếu tố<code>std::strong_order::equal</code>LHS.<code>lhs</code>Và<code>rhs</code>Nếu đối số đầu tiên là</div> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <div class="t-li1">
<span class="t-li">Đầu vào</span>Toán tử bool &lt;(const std :: deque &lt;t, alloc&gt; &amp; lhs,<code>lhs</code>Và<code>rhs</code>, LHS.<code>lhs</code>Nếu đối số đầu tiên là</div> <h3 id="Example">Ví dụ</h3> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/utility/basic_stacktrace/operator_cmp">https://en.cppreference.com/w/cpp/utility/basic_stacktrace/operator_cmp</a>
</p>
</div>
