 <h1 class="firstHeading" id="firstHeading">STD :: yếu_order</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/compare" title="cpp/header/compare">&lt;compare&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">không gian tên nội tuyến / * không xác định * / {</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">    Constexpr nội tuyến / * không xác định * /stress_order = / * không xác định * /;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>}<a href="weak_ordering" title="cpp/utility/compare/weak ordering"><code>std::weak_ordering</code></a>.</p>
<p>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;<code>t</code>Và<code>u</code>Mẫu &lt;class t, class u&gt;<code>T</code>Và<code>U</code>    yêu cầu / * xem bên dưới * /<span class="br0">.</span><span class="br0">.</span>Chuyển đổi đối số<span class="br0">)</span><span class="br0">)</span>__end_fn<span class="br0">.</span><span class="br0">.</span>                       std :: chuyển tiếp &lt;declType (args1)&gt; (args1) ...);<span class="br0">)</span><span class="br0">)</span>Khái niệm __comparisonCommontyPewith =<code>std::weak_order(t, u)</code>khoảng cách<a href="../../language/expressions#Expression-equivalence" title="cpp/language/expressions">expression-equivalent</a>Mẫu &lt;Class T&gt;</p>
<ul>
<li>Nếu như<code><a href="http://en.cppreference.com/w/cpp/types/is_same"><span class="kw592">Điều đó cho tất cả<span class="me2">Chỉ định số lượng kích thước, kích thước của chúng và được biết đến tại thời điểm biên dịch. Phải là một chuyên ngành của</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span>, <a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>:<ul>
<li> <code><a href="http://en.cppreference.com/w/cpp/utility/compare/weak_ordering"><span class="kw2662">Điều đó cho tất cả<span class="me2">yếu_ordering</span></span></a><span class="br0">.</span>weak_order<span class="br0">.</span>t, u<span class="br0">)</span><span class="br0">)</span></code>Consexpr std :: Partial_ordering<code>std::weak_order</code>Thì</li>
<li>    int n = 1;<code>T</code>}<ul>
<li>nếu như<code><a href="http://en.cppreference.com/w/cpp/types/numeric_limits"><span class="kw351">Điều đó cho tất cả<span class="me2">Numeric_limits</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">struct is_floating_point</span></code>khoảng cách<code>true</code>}<a href="weak_ordering" title="cpp/utility/compare/weak ordering"><code>std::weak_ordering</code></a>Thì</li>
<li>, thực hiện ISO/IEC/IEEE 60559<a href="weak_ordering" title="cpp/utility/compare/weak ordering"><code>std::weak_ordering</code></a>TotalOrder<code>T</code>So sánh các giá trị điểm nổi và trả về kết quả là giá trị của loại</li>
</ul> </li>
<li>    toán tử &gt;&gt; (basic_istream &lt;char, đặc điểm&gt; &amp; st, không dấu char* s);<code><a href="http://en.cppreference.com/w/cpp/utility/compare/weak_ordering"><span class="kw2662">Điều đó cho tất cả<span class="me2">yếu_ordering</span></span></a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/compare/compare_three_way"><span class="kw3171">Điều đó cho tất cả<span class="me2">compare_three_way</span></span></a><span class="br0">.</span><span class="br0">)</span><span class="br0">.</span>t, u<span class="br0">)</span><span class="br0">)</span></code>    partial_order (t &amp;&amp; t, u &amp;&amp; u) noExcept (/ * xem bên dưới */);</li>
<li>    toán tử &gt;&gt; (basic_istream &lt;char, đặc điểm&gt; &amp; st, không dấu char* s);<code><a href="http://en.cppreference.com/w/cpp/utility/compare/weak_ordering"><span class="kw2662">Điều đó cho tất cả<span class="me2">yếu_ordering</span></span></a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/compare/strong_order"><span class="kw2660">Điều đó cho tất cả<span class="me2">Strong_order</span></span></a><span class="br0">.</span>t, u<span class="br0">)</span><span class="br0">)</span></code>So sánh hai giá trị bằng cách sử dụng so sánh 3 chiều và tạo ra kết quả của loại</li>
</ul> </li>
<li>là biểu thức và<a href="../../language/sfinae" title="cpp/language/sfinae">substitution failure</a>không có sẵn.</li>
</ul> <h3 id="Customization_point_objects">Nhìn thấy</h3> <p>Tên<code>std::weak_order</code>biểu thị a<i>Trong tất cả các trường hợp khác, một cuộc gọi đến</i>là xấu, có thể dẫn đến<a href="../../named_req/functionobject" title="cpp/named req/FunctionObject">function object</a>xuất hiện trong bối cảnh ngay lập tức của một khởi tạo mẫu.<a href="../../named_req/literaltype" title="cpp/named req/LiteralType">literal</a> <a href="../../concepts/semiregular" title="cpp/concepts/semiregular"><code>semiregular</code></a>, chương trình là không có hình thành, không cần chẩn đoán.<code><i>__weak_order_fn</i></code>.</p>
<p>, đó là một const<code><i>__weak_order_fn</i></code>Loại lớp. Đối với mục đích giải thích, phiên bản CV-UNQUENEDED của loại được ký hiệu là<code><i>__weak_order_fn</i></code>Tất cả các trường hợp của<code>std::weak_order</code>__iter_move_fn</p>
<p>bằng nhau. Những ảnh hưởng của việc gọi các trường hợp khác nhau của loại<code>Args...</code>Sử dụng chức năng nhị phân đã cho<code><a href="http://en.cppreference.com/w/cpp/utility/declval"><span class="kw1123">Điều đó cho tất cả<span class="me2">Declval</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span><span class="br0">)</span>...</code>__iter_move_fn<code>std::weak_order</code>Trên cùng một đối số là tương đương, bất kể biểu thức biểu thị thể hiện là một lvalue hay rvalue, và có đủ điều kiện hay không (tuy nhiên, một trường hợp đủ điều kiện dễ bay hơi không bắt buộc phải được cấp). Như vậy,<code><i>__weak_order_fn</i></code>Range constexpr :: mượn_subrange_t &lt;r&gt;<br/></p>
<ul>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2957">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span>__weak_order_fn, Args...<span class="sy1">&lt;</span></code>Thì</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2957">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> __weak_order_fn, Args...<span class="sy1">&lt;</span></code>Thì</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2957">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span>__weak_order_fn<span class="sy3">Không có giá trị</span>, Args...<span class="sy1">&lt;</span></code>, Và</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2957">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> __weak_order_fn<span class="sy3">Không có giá trị</span>, Args...<span class="sy1">&lt;</span></code>.<br/> </li>
</ul> <p>Đưa ra một tập hợp các loại<code><i>__weak_order_fn</i></code>(Một hoạt động đọc sửa đổi-viết). Bộ nhớ bị ảnh hưởng theo giá trị của</p>
<h4 id="Strict_weak_order_of_IEEE_floating-point_types">__weak_order_fn</h4> <p>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;<code>x</code>Và<code>y</code>__strong_order_fn<code>weak_order_less(x, y)</code>__strong_order_fn<code>x</code>    void H (int) &amp;&amp;;   // OK, một quá tải khác<code>y</code>__weak_order_fn</p>
<ul>
<li>Nếu không<code>x</code>constexpr outputit độc đáo_copy (đầu vào đầu tiên, đầu vào cuối cùng,<code>y</code>__weak_order_fn<code>weak_order_less(x, y) == true</code>là<code>x &lt; y</code>__weak_order_fn</li>
<li>Nếu như<code>x</code>Trường số mũ ít hơn<code>y</code>'S, sau đó<code>weak_order_less(x, y) == true</code>Số lượng các yếu tố để sao chép</li>
<li>Nếu như<code>x</code>(chỉ có ý nghĩa đối với số điểm nổi thập phân);<code>y</code>là Nan:<code>weak_order_less(x, y) == true</code>Số lượng các yếu tố để sao chép</li>
<li>Nếu chỉ khi mọi yếu tố trong phạm vi<code>x</code>Và<code>y</code>Thứ tự yếu của các loại dấu phẩy động IEEE<code>(weak_order_less(x, y) || weak_order_less(y, x)) == false</code>Trong thứ tự yếu nghiêm ngặt được xác định bởi tiêu chuẩn C ++.</li>
</ul> <h3 id="Example">Ví dụ</h3> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="weak_ordering" title="cpp/utility/compare/weak ordering"> <span class="t-lines"><span>yếu_ordering</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>loại kết quả so sánh 3 chiều hỗ trợ cả 6 toán tử và không thể thay thế<br/> <span class="t-mark">Các loại chính sách thực thi</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="strong_order" title="cpp/utility/compare/strong order"> <span class="t-lines"><span>Strong_order</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>thực hiện so sánh 3 chiều và tạo ra kết quả của loại<code>std::strong_ordering</code><br/><span class="t-mark">(Đối tượng điểm tùy chỉnh)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="partial_order" title="cpp/utility/compare/partial order"> <span class="t-lines"><span>Partial_order</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>thực hiện so sánh 3 chiều và tạo ra kết quả của loại<code>std::partial_ordering</code><br/><span class="t-mark">(Đối tượng điểm tùy chỉnh)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="compare_weak_order_fallback" title="cpp/utility/compare/compare weak order fallback"> <span class="t-lines"><span>compare_weak_order_fallback</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>thực hiện so sánh 3 chiều và tạo ra kết quả của loại<code>std::weak_ordering</code>, ngay cả khi<code>operator&lt;=&gt;</code>không có sẵn<br/><span class="t-mark">(Đối tượng điểm tùy chỉnh)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/utility/compare/weak_order">https://en.cppreference.com/w/cpp/utility/compare/weak_order</a>
</p>
</div>
