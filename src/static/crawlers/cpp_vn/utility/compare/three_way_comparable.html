 <h1 class="firstHeading" id="firstHeading">std :: ba_way_comparable, std :: ba_way_comparable_with</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/compare" title="cpp/header/compare">&lt;compare&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;class T, class cat = std :: partial_ordering&gt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">khái niệm ba_way_comparable =</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">    A</pre>
</td> <td>(3)</td> <td> <span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Khái niệm gán được_from =<code>std::three_way_comparable</code>             const std :: remove_reference_t &lt;t&gt; &amp; b) {<code>&lt;=&gt;</code>    __ComparisonCommOnTyPewith &lt;t, u&gt; &amp;&amp;<code>T</code>    Yêu cầu (const std :: remove_reference_t &lt;t&gt; &amp; a,<code>Cat</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>Khái niệm gán được_from =<code>std::three_way_comparable_with</code>             const std :: remove_reference_t &lt;t&gt; &amp; b) {<code>&lt;=&gt;</code>    __WeaklyequalityComparedablewith &lt;t, u&gt;;<code>T</code>Và<code>U</code>        {A &lt;=&gt; B} -&gt; __Comparesas &lt;tat&gt;;<code>Cat</code>    };</div> <p><a href="../../concepts/equality_comparable" title="cpp/concepts/equality comparable"><code>__WeaklyEqualityComparableWith</code></a>Thì<a href="../../concepts/totally_ordered" title="cpp/concepts/totally ordered"><code>__PartiallyOrderedWith</code></a>, Và<a href="../../concepts/equality_comparable" title="cpp/concepts/equality comparable"><code>__ComparisonCommonTypeWith</code></a>Mẫu &lt;class T, class u, class cat = std :: partial_ordering&gt;<a href="../../concepts/equality_comparable" title="cpp/concepts/equality comparable"><code>equality_comparable</code></a>Và<a href="../../concepts/totally_ordered" title="cpp/concepts/totally ordered"><code>totally_ordered</code></a>.</p>
<h3 id="Semantic_requirements">        const std :: remove_reference_t &lt;lhs&gt; &amp;,</h3> <p>Khái niệm __comparisonCommontyPewith =</p>
<span class="t-li">1)</span> <code>T</code>Và<code>Cat</code>    std :: Inone<code>std::three_way_comparable&lt;T, Cat&gt;</code>khái niệm ba_way_comparable_with =<code>a</code>Và<code>b</code>nó đến một đối tượng<code><span class="kw4">hằng số</span> <a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>    std :: ba_way_comparable &lt;t, cat&gt; &amp;&amp;<ul>
<li> <code>(a &lt;=&gt; b == 0) == bool(a == b)</code>Thì</li>
<li> <code>(a &lt;=&gt; b != 0) == bool(a != b)</code>Thì</li>
<li> <code>((a &lt;=&gt; b) &lt;=&gt; 0)</code>Và<code>(0 &lt;=&gt; (b &lt;=&gt; a))</code>phạm vi có giá trị để so sánh</li>
<li> <code>bool(a &gt; b) == bool(b &lt; a)</code>Thì</li>
<li> <code>bool(a &gt;= b) == !bool(a &lt; b)</code>Thì</li>
<li> <code>bool(a &lt;= b) == !bool(b &lt; a)</code>Thì</li>
<li> <code>(a &lt;=&gt; b &lt; 0) == bool(a &lt; b)</code>Thì</li>
<li> <code>(a &lt;=&gt; b &gt; 0) == bool(a &gt; b)</code>Thì</li>
<li> <code>(a &lt;=&gt; b &lt;= 0) == bool(a &lt;= b)</code>, Và</li>
<li> <code>(a &lt;=&gt; b &gt;= 0) == bool(a &gt;= b)</code>, Và</li>
<li>nếu như<code>Cat</code>Chuyển đổi hai thời lượng thành loại chung của chúng và tạo ra một thời lượng mà số lượng đánh dấu là tổng số lượng đánh dấu sau khi chuyển đổi.<code>std::strong_ordering</code>Thì<code>T</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<a href="../../concepts/totally_ordered" title="cpp/concepts/totally ordered"><code>totally_ordered</code></a>.</li>
</ul> <span class="t-li">2)</span> <code>T</code>Thì<code>U</code>, Và<code>Cat</code>    std :: Inone<code>std::three_way_comparable_with&lt;T, U, Cat&gt;</code>    std :: ba_way_comparable &lt;u, cat&gt; &amp;&amp;<ul>
<li> <code>t</code>Và<code>t2</code>Khái niệm __PartallyReeseredWith =<code><span class="kw4">hằng số</span> <a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>Và<code><a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>              STD :: Dự kiến ​​&lt;i2, proj2 &gt;&gt; comp = phạm vi :: Ít hơn&gt;</li>
<li> <code>u</code>Và<code>u2</code>Khái niệm __PartallyReeseredWith =<code><span class="kw4">hằng số</span> <a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">&lt;</span></code>Và<code><a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">&lt;</span></code>tương ứng.</li>
</ul> <p>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;<code>C</code>{<code><a href="http://en.cppreference.com/w/cpp/types/common_reference"><span class="kw2710">Điều đó cho tất cả<span class="me2">Common_Reference_T</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> <a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="sy3">Không có giá trị</span>, <span class="kw4">hằng số</span> <a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">&lt;</span><span class="sy3">Không có giá trị</span><span class="sy1">&lt;</span></code>    __ComparisonCommOnTyPewith &lt;t, u&gt; &amp;&amp;<code>E</code>        const std :: remove_reference_t &lt;t&gt; &amp;,<code>C</code>             const std :: remove_reference_t &lt;u&gt; &amp; u) {<code>CONVERT_TO&lt;C&gt;(E)</code>        {t &lt;u} -&gt; Boolean -Testable;</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx23">
<td> <ul><li> <code><span class="kw1">Mẫu &lt;Biểu đồ lớp, Đặc điểm lớp, Alloc Class, Class Parsable&gt;</span><span class="sy1">is_trivently_destructible_v</span>C<span class="sy1">&lt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/as_const"><span class="kw1124">Điều đó cho tất cả<span class="me2">as_const</span></span></a><span class="br0">.</span>E<span class="br0">)</span><span class="br0">)</span></code>.</li></ul> </td> <td><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></td>
</tr> <tr class="t-rev t-since-cxx23">
<td> <ul>
<li> <code><span class="kw1">Mẫu &lt;Biểu đồ lớp, Đặc điểm lớp, Alloc Class, Class Parsable&gt;</span><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> C<span class="sy3">Không có giá trị</span><span class="sy1">&lt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/as_const"><span class="kw1124">Điều đó cho tất cả<span class="me2">as_const</span></span></a><span class="br0">.</span>E<span class="br0">)</span><span class="br0">)</span></code>Mẫu &lt;Class T, Class U, Class C = std :: Common_Reference_T &lt;Const T &amp;, Const U &amp; &gt;&gt;</li>
<li> <code>static_cast&lt;const C&amp;&gt;(std::move(E))</code>Nếu đối số đầu tiên là</li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table> <p>Loại đối tượng trong đó một đối tượng thuộc loại đó có thể được xây dựng từ một lvalue hoặc const rvalue (có thể là const) của loại đó trong cả bối cảnh sáng tạo trực tiếp và sao chép với ngữ nghĩa thông thường (một bản sao được xây dựng với nguồn không thay đổi).</p>
<ul>
<li> <code>t &lt;=&gt; u</code>Và<code>u &lt;=&gt; t</code>        };</li>
<li> <code>((t &lt;=&gt; u) &lt;=&gt; 0)</code>Và<code>(0 &lt;=&gt; (u &lt;=&gt; t))</code>phạm vi có giá trị để so sánh</li>
<li> <code>(t &lt;=&gt; u == 0) == bool(t == u)</code>Thì</li>
<li> <code>(t &lt;=&gt; u != 0) == bool(t != u)</code>Thì</li>
<li> <code>Cat(t &lt;=&gt; u) == Cat(CONVERT_TO&lt;C&gt;(t2) &lt;=&gt; CONVERT_TO&lt;C&gt;(u2))</code>Thì</li>
<li> <code>(t &lt;=&gt; u &lt; 0) == bool(t &lt; u)</code>Thì</li>
<li> <code>(t &lt;=&gt; u &gt; 0) == bool(t &gt; u)</code>Thì</li>
<li> <code>(t &lt;=&gt; u &lt;= 0) == bool(t &lt;= u)</code>Thì</li>
<li> <code>(t &lt;=&gt; u &gt;= 0) == bool(t &gt;= u)</code>, Và</li>
<li>nếu như<code>Cat</code>Chuyển đổi hai thời lượng thành loại chung của chúng và tạo ra một thời lượng mà số lượng đánh dấu là tổng số lượng đánh dấu sau khi chuyển đổi.<code>std::strong_ordering</code>Thì<code>T</code>Và<code>U</code>    std :: Inone<code><a href="http://en.cppreference.com/w/cpp/concepts/totally_ordered"><span class="kw2953">Điều đó cho tất cả<span class="me2">ký tên_integral</span></span></a><span class="sy1">is_trivently_destructible_v</span>T, U<span class="sy1">&lt;</span></code>.</li>
</ul> <h3 id="Equality_preservation">Bảo tồn bình đẳng</h3> <p>chỉ được mô hình hóa nếu<a href="../../language/requires" title="cpp/language/requires">requires expressions</a>(tức là, biểu thức gán mang lại một lvalue đề cập đến toán hạng bên trái);<a href="../../concepts#Equality_preservation" title="cpp/concepts">equality-preserving</a>Sau khi đánh giá</p>
<h3 id="Implicit_expression_variations">Biểu hiện ẩn</h3> <p>MỘT<a href="../../language/requires" title="cpp/language/requires">requires expression</a>Chỉ định rằng một đối tượng thuộc loại<a href="../../concepts#Implicit_expression_variations" title="cpp/concepts">implicit expression variations</a>.</p>
<h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../../concepts/equality_comparable" title="cpp/concepts/equality comparable"> <span class="t-lines"><span>Common_with</span><span>Chỉ định rằng hai loại chia sẻ một loại chung</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(ý tưởng)<code>==</code>Tích hợp<br/> <span class="t-mark">(ý tưởng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../concepts/totally_ordered" title="cpp/concepts/totally ordered"> <span class="t-lines"><span>(ý tưởng)</span><span>ký tên_integral</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Chỉ định rằng một loại là một loại tích phân được ký kết<br/> <span class="t-mark">(ý tưởng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/utility/compare/three_way_comparable">https://en.cppreference.com/w/cpp/utility/compare/three_way_comparable</a>
</p>
</div>
