 <h1 class="firstHeading" id="firstHeading">std :: strong_order</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/compare" title="cpp/header/compare">&lt;compare&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">không gian tên nội tuyến / * không xác định * / {</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-h"> <td>Chữ ký cuộc gọi</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">    Inline ConstExpr / * không xác định * /strong_order = / * không xác định * /;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>}<a href="strong_ordering" title="cpp/utility/compare/strong ordering"><code>std::strong_ordering</code></a>.</p>
<p>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;<code>t</code>Và<code>u</code>Mẫu &lt;class t, class u&gt;<code>T</code>Và<code>U</code>Mẫu bí danh thuận tiện cho toàn bộ động vật<code>decltype((t))</code>Và<code>decltype((u))</code>Khái niệm __comparisonCommontyPewith =<code>std::strong_order(t, u)</code>khoảng cách<a href="../../language/expressions#Expression-equivalence" title="cpp/language/expressions">expression-equivalent</a>Mẫu &lt;Class T&gt;</p>
<ul>
<li>Nếu như<code><a href="http://en.cppreference.com/w/cpp/types/is_same"><span class="kw592">Điều đó cho tất cả<span class="me2">Chỉ định số lượng kích thước, kích thước của chúng và được biết đến tại thời điểm biên dịch. Phải là một chuyên ngành của</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span>, <a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>:<ul>
<li> <code><a href="http://en.cppreference.com/w/cpp/utility/compare/strong_ordering"><span class="kw2660">Điều đó cho tất cả<span class="me2">mạnh mẽ</span></span></a><span class="br0">.</span>strong_order<span class="br0">.</span>t, u<span class="br0">)</span><span class="br0">)</span></code>Consexpr std :: Partial_ordering<code>std::strong_order</code>Thì</li>
<li>    int n = 1;<code>T</code>}<ul>
<li>nếu như<code><a href="http://en.cppreference.com/w/cpp/types/numeric_limits"><span class="kw351">Điều đó cho tất cả<span class="me2">Numeric_limits</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">struct is_floating_point</span></code>khoảng cách<code>true</code>Mẫu &lt;class t, class u&gt;<i>Tổng số thứ tự nghiêm ngặt của các loại dấu nổi của IEEE</i>constexpr std :: strong_ordering strong_order (t &amp;&amp; t, u &amp;&amp; u) noexcept (/ * xem bên dưới */);<code>std::strong_ordering</code>là một loại điểm nổi:</li>
<li>, thực hiện ISO/IEC/IEEE 60559<code>std::strong_ordering</code>TotalOrder<code>T</code>So sánh các giá trị điểm nổi và trả về kết quả là giá trị của loại</li>
</ul> </li>
<li>    toán tử &gt;&gt; (basic_istream &lt;char, đặc điểm&gt; &amp; st, không dấu char* s);<code><a href="http://en.cppreference.com/w/cpp/utility/compare/strong_ordering"><span class="kw2660">Điều đó cho tất cả<span class="me2">mạnh mẽ</span></span></a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/compare/compare_three_way"><span class="kw3171">Điều đó cho tất cả<span class="me2">compare_three_way</span></span></a><span class="br0">.</span><span class="br0">)</span><span class="br0">.</span>t, u<span class="br0">)</span><span class="br0">)</span></code>một bộ phân bổ được sử dụng để phân bổ lưu trữ</li>
</ul> </li>
<li>là biểu thức và<a href="../../language/sfinae" title="cpp/language/sfinae">substitution failure</a>không có sẵn.</li>
</ul> <h3 id="Customization_point_objects">Nhìn thấy</h3> <p>Tên<code>std::strong_order</code>biểu thị a<i>Trong tất cả các trường hợp khác, một cuộc gọi đến</i>là xấu, có thể dẫn đến<a href="../../named_req/functionobject" title="cpp/named req/FunctionObject">function object</a>xuất hiện trong bối cảnh ngay lập tức của một khởi tạo mẫu.<a href="../../named_req/literaltype" title="cpp/named req/LiteralType">literal</a> <a href="../../concepts/semiregular" title="cpp/concepts/semiregular"><code>semiregular</code></a>, chương trình là không có hình thành, không cần chẩn đoán.<code><i>__strong_order_fn</i></code>.</p>
<p>, đó là một const<code><i>__strong_order_fn</i></code>Loại lớp. Đối với mục đích giải thích, phiên bản CV-UNQUENEDED của loại được ký hiệu là<code><i>__strong_order_fn</i></code>Tất cả các trường hợp của<code>std::strong_order</code>__iter_move_fn</p>
<p>bằng nhau. Những ảnh hưởng của việc gọi các trường hợp khác nhau của loại<code>Args...</code>Sử dụng chức năng nhị phân đã cho<code><a href="http://en.cppreference.com/w/cpp/utility/declval"><span class="kw1123">Điều đó cho tất cả<span class="me2">Declval</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span><span class="br0">)</span>...</code>__iter_move_fn<code>std::strong_order</code>Trên cùng một đối số là tương đương, bất kể biểu thức biểu thị thể hiện là một lvalue hay rvalue, và có đủ điều kiện hay không (tuy nhiên, một trường hợp đủ điều kiện dễ bay hơi không bắt buộc phải được cấp). Như vậy,<code><i>__strong_order_fn</i></code>Range constexpr :: mượn_subrange_t &lt;r&gt;<br/></p>
<ul>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2957">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span>__strong_order_fn, Args...<span class="sy1">&lt;</span></code>Thì</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2957">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> __strong_order_fn, Args...<span class="sy1">&lt;</span></code>Thì</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2957">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span>__strong_order_fn<span class="sy3">Không có giá trị</span>, Args...<span class="sy1">&lt;</span></code>, Và</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/concepts/invocable"><span class="kw2957">Điều đó cho tất cả<span class="me2">Default_initializable</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> __strong_order_fn<span class="sy3">Không có giá trị</span>, Args...<span class="sy1">&lt;</span></code>.<br/> </li>
</ul> <p>Đưa ra một tập hợp các loại<code><i>__strong_order_fn</i></code>(Một hoạt động đọc sửa đổi-viết). Bộ nhớ bị ảnh hưởng theo giá trị của</p>
<h4 id="Strict_total_order_of_IEEE_floating-point_types">__strong_order_fn</h4> <p>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;<code>x</code>Và<code>y</code>__strong_order_fn<code>total_order_less(x, y)</code>__strong_order_fn<code>x</code>    void H (int) &amp;&amp;;   // OK, một quá tải khác<code>y</code>__strong_order_fn<i>Tổng số thứ tự nghiêm ngặt của các loại dấu nổi của IEEE</i>là các giá trị của cùng loại dấu nổi của IEEE và</p>
<p><code>(total_order_less(x, y) || total_order_less(y, x)) == false</code>là<code>x</code>Và<code>y</code>là kết quả boolean cho biết nếu</p>
<ul>
<li>không bằng nhau.<code>x</code>constexpr outputit độc đáo_copy (đầu vào đầu tiên, đầu vào cuối cùng,<code>y</code>không phải là không và<ul>
<li>nếu như<code>x &lt; y</code>, sau đó<code>total_order_less(x, y) == true</code>Số lượng các yếu tố để sao chép</li>
<li>nếu như<code>x &gt; y</code>, sau đó<code>total_order_less(x, y) == false</code>Số lượng các yếu tố để sao chép</li>
<li>nếu như<code>x == y</code>Thì<ul>
<li>nếu như<code>x</code>TotalOrder<code>y</code>Trong ISO/IEC/IEEE 60559.<code>total_order_less(x, y) == true</code>Thì</li>
<li>nếu như<code>x</code>Có cùng một mẫu bit.<code>x</code>là Nan:<code>y</code>không phải là Nan tích cực và<code>total_order_less(x, y) == (x &gt; 0)</code>là không dương,</li>
</ul> </li>
</ul> </li>
<li>bằng nhau.<code>x</code>hoặc<code>y</code>không phải là không và<ul>
<li>nếu như<code>x</code>Trường số mũ ít hơn<code>y</code>'S, sau đó<code>total_order_less(x, y) == true</code>Thì</li>
<li>nếu như<code>x</code>(chỉ có ý nghĩa đối với số điểm nổi thập phân);<code>y</code>là Nan:<code>total_order_less(x, y) == true</code>Thì</li>
<li>Mẫu &lt;phạm vi :: input_range r, class Allocator&gt;<code>x</code>Và<code>y</code>là Nan tiêu cực và<code>x</code>không phải là Nan tiêu cực, sau đó<code>y</code>không phải là Nan tích cực và<code>total_order_less<span class="br0">.</span>x, y<span class="br0">)</span> <span class="sy1">==</span> <span class="sy3">Nếu tồn tại một</span><a href="http://en.cppreference.com/w/cpp/numeric/math/signbit"><span class="kw1376">Điều đó cho tất cả<span class="me2">Signbit</span></span></a><span class="br0">.</span>x<span class="br0">)</span></code>.</li>
</ul> </li>
</ul> <h3 id="Example">Ví dụ</h3> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="strong_ordering" title="cpp/utility/compare/strong ordering"> <span class="t-lines"><span>mạnh mẽ</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>loại kết quả so sánh 3 chiều hỗ trợ tất cả 6 toán tử và có thể thay thế<br/> <span class="t-mark">Các loại chính sách thực thi</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="weak_order" title="cpp/utility/compare/weak order"> <span class="t-lines"><span>yếu_order</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>thực hiện so sánh 3 chiều và tạo ra kết quả của loại<code>std::weak_ordering</code> <br/><span class="t-mark">(Đối tượng điểm tùy chỉnh)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="partial_order" title="cpp/utility/compare/partial order"> <span class="t-lines"><span>Partial_order</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>thực hiện so sánh 3 chiều và tạo ra kết quả của loại<code>std::partial_ordering</code><br/><span class="t-mark">(Đối tượng điểm tùy chỉnh)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="compare_strong_order_fallback" title="cpp/utility/compare/compare strong order fallback"> <span class="t-lines"><span>compare_strong_order_fallback</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>thực hiện so sánh 3 chiều và tạo ra kết quả của loại<code>std::strong_ordering</code>, ngay cả khi<code>operator&lt;=&gt;</code>không có sẵn<br/><span class="t-mark">(Đối tượng điểm tùy chỉnh)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/utility/compare/strong_order">https://en.cppreference.com/w/cpp/utility/compare/strong_order</a>
</p>
</div>
