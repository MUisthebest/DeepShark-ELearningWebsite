 <h1 class="firstHeading" id="firstHeading">STD :: char_traits &lt;par&gt; :: eq/lt, std :: char_traits &lt;wchar_t&gt; :: eq/lt, std :: char_traits &lt;char8_t&gt; :: eq/lt, std :: char_traits</h1> <table class="t-dcl-begin"> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx11"> <td> <pre data-language="cpp">Bool tĩnh EQ (char_type A, char_type b);</pre>
</td> <td> <span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">ConcTexpr static bool eq (char_type A, char_type b) noexcept;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(2)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx11"> <td> <pre data-language="cpp">bool lt (char_type A, char_type b);</pre>
</td> <td> <span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Constic static bool lt (char_type A, char_type b) noexcept;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> </table> <p>So sánh hai ký tự.</p>
<span class="t-li">1)</span>void Atomic_flag_wait_explicit (đối tượng Atomic_flag* dễ bay hơi<code>a</code>Và<code>b</code>cho sự bình đẳng, hành xử giống hệt<ul>
<li> <code>static_cast&lt;unsigned char&gt;(a) == static_cast&lt;unsigned char&gt;(b)</code>Sử dụng chức năng nhị phân đã cho<code>char_type</code>khoảng cách<span class="kw4">char</span>Thì</li>
<li> <code>a == b</code>Nếu đối số đầu tiên là</li>
</ul> <span class="t-li">2)</span>void Atomic_flag_wait_explicit (đối tượng Atomic_flag* dễ bay hơi<code>a</code>Và<code>b</code>theo cách mà chúng hoàn toàn được đặt hàng, hành xử giống hệt<ul>
<li> <code>static_cast&lt;unsigned char&gt;(a) &lt; static_cast&lt;unsigned char&gt;(b)</code>Sử dụng chức năng nhị phân đã cho<code>char_type</code>khoảng cách<span class="kw4">char</span>Thì</li>
<li> <code>a &lt; b</code>Nếu đối số đầu tiên là</li>
</ul> <p>(Raco).<a href="../../named_req/chartraits" title="cpp/named req/CharTraits">CharTraits</a>các ký tự trong chuỗi ký tự được trỏ bởi<code>X::eq</code>Và<code>X::lt</code>.</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Trao đổi các giá trị của các yếu tố mà các trình rút đã cho đang chỉ ra.</td> <td>-</td> <td>giá trị ký tự để so sánh</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">1)</span> <code>true</code>nếu như<code>a</code>Và<code>b</code>phạm vi có giá trị để so sánh<code>false</code>Nếu đối số đầu tiên là</div> <div class="t-li1">
<span class="t-li">2)</span> <code>true</code>nếu như<code>a</code>là ít hơn<code>b</code>Thì<code>false</code>Nếu đối số đầu tiên là</div> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>trình rút vào các yếu tố để hoán đổi</p>
<h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue467" rel="nofollow">LWG 467</a> </td> <td>C ++ 98</td> <td>vì<a href="http://en.cppreference.com/w/cpp/string/char_traits"><span class="kw1270">Điều đó cho tất cả<span class="me2">char_traits</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">char</span><span class="sy1">&lt;</span>, ngữ nghĩa của<code>eq()</code>Và<code>lt()</code><br/>giống như tích hợp<code>==</code>Và<code>&lt;</code>    __ComparisonCommOnTyPewith &lt;t, u&gt; &amp;&amp;<span class="kw4">char</span>(Được kiểm soát bởi Chỉ thị<sup class="reference" id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup> </td> <td>thay đổi thành tích hợp<code>==</code>Và<br/><code>&lt;</code>    __ComparisonCommOnTyPewith &lt;t, u&gt; &amp;&amp;<span class="kw4">STD</span> <span class="kw4">char</span> </td>
</tr>
</table> <ol class="references"> <li id="cite_note-1"> <span class="reference-text">Hầu hết các triển khai đều gọi<code><a href="../byte/memcmp" title="cpp/string/byte/memcmp">std::memcmp()</a></code>cho hiệu quả, trong đó giải thích dữ liệu như các mảng của<code>unsigned char</code>. Nếu như<code>char</code> <a href="../../language/types#Character_types" title="cpp/language/types">is signed</a>về các triển khai như vậy,<code><a href="http://en.cppreference.com/w/cpp/string/char_traits"><span class="kw1270">Điều đó cho tất cả<span class="me2">char_traits</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">char</span><span class="sy1">&lt;</span></code>không đáp ứng các yêu cầu của<a href="../../named_req/chartraits" title="cpp/named req/CharTraits">CharTraits</a>.</span> </li> </ol> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/string/char_traits/cmp">https://en.cppreference.com/w/cpp/string/char_traits/cmp</a>
</p>
</div>
