 <h1 class="firstHeading" id="firstHeading">STD :: Tệp</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/cstdio" title="cpp/header/cstdio">&lt;cstdio&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">typedef / * không xác định * / tệp;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Mỗi<code>std::FILE</code>Đối tượng biểu thị một luồng C.</p>
<p>C tiêu chuẩn (được tham chiếu theo tiêu chuẩn C ++) không chỉ định xem liệu<code>std::FILE</code>là một loại đối tượng hoàn chỉnh. Mặc dù có thể sao chép hợp lệ<code>std::FILE</code>, sử dụng một con trỏ tới một bản sao như một đối số cho hàm I/O gọi hành vi không xác định. Nói cách khác,<code>std::FILE</code>có thể không thể sao chép về mặt ngữ nghĩa.</p>
<p>Các luồng I/O có thể được sử dụng cho cả đầu vào và đầu ra chưa được định dạng và được định dạng. Hơn nữa, các chức năng xử lý đầu vào và đầu ra cũng có thể nhạy cảm với locale, sao cho chuyển đổi rộng/multibyte được thực hiện khi cần thiết.</p>
<h3 id="Stream_state">Trạng thái phát trực tuyến</h3> <p>Bên cạnh thông tin dành riêng cho hệ thống cần thiết để truy cập thiết bị (<i>ví dụ.,</i>một mô tả tệp posix), mỗi<code>std::FILE</code>Đối tượng trực tiếp hoặc gián tiếp giữ các mục sau:</p>
<ol>
<li>Chiều rộng ký tự: Und đặt, hẹp hoặc rộng.</li>
<li>Trạng thái phân tích cú pháp để chuyển đổi giữa các ký tự multibyte và rộng (một đối tượng thuộc loại<code><a href="../../string/multibyte/mbstate_t" title="cpp/string/multibyte/mbstate t">std::mbstate_t</a></code>)</li>
<li>Trạng thái đệm: Không bị ảnh hưởng, đệm dòng, được đệm hoàn toàn.</li>
<li>Bộ đệm, có thể được thay thế bằng bộ đệm ngoài, do người dùng cung cấp.</li>
<li>Chế độ I/O: Đầu vào, đầu ra hoặc cập nhật (cả đầu vào và đầu ra).</li>
<li>Chỉ báo chế độ nhị phân/văn bản.</li>
<li>Chỉ báo trạng thái cuối tập tin.</li>
<li>Chỉ báo trạng thái lỗi.</li>
<li>Chỉ báo vị trí tệp, có thể truy cập như một đối tượng của loại<code><a href="fpos_t" title="cpp/io/c/fpos t">std::fpos_t</a></code>, trong đó, đối với các luồng rộng, bao gồm trạng thái phân tích cú pháp.</li>
<li> <span class="t-mark-rev t-since-cxx17">Dest_at</span>Khóa reentrant được sử dụng để ngăn chặn các cuộc đua dữ liệu khi nhiều luồng đọc, ghi, vị trí hoặc truy vấn vị trí của luồng.</li>
</ol> <h4 id="Narrow_and_wide_orientation">Định hướng hẹp và rộng</h4> <p>Một luồng mới mở không có định hướng. Cuộc gọi đầu tiên đến<code>std::fwide</code>hoặc cho bất kỳ hàm I/O nào thiết lập định hướng: hàm I/O rộng làm cho luồng rộng theo định hướng rộng; Một hàm I/O hẹp làm cho luồng định hướng hẹp. Sau khi được đặt, định hướng chỉ có thể được thay đổi<code><a href="freopen" title="cpp/io/c/freopen">std::freopen</a></code>. Các hàm I/O hẹp không thể được gọi trên một luồng định hướng rộng; Các hàm I/O rộng không thể được gọi trên một luồng định hướng hẹp. Các hàm I/O rộng chuyển đổi giữa các ký tự rộng và đa cấp như thể bằng cách gọi<code><a href="../../string/multibyte/mbrtowc" title="cpp/string/multibyte/mbrtowc">std::mbrtowc</a></code>hoặc<code><a href="../../string/multibyte/wcrtomb" title="cpp/string/multibyte/wcrtomb">std::wcrtomb</a></code>với trạng thái chuyển đổi như được mô tả bởi luồng. Không giống như các chuỗi ký tự multibyte có giá trị trong một chương trình, các chuỗi ký tự multibyte trong tệp có thể chứa các null được nhúng và không phải bắt đầu hoặc kết thúc ở trạng thái dịch chuyển ban đầu.</p>
<p>Trạng thái chuyển đổi của một luồng với hướng rộng được thiết lập bởi locale C được cài đặt tại thời điểm định hướng của luồng được đặt.</p>
<h4 id="Binary_and_text_modes">Chế độ nhị phân và văn bản</h4> <p>MỘT<i>luồng văn bản</i>là một chuỗi các ký tự có thể được sáng tác thành các dòng; Một dòng có thể được phân tách thành các ký tự bằng không hoặc nhiều hơn cộng với việc chấm dứt<code>'\n'</code>(Nhân vật của New Newline). Liệu dòng cuối cùng có yêu cầu chấm dứt<code>'\n'</code>là thực hiện được xác định. Hơn nữa, các ký tự có thể phải được thêm, thay đổi hoặc xóa trên đầu vào và đầu ra để phù hợp với các quy ước để biểu diễn văn bản trong HĐH (đặc biệt, các luồng C trên Windows OS chuyển đổi<code>'\n'</code>ĐẾN<code>'\r\n'</code>trên đầu ra và chuyển đổi<code>'\r\n'</code>ĐẾN<code>'\n'</code>trên đầu vào).</p>
<p>Dữ liệu được đọc từ luồng văn bản được đảm bảo để so sánh bằng dữ liệu trước đó đã được ghi ra với luồng đó chỉ khi mỗi điều sau đây là đúng:</p>
<ul>
<li>Dữ liệu chỉ bao gồm các ký tự in và/hoặc các ký tự điều khiển<code>'\t'</code>Và<code>'\n'</code>(Đặc biệt, trên hệ điều hành Windows, ký tự<code>'\0x1A'</code>chấm dứt đầu vào).</li>
<li>KHÔNG<code>'\n'</code>ký tự ngay trước các ký tự không gian (các ký tự không gian như vậy có thể biến mất khi đầu ra đó sau đó được đọc dưới dạng đầu vào).</li>
<li>Nhân vật cuối cùng là<code>'\n'</code>.</li>
</ul> <p>MỘT<i>luồng nhị phân</i>là một chuỗi các ký tự được đặt hàng có thể ghi lại dữ liệu nội bộ một cách minh bạch. Dữ liệu được đọc từ một luồng nhị phân luôn bằng dữ liệu được ghi ra trước đó vào luồng đó, ngoại trừ việc triển khai được phép nối một số ký tự null không xác định vào cuối luồng. Một luồng nhị phân rộng không cần kết thúc ở trạng thái thay đổi ban đầu.</p>
<h3 id="Notes">Ghi chú</h3> <p>Posix rõ ràng yêu cầu rằng<code>LC_CTYPE</code>Facet của locale C hiện đang được cài đặt được lưu trữ trong<code>FILE</code>Đối tượng ngay khi định hướng của luồng trở nên rộng; Posix yêu cầu điều này<code>LC_CTYPE</code>Mặt được sử dụng cho tất cả I/O trong tương lai trên luồng này cho đến khi định hướng được thay đổi, bất kể mọi cuộc gọi tiếp theo đến<code><a href="../../locale/setlocale" title="cpp/locale/setlocale">std::setlocale</a></code>.</p>
<p>Người ta dự định rằng mỗi dòng văn bản được cấu tạo từ dữ liệu về cơ bản là người có thể đọc được. Việc triển khai POSIX không phân biệt giữa các luồng văn bản và nhị phân (không có ánh xạ đặc biệt cho<code>'\n'</code>hoặc bất kỳ ký tự khác).</p>
<h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../basic_streambuf" title="cpp/io/basic streambuf"> <span class="t-lines"><span>basic_streambuf</span></span></a></div> </td> <td>Tóm tắt một thiết bị thô<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../basic_filebuf" title="cpp/io/basic filebuf"> <span class="t-lines"><span>BASIC_FILEBUF</span></span></a></div> </td> <td>thực hiện thiết bị tệp thô<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="std_streams" title="cpp/io/c/std streams"> <span class="t-lines"><span>Stdin</span><span>Stdout</span><span>Stderr</span></span></a></div> </td> <td>Biểu hiện của loại<code>FILE*</code>được liên kết với luồng đầu vào<br/>Biểu hiện của loại<code>FILE*</code>liên kết với luồng đầu ra<br/>Biểu hiện của loại<code>FILE*</code>được liên kết với luồng đầu ra lỗi<br/> <span class="t-mark">(Hằng số vĩ mô)</span> </td>
</tr> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/io/FILE" title="c/io/FILE">C documentation</a></span>vì<code>FILE</code> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/io/c/FILE">https://en.cppreference.com/w/cpp/io/c/FILE</a>
</p>
</div>
