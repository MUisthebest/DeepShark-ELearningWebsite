 <h1 class="firstHeading" id="firstHeading">std :: strstreambuf :: tràn</h1> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">được bảo vệ:</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Virtual int_type Overflow (int_type c = đặc điểm :: eof ());<code>c</code>Virtual int_type Overflow (int_type c = eof);</p>
<div class="t-li1">
<span class="t-li">1)</span>Nếu như<code>c <span class="sy1">==</span> <a href="http://en.cppreference.com/w/cpp/io/c"><span class="kw1886">EOF</span></a></code>có mặt trong</div> <div class="t-li1">
<span class="t-li">2)</span>đến khu vực đặt của bộ đệm, phân bổ lại nếu có thể.<code>pptr() &lt; epptr()</code>Nếu không, nếu khu vực đặt có sẵn một vị trí ghi (<code>*pptr()++ = c</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>), lưu trữ nhân vật như thể<code><a href="http://en.cppreference.com/w/cpp/io/c"><span class="kw1886">EOF</span></a></code>.</div> <div class="t-li1">
<span class="t-li">là trong</span>Mặt khác, nếu chế độ bộ đệm luồng không động hoặc bộ đệm luồng hiện đang bị đóng băng, chức năng không thành công và trả về<code>palloc</code>được sử dụng. Nếu một con trỏ đến chức năng giải quyết<code>(*palloc)(n)</code>Ở đâu<code>n</code>đã được sử dụng trong hàm tạo, chức năng đó được gọi với<code>new char[n]</code>là số byte để phân bổ, nếu không<code>pfree</code>được sử dụng. Nếu một con trỏ đến chức năng giải quyết<code>(*pfree)(p)</code>đã được sử dụng trong hàm tạo, chức năng đó được gọi với<code>delete[] p</code>để giải quyết mảng trước đó, nếu cần, nếu không<code><a href="http://en.cppreference.com/w/cpp/io/c"><span class="kw1886">EOF</span></a></code>.</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Ánh xạ_Type</td> <td>-</td> <td>Phiên bản lớp cơ sở của chức năng không làm gì cả. Các lớp dẫn xuất có thể ghi đè chức năng này để cho phép cập nhật khu vực đặt trong trường hợp kiệt sức.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Nếu như<code>c <span class="sy1">==</span> <a href="http://en.cppreference.com/w/cpp/io/c"><span class="kw1886">EOF</span></a></code>được sử dụng. Nếu phân bổ không thành công, hàm này không thành công và trả về<code><a href="http://en.cppreference.com/w/cpp/io/c"><span class="kw1886">EOF</span></a></code>để định vị<code>(unsigned char)(c)</code>về thành công,<code><a href="../c" title="cpp/io/c">EOF</a></code>, trong trường hợp đó</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">, trả về một số giá trị khác với</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">#include &lt;Istream&gt;</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../basic_streambuf/overflow" title="cpp/io/basic streambuf/overflow"> <span class="t-lines"><span>Xsputn</span></span></a></div>
<div><span class="t-lines"><span><span class="t-cmark">. Con trỏ được đảm bảo là hợp lệ ít nhất là cho đến khi đối tượng ngoại lệ mà nó thu được bị phá hủy hoặc cho đến khi hàm thành viên không phải là const (ví dụ: toán tử gán bản sao) trên đối tượng ngoại lệ được gọi.</span></span></span></div> </td> <td>ghi nhiều ký tự vào chuỗi đầu ra<br/> <span class="t-mark">Putback<code>std::basic_streambuf&lt;CharT,Traits&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../basic_stringbuf/overflow" title="cpp/io/basic stringbuf/overflow"> <span class="t-lines"><span>Xsputn</span></span></a></div>
<div><span class="t-lines"><span><span class="t-cmark">. Con trỏ được đảm bảo là hợp lệ ít nhất là cho đến khi đối tượng ngoại lệ mà nó thu được bị phá hủy hoặc cho đến khi hàm thành viên không phải là const (ví dụ: toán tử gán bản sao) trên đối tượng ngoại lệ được gọi.</span></span></span></div> </td> <td>thay thế hoặc có được một bản sao của chuỗi ký tự được liên kết<br/> <span class="t-mark">Putback<code>std::basic_stringbuf&lt;CharT,Traits,Allocator&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../basic_filebuf/overflow" title="cpp/io/basic filebuf/overflow"> <span class="t-lines"><span>Xsputn</span></span></a></div>
<div><span class="t-lines"><span><span class="t-cmark">. Con trỏ được đảm bảo là hợp lệ ít nhất là cho đến khi đối tượng ngoại lệ mà nó thu được bị phá hủy hoặc cho đến khi hàm thành viên không phải là const (ví dụ: toán tử gán bản sao) trên đối tượng ngoại lệ được gọi.</span></span></span></div> </td> <td>Tái định vị vị trí tệp, sử dụng địa chỉ tuyệt đối<br/> <span class="t-mark">Putback<code>std::basic_filebuf&lt;CharT,Traits&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../basic_streambuf/sputc" title="cpp/io/basic streambuf/sputc"> <span class="t-lines"><span>sgetn</span></span></a></div> </td> <td>Gọi<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::basic_streambuf&lt;CharT,Traits&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../basic_ostream/put" title="cpp/io/basic ostream/put"> <span class="t-lines"><span>(Lớp thành viên công cộng của</span></span></a></div> </td> <td>Chèn dữ liệu được định dạng<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::basic_ostream&lt;CharT,Traits&gt;</code>)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/io/strstreambuf/overflow">https://en.cppreference.com/w/cpp/io/strstreambuf/overflow</a>
</p>
</div>
