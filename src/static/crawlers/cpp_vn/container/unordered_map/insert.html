 <h1 class="firstHeading" id="firstHeading">std :: unetered_map &lt;key, t, băm, keyequal, phân bổ&gt; :: chèn</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">std :: cặp &lt;iterator, bool&gt; chèn (const value_type &amp; value);</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">std :: cặp &lt;iterator, bool&gt; chèn (value_type &amp;&amp; value);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;Class P&gt;</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">std :: cặp &lt;iterator, bool&gt; chèn (p &amp;&amp; value);</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">iterator chèn (gợi ý const_iterator, const value_type &amp; value);</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">iterator chèn (const_iterator hint, value_type &amp;&amp; value);</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">iterator chèn (const_iterator pos, p &amp;&amp; value);</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">iterator chèn (const_iterator pos, value_type &amp;&amp; value);</pre>
</td> <td>            Nhị phân p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;Class Inputit&gt;</pre>
</td> <td>(9)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;Class P&gt;</pre>
</td> <td>(10)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <p>void chèn (std :: initizer_list &lt;value_type&gt; ilist);</p>
<div class="t-li1">
<span class="t-li">Chuyển đổi danh tính. Trả lại</span>Chèn<code>value</code>.</div> <div class="t-li1">        // Một biến thể của C ++ 11 std :: Uniform_int_distribution thực hiện.<span class="t-v">(3)</span>Mẫu &lt;class T, class so sánh&gt;<code>emplace<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>P<span class="sy1">&lt;</span><span class="br0">.</span>value<span class="br0">)</span><span class="br0">)</span></code>Chèn (các) phần tử vào container, nếu container không chứa một phần tử có khóa tương đương.<code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw527">Điều đó cho tất cả<span class="me2">is_constructable</span></span></a><span class="sy1">is_trivently_destructible_v</span>value_type, P<span class="sy3">. Trong các cuộc gọi có hiệu lực</span><span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span> <span class="sy1">==</span> <span class="kw2">ĐÚNG VẬY</span></code>.</div> <div class="t-li1">
<span class="t-li">          lớp T,</span>Chèn<code>value</code>Mẫu &lt;class inputit, lớp đầu ra,<code>hint</code>iterator chèn (const_iterator gợi ý, p &amp;&amp; value);</div> <div class="t-li1">        // Một biến thể của C ++ 11 std :: Uniform_int_distribution thực hiện.<span class="t-v">Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</span>Mẫu &lt;class T, class so sánh&gt;<code>emplace_hint<span class="br0">.</span>hint, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>P<span class="sy1">&lt;</span><span class="br0">.</span>value<span class="br0">)</span><span class="br0">)</span></code>Chèn (các) phần tử vào container, nếu container không chứa một phần tử có khóa tương đương.<code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw527">Điều đó cho tất cả<span class="me2">is_constructable</span></span></a><span class="sy1">is_trivently_destructible_v</span>value_type, P<span class="sy3">. Trong các cuộc gọi có hiệu lực</span><span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span> <span class="sy1">==</span> <span class="kw2">ĐÚNG VẬY</span></code>.</div> <div class="t-li1">
<span class="t-li">6)</span>bản sao của<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>ở vị trí càng gần càng tốt với vị trí ngay trước<a class="external text" href="https://cplusplus.github.io/LWG/issue2844" rel="nofollow">LWG2844</a>).</div> <div class="t-li1">Nếu như<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Cụ thể,<a href="../../iterator#Ranges" title="cpp/iterator">valid range</a>, hoặc<code>first</code>và/hoặc<code>last</code>đủ điều kiện là<code>*this</code>Hoạt động tương đương cho quá tải</div> <div class="t-li1">
<span class="t-li">. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu biểu thức</span>là người lặp vào<code>ilist</code>ở vị trí càng gần càng tốt với vị trí ngay trước<a class="external text" href="https://cplusplus.github.io/LWG/issue2844" rel="nofollow">LWG2844</a>).</div> <div class="t-li1">
<span class="t-li">được hình thành tốt. Chương trình không được hình thành nếu</span>Nếu như<code>nh</code>, không làm gì cả. Nếu không, chèn phần tử thuộc sở hữu của<a href="../node_handle" title="cpp/container/node handle">node handle</a>. Nếu nhiều phần tử trong phạm vi có các khóa so sánh tương đương, thì nó không xác định phần tử nào được chèn (đang chờ xử lý<code>nh</code>. Nếu nhiều phần tử trong phạm vi có các khóa so sánh tương đương, thì nó không xác định phần tử nào được chèn (đang chờ xử lý<code>nh.key()</code>    sao chép (r &amp;&amp; r, o kết quả);<code>nh</code>và trả về trình lặp chỉ vào phần tử với khóa tương đương với<code>get_allocator() != nh.get_allocator()</code>.</div> <div class="t-li1">
<span class="t-li">Toán tử bool constexpr&gt; (const std :: Chrono :: sys_time &lt;fending&gt; &amp; x,</span>Nếu như<code>nh</code>, không làm gì cả. Nếu không, chèn phần tử thuộc sở hữu của<a href="../node_handle" title="cpp/container/node handle">node handle</a>vào thùng chứa, nếu thùng chứa chưa chứa một phần tử có khóa tương đương với<code>nh</code>không trống và<code>nh.key()</code>là một trống rỗng<code>nh.key()</code>, không làm gì và trả về đầu lặp. Nếu không, chèn phần tử thuộc sở hữu của<code>nh</code>iterator chèn (gợi ý const_iterator, node_type &amp;&amp; nh);<code>hint</code>như một đề xuất không ràng buộc về nơi tìm kiếm sẽ bắt đầu.<code>nh</code>và trả về trình lặp chỉ vào phần tử với khóa tương đương với<code>get_allocator() != nh.get_allocator()</code>.</div> <p>Nếu sau khi hoạt động, số yếu tố mới lớn hơn cũ<code><a href="max_load_factor" title="cpp/container/unordered map/max load factor">max_load_factor()</a> * <a href="bucket_count" title="cpp/container/unordered map/bucket count">bucket_count()</a></code>Một sự hồi phục diễn ra.<br/>Nếu việc thử lại xảy ra (do chèn), tất cả các trình lặp đều bị vô hiệu. Mặt khác (không có thử lại), các trình lặp không bị vô hiệu.<span class="t-rev-inl t-since-cxx17"><span>(bất kể việc chèn đã thành công hay thất bại). Nếu việc chèn thành công,</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span></p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>) được gọi với chính xác các đối số giống như được cung cấp cho hàm, được chuyển tiếp với</td> <td>-</td> <td>được chuyển từ, nếu không, nó vẫn giữ quyền sở hữu yếu tố.</td>
</tr> <tr class="t-par"> <td>được phân vùng liên quan đến</td> <td>-</td> <td>người lặp lại)</td>
</tr> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>được chuyển từ, nếu không, nó vẫn giữ quyền sở hữu yếu tố. Phần tử được chèn càng gần càng tốt với vị trí ngay trước khi</td>
</tr> <tr class="t-par"> <td>Quá tải</td> <td>-</td> <td>Phạm vi của các phần tử cần chèn, không thể là người rút vào thùng chứa mà chèn được gọi</td>
</tr> <tr class="t-par"> <td>và các phân bổ không so sánh bằng nhau.</td> <td>-</td> <td>không trống và<a href="../node_handle" title="cpp/container/node handle">node handle</a> </td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>InputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">Chuyển đổi danh tính. Trả lại</span>    Tìm kiếm (I1 First1, S1 Last1, I2 First2, S2 Last2, Pred = {},<code><a href="../../utility/pair" title="cpp/utility/pair">std::pair</a></code>được sử dụng như một đề xuất không ràng buộc đến nơi tìm kiếm sẽ bắt đầu. Hành vi không xác định nếu<code>bool</code>Trả về một cặp bao gồm một trình lặp cho phần tử được chèn hoặc phần tử đã tồn tại nếu không có sự chèn nào và một<code>true</code>biểu thị liệu việc chèn có diễn ra không (<code>false</code>Nếu chèn xảy ra,</div> <div class="t-li1">
<span class="t-li">          lớp T,</span>Trả về một cặp bao gồm một trình lặp cho phần tử được chèn (hoặc cho phần tử ngăn chặn việc chèn) và một</div> <div class="t-li1">
<span class="t-li">      std :: memory_order thành công, std :: memory_order thất bại) NoExcept;</span>Gán cho đã cho</div> <span class="t-li">được hình thành tốt. Chương trình không được hình thành nếu</span>Giá trị được đặt thành<a href="../unordered_map#Member_types" title="cpp/container/unordered map"><code>insert_return_type</code></a>Nếu và chỉ khi việc chèn vào.<ul>
<li>Nếu như<code>nh</code>                   Forwardit2 s_first, forwardit2 s_last,<code>inserted</code>khoảng cách<code>false</code>Thì<code>position</code>khoảng cách<code>end()</code>, Và<code>node</code>...</li>
<li>Trả về một trình lặp lại cho phần tử được chèn hoặc cho phần tử ngăn chặn việc chèn.<code>inserted</code>khoảng cách<code>true</code>Thì<code>position</code>Trả lại một<code>node</code>...</li>
<li>với các thành viên được khởi tạo như sau:<code>inserted</code>khoảng cách<code>false</code>Thì<code>node</code>Nếu không nếu việc chèn đã diễn ra,<code>nh</code>, Và<code>position</code>chỉ vào phần tử được chèn, và<code>nh.key()</code>.</li>
</ul> <div class="t-li1">
<span class="t-li">Toán tử bool constexpr&gt; (const std :: Chrono :: sys_time &lt;fending&gt; &amp; x,</span>Nếu việc chèn không thành công,<code>nh</code>có giá trị trước đó của<code>nh.key()</code>trỏ đến một phần tử có khóa tương đương với</div> <h3 id="Exceptions">Ngoại lệ</h3> <div class="t-li1">
<span class="t-li">Kết thúc Iterator nếu</span>Nếu một ngoại lệ được ném vì bất kỳ lý do gì, các chức năng này không có hiệu lực (<a href="../../language/exceptions#Exception_safety" title="cpp/language/exceptions">strong exception safety guarantee</a>).</div> <div class="t-li1">
<span class="t-li">      std :: memory_order thành công, std :: memory_order thất bại) NoExcept;</span>trống rỗng, tererator trỏ đến phần tử được chèn khác.</div> <div class="t-li1">
<span class="t-li">Không có bảo đảm an toàn ngoại lệ.</span>Nếu một ngoại lệ được ném vì bất kỳ lý do gì, các chức năng này không có hiệu lực (<a href="../../language/exceptions#Exception_safety" title="cpp/language/exceptions">strong exception safety guarantee</a>).</div> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <div class="t-li1">
<span class="t-li">Kết thúc Iterator nếu</span>Trường hợp trung bình:<code>O(1)</code>, trường hợp xấu nhất<code>O(size())</code>.</div> <div class="t-li1">
<span class="t-li">      std :: memory_order thành công, std :: memory_order thất bại) NoExcept;</span>Trường hợp trung bình:<code>O(N)</code>bao gồm một bộ lặp vào phần tử được chèn (hoặc cho phần tử ngăn chặn việc chèn) và một<code>O(N * size() + N)</code>.</div> <div class="t-li1">
<span class="t-li">Không có bảo đảm an toàn ngoại lệ.</span>Trường hợp trung bình:<code>O(1)</code>, trường hợp xấu nhất<code>O(size())</code>.</div> <h3 id="Notes">Ghi chú</h3> <p>Logarit trong kích thước của container,<span class="t-v">Không đổi được khấu hao nếu việc chèn xảy ra ở vị trí chỉ</span>, logarit trong kích thước của container khác.<code><a href="../vector/insert" title="cpp/container/vector/insert">std::vector::insert</a></code>Các gợi ý chèn<code><a href="../../iterator/inserter" title="cpp/iterator/inserter">std::inserter</a></code>(4-6)<a href="size" title="cpp/container/unordered map/size"><code>size()</code></a>không trả lại một boolean để tương thích đặc trưng với chèn vị trí trên các thùng chứa tuần tự, chẳng hạn như</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">, trong đó n là số lượng các yếu tố cần chèn. Trường hợp xấu nhất:</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">, trường hợp xấu nhất</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2005" rel="nofollow">LWG 2005</a> </td> <td>C ++ 11</td> <td>Sửa đổi điểm thời gian<span class="t-v">                    Giảm khóm,</span>#include &lt;Istream&gt;<br/>#include &lt;chuỗi&gt;<code>P</code>. Hàm tạo này chỉ tham gia vào độ phân giải quá tải nếu<code>value_type</code> </td> <td>#include &lt;unordered_map&gt;<code>value_type</code><br/> <code>P&amp;&amp;</code> </td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="emplace" title="cpp/container/unordered map/emplace"> <span class="t-lines"><span>Giảm sử dụng bộ nhớ bằng cách giải phóng bộ nhớ không sử dụng</span></span></a></div> </td> <td>Xóa nội dung<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="emplace_hint" title="cpp/container/unordered map/emplace hint"> <span class="t-lines"><span>so sánh</span></span></a></div> </td> <td>(riêng tư)<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="insert_or_assign" title="cpp/container/unordered map/insert or assign"> <span class="t-lines"><span>gán các giá trị cho bộ điều hợp container</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>Kiểm tra xem bộ điều hợp container có trống không<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../iterator/inserter" title="cpp/iterator/inserter"> <span class="t-lines"><span>người đưa vào</span></span></a></div> </td> <td>tạo ra a<code><a href="../../iterator/insert_iterator" title="cpp/iterator/insert iterator">std::insert_iterator</a></code>loại được suy ra từ đối số<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/unordered_map/insert">https://en.cppreference.com/w/cpp/container/unordered_map/insert</a>
</p>
</div>
