 <h1 class="firstHeading" id="firstHeading">std :: unetered_map &lt;key, t, băm, keyequal, phân bổ&gt; :: toán tử []</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">T &amp; toán tử [] (khóa const &amp; khóa);</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">T &amp; toán tử [] (khóa &amp;&amp; khóa);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> </table> <p>Trả về một tham chiếu đến giá trị được ánh xạ tới một khóa tương đương với<code>key</code>, thực hiện một chèn nếu khóa đó chưa tồn tại.</p>
<div class="t-li1">
<span class="t-li">1)</span>Chèn a<code>value_type</code>đối tượng được xây dựng tại chỗ từ<code><a href="http://en.cppreference.com/w/cpp/utility/piecewise_construct"><span class="kw1109">Điều đó cho tất cả<span class="me2">Piecewise_construct</span></span></a>, <a href="http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple"><span class="kw1117">Điều đó cho tất cả<span class="me2">forward_as_tuple</span></span></a><span class="br0">.</span>key<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/tuple"><span class="kw1101">Điều đó cho tất cả<span class="me2">Tuple</span></span></a><span class="sy1">&lt;&gt;</span><span class="br0">.</span><span class="br0">)</span></code>Nếu khóa không tồn tại.<span class="t-rev-inl t-since-cxx17"><span>Chức năng này tương đương với<code>return this-&gt;try_emplace(key).first-&gt;second;</code>.</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>Khi bộ phân bổ mặc định được sử dụng, điều này dẫn đến khóa được bản sao được xây dựng từ<code>key</code>và giá trị được ánh xạ là<a href="../../language/value_initialization" title="cpp/language/value initialization">value-initialized</a>.<table class="t-par-begin"> <tr class="t-par-req"> <td colspan="3">-<code>value_type</code>// thực hiện đầu tiên<a href="../../named_req/emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a>từ<code><a href="http://en.cppreference.com/w/cpp/utility/piecewise_construct"><span class="kw1109">Điều đó cho tất cả<span class="me2">Piecewise_construct</span></span></a>, <a href="http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple"><span class="kw1117">Điều đó cho tất cả<span class="me2">forward_as_tuple</span></span></a><span class="br0">.</span>key<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/tuple"><span class="kw1101">Điều đó cho tất cả<span class="me2">Tuple</span></span></a><span class="sy1">&lt;&gt;</span><span class="br0">.</span><span class="br0">)</span></code>. Khi bộ phân bổ mặc định được sử dụng, điều này có nghĩa là<code>key_type</code>// thực hiện đầu tiên<a href="../../named_req/copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>Và<code>mapped_type</code>// thực hiện đầu tiên<a href="../../named_req/defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a>.</td>
</tr>
</table>
</div> <div class="t-li1">
<span class="t-li">2)</span>Chèn a<code>value_type</code>đối tượng được xây dựng tại chỗ từ<code><a href="http://en.cppreference.com/w/cpp/utility/piecewise_construct"><span class="kw1109">Điều đó cho tất cả<span class="me2">Piecewise_construct</span></span></a>, <a href="http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple"><span class="kw1117">Điều đó cho tất cả<span class="me2">forward_as_tuple</span></span></a><span class="br0">.</span>std<span class="sy4">::</span><span class="me2">(Niebloid)</span><span class="br0">.</span>key<span class="br0">)</span><span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/tuple"><span class="kw1101">Điều đó cho tất cả<span class="me2">Tuple</span></span></a><span class="sy1">&lt;&gt;</span><span class="br0">.</span><span class="br0">)</span></code>Nếu khóa không tồn tại.<span class="t-rev-inl t-since-cxx17"><span>Chức năng này tương đương với<code>return this-&gt;try_emplace(std::move(key)).first-&gt;second;</code>.</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span><br/>Khi bộ phân bổ mặc định được sử dụng, điều này dẫn đến khóa đang di chuyển được xây dựng từ<code>key</code>và giá trị được ánh xạ là<a href="../../language/value_initialization" title="cpp/language/value initialization">value-initialized</a>.<table class="t-par-begin"> <tr class="t-par-req"> <td colspan="3">-<code>value_type</code>// thực hiện đầu tiên<a href="../../named_req/emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a>từ<code><a href="http://en.cppreference.com/w/cpp/utility/piecewise_construct"><span class="kw1109">Điều đó cho tất cả<span class="me2">Piecewise_construct</span></span></a>, <a href="http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple"><span class="kw1117">Điều đó cho tất cả<span class="me2">forward_as_tuple</span></span></a><span class="br0">.</span>std<span class="sy4">::</span><span class="me2">(Niebloid)</span><span class="br0">.</span>key<span class="br0">)</span><span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/tuple"><span class="kw1101">Điều đó cho tất cả<span class="me2">Tuple</span></span></a><span class="sy1">&lt;&gt;</span><span class="br0">.</span><span class="br0">)</span></code>. Khi bộ phân bổ mặc định được sử dụng, điều này có nghĩa là<code>key_type</code>// thực hiện đầu tiên<a href="../../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>Và<code>mapped_type</code>// thực hiện đầu tiên<a href="../../named_req/defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a>.</td>
</tr>
</table>
</div> <p>Nếu sau khi hoạt động, số yếu tố mới lớn hơn cũ<code><a href="max_load_factor" title="cpp/container/unordered map/max load factor">max_load_factor()</a> * <a href="bucket_count" title="cpp/container/unordered map/bucket count">bucket_count()</a></code>Một sự hồi phục diễn ra.<br/>Nếu việc thử lại xảy ra (do chèn), tất cả các trình lặp đều bị vô hiệu. Mặt khác (không có thử lại), các trình lặp không bị vô hiệu.</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Hành vi không được xác định nếu mảng chưa được phân vùng theo thứ tự tăng dần đối với khóa, theo cùng một tiêu chí</td> <td>-</td> <td>chìa khóa của yếu tố cần tìm</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Tham chiếu đến giá trị được ánh xạ của phần tử mới nếu không có phần tử nào có khóa<code>key</code>tồn tại. Nếu không thì một tham chiếu đến giá trị được ánh xạ của phần tử hiện có có khóa tương đương với<code>key</code>.</p>
<h3 id="Exceptions">Ngoại lệ</h3> <p>trống rỗng, trình lặp chỉ vào phần tử được chèn nếu chèn diễn ra và trình lặp chỉ vào một phần tử có khóa tương đương với</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Trường hợp trung bình: Không đổi, trường hợp xấu nhất: kích thước tuyến tính.</p>
<h3 id="Notes">Ghi chú</h3> <p>Trong các tiêu chuẩn C ++ 11 và C ++ 14 được xuất bản, chức năng này được chỉ định để yêu cầu<code>mapped_type</code>được<a href="../../named_req/defaultinsertable" title="cpp/named req/DefaultInsertable">DefaultInsertable</a>Và<code>key_type</code>được<a href="../../named_req/copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a>hoặc<a href="../../named_req/moveinsertable" title="cpp/named req/MoveInsertable">MoveInsertable</a>Mẫu &lt;Class T&gt;<code>*this</code>. Thông số kỹ thuật này đã bị lỗi và đã được cố định bởi<a class="external text" href="https://cplusplus.github.io/LWG/issue2469" rel="nofollow">LWG issue 2469</a>và mô tả ở trên kết hợp độ phân giải của vấn đề đó.</p>
<p>Tuy nhiên, một triển khai (LIBC ++) được biết là xây dựng<code>key_type</code>Và<code>mapped_type</code>Đối tượng thông qua hai bộ phân bổ riêng biệt<code>construct()</code>các cuộc gọi, theo yêu cầu của các tiêu chuẩn như được công bố, thay vì đặt một<code>value_type</code>Giống như các tài liệu tham khảo ngôn ngữ, sự ổn định là nông cạn đối với</p>
<p><code>operator[]</code>không phải là công ty vì nó chèn khóa nếu nó không tồn tại. Nếu hành vi này là không mong muốn hoặc nếu container là<code>const</code>Thì<a href="at" title="cpp/container/unordered map/at"><code>at()</code></a>có thể được sử dụng.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p><a href="insert_or_assign" title="cpp/container/unordered map/insert or assign"><code>insert_or_assign()</code></a>Nếu nhiệm vụ diễn ra. Thành phần Iterator đang chỉ vào phần tử được chèn hoặc cập nhật.<code>operator[]</code>Trình lặp chỉ vào phần tử đã được chèn hoặc cập nhật.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;Istream&gt;</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">#include &lt;chuỗi&gt;</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="at" title="cpp/container/unordered map/at"> <span class="t-lines"><span>bằng không).</span></span></a></div> </td> <td>(tuyên bố ngầm)<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="insert_or_assign" title="cpp/container/unordered map/insert or assign"> <span class="t-lines"><span>gán các giá trị cho bộ điều hợp container</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>Kiểm tra xem bộ điều hợp container có trống không<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="try_emplace" title="cpp/container/unordered map/try emplace"> <span class="t-lines"><span>đối tượng hàm so sánh của loại</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>Đối tượng thành viên chỉ dành cho người biểu diễn*<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/unordered_map/operator_at">https://en.cppreference.com/w/cpp/container/unordered_map/operator_at</a>
</p>
</div>
