 <h1 class="firstHeading" id="firstHeading">std :: unetered_map &lt;key, t, băm, keyequal, phân bổ&gt; :: unetered_map</h1> <table class="t-dcl-begin"> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx20"> <td><pre data-language="cpp">unetered_map ()</pre></td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">    : Unordered_map (size_type (/ * thực hiện đã xác định */)) {}</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">unetered_map ();</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx14"> <td> <pre data-language="cpp">Rõ ràng unetered_map (size_type bucket_count,</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span> </td> </tr> <tr class="t-dcl t-since-cxx14"> <td> <pre data-language="cpp">                        const Hash &amp; Hash = Hash (),</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">                        const key_equal &amp; bằng = key_equal (),</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">                        const allocator &amp; alloc = allocator ());</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx14"> <td> <pre data-language="cpp">unetered_map (size_type bucket_count,</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td> <span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span> </td> </tr> <tr class="t-dcl t-since-cxx14"> <td> <pre data-language="cpp">               const ALLOCATOR &amp; ALLOC)</pre>
</td> <td>            Nhị phân p);</td> <td> <span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">    : Unordered_map (Bucket_count, Hash (), key_equal (), alloc) {}</pre>
</td> <td>(9)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">unetered_map (size_type bucket_count,</pre>
</td> <td>(10)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">               const băm &amp; băm,</pre>
</td> <td>(11)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">               const ALLOCATOR &amp; ALLOC)</pre>
</td> <td>(12)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">    : unetered_map (bucket_count, băm, key_equal (), alloc) {}</pre>
</td> <td>(13)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx14"> <td> <pre data-language="cpp">rõ ràng unetered_map (const allocator &amp; alloc);</pre>
</td> <td>(14)</td> <td> <span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span> </td> </tr> <tr class="t-dcl t-since-cxx14"> <td> <pre data-language="cpp">Mẫu &lt;Class Inputit&gt;</pre>
</td> <td>(15)</td> <td> <span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">Unorered_map (đầu vào đầu tiên, đầu vào cuối cùng,</pre>
</td> <td>(16)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">               size_type bucket_count = / * đã xác định * /,,</pre>
</td> <td>Nhà điều hành Auto Auto của Const</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">               const Hash &amp; Hash = Hash (),</pre>
</td> <td>    -&gt; std :: Chrono :: tháng_day_last;</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> </table> <p>               const key_equal &amp; bằng = key_equal (),<code>bucket_count</code>               const allocator &amp; alloc = allocator ());<code>hash</code>Mẫu &lt;Class Inputit&gt;<code>equal</code>Unorered_map (đầu vào đầu tiên, đầu vào cuối cùng,<code>alloc</code>Xây dựng container với</p>
<div class="t-li1">
<span class="t-li">Unordered_map (unetered_map &amp;&amp; other, const allocator &amp; alloc);</span>               const ALLOCATOR &amp; ALLOC)<code><a href="max_load_factor" title="cpp/container/unordered map/max load factor">max_load_factor()</a></code>ĐẾN<code>1.0</code>    : unetered_map (đầu tiên, cuối cùng,</div> <div class="t-li1">
<span class="t-li">unetered_map (std :: initizer_list &lt;value_type&gt; init,</span>Di chuyển hàm tạo. Cấu trúc container với nội dung của<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Mẫu &lt;Class Inputit&gt;<code><a href="max_load_factor" title="cpp/container/unordered map/max load factor">max_load_factor()</a></code>ĐẾN<code>1.0</code>ở vị trí càng gần càng tốt với vị trí ngay trước<a class="external text" href="https://cplusplus.github.io/LWG/issue2844" rel="nofollow">LWG2844</a>).</div> <div class="t-li1">
<span class="t-li">Không có bảo đảm an toàn ngoại lệ.</span>Hàm tạo mặc định. Xây dựng một thùng chứa trống với bộ phân bổ được xây dựng mặc định.<code>other</code>Unorered_map (đầu vào đầu tiên, đầu vào cuối cùng,<code>alloc</code>MAP (STD :: SITECHIZER_LIST &lt;calue_type&gt; init,<code><a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span>allocator_type<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">Xây dựng container với</span><span class="br0">.</span>other.<span class="me1">phá hủy các</span><span class="br0">.</span><span class="br0">)</span><span class="br0">)</span></code>.<table class="t-rev-begin"> <tr class="t-rev t-since-cxx23">
<td> <p>Sẽ thực hiện một bản sao.<code>Allocator</code>               const ALLOCATOR &amp; ALLOC)<a href="../../language/class_template_argument_deduction" title="cpp/language/class template argument deduction">class template argument deduction</a>.</p>
</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table>
</div> <div class="t-li1">
<span class="t-li">               const key_equal &amp; bằng = key_equal (),</span> <a href="../../language/move_constructor" title="cpp/language/move constructor">Move constructor</a>     const so sánh &amp; comp = so sánh (),<code>other</code>     const allocator &amp; alloc = allocator ());<code>alloc</code>MAP (STD :: SITECHIZER_LIST &lt;calue_type&gt; init,<code>other</code>.<table class="t-rev-begin"> <tr class="t-rev t-since-cxx23">
<td> <p>Sẽ thực hiện một bản sao.<code>Allocator</code>               const ALLOCATOR &amp; ALLOC)<a href="../../language/class_template_argument_deduction" title="cpp/language/class template argument deduction">class template argument deduction</a>.</p>
</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table>
</div> <div class="t-li1">
<span class="t-li">               const allocator &amp; alloc = allocator ());</span> <a href="../../language/list_initialization" title="cpp/language/list initialization">Initializer-list constructor</a>   : map (init, so sánh (), alloc) {}<code>init</code>                                  I2 First2, S2 Last2,<code>unordered_map(init.begin(), init.end())</code>.</div> <div class="t-li1">
<span class="t-li">               const ALLOCATOR &amp; ALLOC)</span>     const so sánh &amp; comp = so sánh (),<code>rg</code>ở vị trí càng gần càng tốt với vị trí ngay trước<a class="external text" href="https://cplusplus.github.io/LWG/issue2844" rel="nofollow">LWG2844</a>).</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Sử dụng ngữ nghĩa di chuyển. Người phân bổ có được bằng cách xây dựng di chuyển từ bộ phân bổ thuộc</td> <td>-</td> <td>Nhà xây dựng di chuyển mở rộng phân bổ. Sử dụng</td>
</tr> <tr class="t-par"> <td>Một loại lặp có danh mục, giá trị, sự khác biệt, con trỏ và</td> <td>-</td> <td>Unordered_map (const unetered_map &amp; other);</td>
</tr> <tr class="t-par"> <td>băm</td> <td>-</td> <td>Unordered_map (const unedered_map &amp; other, const allocator &amp; alloc);</td>
</tr> <tr class="t-par"> <td>(Niebloid)</td> <td>-</td> <td>Unordered_map (Unordered_map &amp;&amp; khác);</td>
</tr> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>; nếu như<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>, điều này dẫn đến một động thái yếu tố khôn ngoan.</td>
</tr> <tr class="t-par"> <td>được hủy bỏ chính xác một lần.</td> <td>-</td> <td>Một<a href="../../ranges/to#container_compatible_range" title="cpp/ranges/to">container compatible range</a>RG<a href="../../ranges/input_range" title="cpp/ranges/input range"><code>input_range</code></a>, đó là, một<a href="../unordered_map#Member_types" title="cpp/container/unordered map"><code>value_type</code></a> </td>
</tr> <tr class="t-par"> <td>khác</td> <td>-</td> <td>Trong lúc</td>
</tr> <tr class="t-par"> <td>trong phạm vi</td> <td>-</td> <td>, chỉ đối số đầu tiên góp phần khấu trừ của container</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>InputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</td>
</tr>
</table> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <div class="t-li1">
<span class="t-li">Unordered_map (unetered_map &amp;&amp; other, const allocator &amp; alloc);</span>trình rút vào các yếu tố để hoán đổi</div> <div class="t-li1">
<span class="t-li">unetered_map (std :: initizer_list &lt;value_type&gt; init,</span>               size_type bucket_count = / * đã xác định * /,,<code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>               const Hash &amp; Hash = Hash (),<sup>    return (! (đầu tiên == cuối cùng) và! (giá trị &lt; *đầu tiên));</sup>).</div> <div class="t-li1">
<span class="t-li">Không có bảo đảm an toàn ngoại lệ.</span>các yếu tố có thể chuyển đổi thành<code>other</code>.</div> <div class="t-li1">
<span class="t-li">               const key_equal &amp; bằng = key_equal (),</span>   : map (std :: from_range, std :: forward &lt;r&gt; (rg), so sánh (), alloc) {}<code>alloc</code>Xây dựng container mới từ nhiều nguồn dữ liệu khác nhau và tùy chọn sử dụng phân bổ do người dùng cung cấp<code>alloc != other.get_allocator()</code>hoặc đối tượng hàm so sánh</div> <div class="t-li1">
<span class="t-li">               const allocator &amp; alloc = allocator ());</span>    : unetered_map (init, bucket_count,<code><a href="http://en.cppreference.com/w/cpp/iterator/size"><span class="kw687">Điều đó cho tất cả<span class="me2">kích cỡ</span></span></a><span class="br0">.</span>init<span class="br0">)</span></code>                    Hash (), key_equal (), alloc) {}<sup>    return (! (đầu tiên == cuối cùng) và! (giá trị &lt; *đầu tiên));</sup>).</div> <div class="t-li1">
<span class="t-li">               const ALLOCATOR &amp; ALLOC)</span>    : unetered_map (init, bucket_count,<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3142">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>rg<span class="br0">)</span></code>                    Hash (), key_equal (), alloc) {}<sup>    return (! (đầu tiên == cuối cùng) và! (giá trị &lt; *đầu tiên));</sup>).</div> <h3 id="Exceptions">Ngoại lệ</h3> <p>Cấu trúc container với nội dung của phạm vi<code>Allocator::allocate</code>phân bổ</p>
<h3 id="Notes">Ghi chú</h3>người phân bổ sử dụng cho tất cả các phân bổ bộ nhớ của container này<span class="t-v">(4)</span>Kích thước của container<code>other</code>phạm vi<code>*this</code>để sao chép các yếu tố từ<a class="external text" href="https://eel.is/c++draft/container.reqmts#67" rel="nofollow">[container.reqmts]/67</a>một thùng chứa khác được sử dụng làm nguồn để khởi tạo các phần tử của container với<a class="external text" href="https://cplusplus.github.io/LWG/issue2321" rel="nofollow">LWG issue 2321</a>.<p>unetered_map (std :: initizer_list &lt;value_type&gt; init,<code>Allocator</code>Mẫu &lt;Class T&gt;<a href="../../language/template_argument_deduction#Non-deduced_contexts" title="cpp/language/template argument deduction">non-deduced contexts</a>Cấu trúc container với nội dung của</p>
<table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../../feature_test#cpp_lib_containers_ranges" title="cpp/feature test"><code>__cpp_lib_containers_ranges</code></a></td> <td><span class="nu0">và không trả lại gì.</span></td> <td><span class="t-mark">Phạm vi :: IOTA</span></td> <td>
<a href="../../ranges/to#container_compatible_range" title="cpp/ranges/to">Ranges-aware</a>đối tượng chức năng so sánh để sử dụng cho tất cả các so sánh của các khóa<span class="t-v">               size_type bucket_count,</span> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">               const băm &amp; băm,</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2193" rel="nofollow">LWG 2193</a> </td> <td>C ++ 11</td> <td>               const ALLOCATOR &amp; ALLOC)<span class="t-v">(1)</span>    : unetered_map (init, bucket_count,</td> <td>#include &lt;Deque&gt;</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="operator=" title="cpp/container/unordered map/operator="> <span class="t-lines"><span>chuyên môn)</span></span></a></div> </td> <td>con trỏ<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/unordered_map/unordered_map">https://en.cppreference.com/w/cpp/container/unordered_map/unordered_map</a>
</p>
</div>
