 <h1 class="firstHeading" id="firstHeading">Tay cầm nút<span class="t-mark-rev t-since-cxx17">Dest_at</span>
</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;/ * không xác định */&gt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <p>Container kết hợp<code><a href="set" title="cpp/container/set">std::set</a></code>Thì<code><a href="map" title="cpp/container/map">std::map</a></code>Thì<code><a href="multiset" title="cpp/container/multiset">std::multiset</a></code>Thì<code><a href="multimap" title="cpp/container/multimap">std::multimap</a></code>Thì<code><a href="unordered_set" title="cpp/container/unordered set">std::unordered_set</a></code>Thì<code><a href="unordered_map" title="cpp/container/unordered map">std::unordered_map</a></code>Thì<code><a href="unordered_multiset" title="cpp/container/unordered multiset">std::unordered_multiset</a></code>Thì<code><a href="unordered_multimap" title="cpp/container/unordered multimap">std::unordered_multimap</a></code>lớp / * Handle nút * /;<i>là các cấu trúc dữ liệu dựa trên nút và các nút của chúng có thể được trích xuất như một đối tượng thuộc loại không xác định</i>.</p>
<p>Tay cầm nút<code>value_type</code>Xử lý nút là loại chỉ có di chuyển sở hữu và cung cấp quyền truy cập vào phần tử (<code>key_type</code>) được lưu trữ trong nút và cung cấp quyền truy cập không phải const vào phần chính của phần tử (<code>mapped_type</code>) và phần được ánh xạ của phần tử (</p>
<p>). Nếu xử lý nút phá hủy trong khi giữ nút, nút sẽ bị phá hủy đúng cách bằng cách sử dụng bộ phân bổ thích hợp cho container. Tay cầm nút chứa một bản sao của bộ phân bổ container. Điều này là cần thiết để tay cầm nút có thể vượt qua container.<span class="coMULTI">Loại tay cầm nút chính xác (hiển thị ở đây là</span>/ * tay cầm nút */<code>node_type</code>.</p>
<p>) không xác định, nhưng mỗi container hiển thị loại xử lý nút của nó là thành viên<code><a href="map" title="cpp/container/map">std::map</a></code>Tay cầm nút có thể được sử dụng để chuyển quyền sở hữu một phần tử giữa hai container kết hợp có cùng một khóa, giá trị và loại phân bổ (bỏ qua so sánh hoặc băm/bình đẳng), mà không gọi bất kỳ hoạt động sao chép/di chuyển nào trên phần tử container (loại hoạt động này được gọi là "ghép"). Chuyển giao giữa các thùng chứa độc đáo và không duy nhất cũng được cho phép: một tay cầm nút từ một<code><a href="multimap" title="cpp/container/multimap">std::multimap</a></code>có thể được chèn vào một<code><a href="unordered_map" title="cpp/container/unordered map">std::unordered_map</a></code>hoặc<code><a href="set" title="cpp/container/set">std::set</a></code>.</p>
<p>, nhưng không vào<code>extract</code>.</p>
<p>Một tay cầm nút có thể trống, trong trường hợp nó không giữ phần tử và không có bộ phân bổ. Tay cầm nút được xây dựng và di chuyển mặc định là trống. Ngoài ra, một tay cầm nút trống có thể được tạo ra bởi một cuộc gọi không thành công cho chức năng thành viên container</p>
<p>Con trỏ và tham chiếu đến một phần tử thu được trong khi nó được sở hữu bởi một tay cầm nút bị vô hiệu nếu phần tử được chèn thành công vào một thùng chứa.<code><a href="map" title="cpp/container/map">std::map</a></code>Thì<code><a href="multimap" title="cpp/container/multimap">std::multimap</a></code>Thì<code><a href="unordered_map" title="cpp/container/unordered map">std::unordered_map</a></code>, Và<code><a href="unordered_multimap" title="cpp/container/unordered multimap">std::unordered_multimap</a></code>Đối với tất cả các thùng chứa bản đồ (<code>key_type</code>khoảng cách<code>K</code>Và<code>mapped_type</code>khoảng cách<code>T</code>) của ai<code><a href="../utility/pair" title="cpp/utility/pair">std::pair</a></code>, Hành vi của các hoạt động liên quan đến xử lý nút không được xác định nếu một chuyên gia do người dùng xác định<a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1099">Điều đó cho tất cả<span class="me2">đôi</span></span></a><span class="sy1">is_trivently_destructible_v</span>K, t<span class="sy1">&lt;</span>hoặc<a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1099">Điều đó cho tất cả<span class="me2">đôi</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span>K, t<span class="sy1">&lt;</span>.</p>
<h3 id="Member_types">nhà điều hành ()</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>ATOMIC_UNSIGNED_LOCK_FREE</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code>key_type</code><span class="t-mark">ánh xạ_type &amp; ánh xạ () const;</span> </td> <td>(Chỉ bản đồ container)</td>
</tr> <tr class="t-dsc"> <td> <code>mapped_type</code><span class="t-mark">ánh xạ_type &amp; ánh xạ () const;</span> </td> <td>(Chỉ bản đồ container)</td>
</tr> <tr class="t-dsc"> <td> <code>value_type</code><span class="t-mark">value_type &amp; value () const;</span> </td> <td>(Chỉ đặt container)</td>
</tr> <tr class="t-dsc"> <td> <code>allocator_type</code> </td> <td>phần tử được lưu trữ trong nút</td>
</tr> </table> <h3 id="Member_functions">nếu không thì</h3> <div class="t-member"> <h2 id="constructors">người xây dựng</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">bộ phân bổ sẽ được sử dụng khi phá hủy phần tử</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">ConstExpr / * nút-Handle * /() NoExcept;</pre>
</td> <td>(2)</td> <td class="t-dcl-nopad"> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>/ * Node-Handle */(/ * Node-Handle */&amp;&amp; NH) NOExcept;</div> <div class="t-li1">
<span class="t-li">2)</span>Trình xây dựng mặc định khởi tạo tay cầm nút đến trạng thái trống.<code>nh</code>Trình xây dựng di chuyển có quyền sở hữu phần tử container từ<code>nh</code>, di chuyển-cấu trúc người phân bổ thành viên và lá</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và các phân bổ không so sánh bằng nhau.</td> <td>-</td> <td>NH</td>
</tr>
</table> <h3 id="Notes">Ghi chú</h3> <p>Một tay cầm nút có cùng loại (không nhất thiết phải cùng một thùng chứa)</p>
</div> <h2 id="operator.3D">chuyên môn)</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">Tay cầm nút chỉ di chuyển, hàm tạo sao chép không được xác định.</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <ul>
<li>~/ * Node-Handle */();</li>
<ul>
<li>Nếu tay cầm nút không trống,<code>value_type</code>phá hủy<code>std::allocator_traits&lt;allocator_type&gt;::destroy</code>Số lượng các yếu tố để sao chép</li>
<li>Allocator_Type<a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span>Hành vi không được xác định nếu cả hai nút không trống và<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">Allocator_Type</span><span class="sy1">is_trivently_destructible_v</span><span class="coMULTI">rebind_traits</span><span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">/ * container-node-type */</span>Số lượng các yếu tố để sao chép</li>
</ul>
<li>Giải quyết<code>nh</code>Số lượng các yếu tố để sao chép</li>
<li>Có được quyền sở hữu phần tử container từ<a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span>Hành vi không được xác định nếu cả hai nút không trống và<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">Allocator_Type</span>khoảng cách<code>true</code>Tuyên truyền_on_container_move_assignment<code>nh</code>Số lượng các yếu tố để sao chép</li>
<li>, di chuyển-thiết kế bộ phân bổ từ<code>nh</code>bộ</li>
</ul> <p>đến trạng thái trống.<a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span>Hành vi không được xác định nếu cả hai nút không trống và<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">Allocator_Type</span>khoảng cách<code>false</code>Tuyên truyền_on_container_swap</p>
<h3 id="Parameters_2">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và các phân bổ không so sánh bằng nhau.</td> <td>-</td> <td>NH</td>
</tr>
</table> <h3 id="Return">Tay cầm nút có cùng loại (không nhất thiết phải cùng một thùng chứa)</h3> <p><code>*this</code></p>
<h3 id="Exceptions">Ngoại lệ</h3> <p>Không ném gì.</p>
<h3 id="Notes_2">Ghi chú</h3> <p>Trở lại</p>
<h2 id="destructor">Tay cầm nút chỉ di chuyển, gán bản sao không được xác định.</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">người phá hủy</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <ul>
<li>~/ * Node-Handle */();</li>
<ul>
<li>Nếu tay cầm nút không trống,<code>value_type</code>phá hủy<a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span>Hành vi không được xác định nếu cả hai nút không trống và<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">(Niebloid)</span>Số lượng các yếu tố để sao chép</li>
<li>Allocator_Type<a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span>Hành vi không được xác định nếu cả hai nút không trống và<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">Allocator_Type</span><span class="sy1">is_trivently_destructible_v</span><span class="coMULTI">rebind_traits</span><span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">/ * container-node-type */</span>.</li>
</ul>
</ul> <div class="t-member"> <h2 id="empty">trống</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">Giải quyết</pre></td> <td class="t-dcl-nopad"> </td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">bool trống () const noexcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Mẫu &lt;Class execPolicy,<code>true</code>Chuyển đổi thành<code>false</code>Nếu đối số đầu tiên là</p>
</div> <div class="t-member"> <h2 id="operator_bool">(hằng số thành viên tĩnh công cộng)</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">Nếu tay cầm nút trống,</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>toán tử rõ ràng bool () const noexcept;<code>false</code>Chuyển đổi thành<code>true</code>Nếu đối số đầu tiên là</p>
</div> <div class="t-member"> <h2 id="get_allocator">phá hủy các</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">Nếu tay cầm nút trống,</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>allocator_type get_allocator () const;</p>
<h3 id="Exceptions_2">Ngoại lệ</h3> <p>Không ném gì.</p>
</div> <div class="t-member"> <h2 id="value">được phân vùng liên quan đến</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">Trả về một bản sao của bộ phân bổ được lưu trữ (là bản sao của bộ phân bổ của thùng chứa nguồn). Hành vi không được xác định nếu tay cầm nút trống.</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark">value_type &amp; value () const;</span> </td> </tr> </table> <p>(Chỉ bản đồ container)<code>value_type</code>Thành viên của</p>
<h3 id="Exceptions_3">Ngoại lệ</h3> <p>Không ném gì.</p>
</div> <div class="t-member"> <h2 id="key">Hành vi không được xác định nếu mảng chưa được phân vùng theo thứ tự tăng dần đối với khóa, theo cùng một tiêu chí</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">SubObject trong đối tượng phần tử container được quản lý bởi tay cầm nút này. Hành vi không được xác định nếu tay cầm nút trống.</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark">ánh xạ_type &amp; ánh xạ () const;</span> </td> </tr> </table> <p>(Chỉ bản đồ container)<code>key_type</code>Trả về một tham chiếu đến<code>value_type</code>Thành viên của</p>
<h3 id="Exceptions_4">Ngoại lệ</h3> <p>Không ném gì.</p>
<h3 id="Notes_3">Ghi chú</h3> <p>SubObject trong đối tượng phần tử container được quản lý bởi tay cầm nút này. Hành vi không được xác định nếu tay cầm nút trống.</p>
</div> <div class="t-member"> <h2 id="mapped">Hàm này cho phép sửa đổi khóa của một nút được trích xuất từ ​​bản đồ, sau đó gửi lại nó vào bản đồ, mà không bao giờ sao chép hoặc di chuyển phần tử.</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">ánh xạ</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark">ánh xạ_type &amp; ánh xạ () const;</span> </td> </tr> </table> <p>(Chỉ bản đồ container)<code>mapped_type</code>Trả về một tham chiếu đến<code>value_type</code>Thành viên của</p>
<h3 id="Exceptions_5">Ngoại lệ</h3> <p>Không ném gì.</p>
</div> <h2 id="swap">Được xác định trong tiêu đề</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">SubObject trong đối tượng phần tử container được quản lý bởi tay cầm nút này. Hành vi không được xác định nếu tay cầm nút trống.</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <ul>
<li>void hoán đổi (/ * nút-tay hiệu */&amp; NH) noExcept (/ * xem bên dưới */);</li>
<li>hoán đổi quyền sở hữu các nút container;<a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span>Hành vi không được xác định nếu cả hai nút không trống và<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">và các phân bổ không so sánh bằng nhau.</span>khoảng cách<code>true</code>Tuyên truyền_on_container_swap</li>
</ul> <p>, hoán đổi các phân bổ là tốt.<a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span>Hành vi không được xác định nếu cả hai nút không trống và<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">và các phân bổ không so sánh bằng nhau.</span>khoảng cách<code>false</code>Tuyên truyền_on_container_swap</p>
<h3 id="Exceptions_6">Ngoại lệ</h3> <div class="t-noexcept-full">
<a href="../language/noexcept_spec" title="cpp/language/noexcept spec"><code>noexcept</code></a>Đặc điểm kỹ thuật:<div class="t-noexcept-box"><span class="t-cc"><code><span class="kw1">Noexcept</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span>allocator_type<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">và các phân bổ không so sánh bằng nhau.</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span> <span class="sy3">Mẫu &lt;std :: forward_iterator i1, std :: sentinel_for &lt;i1&gt; s1,</span><br/> <a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span>allocator_type<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">Tuyên truyền_on_container_swap</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span><span class="br0">)</span></code></span></div>
</div> <h3 id="Non-member_functions">Các chức năng không phải thành viên</h3> <div class="t-member"> <h2 id="swap_2">Được xác định trong tiêu đề</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">is_always_equal</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>bạn bè hoán đổi void (/ * Node-Handle */&amp; x,/ * Node-Handle */&amp; y) noExcept (noexcept (x.swap (y)));<code>x.swap(y)</code>.</p>
<p>Thực thi hiệu quả<a href="../language/unqualified_lookup" title="cpp/language/unqualified lookup">unqualified</a>hoặc<a href="../language/qualified_lookup" title="cpp/language/qualified lookup">qualified lookup</a>Chức năng này không thể nhìn thấy thông thường<a href="../language/adl" title="cpp/language/adl">argument-dependent lookup</a>Chuyển đổi danh tính:<code><i>và chỉ có thể được tìm thấy bởi</i></code>Hương hiệu nút</p>
</div> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/node_handle">https://en.cppreference.com/w/cpp/container/node_handle</a>
</p>
</div>
