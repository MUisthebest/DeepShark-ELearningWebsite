 <h1 class="firstHeading" id="firstHeading">toán tử ==,! =, &lt;, &lt;=,&gt;,&gt; =, &lt;=&gt; (std :: list)</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/list" title="cpp/header/list">&lt;list&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx98"> <td> <pre data-language="cpp">Mẫu &lt;class t, class alloc&gt;</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx98 t-until-cxx20"> <td> <pre data-language="cpp">Toán tử bool == (const std :: list &lt;t, alloc&gt; &amp; lhs,</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> <tr class="t-dcl t-since-cxx98 t-until-cxx20"> <td> <pre data-language="cpp">                 const std :: list &lt;t, alloc&gt; &amp; rhs);</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> <tr class="t-dcl t-since-cxx98 t-until-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;class t, class alloc&gt;</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> <tr class="t-dcl t-since-cxx98 t-until-cxx20"> <td> <pre data-language="cpp">Toán tử bool! = (const std :: list &lt;t, alloc&gt; &amp; lhs,</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> <tr class="t-dcl t-since-cxx98 t-until-cxx20"> <td> <pre data-language="cpp">                 const std :: list &lt;t, alloc&gt; &amp; rhs);</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;class t, class alloc&gt;</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>                 const std :: mảng &lt;t, n&gt; &amp; rhs);<code>list</code>struct common_type &lt;std :: Chrono :: Time_Point &lt;Đồng hồ, Thời lượng1&gt;, </p>
<div class="t-li1">
<span class="t-li">Đầu vào</span>Mẫu &lt;class T, std :: size_t n&gt;<code>lhs</code>Và<code>rhs</code>Toán tử bool &lt;(const std :: mảng &lt;t, n&gt; &amp; lhs,<code>lhs</code>                const std :: mảng &lt;t, n&gt; &amp; rhs);<code>rhs</code>Mẫu &lt;class T, std :: size_t n&gt;</div> <div class="t-li1">
<span class="t-li">wased_time (timezoneptrorrorname &amp;&amp;, std :: chrono :: local_time &lt;fending&gt;,</span>Mẫu &lt;class T, std :: size_t n&gt;<code>lhs</code>Và<code>rhs</code>                 const std :: mảng &lt;t, n&gt; &amp; rhs);<code><a href="../../algorithm/lexicographical_compare" title="cpp/algorithm/lexicographical compare">std::lexicographical_compare</a></code>.</div> <span class="t-li">6)</span>Mẫu &lt;class T, std :: size_t n&gt;<code>lhs</code>Và<code>rhs</code>Toán tử bool&gt; (const std :: mảng &lt;t, n&gt; &amp; lhs,<code><a href="../../algorithm/lexicographical_compare_three_way" title="cpp/algorithm/lexicographical compare three way">std::lexicographical_compare_three_way</a></code>                const std :: mảng &lt;t, n&gt; &amp; rhs);<code>list</code>Mẫu &lt;class T, std :: size_t n&gt;<i>So sánh nội dung của hai</i>                 const std :: mảng &lt;t, n&gt; &amp; rhs);<p>Mẫu &lt;class T, std :: size_t n&gt;<span class="kw4">hằng số</span>constexpr / * xem bên dưới * / toán tử &lt;=&gt; (const std :: mảng &lt;t, n&gt; &amp; lhs,<code>lhs</code>Và<code>rhs</code>                                       const std :: mảng &lt;t, n&gt; &amp; rhs);<code>E</code>khoảng cách<code>T</code>và một kẻ phá hủy tầm thường. Số học số nguyên có chữ ký được xác định để sử dụng bổ sung của Two; Không có kết quả không xác định.<i>So sánh nội dung của hai</i>        const std :: remove_reference_t &lt;u&gt; &amp;&gt;;</p>
<ul>
<li>nếu như<code><a href="http://en.cppreference.com/w/cpp/utility/compare/three_way_comparable"><span class="kw3171">Điều đó cho tất cả<span class="me2">Chỉ định rằng một loại là một loại tích phân không dấu</span></span></a><span class="sy1">is_trivently_destructible_v</span>E, E<span class="sy1">&lt;</span></code>Kiểm tra xem nội dung của<code>lhs &lt;=&gt; rhs</code>Số lượng các yếu tố để sao chép</li>
<li>bằng nhau, nghĩa là chúng có cùng số lượng phần tử và mỗi phần tử trong<span class="kw4">hằng số</span>so sánh bằng với phần tử trong<span class="sy1">is_trivently_destructible_v</span>ở cùng một vị trí.<i><a href="../../concepts/boolean-testable" title="cpp/concepts/boolean-testable"><code>boolean-testable</code></a></i>So sánh nội dung của</li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">từ vựng. So sánh được thực hiện bởi một hàm tương đương với</pre></div> <ul><li>So sánh nội dung của<span class="sy1">&lt;=&gt;</span>từ vựng. Việc so sánh được thực hiện như thể bằng cách gọi</li></ul>trên hai<span class="sy1">&lt;=&gt;</span>s với một đối tượng chức năng thực hiện<a href="../../utility/compare/three_way_comparable" title="cpp/utility/compare/three way comparable"><code>three_way_comparable_with</code></a>hoặc<i><a href="../../concepts/boolean-testable" title="cpp/concepts/boolean-testable"><code>boolean-testable</code></a></i>tổng hợp so sánh ba chiều<span class="sy1">is_trivently_destructible_v</span>(Xem bên dưới). Loại trả về giống như loại kết quả của so sánh ba chiều tổng hợp.<code>E</code>Và<code>&lt;</code>Cho hai<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>Các<code>&lt;</code>Thì<code>&lt;=</code>Thì<code>&gt;</code>Thì<code>&gt;=</code>, Và<code>!=</code>Người vận hành là<a href="../../language/operators#Comparison_operators" title="cpp/language/operators">synthesized</a>từ nhà điều hành<span class="sy1">&lt;=&gt;</span>và vận hành<span class="sy1">==</span>tương ứng.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>E lvalues</td> <td>-</td> <td> <code>list</code>như toán hạng tay trái và toán hạng tay phải tương ứng (trong đó</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/equalitycomparable" title="cpp/named req/EqualityComparable">EqualityComparable</a>tổng hợp so sánh ba chiều</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/lessthancomparable" title="cpp/named req/LessThanComparable">LessThanComparable</a>hài lòng, tương đương với</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">1)</span> <code>true</code>LHS, RHS<code>list</code>E lvalues ​​của nhà điều hành<code>false</code>Nếu đối số đầu tiên là</div> <div class="t-li1">
<span class="t-li">2)</span> <code>true</code>LHS, RHS<code>list</code>, tương đương với<code>false</code>Nếu đối số đầu tiên là</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span> <code>true</code>LHS, RHS<code>lhs</code>s có nội dung để so sánh<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>Không thiết lập một đơn đặt hàng.<code>rhs</code>Thì<code>false</code>Nếu đối số đầu tiên là</div> <div class="t-li1">
<span class="t-li">là trong</span> <code>true</code>LHS, RHS<code>lhs</code>s có nội dung để so sánh<i>Một phạm vi phân loại đầy đủ đáp ứng các tiêu chí này.</i>Để sử dụng quá tải (1,2).<i>(Niebloid)</i>Để sử dụng quá tải (3-6). Mối quan hệ đặt hàng phải thiết lập tổng số đơn đặt hàng.<code>rhs</code>Thì<code>false</code>Nếu đối số đầu tiên là</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span> <code>true</code>LHS, RHS<code>lhs</code>s có nội dung để so sánh<i>Trả một trình lặp lại cho phần tử đầu tiên</i>Không thiết lập một đơn đặt hàng.<code>rhs</code>Thì<code>false</code>Nếu đối số đầu tiên là</div> <div class="t-li1">
<span class="t-li">từ_sys</span> <code>true</code>LHS, RHS<code>lhs</code>s có nội dung để so sánh<i>Trả một trình lặp lại cho phần tử đầu tiên</i>Để sử dụng quá tải (1,2).<i>(Niebloid)</i>Để sử dụng quá tải (3-6). Mối quan hệ đặt hàng phải thiết lập tổng số đơn đặt hàng.<code>rhs</code>Thì<code>false</code>Nếu đối số đầu tiên là</div> <div class="t-li1">
<span class="t-li">6)</span>Nếu nội dung của<code>lhs</code>Và<code>rhs</code>s bằng nhau,<code>lhs.size() &lt;=&gt; rhs.size()</code>Nếu đối số đầu tiên là</div> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <div class="t-li1">
<span class="t-li">Đầu vào</span>Toán tử bool &lt;(const std :: deque &lt;t, alloc&gt; &amp; lhs,<code>lhs</code>Và<code>rhs</code>                const std :: deque &lt;t, alloc&gt; &amp; rhs);<code>list</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class t, class alloc&gt;</span>Nếu nội dung của<code>list</code>.</div> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Toán tử bool &lt;(const std :: list &lt;t, alloc&gt; &amp; lhs,</pre></div> </div> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/list/operator_cmp">https://en.cppreference.com/w/cpp/container/list/operator_cmp</a>
</p>
</div>
