 <h1 class="firstHeading" id="firstHeading">std :: unetered_multimap &lt;key, t, băm, keyequal, phân bổ&gt; :: toán tử =</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">unetered_multimap &amp; toán tử = (const unedered_multimap &amp; other);</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(2)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx17"> <td><pre data-language="cpp">unetered_multimap &amp; toán tử = (unetered_multimap &amp;&amp; khác);</pre></td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx17">xáo trộn</span>
</td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">unetered_multimap &amp; toán tử = (unetered_multimap &amp;&amp; khác) noExcept (/ * xem bên dưới */);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">unetered_multimap &amp; toán tử = (std :: initizer_list &lt;value_type&gt; ilist);</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> </table> <p>void gán (std :: initizer_list &lt;t&gt; ilist);</p>
<div class="t-li1">
<span class="t-li">1)</span>Sao chép toán tử gán. Thay thế nội dung bằng một bản sao nội dung của<code>other</code>.</div> <div class="t-li1">Nếu như<code><a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span>allocator_type<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">Tuyên truyền_on_container_copy_assignment</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span></code>khoảng cách<code>true</code>, người phân bổ của<code>*this</code>được thay thế bằng một bản sao của<code>other</code>. Nếu người phân bổ của<code>*this</code>Sau khi gán sẽ so sánh không đồng đều với giá trị cũ của nó, bộ phân bổ cũ được sử dụng để phân phối bộ nhớ, sau đó bộ phân bổ mới được sử dụng để phân bổ nó trước khi sao chép các yếu tố. Nếu không, bộ nhớ thuộc sở hữu của<code>*this</code>có thể được sử dụng lại khi có thể. Trong mọi trường hợp, các yếu tố ban đầu thuộc<code>*this</code>có thể bị phá hủy hoặc thay thế bằng cách ký kết bản sao nguyên tố.</div> <div class="t-li1">
<span class="t-li">2)</span>Di chuyển toán tử chuyển nhượng. Thay thế nội dung bằng các nội dung của<code>other</code>sử dụng ngữ nghĩa di chuyển (tức là dữ liệu trong<code>other</code>được chuyển từ<code>other</code>vào container này).<code>other</code>ở trong trạng thái hợp lệ nhưng không xác định sau đó.</div> <div class="t-li1">Nếu như<code><a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span>allocator_type<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">Allocator_Type</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span></code>khoảng cách<code>true</code>, người phân bổ của<code>*this</code>được thay thế bằng một bản sao của bản sao của<code>other</code>. Nếu nó là<code>false</code>và những người phân bổ của<code>*this</code>Và<code>other</code>Không so sánh bằng nhau,<code>*this</code>không thể sở hữu bộ nhớ thuộc sở hữu của<code>other</code>và phải di chuyển từng phần tử riêng lẻ, phân bổ bộ nhớ bổ sung bằng cách sử dụng bộ phân bổ riêng của nó khi cần thiết. Trong mọi trường hợp, tất cả các yếu tố ban đầu thuộc<code>*this</code>bị phá hủy hoặc thay thế bằng cách gán di chuyển theo yếu tố.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Thay thế nội dung bằng các nội dung được xác định bởi danh sách khởi tạo<code>ilist</code>.</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>khác</td> <td>-</td> <td>một thùng chứa khác để sử dụng làm nguồn dữ liệu</td>
</tr> <tr class="t-par"> <td>Quá tải</td> <td>-</td> <td>Danh sách khởi tạo để sử dụng làm nguồn dữ liệu</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code>*this</code></p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <div class="t-li1">
<span class="t-li">1)</span>Tuyến tính trong kích thước của<code>*this</code>Và<code>other</code>.</div> <div class="t-li1">
<span class="t-li">2)</span>Tuyến tính trong kích thước của<code>*this</code>Trừ khi các phân bổ không so sánh bằng nhau và không tuyên truyền, trong trường hợp đó tuyến tính về kích thước của<code>*this</code>Và<code>other</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Tuyến tính trong kích thước của<code>*this</code>Và<code>ilist</code>.</div> <h3 id="Exceptions">Ngoại lệ</h3> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <p>Có thể ném các trường hợp ngoại lệ do thực hiện.</p>
</td> <td><span class="t-mark-rev t-until-cxx17">xáo trộn</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <span class="t-li">(Do đó,</span>Có thể ném các trường hợp ngoại lệ do thực hiện.<span class="t-li">2)</span> <div class="t-noexcept-full">
<a href="../../language/noexcept_spec" title="cpp/language/noexcept spec"><code>noexcept</code></a>Đặc điểm kỹ thuật:<div class="t-noexcept-box"><span class="t-cc"><code><span class="kw1">Noexcept</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span>Allocator<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">Tuyên truyền_on_container_swap</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span><br/> <p><span class="sy3">. Trong các cuộc gọi có hiệu lực</span> <a href="http://en.cppreference.com/w/cpp/types/is_move_assignable"><span class="kw567">Điều đó cho tất cả<span class="me2">is_nothrow_move_assignable</span></span></a><span class="sy1">is_trivently_destructible_v</span>Băm<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span><br/></p>
<span class="sy3">. Trong các cuộc gọi có hiệu lực</span> <a href="http://en.cppreference.com/w/cpp/types/is_move_assignable"><span class="kw567">Điều đó cho tất cả<span class="me2">is_nothrow_move_assignable</span></span></a><span class="sy1">is_trivently_destructible_v</span>Pred<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span><span class="br0">)</span></code></span></div>
</div> </td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <h3 id="Notes">Ghi chú</h3> <p>Sau khi chuyển nhượng di chuyển container (quá tải<span class="t-v">(2)</span>), trừ khi việc chuyển nhượng di chuyển theo yếu tố bị ép buộc bởi các phân bổ, tài liệu tham khảo, con trỏ và trình lặp không tương thích<code>other</code>phạm vi<code>*this</code>để sao chép các yếu tố từ<a class="external text" href="https://eel.is/c++draft/container.reqmts#67" rel="nofollow">[container.reqmts]/67</a>một thùng chứa khác được sử dụng làm nguồn để khởi tạo các phần tử của container với<a class="external text" href="https://cplusplus.github.io/LWG/issue2321" rel="nofollow">LWG issue 2321</a>.</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example">
<p>Trong thực tế, việc triển khai<code>operator=</code>để gán một<code><a href="../unordered_multimap" title="cpp/container/unordered multimap">std::unordered_multimap</a></code>với người khác:</p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;Khai phạm_list&gt;</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">#include &lt;Istream&gt;</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="unordered_multimap" title="cpp/container/unordered multimap/unordered multimap"> <span class="t-lines"><span>chuyên môn)</span></span></a></div> </td> <td>Với kích thước nhỏ hơn không làm mất hiệu lực bất kỳ tài liệu tham khảo nào đối với các yếu tố không bị hỏng.<code>unordered_multimap</code> <br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/unordered_multimap/operator%3D">https://en.cppreference.com/w/cpp/container/unordered_multimap/operator%3D</a>
</p>
</div>
