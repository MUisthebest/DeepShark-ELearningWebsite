 <h1 class="firstHeading" id="firstHeading">std :: unetered_multimap &lt;key, t, băm, keyequal, phân bổ&gt; :: chèn</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/unordered_map" title="cpp/header/unordered map">&lt;unordered_map&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">iterator chèn (const value_type &amp; value);</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">iterator chèn (value_type &amp;&amp; value);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;Class P&gt;</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">std :: cặp &lt;iterator, bool&gt; chèn (p &amp;&amp; value);</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">iterator chèn (gợi ý const_iterator, const value_type &amp; value);</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">iterator chèn (const_iterator hint, value_type &amp;&amp; value);</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">iterator chèn (const_iterator pos, p &amp;&amp; value);</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">iterator chèn (const_iterator pos, value_type &amp;&amp; value);</pre>
</td> <td>            Nhị phân p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">iterator chèn (p &amp;&amp; value);</pre>
</td> <td>(9)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;Class P&gt;</pre>
</td> <td>(10)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <p>iterator chèn (node_type &amp;&amp; nh);</p>
<div class="t-li1">
<span class="t-li">Chuyển đổi danh tính. Trả lại</span>Chèn<code>value</code>.</div> <div class="t-li1">        // Một biến thể của C ++ 11 std :: Uniform_int_distribution thực hiện.<span class="t-v">(3)</span>Mẫu &lt;class T, class so sánh&gt;<code>emplace<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>P<span class="sy1">&lt;</span><span class="br0">.</span>value<span class="br0">)</span><span class="br0">)</span></code>Chèn (các) phần tử vào container, nếu container không chứa một phần tử có khóa tương đương.<code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw527">Điều đó cho tất cả<span class="me2">is_constructable</span></span></a><span class="sy1">is_trivently_destructible_v</span>value_type, P<span class="sy3">. Trong các cuộc gọi có hiệu lực</span><span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span> <span class="sy1">==</span> <span class="kw2">ĐÚNG VẬY</span></code>.</div> <div class="t-li1">
<span class="t-li">          lớp T,</span>Chèn<code>value</code>Mẫu &lt;class inputit, lớp đầu ra,<code>hint</code>iterator chèn (const_iterator gợi ý, p &amp;&amp; value);</div> <div class="t-li1">        // Một biến thể của C ++ 11 std :: Uniform_int_distribution thực hiện.<span class="t-v">Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</span>Mẫu &lt;class T, class so sánh&gt;<code>emplace_hint<span class="br0">.</span>hint, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>P<span class="sy1">&lt;</span><span class="br0">.</span>value<span class="br0">)</span><span class="br0">)</span></code>Chèn (các) phần tử vào container, nếu container không chứa một phần tử có khóa tương đương.<code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw527">Điều đó cho tất cả<span class="me2">is_constructable</span></span></a><span class="sy1">is_trivently_destructible_v</span>value_type, P<span class="sy3">. Trong các cuộc gọi có hiệu lực</span><span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span> <span class="sy1">==</span> <span class="kw2">ĐÚNG VẬY</span></code>.</div> <div class="t-li1">
<span class="t-li">6)</span>bản sao của<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>.</div> <div class="t-li1">Nếu như<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Cụ thể,<a href="../../iterator#Ranges" title="cpp/iterator">valid range</a>, hoặc<code>first</code>và/hoặc<code>last</code>đủ điều kiện là<code>*this</code>Hoạt động tương đương cho quá tải</div> <div class="t-li1">
<span class="t-li">. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu biểu thức</span>là người lặp vào<code>ilist</code>.</div> <div class="t-li1">
<span class="t-li">được hình thành tốt. Chương trình không được hình thành nếu</span>Nếu như<code>nh</code>, không làm gì cả. Nếu không, chèn phần tử thuộc sở hữu của<a href="../node_handle" title="cpp/container/node handle">node handle</a>. Nếu nhiều phần tử trong phạm vi có các khóa so sánh tương đương, thì nó không xác định phần tử nào được chèn (đang chờ xử lý<code>nh</code>vào thùng chứa và trả về một trình lặp chỉ vào phần tử được chèn. Hành vi không xác định nếu<code>nh</code>và trả về trình lặp chỉ vào phần tử với khóa tương đương với<code>get_allocator() != nh.get_allocator()</code>.</div> <div class="t-li1">
<span class="t-li">Toán tử bool constexpr&gt; (const std :: Chrono :: sys_time &lt;fending&gt; &amp; x,</span>Nếu như<code>nh</code>, không làm gì cả. Nếu không, chèn phần tử thuộc sở hữu của<a href="../node_handle" title="cpp/container/node handle">node handle</a>vào thùng chứa, nếu thùng chứa chưa chứa một phần tử có khóa tương đương với<code>nh</code>tồn tại trong container, phần tử được chèn vào cuối phạm vi đó. Hành vi không xác định nếu<code>nh.key()</code>.<code>hint</code>như một đề xuất không ràng buộc về nơi tìm kiếm sẽ bắt đầu.<code>nh</code>và trả về trình lặp chỉ vào phần tử với khóa tương đương với<code>get_allocator() != nh.get_allocator()</code>.</div> <p>Nếu sau khi hoạt động, số yếu tố mới lớn hơn cũ<code><a href="max_load_factor" title="cpp/container/unordered multimap/max load factor">max_load_factor()</a> * <a href="bucket_count" title="cpp/container/unordered multimap/bucket count">bucket_count()</a></code>Một sự hồi phục diễn ra.<br/>Nếu việc thử lại xảy ra (do chèn), tất cả các trình lặp đều bị vô hiệu. Mặt khác (không có thử lại), các trình lặp không bị vô hiệu.<span class="t-rev-inl t-since-cxx17"><span>(bất kể việc chèn đã thành công hay thất bại). Nếu việc chèn thành công,</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span></p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>) được gọi với chính xác các đối số giống như được cung cấp cho hàm, được chuyển tiếp với</td> <td>-</td> <td>được chuyển từ, nếu không, nó vẫn giữ quyền sở hữu yếu tố.</td>
</tr> <tr class="t-par"> <td>được phân vùng liên quan đến</td> <td>-</td> <td>người lặp lại)</td>
</tr> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>được chuyển từ, nếu không, nó vẫn giữ quyền sở hữu yếu tố. Phần tử được chèn càng gần càng tốt với vị trí ngay trước khi</td>
</tr> <tr class="t-par"> <td>Quá tải</td> <td>-</td> <td>Phạm vi của các phần tử cần chèn, không thể là người rút vào thùng chứa mà chèn được gọi</td>
</tr> <tr class="t-par"> <td>và các phân bổ không so sánh bằng nhau.</td> <td>-</td> <td>không trống và<a href="../node_handle" title="cpp/container/node handle">node handle</a> </td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>InputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">Kết thúc Iterator nếu</span>iterator xuất hiện (args &amp;&amp; ... args);</div> <div class="t-li1">
<span class="t-li">      std :: memory_order thành công, std :: memory_order thất bại) NoExcept;</span>Gán cho đã cho</div> <div class="t-li1">
<span class="t-li">Không có bảo đảm an toàn ngoại lệ.</span>Nếu việc chèn không thành công,<code>nh</code>9,10)</div> <h3 id="Exceptions">Ngoại lệ</h3> <div class="t-li1">
<span class="t-li">Kết thúc Iterator nếu</span>Nếu một ngoại lệ được ném vì bất kỳ lý do gì, các chức năng này không có hiệu lực (<a href="../../language/exceptions#Exception_safety" title="cpp/language/exceptions">strong exception safety guarantee</a>).</div> <div class="t-li1">
<span class="t-li">      std :: memory_order thành công, std :: memory_order thất bại) NoExcept;</span>trống rỗng, tererator trỏ đến phần tử được chèn khác.</div> <div class="t-li1">
<span class="t-li">Không có bảo đảm an toàn ngoại lệ.</span>Nếu một ngoại lệ được ném vì bất kỳ lý do gì, các chức năng này không có hiệu lực (<a href="../../language/exceptions#Exception_safety" title="cpp/language/exceptions">strong exception safety guarantee</a>).</div> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <div class="t-li1">
<span class="t-li">Kết thúc Iterator nếu</span>Trường hợp trung bình:<code>O(1)</code>, trường hợp xấu nhất<code>O(size())</code>.</div> <div class="t-li1">
<span class="t-li">      std :: memory_order thành công, std :: memory_order thất bại) NoExcept;</span>Trường hợp trung bình:<code>O(N)</code>bao gồm một bộ lặp vào phần tử được chèn (hoặc cho phần tử ngăn chặn việc chèn) và một<code>O(N * size() + N)</code>.</div> <div class="t-li1">
<span class="t-li">Không có bảo đảm an toàn ngoại lệ.</span>Trường hợp trung bình:<code>O(1)</code>, trường hợp xấu nhất<code>O(size())</code>.</div> <h3 id="Example">Ví dụ</h3> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2005" rel="nofollow">LWG 2005</a> </td> <td>C ++ 11</td> <td>Sửa đổi điểm thời gian<span class="t-v">                    Giảm khóm,</span>#include &lt;Istream&gt;<br/>#include &lt;chuỗi&gt;<code>P</code>. Hàm tạo này chỉ tham gia vào độ phân giải quá tải nếu<code>value_type</code> </td> <td>#include &lt;unordered_map&gt;<code>value_type</code><br/> <code>P&amp;&amp;</code> </td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="emplace" title="cpp/container/unordered multimap/emplace"> <span class="t-lines"><span>Giảm sử dụng bộ nhớ bằng cách giải phóng bộ nhớ không sử dụng</span></span></a></div> </td> <td>Xóa nội dung<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="emplace_hint" title="cpp/container/unordered multimap/emplace hint"> <span class="t-lines"><span>so sánh</span></span></a></div> </td> <td>(riêng tư)<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../iterator/inserter" title="cpp/iterator/inserter"> <span class="t-lines"><span>người đưa vào</span></span></a></div> </td> <td>tạo ra a<code><a href="../../iterator/insert_iterator" title="cpp/iterator/insert iterator">std::insert_iterator</a></code>loại được suy ra từ đối số<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/unordered_multimap/insert">https://en.cppreference.com/w/cpp/container/unordered_multimap/insert</a>
</p>
</div>
