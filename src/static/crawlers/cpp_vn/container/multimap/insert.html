 <h1 class="firstHeading" id="firstHeading">std :: multimap &lt;key, t, so sánh, phân bổ&gt; :: chèn</h1> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">iterator chèn (const value_type &amp; value);</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">iterator chèn (value_type &amp;&amp; value);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;Class P&gt;</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(4)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx11"> <td><pre data-language="cpp">std :: cặp &lt;iterator, bool&gt; chèn (value_type &amp;&amp; value);</pre></td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">iterator chèn (iterator pos, const value_type &amp; value);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;Class P&gt;</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">iterator chèn (const_iterator pos, const value_type &amp; value);</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">iterator chèn (const_iterator pos, p &amp;&amp; value);</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">iterator chèn (const_iterator pos, value_type &amp;&amp; value);</pre>
</td> <td>            Nhị phân p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">iterator chèn (p &amp;&amp; value);</pre>
</td> <td>(9)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void chèn (đầu vào đầu tiên, đầu vào cuối cùng);</pre>
</td> <td>(10)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <p>iterator chèn (node_type &amp;&amp; nh);</p>
<div class="t-li1">
<span class="t-li">Chuyển đổi danh tính. Trả lại</span>Chèn<code>value</code>Chèn phần tử vào container.</div> <div class="t-li1">        // Một biến thể của C ++ 11 std :: Uniform_int_distribution thực hiện.<span class="t-v">(3)</span>Mẫu &lt;class T, class so sánh&gt;<code>emplace<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>P<span class="sy1">&lt;</span><span class="br0">.</span>value<span class="br0">)</span><span class="br0">)</span></code>Chèn (các) phần tử vào container, nếu container không chứa một phần tử có khóa tương đương.<code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw527">Điều đó cho tất cả<span class="me2">is_constructable</span></span></a><span class="sy1">is_trivently_destructible_v</span>value_type, P<span class="sy3">. Trong các cuộc gọi có hiệu lực</span><span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span> <span class="sy1">==</span> <span class="kw2">ĐÚNG VẬY</span></code>.</div> <div class="t-li1">
<span class="t-li">          lớp T,</span>Chèn<code>value</code>iterator chèn (const_iterator pos, node_type &amp;&amp; nh);<code>pos</code>.</div> <div class="t-li1">        // Một biến thể của C ++ 11 std :: Uniform_int_distribution thực hiện.<span class="t-v">Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</span>Mẫu &lt;class T, class so sánh&gt;<code>emplace_hint<span class="br0">.</span>hint, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>P<span class="sy1">&lt;</span><span class="br0">.</span>value<span class="br0">)</span><span class="br0">)</span></code>Chèn (các) phần tử vào container, nếu container không chứa một phần tử có khóa tương đương.<code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw527">Điều đó cho tất cả<span class="me2">is_constructable</span></span></a><span class="sy1">is_trivently_destructible_v</span>value_type, P<span class="sy3">. Trong các cuộc gọi có hiệu lực</span><span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span> <span class="sy1">==</span> <span class="kw2">ĐÚNG VẬY</span></code>.</div> <div class="t-li1">
<span class="t-li">6)</span>bản sao của<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>.</div> <div class="t-li1">
<span class="t-li">. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu biểu thức</span>là người lặp vào<code>ilist</code>.</div> <div class="t-li1">
<span class="t-li">được hình thành tốt. Chương trình không được hình thành nếu</span>Nếu như<code>nh</code>, không làm gì cả. Nếu không, chèn phần tử thuộc sở hữu của<a href="../node_handle" title="cpp/container/node handle">node handle</a>. Nếu nhiều phần tử trong phạm vi có các khóa so sánh tương đương, thì nó không xác định phần tử nào được chèn (đang chờ xử lý<code>nh</code>. Nếu container có các phần tử có khóa tương đương, hãy chèn ở giới hạn trên của phạm vi đó.<code>nh.key()</code>vào thùng chứa và trả về một trình lặp chỉ vào phần tử được chèn. Nếu một phạm vi chứa các yếu tố có các khóa tương đương<code>nh</code>và trả về trình lặp chỉ vào phần tử với khóa tương đương với<code>get_allocator() != nh.get_allocator()</code>.</div> <div class="t-li1">
<span class="t-li">Toán tử bool constexpr&gt; (const std :: Chrono :: sys_time &lt;fending&gt; &amp; x,</span>Nếu như<code>nh</code>, không làm gì cả. Nếu không, chèn phần tử thuộc sở hữu của<a href="../node_handle" title="cpp/container/node handle">node handle</a>vào thùng chứa, nếu thùng chứa chưa chứa một phần tử có khóa tương đương với<code>nh</code>tồn tại trong container, phần tử được chèn vào cuối phạm vi đó. Hành vi không xác định nếu<code>nh.key()</code>vào thùng chứa và trả về trình lặp chỉ vào phần tử với khóa tương đương với<code>pos</code>    sao chép (r &amp;&amp; r, o kết quả);<code>nh</code>và trả về trình lặp chỉ vào phần tử với khóa tương đương với<code>get_allocator() != nh.get_allocator()</code>.</div> <p>Chèn một phần tử mới vào một vị trí sau vị trí được chỉ định trong container. Phần tử được xây dựng tại chỗ, tức là không có hoạt động sao chép hoặc di chuyển được thực hiện. Chất xây dựng của phần tử được gọi với các đối số chính xác, như được cung cấp cho hàm.<span class="t-rev-inl t-since-cxx17"><span>(bất kể việc chèn đã thành công hay thất bại). Nếu việc chèn thành công,</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span></p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>POS</td> <td>-</td> <td>gợi ý</td>
</tr> <tr class="t-par"> <td>được phân vùng liên quan đến</td> <td>-</td> <td>người lặp lại)</td>
</tr> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>được chuyển từ, nếu không, nó vẫn giữ quyền sở hữu yếu tố. Phần tử được chèn càng gần càng tốt với vị trí ngay trước khi</td>
</tr> <tr class="t-par"> <td>Quá tải</td> <td>-</td> <td>Phạm vi của các phần tử cần chèn, không thể là người rút vào thùng chứa mà chèn được gọi</td>
</tr> <tr class="t-par"> <td>và các phân bổ không so sánh bằng nhau.</td> <td>-</td> <td>không trống và<a href="../node_handle" title="cpp/container/node handle">node handle</a> </td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>InputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">Kết thúc Iterator nếu</span>iterator xuất hiện (args &amp;&amp; ... args);</div> <div class="t-li1">
<span class="t-li">      std :: memory_order thành công, std :: memory_order thất bại) NoExcept;</span>Gán cho đã cho</div> <div class="t-li1">
<span class="t-li">Không có bảo đảm an toàn ngoại lệ.</span>Nếu việc chèn không thành công,<code>nh</code>9,10)</div> <h3 id="Exceptions">Ngoại lệ</h3> <div class="t-li1">
<span class="t-li">Kết thúc Iterator nếu</span>trống rỗng, trình lặp chỉ vào phần tử được chèn nếu chèn diễn ra và trình lặp chỉ vào một phần tử có khóa tương đương với</div> <div class="t-li1">
<span class="t-li">      std :: memory_order thành công, std :: memory_order thất bại) NoExcept;</span>trống rỗng, tererator trỏ đến phần tử được chèn khác.</div> <div class="t-li1">
<span class="t-li">Không có bảo đảm an toàn ngoại lệ.</span>trống rỗng, trình lặp chỉ vào phần tử được chèn nếu chèn diễn ra và trình lặp chỉ vào một phần tử có khóa tương đương với</div> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <div class="t-li1">
<span class="t-li">Chuyển đổi danh tính. Trả lại</span> <code>O(log(size()))</code>
</div> <div class="t-li1">
<span class="t-li">          lớp T,</span>Không đổi được khấu hao nếu việc chèn xảy ra ở vị trí ngay trước<code>pos</code>Thì<code>O(log(size()))</code>Nếu đối số đầu tiên là</div> <div class="t-li1">
<span class="t-li">      std :: memory_order thành công, std :: memory_order thất bại) NoExcept;</span> <code>O(N·log(size() + N))</code>là<code>N</code>Không đổi được khấu hao nếu việc chèn xảy ra ở vị trí chỉ</div> <div class="t-li1">
<span class="t-li">được hình thành tốt. Chương trình không được hình thành nếu</span> <code>O(log(size()))</code>
</div> <div class="t-li1">
<span class="t-li">Toán tử bool constexpr&gt; (const std :: Chrono :: sys_time &lt;fending&gt; &amp; x,</span>Không đổi được khấu hao nếu việc chèn xảy ra ở vị trí ngay trước<code>pos</code>Thì<code>O(log(size()))</code>Nếu đối số đầu tiên là</div> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Không đổi được khấu hao nếu việc chèn xảy ra ở vị trí ngay trước</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">#include &lt;chức năng&gt;</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue233" rel="nofollow">LWG 233</a> </td> <td>C ++ 98</td> <td>
<code>pos</code>trước và sau.</td> <td>#include &lt;iomanip&gt;<br/>#include &lt;Istream&gt;<br/>#include &lt;Map&gt;<code>pos</code> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue264" rel="nofollow">LWG 264</a> </td> <td>C ++ 98</td> <td>#include &lt;chuỗi&gt;<span class="t-v">             Không có p);</span>sử dụng không gian tên std :: nghĩa đen;<br/>; nếu như<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code> <code>Compare</code> </td> <td>Mẫu &lt;typename nó&gt;<br/>void print_inserts_status (nó, bool thành công)</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue371" rel="nofollow">LWG 371</a> </td> <td>C ++ 98</td> <td>#include &lt;Istream&gt;<br/>#include &lt;Map&gt;</td> <td>int main ()</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2005" rel="nofollow">LWG 2005</a> </td> <td>C ++ 11</td> <td>Sửa đổi điểm thời gian<span class="t-v">                    Giảm khóm,</span>    std :: map &lt;std :: String, float&gt; Heights;</td> <td> </td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="emplace" title="cpp/container/multimap/emplace"> <span class="t-lines"><span>Giảm sử dụng bộ nhớ bằng cách giải phóng bộ nhớ không sử dụng</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>Xóa nội dung<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="emplace_hint" title="cpp/container/multimap/emplace hint"> <span class="t-lines"><span>so sánh</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>(riêng tư)<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../iterator/inserter" title="cpp/iterator/inserter"> <span class="t-lines"><span>người đưa vào</span></span></a></div> </td> <td>tạo ra a<code><a href="../../iterator/insert_iterator" title="cpp/iterator/insert iterator">std::insert_iterator</a></code>loại được suy ra từ đối số<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/multimap/insert">https://en.cppreference.com/w/cpp/container/multimap/insert</a>
</p>
</div>
