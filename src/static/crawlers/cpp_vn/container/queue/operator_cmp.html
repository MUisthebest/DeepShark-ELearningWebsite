 <h1 class="firstHeading" id="firstHeading">toán tử ==,! =, &lt;, &lt;=,&gt;,&gt; =, &lt;=&gt;<small>Thuật toán</small>
</h1> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">Mẫu &lt;class T, class Container&gt;</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Toán tử bool == (const std :: hàng đợi &lt;t, container&gt; &amp; lhs,</pre>
</td> <td>(2)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">                 const std :: Hàng đợi &lt;t, container&gt; &amp; rhs);</pre>
</td> <td>(3)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Mẫu &lt;class T, class Container&gt;</pre>
</td> <td>(4)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">toán tử bool! = (const std :: hàng đợi &lt;t, container&gt; &amp; lhs,</pre>
</td> <td>             Không có p);</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">                 const std :: Hàng đợi &lt;t, container&gt; &amp; rhs);</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;class T, class Container&gt;</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Toán tử bool &lt;(const std :: hàng đợi &lt;t, container&gt; &amp; lhs,</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>E lvalues</td> <td>-</td> <td>                 const std :: Hàng đợi &lt;t, container&gt; &amp; rhs);</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/equalitycomparable" title="cpp/named req/EqualityComparable">EqualityComparable</a>.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">Kết thúc Iterator nếu</span> <code>true</code>Mẫu &lt;class T, class Container&gt;<code>true</code>Thì<code>false</code>Nếu đối số đầu tiên là</div> <div class="t-li1">
<span class="t-li">6)</span>Toán tử bool &lt;= (const std :: hàng đợi &lt;t, container&gt; &amp; lhs,</div> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Tuyến tính trong kích thước của container.</p>
<h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue410" rel="nofollow">LWG 410</a> </td> <td>C ++ 98</td> <td>                 const std :: xếp hàng &lt;t, container&gt; &amp; rhs);<code>!=</code>Thì<code>&gt;</code>Thì<code>&lt;=</code>Và<code>&gt;=</code>. Các cơ chế được sử dụng để đảm bảo tính nguyên tử và thứ tự bộ nhớ phải tương thích.</td> <td>Được cho</td>
</tr>
</table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/queue/operator_cmp">https://en.cppreference.com/w/cpp/container/queue/operator_cmp</a>
</p>
</div>
