 <h1 class="firstHeading" id="firstHeading">std :: vector &lt;t, phân bổ&gt; :: thay đổi kích thước</h1> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">void thay đổi kích thước (số lượng size_type);</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">ForwardItIT2 Sao chép (Chính sách thực thi &amp;&amp; chính sách,</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void thay đổi kích thước (SIZE_TYPE số lượng, const value_type &amp; value);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">ForwardItIT2 Sao chép (Chính sách thực thi &amp;&amp; chính sách,</span> </td> </tr> </table> <p>Thay đổi kích thước container để chứa<code>count</code>các yếu tố, không làm gì nếu<code>count == size()</code>.</p>
<p>Nếu kích thước hiện tại lớn hơn<code>count</code>, container được giảm xuống đầu tiên<code>count</code>các yếu tố.</p>
<p>Nếu kích thước hiện tại nhỏ hơn<code>count</code>Thì</p>
<div class="t-li1">
<span class="t-li">1)</span>thêm vào<a href="../../named_req/defaultinsertable" title="cpp/named req/DefaultInsertable">default-inserted</a>Các yếu tố được nối thêm.</div> <div class="t-li1">
<span class="t-li">2)</span>Bản sao bổ sung của<code>value</code>được thêm vào.</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>(Niebloid)</td> <td>-</td> <td>Kích thước mới của container</td>
</tr> <tr class="t-par"> <td>được phân vùng liên quan đến</td> <td>-</td> <td>giá trị để khởi tạo các yếu tố mới với</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/moveinsertable" title="cpp/named req/MoveInsertable">MoveInsertable</a>Và<a href="../../named_req/defaultinsertable" title="cpp/named req/DefaultInsertable">DefaultInsertable</a>is_array_v</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a>Mảng tích hợp để được chuyển đổi</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Gán cho đã cho</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Tuyến tính trong sự khác biệt giữa kích thước hiện tại và<code>count</code>. Độ phức tạp bổ sung có thể do phân bổ lại nếu công suất nhỏ hơn<code>count</code>.</p>
<h3 id="Exceptions">Ngoại lệ</h3> <p>Nếu một ngoại lệ được ném vì bất kỳ lý do gì, các chức năng này không có hiệu lực (<a href="../../language/exceptions#Exception_safety" title="cpp/language/exceptions">strong exception safety guarantee</a>). Mặc dù không được chỉ định rõ ràng,<code><a href="../../error/length_error" title="cpp/error/length error">std::length_error</a></code>bị ném nếu dung lượng yêu cầu của vectơ mới sẽ vượt quá<code><a href="max_size" title="cpp/container/vector/max size">max_size()</a></code>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-11">
<td> <p>Trong quá tải<span class="t-v">(1)</span>Sử dụng chức năng nhị phân đã cho<code>T</code>Nếu một ngoại lệ được ném, chức năng này không có hiệu lực (đảm bảo ngoại lệ mạnh). Nếu như<span class="kw1">Noexcept</span>và T không phải là<a href="../../named_req/copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a>Mẫu &lt;Class T&gt;<code>*this</code>và không</p>
</td> <td><a class="new" href="https://en.cppreference.com/mwiki/index.php?title=Template:mark_since_11&amp;action=edit&amp;redlink=1" title="Template:mark since 11 (page does not exist)">Template:mark since 11</a></td>
</tr> </table> <h3 id="Notes">Ghi chú</h3> <p>Nếu có giá trị bắt đầu quá tải<span class="t-v">(1)</span>không mong muốn, ví dụ, nếu các yếu tố thuộc loại không phải lớp và không cần thiết, thì có thể tránh được bằng cách cung cấp một<a class="external text" href="https://stackoverflow.com/a/21028912/273767" rel="nofollow">custom <code>Allocator::construct</code></a>.<br/>Khả năng vector không bao giờ giảm khi thay đổi kích thước nhỏ hơn vì điều đó sẽ làm mất hiệu lực tất cả các trình lặp, thay vì chỉ những người sẽ bị vô hiệu hóa bởi chuỗi tương đương của<code><a href="pop_back" title="cpp/container/vector/pop back">pop_back()</a></code>cuộc gọi.</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;Vector&gt;</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">#include &lt;Istream&gt;</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue679" rel="nofollow">LWG 679</a> </td> <td>C ++ 98</td> <td>
<code>resize()</code> <code>value</code>void in (Auto Rem, Const Std :: Deque &lt;Int&gt; &amp; C)</td> <td>{</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue1525" rel="nofollow">LWG 1525</a> </td> <td>C ++ 98</td> <td>    for (std :: cout &lt;&lt; rem; const int el: c)<code>resize(size())</code>phù hợp khi sao chép bên phải (cuối phạm vi đích nằm ngoài phạm vi nguồn).</td> <td>Mẫu &lt;class inputit, class outputit&gt;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2033" rel="nofollow">LWG 2033</a> </td> <td>C ++ 11</td> <td>        std :: cout &lt;&lt; el &lt;&lt; '';<code><a href="erase" title="cpp/container/vector/erase">erase()</a></code><br/> <code>T</code>void in (Auto Rem, Const Std :: Vector &lt;Int&gt; &amp; C)</td> <td>    std :: cout &lt;&lt; '\ n';    <code><a href="pop_back" title="cpp/container/vector/pop back">pop_back()</a></code><br/>{</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2066" rel="nofollow">LWG 2066</a> </td> <td>C ++ 11</td> <td>đã được sắp xếp bởi<span class="t-v">(1)</span>    for (std :: cout &lt;&lt; rem; const int el: c)<span class="t-v">(2)</span> </td> <td>Được cho</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="size" title="cpp/container/vector/size"> <span class="t-lines"><span>kích cỡ</span></span></a></div> </td> <td>trả về một trình lặp đến cuối<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="insert" title="cpp/container/vector/insert"> <span class="t-lines"><span>get_allocator</span></span></a></div> </td> <td>Trả về người phân bổ liên quan<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="erase" title="cpp/container/vector/erase"> <span class="t-lines"><span>Prepend_range</span></span></a></div> </td> <td>chèn các yếu tố<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/vector/resize">https://en.cppreference.com/w/cpp/container/vector/resize</a>
</p>
</div>
