 <h1 class="firstHeading" id="firstHeading">STD :: Vector &lt;T, Alolocator&gt; :: Dự trữ</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">khoảng trống dự trữ (size_type new_cap);</pre></td> <td class="t-dcl-nopad"> </td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Lựa chọn khoảng trống của ConstExpr (size_type new_cap);</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>Tăng dung lượng của vectơ (tổng số phần tử mà vectơ có thể giữ mà không cần phân bổ lại) cho một giá trị lớn hơn hoặc bằng<code>new_cap</code>. Nếu như<code>new_cap</code>lớn hơn hiện tại<code><a href="capacity" title="cpp/container/vector/capacity">capacity()</a></code>, lưu trữ mới được phân bổ, nếu không chức năng không làm gì cả.</p>
<p><code>reserve()</code>không thay đổi kích thước của vectơ.</p>
<p>Nếu như<code>new_cap</code>Để so sánh các giá trị.<code><a href="capacity" title="cpp/container/vector/capacity">capacity()</a></code>, tất cả các trình lặp, bao gồm cả<code><a href="end" title="cpp/container/vector/end">end()</a></code>Iterator, và tất cả các tài liệu tham khảo cho các yếu tố bị vô hiệu. Nếu không, không có trình lặp hoặc tài liệu tham khảo bị vô hiệu.</p>
<p>Sau khi gọi đến<code>reserve()</code>, các phần chèn sẽ không kích hoạt phân bổ lại trừ khi việc chèn sẽ làm cho kích thước của vectơ lớn hơn giá trị của<code><a href="capacity" title="cpp/container/vector/capacity">capacity()</a></code>.</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>new_cap</td> <td>-</td> <td>dung lượng mới của vectơ, với số lượng các yếu tố</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/moveinsertable" title="cpp/named req/MoveInsertable">MoveInsertable</a>Mẫu &lt;Class T&gt;<code>*this</code>.<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Gán cho đã cho</p>
<h3 id="Exceptions">Ngoại lệ</h3> <ul>
<li> <code><a href="../../error/length_error" title="cpp/error/length error">std::length_error</a></code>nếu như<code>new_cap &gt; max_size()</code>.</li>
<li>Bất kỳ ngoại lệ nào được ném bởi<code>Allocator::allocate()</code>(tiêu biểu<code><a href="../../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>).</li>
</ul> <p>Nếu một ngoại lệ được ném, chức năng này không có hiệu lực (<a href="../../language/exceptions#Exception_safety" title="cpp/language/exceptions">strong exception guarantee</a>).</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>Nếu như<code>T</code>Nếu một ngoại lệ được ném, chức năng này không có hiệu lực (đảm bảo ngoại lệ mạnh). Nếu như<span class="kw1">Noexcept</span>và T không phải là<a href="../../named_req/copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a>Mẫu &lt;Class T&gt;<code>*this</code>và không</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Nhiều nhất tuyến tính trong<code><a href="size" title="cpp/container/vector/size">size()</a></code>của container.</p>
<h3 id="Notes">Ghi chú</h3> <p>Sử dụng chính xác<code>reserve()</code>có thể ngăn chặn sự phân bổ không cần thiết, nhưng việc sử dụng không phù hợp<code>reserve()</code>(Ví dụ, gọi nó trước mỗi<code><a href="push_back" title="cpp/container/vector/push back">push_back()</a></code>gọi) thực sự có thể làm tăng số lượng phân bổ lại (bằng cách gây ra khả năng tăng tuyến tính thay vì theo cấp số nhân) và dẫn đến tăng độ phức tạp tính toán và giảm hiệu suất. Ví dụ: một hàm nhận một vectơ tùy ý bằng cách tham chiếu và nối thêm các phần tử vào nó thường<i>không</i>gọi <code>reserve()</code>Trên vector, vì nó không biết về các đặc điểm sử dụng của vector.</p>
<p>Khi chèn một phạm vi, phiên bản phạm vi của<code><a href="insert" title="cpp/container/vector/insert">insert()</a></code>thường thích hợp hơn vì nó bảo tồn hành vi tăng trưởng công suất chính xác, không giống như<code>reserve()</code>tiếp theo là một loạt các<code><a href="push_back" title="cpp/container/vector/push back">push_back()</a></code>struct common_type &lt;std :: Chrono :: Time_Point &lt;Đồng hồ, Thời lượng1&gt;, </p>
<p><code>reserve()</code>không thể được sử dụng để giảm công suất của container; đến cuối cùng<code><a href="shrink_to_fit" title="cpp/container/vector/shrink to fit">shrink_to_fit()</a></code>được cung cấp.</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;CstDdef&gt;</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">#include &lt;Istream&gt;</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue329" rel="nofollow">LWG 329</a> </td> <td>C ++ 98</td> <td>#include &lt;New&gt;<br/>#include &lt;Vector&gt;<br/> <code>reserve()</code> </td> <td>// Phân bổ C ++ tối thiểu 11 với đầu ra gỡ lỗi<br/>Mẫu &lt;Lớp TP&gt;<br/>Cấu trúc nalloc<code><a href="capacity" title="cpp/container/vector/capacity">capacity()</a></code> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2033" rel="nofollow">LWG 2033</a> </td> <td>C ++ 11</td> <td>
<code>T</code>Thuật toán<a href="../../named_req/moveinsertable" title="cpp/named req/MoveInsertable">MoveInsertable</a> </td> <td>Thực hiện quá tải</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="capacity" title="cpp/container/vector/capacity"> <span class="t-lines"><span>Nếu vector thay đổi năng lực, tất cả chúng.</span></span></a></div> </td> <td>Nếu không, chỉ những người ở hoặc sau điểm chèn (bao gồm cả<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="max_size" title="cpp/container/vector/max size"> <span class="t-lines"><span>trả về một trình lặp ngược lại cho đầu</span></span></a></div> </td> <td>trả về một trình lặp ngược về cuối<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="resize" title="cpp/container/vector/resize"> <span class="t-lines"><span>Emplace_Front</span></span></a></div> </td> <td>xây dựng một phần tử tại chỗ<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shrink_to_fit" title="cpp/container/vector/shrink to fit"> <span class="t-lines"><span>giao phó</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">.<span title="not available in libstdc++ C++98 mode">gán các giá trị cho container</span>)</span></span></span></div> </td> <td>gán_range<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/vector/reserve">https://en.cppreference.com/w/cpp/container/vector/reserve</a>
</p>
</div>
