 <h1 class="firstHeading" id="firstHeading">STD :: Vector &lt;T, Allocator&gt; :: Vector</h1> <table class="t-dcl-begin"> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="4">(1)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx17"> <td><pre data-language="cpp">vector ();</pre></td> <td><span class="t-mark-rev t-until-cxx17">xáo trộn</span></td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td> <pre data-language="cpp">vector () noExcept (noexcept (allocator ()));</pre>
</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">constexpr vector () NoExcept (noexcept (allocator ()));</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="4">(2)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx17"> <td><pre data-language="cpp">vector rõ ràng (const Alleocator &amp; alloc);</pre></td> <td><span class="t-mark-rev t-until-cxx17">xáo trộn</span></td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td> <pre data-language="cpp">vector rõ ràng (const Alleocator &amp; alloc) noExcept;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Vector rõ ràng của const constexpr (const Alleocator &amp; alloc) NoExcept;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="4">(3)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx11"> <td><pre data-language="cpp">vector rõ ràng (số lượng size_type,</pre></td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx20"> <td> <pre data-language="cpp">                 const t &amp; value = t (),</pre>
</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">                 const allocator &amp; alloc = allocator ());</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="4">(4)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx14"> <td><pre data-language="cpp">Vector (SIZE_TYPE số lượng,</pre></td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx14">Constexpr std :: cặp &lt;const t &amp;, const t &amp;&gt; minmax (const t &amp; a, const t &amp; b,</span>
</td> </tr> <tr class="t-dcl t-since-cxx14 t-until-cxx20"> <td> <pre data-language="cpp">                 const t &amp; value,</pre>
</td> <td> <span class="t-mark-rev t-since-cxx14">(kể từ C ++ 14)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">                 const allocator &amp; alloc = allocator ());</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">             Không có p);</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">vector constexpr (số lượng size_type,</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">                  const t &amp; value,</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td></td> </tr> <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">                  const allocator &amp; alloc = allocator ());</pre></td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">vector rõ ràng (số lượng size_type);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">            Chuyển tiếp 2 First2);</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx20"> <td><pre data-language="cpp">vector rõ ràng (số lượng size_type,</pre></td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">                 const allocator &amp; alloc = allocator ());</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="4">            Nhị phân p);</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx17"> <td><pre data-language="cpp">Vector rõ ràng của const constexpr (số lượng Size_type,</pre></td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx17">xáo trộn</span>
</td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td> <pre data-language="cpp">                           const allocator &amp; alloc = allocator ());</pre>
</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Class Inputit&gt;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(9)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx20"> <td><pre data-language="cpp">vector (đầu vào đầu tiên, đầu vào cuối cùng,</pre></td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">        const allocator &amp; alloc = allocator ());</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(10)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx20"> <td><pre data-language="cpp">Mẫu &lt;Class Inputit&gt;</pre></td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">vector constexpr (đầu vào đầu tiên, đầu vào cuối cùng,</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td><pre data-language="cpp">                  const allocator &amp; alloc = allocator ());</pre></td> <td>(11)</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td> </tr> </table> <p>       const allocator &amp; alloc = allocator ());<code>alloc</code>.</p>
<div class="t-li1">
<span class="t-li">1)</span>deque (const deque &amp; other);</div> <div class="t-li1">
<span class="t-li">2)</span>deque (const deque &amp; other, const allocator &amp; alloc);<code>alloc</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Deque (std :: initizer_list &lt;t&gt; init,<code>count</code>deque (deque &amp;&amp; other, const allocator &amp; alloc);<code>value</code>.</div> <div class="t-li1">
<span class="t-li">là trong</span>Deque (std :: initizer_list &lt;t&gt; init,<code>count</code> <a href="../../named_req/defaultinsertable" title="cpp/named req/DefaultInsertable">default-inserted</a>       const allocator &amp; alloc = allocator ());<code>T</code>Mẫu &lt;</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Di chuyển hàm tạo. Cấu trúc container với nội dung của<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>.<table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <p>       const allocator &amp; alloc = allocator ());<code>vector(static_cast&lt;size_type&gt;(first), static_cast&lt;value_type&gt;(last), a)</code>nếu như<code>InputIt</code>khái niệm tích phân = std :: is_integral_v &lt;t&gt;;</p>
</td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> <p>                const std :: chrono :: sys_time &lt;thời gian&gt; &amp; tp);<code>InputIt</code>Phần cuối của phạm vi ban đầu<a href="../../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>Xây dựng một thùng chứa mới từ nhiều nguồn dữ liệu khác nhau, tùy chọn sử dụng bộ phân bổ do người dùng cung cấp<span class="t-v">(3)</span>.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table>
</div> <div class="t-li1">
<span class="t-li">từ_sys</span>Hàm tạo mặc định. Xây dựng một thùng chứa trống với bộ phân bổ được xây dựng mặc định.<code>other</code>.<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>Xây dựng một thùng chứa trống với bộ phân bổ đã cho<code><a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span>allocator_type<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">Xây dựng container với</span><span class="br0">.</span><br/> other.get_allocator())</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table>
</div> <div class="t-li1">
<span class="t-li">6)</span>Bản sao của các phần tử có giá trị<code>other</code>Mẫu &lt;class inputit, lớp đầu ra,<code>alloc</code>Xây dựng container với<table class="t-rev-begin"> <tr class="t-rev t-since-cxx23">
<td> <p>Là người phân bổ.<a href="../../language/class_template_argument_deduction" title="cpp/language/class template argument deduction">class template argument deduction</a>Trong lúc<code>Allocator</code>, chỉ đối số đầu tiên góp phần khấu trừ của container</p>
</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table>
</div> <div class="t-li1">
<span class="t-li">. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu biểu thức</span>Hàm tạo này có tác dụng tương tự như<code>other</code>, để tránh sự mơ hồ với quá tải<code>other</code>vector (const vector &amp; other);<code>other</code>vector conct (const vector &amp; other);<code><a href="empty" title="cpp/container/vector/empty">empty()</a></code>.</div> <div class="t-li1">
<span class="t-li">được hình thành tốt. Chương trình không được hình thành nếu</span>Sao chép hàm tạo. Cấu trúc container với bản sao nội dung của<code>alloc</code>Bộ phân bổ có được như thể bằng cách gọi<code>other</code>select_on_container_copy_construction<code>alloc != other.get_allocator()</code>vector (const vector &amp; other, const allocator &amp; alloc);<code>other</code>vector const (const vector &amp; other, const allocator &amp; alloc);<table class="t-rev-begin"> <tr class="t-rev t-since-cxx23">
<td> <p>Là người phân bổ.<a href="../../language/class_template_argument_deduction" title="cpp/language/class template argument deduction">class template argument deduction</a>Trong lúc<code>Allocator</code>, chỉ đối số đầu tiên góp phần khấu trừ của container</p>
</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table>
</div> <div class="t-li1">
<span class="t-li">Toán tử bool constexpr&gt; (const std :: Chrono :: sys_time &lt;fending&gt; &amp; x,</span>tham số mẫu.<code>init</code>.</div> <div class="t-li1">
<span class="t-li">                           const std :: Chrono :: Leap_Second &amp; y) noExcept;</span>Di chuyển hàm tạo. Cấu trúc container với nội dung của<code>rg</code>.</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Sử dụng ngữ nghĩa di chuyển. Người phân bổ có được bằng cách xây dựng di chuyển từ bộ phân bổ thuộc</td> <td>-</td> <td>Nhà xây dựng di chuyển mở rộng phân bổ. Sử dụng</td>
</tr> <tr class="t-par"> <td>(Niebloid)</td> <td>-</td> <td>Là bộ phân bổ cho container mới, di chuyển nội dung từ</td>
</tr> <tr class="t-par"> <td>được phân vùng liên quan đến</td> <td>-</td> <td>Kích thước mới của container</td>
</tr> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>; nếu như<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>, điều này dẫn đến một động thái yếu tố khôn ngoan.</td>
</tr> <tr class="t-par"> <td>khác</td> <td>-</td> <td>Trong lúc</td>
</tr> <tr class="t-par"> <td>trong phạm vi</td> <td>-</td> <td>, chỉ đối số đầu tiên góp phần khấu trừ của container</td>
</tr> <tr class="t-par"> <td>được hủy bỏ chính xác một lần.</td> <td>-</td> <td>Một<a href="../../ranges/to#container_compatible_range" title="cpp/ranges/to">container compatible range</a>RG<a href="../../ranges/input_range" title="cpp/ranges/input range"><code>input_range</code></a>, đó là, một<code>T</code> </td>
</tr>
</table> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <div class="t-li1">
<span class="t-li">Đầu vào</span>trình rút vào các yếu tố để hoán đổi</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span>bool is_heap (execPolicy &amp;&amp; chính sách,<code>count</code>.</div> <span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>vector (vector &amp;&amp; khác);<code>first</code>Và<code>last</code>                  const allocator &amp; alloc = allocator ());<ul>
<li>Nếu như<code>first</code>Và<code>last</code>Vector concT (vector &amp;&amp; khác) NoExcept;</li>
<ul>
<li>                  const allocator &amp; alloc = allocator ());<code>T</code>vector const (vector &amp;&amp; other, const allocator &amp; alloc);</li>
<li>được đảm bảo là</li>
</ul>
<li>, điều này dẫn đến một động thái yếu tố khôn ngoan. (Trong trường hợp đó,<code>first</code>Và<code>last</code>ConstExPR Vector (STD :: SITIBERIZER_LIST &lt;T&gt; init,</li>
<ul>
<li>                  const allocator &amp; alloc = allocator ());<code>T</code>như n,</li>
<li>Cả hai đều là người lặp đi về phía trước, hai chiều hoặc truy cập ngẫu nhiên,</li>
</ul>
</ul> <div class="t-li1">
<span class="t-li">cluct clock_time_conversion &lt;std :: Chrono :: System_Clock, Clock&gt;;</span>các yếu tố có thể chuyển đổi thành<code>other</code>.</div> <div class="t-li1">
<span class="t-li">. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu biểu thức</span>trình rút vào các yếu tố để hoán đổi</div> <div class="t-li1">
<span class="t-li">được hình thành tốt. Chương trình không được hình thành nếu</span>tham số mẫu.<code>alloc != other.get_allocator()</code>Xây dựng container với nội dung của danh sách khởi tạo</div> <div class="t-li1">
<span class="t-li">Toán tử bool constexpr&gt; (const std :: Chrono :: sys_time &lt;fending&gt; &amp; x,</span>các yếu tố có thể chuyển đổi thành<code>init</code>.</div> <span class="t-li">                           const std :: Chrono :: Leap_Second &amp; y) noExcept;</span>Cho quá tải<code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3142">    adjacent_find (tôi đầu tiên, s cuối cùng, pred = {}, proj proj = {});<span class="me2">STD ::</span></span></a><span class="br0">.</span>rg<span class="br0">)</span></code>                  const allocator &amp; alloc = allocator ());<ul>
<li>Nếu như<code>R</code>Range constexpr :: mượn_subrange_t &lt;r&gt;<code>ranges::forward_range</code>hoặc<code>ranges::sized_range</code>Thì</li>
<ul>
<li>. Sau khi di chuyển,<code>rg</code>, Và</li>
<li>được đảm bảo là</li>
</ul>
<li>, điều này dẫn đến một động thái yếu tố khôn ngoan. (Trong trường hợp đó,<code>R</code>không được đảm bảo là trống sau khi di chuyển.)</li>
<ul>
<li>Cho khoảng cách giữa<code>T</code>như n,</li>
<li>Cả hai đều là người lặp đi về phía trước, hai chiều hoặc truy cập ngẫu nhiên,</li>
</ul>
</ul> <h3 id="Exceptions">Ngoại lệ</h3> <p>Cấu trúc container với nội dung của phạm vi<code>Allocator::allocate</code>phân bổ</p>
<h3 id="Notes">Ghi chú</h3> <p>người phân bổ sử dụng cho tất cả các phân bổ bộ nhớ của container này<span class="t-v">            Nhị phân p);</span>Kích thước của container<code>other</code>phạm vi<code>*this</code>để sao chép các yếu tố từ<a class="external text" href="https://eel.is/c++draft/container.reqmts#67" rel="nofollow">[container.reqmts]/67</a>một thùng chứa khác được sử dụng làm nguồn để khởi tạo các phần tử của container với<a class="external text" href="https://cplusplus.github.io/LWG/issue2321" rel="nofollow">LWG issue 2321</a>.</p>
<p>Hàm tạo bản sao của<span class="t-v">(4)</span>chỉ được gọi là n lần, và<span class="kw4">int</span>Không có sự phân bổ lại xảy ra.<a href="../../language/new" title="cpp/language/new"><code>new[]</code></a>Nếu không thì (<span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span><span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span>có thể đại diện cho các phân số của ve.<a class="external text" href="https://stackoverflow.com/a/21028912/273767" rel="nofollow">custom <code>Allocator::construct</code></a>chỉ là người lặp đầu vào),</p>
<p>Hàm tạo bản sao của<span class="t-v">(10)</span>được gọi là o (n) lần, và<a href="../../language/list_initialization" title="cpp/language/list initialization">list initialization</a>Và<a href="../../language/direct_initialization" title="cpp/language/direct initialization">direct initialization</a>Việc phân bổ lại xảy ra o (log n) lần.</p>
<div class="cpp source-cpp"><pre data-language="cpp">như n,</pre></div> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../../feature_test#cpp_lib_containers_ranges" title="cpp/feature test"><code>__cpp_lib_containers_ranges</code></a></td> <td><span class="nu0">và không trả lại gì.</span></td> <td><span class="t-mark">Phạm vi :: IOTA</span></td> <td>
<a href="../../ranges/to#container_compatible_range" title="cpp/ranges/to">Ranges-aware</a>Tag và một<span class="t-v">.<a href="#Version_11">11</a>)</span> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Khởi tạo chính xác n phần tử từ kết quả của các trình lặp liên tiếp của việc phân tích liên tiếp của</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Tuyến tính nếu</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue134" rel="nofollow">LWG 134</a> </td> <td>C ++ 98</td> <td>Không có sự phân bổ lại xảy ra.<br/>Nếu không thì (</td> <td>Phạm vi đầu vào mô hình),</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue868" rel="nofollow">LWG 868</a> </td> <td>C ++ 98</td> <td>. Tiêu chuẩn hiện tại làm cho đảm bảo này thông qua câu lệnh chăn trong<span class="t-v">(4)</span>và một đảm bảo trực tiếp hơn đang được xem xét thông qua</td> <td>#include &lt;Istream&gt;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2193" rel="nofollow">LWG 2193</a> </td> <td>C ++ 11</td> <td>#include &lt;chuỗi&gt;</td> <td>#include &lt;Deque&gt;</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="assign" title="cpp/container/vector/assign"> <span class="t-lines"><span>Loại số nguyên đã ký (thường là</span></span></a></div> </td> <td>con trỏ<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="operator=" title="cpp/container/vector/operator="> <span class="t-lines"><span>chuyên môn)</span></span></a></div> </td> <td>con trỏ<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/vector/vector">https://en.cppreference.com/w/cpp/container/vector/vector</a>
</p>
</div>
