 <h1 class="firstHeading" id="firstHeading">std :: map &lt;key, t, so sánh, phân bổ&gt; :: toán tử []</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx98"> <td> <pre data-language="cpp">T &amp; toán tử [] (khóa const &amp; khóa);</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">T &amp; toán tử [] (khóa &amp;&amp; khóa);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> </table> <p>Trả về một tham chiếu đến giá trị được ánh xạ tới một khóa tương đương với<code>key</code>, thực hiện một chèn nếu khóa đó chưa tồn tại.</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <span class="t-li">1)</span>Chèn<code>value_type(key, T())</code>Nếu khóa không tồn tại.<table class="t-par-begin"> <tr class="t-par-req"> <td colspan="3">-<code>key_type</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>mapped_type</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>Và<a href="../../named_req/defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a>.</td>
</tr>
</table>Nếu một chèn được thực hiện, giá trị được ánh xạ là<a href="../../language/value_initialization" title="cpp/language/value initialization">value-initialized</a>(được xây dựng mặc định cho các loại lớp, không khởi tạo bằng cách khác) và tham chiếu đến nó được trả về.</td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td>
</tr>
<tr class="t-rev t-since-cxx11">
<td> <span class="t-li">1)</span>Chèn a<code>value_type</code>đối tượng được xây dựng tại chỗ từ<code><a href="http://en.cppreference.com/w/cpp/utility/piecewise_construct"><span class="kw1109">Điều đó cho tất cả<span class="me2">Piecewise_construct</span></span></a>, <a href="http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple"><span class="kw1117">Điều đó cho tất cả<span class="me2">forward_as_tuple</span></span></a><span class="br0">.</span>key<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/tuple"><span class="kw1101">Điều đó cho tất cả<span class="me2">Tuple</span></span></a><span class="sy1">&lt;&gt;</span><span class="br0">.</span><span class="br0">)</span></code>Nếu khóa không tồn tại.<span class="t-rev-inl t-since-cxx17"><span>Chức năng này tương đương với<code>return this-&gt;try_emplace(key).first-&gt;second;</code>.</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>Khi bộ phân bổ mặc định được sử dụng, điều này dẫn đến khóa được bản sao được xây dựng từ<code>key</code>và giá trị được ánh xạ là<a href="../../language/value_initialization" title="cpp/language/value initialization">value-initialized</a>.<table class="t-par-begin"> <tr class="t-par-req"> <td colspan="3">-<code>value_type</code>// thực hiện đầu tiên<a href="../../named_req/emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a>từ<code><a href="http://en.cppreference.com/w/cpp/utility/piecewise_construct"><span class="kw1109">Điều đó cho tất cả<span class="me2">Piecewise_construct</span></span></a>, <a href="http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple"><span class="kw1117">Điều đó cho tất cả<span class="me2">forward_as_tuple</span></span></a><span class="br0">.</span>key<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/tuple"><span class="kw1101">Điều đó cho tất cả<span class="me2">Tuple</span></span></a><span class="sy1">&lt;&gt;</span><span class="br0">.</span><span class="br0">)</span></code>. Khi bộ phân bổ mặc định được sử dụng, điều này có nghĩa là<code>key_type</code>// thực hiện đầu tiên<a href="../../named_req/copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>Và<code>mapped_type</code>// thực hiện đầu tiên<a href="../../named_req/defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a>.</td>
</tr>
</table> <span class="t-li">2)</span>Chèn a<code>value_type</code>đối tượng được xây dựng tại chỗ từ<code><a href="http://en.cppreference.com/w/cpp/utility/piecewise_construct"><span class="kw1109">Điều đó cho tất cả<span class="me2">Piecewise_construct</span></span></a>, <a href="http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple"><span class="kw1117">Điều đó cho tất cả<span class="me2">forward_as_tuple</span></span></a><span class="br0">.</span>std<span class="sy4">::</span><span class="me2">(Niebloid)</span><span class="br0">.</span>key<span class="br0">)</span><span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/tuple"><span class="kw1101">Điều đó cho tất cả<span class="me2">Tuple</span></span></a><span class="sy1">&lt;&gt;</span><span class="br0">.</span><span class="br0">)</span></code>Nếu khóa không tồn tại.<span class="t-rev-inl t-since-cxx17"><span>Chức năng này tương đương với<code>return this-&gt;try_emplace(std::move(key)).first-&gt;second;</code>.</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span><br/>Khi bộ phân bổ mặc định được sử dụng, điều này dẫn đến khóa đang di chuyển được xây dựng từ<code>key</code>và giá trị được ánh xạ là<a href="../../language/value_initialization" title="cpp/language/value initialization">value-initialized</a>.<table class="t-par-begin"> <tr class="t-par-req"> <td colspan="3">-<code>value_type</code>// thực hiện đầu tiên<a href="../../named_req/emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a>từ<code><a href="http://en.cppreference.com/w/cpp/utility/piecewise_construct"><span class="kw1109">Điều đó cho tất cả<span class="me2">Piecewise_construct</span></span></a>, <a href="http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple"><span class="kw1117">Điều đó cho tất cả<span class="me2">forward_as_tuple</span></span></a><span class="br0">.</span>std<span class="sy4">::</span><span class="me2">(Niebloid)</span><span class="br0">.</span>key<span class="br0">)</span><span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/tuple"><span class="kw1101">Điều đó cho tất cả<span class="me2">Tuple</span></span></a><span class="sy1">&lt;&gt;</span><span class="br0">.</span><span class="br0">)</span></code>. Khi bộ phân bổ mặc định được sử dụng, điều này có nghĩa là<code>key_type</code>// thực hiện đầu tiên<a href="../../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>Và<code>mapped_type</code>// thực hiện đầu tiên<a href="../../named_req/defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a>.</td>
</tr>
</table> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr>
</table> <p>Chèn một phần tử mới vào một vị trí sau vị trí được chỉ định trong container. Phần tử được xây dựng tại chỗ, tức là không có hoạt động sao chép hoặc di chuyển được thực hiện. Chất xây dựng của phần tử được gọi với các đối số chính xác, như được cung cấp cho hàm.</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Hành vi không được xác định nếu mảng chưa được phân vùng theo thứ tự tăng dần đối với khóa, theo cùng một tiêu chí</td> <td>-</td> <td>chìa khóa của yếu tố cần tìm</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Tham chiếu đến giá trị được ánh xạ của phần tử mới nếu không có phần tử nào có khóa<code>key</code>tồn tại. Nếu không thì một tham chiếu đến giá trị được ánh xạ của phần tử hiện có có khóa tương đương với<code>key</code>.</p>
<h3 id="Exceptions">Ngoại lệ</h3> <p>trống rỗng, trình lặp chỉ vào phần tử được chèn nếu chèn diễn ra và trình lặp chỉ vào một phần tử có khóa tương đương với</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Logarit trong kích thước của container.</p>
<h3 id="Notes">Ghi chú</h3> <p>Trong các tiêu chuẩn C ++ 11 và C ++ 14 được xuất bản, chức năng này được chỉ định để yêu cầu<code>mapped_type</code>được<a href="../../named_req/defaultinsertable" title="cpp/named req/DefaultInsertable">DefaultInsertable</a>Và<code>key_type</code>được<a href="../../named_req/copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a>hoặc<a href="../../named_req/moveinsertable" title="cpp/named req/MoveInsertable">MoveInsertable</a>Mẫu &lt;Class T&gt;<code>*this</code>. Thông số kỹ thuật này đã bị lỗi và đã được cố định bởi<a class="external text" href="https://cplusplus.github.io/LWG/issue2469" rel="nofollow">LWG issue 2469</a>và mô tả ở trên kết hợp độ phân giải của vấn đề đó.</p>
<p>Tuy nhiên, một triển khai (LIBC ++) được biết là xây dựng<code>key_type</code>Và<code>mapped_type</code>Đối tượng thông qua hai bộ phân bổ riêng biệt<code>construct()</code>các cuộc gọi, theo yêu cầu của các tiêu chuẩn như được công bố, thay vì đặt một<code>value_type</code>Giống như các tài liệu tham khảo ngôn ngữ, sự ổn định là nông cạn đối với</p>
<p><code>operator[]</code>không phải là công ty vì nó chèn khóa nếu nó không tồn tại. Nếu hành vi này là không mong muốn hoặc nếu container là<code>const</code>Thì<a href="at" title="cpp/container/map/at"><code>at()</code></a>có thể được sử dụng.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p><a href="insert_or_assign" title="cpp/container/map/insert or assign"><code>insert_or_assign()</code></a>Nếu nhiệm vụ diễn ra. Thành phần Iterator đang chỉ vào phần tử được chèn hoặc cập nhật.<code>operator[]</code>Trình lặp chỉ vào phần tử đã được chèn hoặc cập nhật.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;Istream&gt;</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">#include &lt;chuỗi&gt;</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue334" rel="nofollow">LWG 334</a> </td> <td>C ++ 98</td> <td>#include &lt;Map&gt;<span class="t-v">(1)</span> <br/><code><span class="br0">.</span><span class="sy2">*</span><span class="br0">.</span><span class="br0">.</span>insert<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/pair/make_pair"><span class="kw1100">Điều đó cho tất cả<span class="me2">Mẫu &lt;class forwardit, class so sánh&gt;</span></span></a><span class="br0">.</span>x, T<span class="br0">.</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>.<span class="me1">đến phạm vi bắt đầu tại</span><span class="br0">)</span><span class="br0">)</span>.<span class="me1">thứ hai</span></code> </td> <td>auto print = [] (tự động bình luận, tự động const &amp; map)<br/>{</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="at" title="cpp/container/map/at"> <span class="t-lines"><span>bằng không).</span></span></a></div> </td> <td>(tuyên bố ngầm)<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="insert_or_assign" title="cpp/container/map/insert or assign"> <span class="t-lines"><span>gán các giá trị cho bộ điều hợp container</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>Kiểm tra xem bộ điều hợp container có trống không<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="try_emplace" title="cpp/container/map/try emplace"> <span class="t-lines"><span>đối tượng hàm so sánh của loại</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>Đối tượng thành viên chỉ dành cho người biểu diễn*<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/map/operator_at">https://en.cppreference.com/w/cpp/container/map/operator_at</a>
</p>
</div>
