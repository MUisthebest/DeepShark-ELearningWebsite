 <h1 class="firstHeading" id="firstHeading">std :: multiset &lt;key, so sánh, phân bổ&gt; :: erase</h1> <table class="t-dcl-begin"> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx23"> <td><pre data-language="cpp">iterator Erase (Iterator POS);</pre></td> <td><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">iterator Erase (iterator pos) yêu cầu (! std :: more_as &lt;iterator, const_iterator&gt;);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">iterator xóa (const_iterator pos);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(3)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx11"> <td> <pre data-language="cpp">iterator xóa (tererator đầu tiên, iterator cuối cùng);</pre>
</td> <td> <span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">iterator xóa (const_iterator đầu tiên, const_iterator cuối cùng);</pre>
</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">size_type xóa (khóa const &amp; key);</pre>
</td> <td>(4)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td><pre data-language="cpp">Mẫu &lt;Class K&gt;</pre></td> <td>             Không có p);</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td> </tr> </table> <p>Loại bỏ các phần tử được chỉ định khỏi container. Thứ tự của các yếu tố tương đương còn lại được bảo tồn.</p>
<div class="t-li1">
<span class="t-li">Đầu vào</span>Loại bỏ phần tử tại<code>pos</code>.<span class="t-rev-inl t-since-cxx11"><span>Chỉ có một quá tải được cung cấp nếu<code>iterator</code>Và<code>const_iterator</code>là cùng một loại.</span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>
</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Loại bỏ các yếu tố trong phạm vi<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>size_type xóa (k &amp;&amp; x);<code>*this</code>.</div> <div class="t-li1">
<span class="t-li">là trong</span>Loại bỏ tất cả các yếu tố với khóa tương đương với<code>key</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Loại bỏ phần tử (nếu một người tồn tại) với khóa tương đương với<i>tương đương</i>đến giá trị<code>x</code>. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu ID đủ điều kiện<code>Compare::is_transparent</code>Loại bỏ tất cả các yếu tố bằng khóa so sánh<code>iterator</code>constexpr outputit độc đáo_copy (đầu vào đầu tiên, đầu vào cuối cùng,<code>const_iterator</code>là hợp lệ và biểu thị một loại, và không<code>K</code>có thể chuyển đổi hoàn toàn từ<code>Key</code>.</div> <p>Tài liệu tham khảo và lặp lại các yếu tố bị xóa bị vô hiệu. Các tài liệu tham khảo và lặp khác không bị ảnh hưởng.</p>
<p>Người lặp<code>pos</code>phải hợp lệ và có thể điều chỉnh được. Do đó<code><a href="end" title="cpp/container/multiset/end">end()</a></code>iterator (hợp lệ, nhưng không thể phân biệt được) không thể được sử dụng như một giá trị<code>pos</code>.</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>POS</td> <td>-</td> <td>trình rút vào phần tử để xóa</td>
</tr> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>Phạm vi của các yếu tố để loại bỏ</td>
</tr> <tr class="t-par"> <td>Hành vi không được xác định nếu mảng chưa được phân vùng theo thứ tự tăng dần đối với khóa, theo cùng một tiêu chí</td> <td>-</td> <td>. Nó cho phép gọi chức năng này mà không cần xây dựng một thể hiện</td>
</tr> <tr class="t-par"> <td>x</td> <td>-</td> <td>Giá trị khóa của các yếu tố để xóa</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">Chuyển đổi danh tính. Trả lại</span>Iterator theo phần tử bị loại bỏ cuối cùng.</div> <div class="t-li1">
<span class="t-li">là trong</span>Số lượng các yếu tố bị xóa (</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Số lượng các yếu tố bị xóa (</div> <h3 id="Exceptions">Ngoại lệ</h3> <div class="t-li1">
<span class="t-li">Chuyển đổi danh tính. Trả lại</span>Không ném gì.</div> <div class="t-li1">
<span class="t-li">cluct clock_time_conversion &lt;clock, std :: Chrono :: System_Clock&gt;;</span>Số lượng các yếu tố bị loại bỏ.<code>Compare</code>Giống như các tài liệu tham khảo ngôn ngữ, sự ổn định là nông cạn đối với</div> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Bất kỳ trường hợp ngoại lệ nào được ném bởi<code>c</code>của<code>multiset</code>:</p>
<div class="t-li1">
<span class="t-li">Đầu vào</span>Đưa ra một ví dụ</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span> <code>log<span class="br0">.</span>c.<span class="me1">kích cỡ</span><span class="br0">.</span><span class="br0">)</span><span class="br0">)</span> <span class="sy2">gọi</span> <a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>first, last<span class="br0">)</span></code>
</div> <div class="t-li1">
<span class="t-li">là trong</span> <code>log(c.size()) + c.count(key)</code>
</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span> <code>log(c.size()) + c.count(x)</code>
</div> <h3 id="Notes">Ghi chú</h3> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../../feature_test#cpp_lib_associative_heterogeneous_erasure" title="cpp/feature test"><code>__cpp_lib_associative_heterogeneous_erasure</code></a></td> <td><span class="nu0">3)</span></td> <td><span class="t-mark">Phạm vi :: IOTA</span></td> <td>Erasure không đồng nhất trong<a href="../../container#Associative_containers" title="cpp/container">associative containers</a>Và<a href="../../container#Unordered_associative_containers" title="cpp/container">unordered associative containers</a>Hằng số được khấu hao<span class="t-v">.<a href="#Version_5">5</a>)</span> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;set&gt;</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">#include &lt;Istream&gt;</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác<br/> </th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue130" rel="nofollow">LWG 130</a> </td> <td>C ++ 98</td> <td>#include &lt;Istream&gt;<span class="t-v">(1)</span>Và<span class="t-v">(3)</span> <span class="kw4">Vô hiệu</span>int main ()<br/>{<code>erase()</code>    std :: map &lt;int, std :: chuỗi&gt; c =</td> <td>, số lượng tăng số lặp là tuyến tính. Đáng chú ý,<code>iterator</code> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue371" rel="nofollow">LWG 371</a> </td> <td>C ++ 98</td> <td>#include &lt;Istream&gt;<br/> </td> <td>int main ()</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2059" rel="nofollow">LWG 2059</a> </td> <td>C ++ 11</td> <td>    {<span class="t-v">(1)</span>        {1, "một"}, {2, "hai"}, {3, "ba"},<span class="t-v">(2)</span>        {4, "bốn"}, {5, "năm"}, {6, "sáu"}</td> <td> <span class="t-v">(1)</span>Truy cập phần tử</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="clear" title="cpp/container/multiset/clear"> <span class="t-lines"><span>thông thoáng</span></span></a></div> </td> <td>gán một loạt các giá trị cho container<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/multiset/erase">https://en.cppreference.com/w/cpp/container/multiset/erase</a>
</p>
</div>
