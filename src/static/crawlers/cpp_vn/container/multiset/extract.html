 <h1 class="firstHeading" id="firstHeading">std :: multiset &lt;key, so sánh, phân bổ&gt; :: actact</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Trích xuất node_type (vị trí const_iterator);</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Trích xuất node_type (khóa const &amp; k);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td><pre data-language="cpp">Mẫu &lt;Class K&gt;</pre></td> <td>(3)</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Trích xuất node_type (K &amp;&amp; x);<code>position</code>chấp nhận một đối số của loại<a href="../node_handle" title="cpp/container/node handle">node handle</a>Không liên kết nút chứa phần tử được trỏ bởi</div> <div class="t-li1">
<span class="t-li">2)</span>mà sở hữu nó.<code>k</code>, tách nút chứa phần tử đầu tiên như vậy từ container và trả về một<a href="../node_handle" title="cpp/container/node handle">node handle</a>, tách nút chứa phần tử đó từ container và trả về</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>                                   Nhị phân p);<span class="t-v">(2)</span>. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu ID đủ điều kiện<code>Compare::is_transparent</code>Loại bỏ tất cả các yếu tố bằng khóa so sánh<code>iterator</code>constexpr outputit độc đáo_copy (đầu vào đầu tiên, đầu vào cuối cùng,<code>const_iterator</code>là hợp lệ và biểu thị một loại, và không<code>K</code>có thể chuyển đổi hoàn toàn từ<code>Key</code>.</div> <p>mà sở hữu nó. Nếu không, trả về một tay cầm nút trống.<code><a href="erase" title="cpp/container/multiset/erase">erase()</a></code>).</p>
<p>Trong cả hai trường hợp, không có phần tử nào được sao chép hoặc di chuyển, chỉ các con trỏ bên trong của các nút container được sửa lại (tái cân bằng có thể xảy ra, như với</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Trích xuất một nút chỉ làm mất hiệu lực các trình lặp vào phần tử được trích xuất. Con trỏ và tham chiếu đến phần tử được trích xuất vẫn còn hợp lệ, nhưng không thể được sử dụng trong khi phần tử được sở hữu bởi một tay cầm nút: chúng trở nên có thể sử dụng nếu phần tử được chèn vào một thùng chứa.</td> <td>-</td> <td>chức vụ</td>
</tr> <tr class="t-par"> <td>một trình lặp hợp lệ vào thùng chứa này</td> <td>-</td> <td>k</td>
</tr> <tr class="t-par"> <td>x</td> <td>-</td> <td>một khóa để xác định nút sẽ được trích xuất</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>MỘT<a href="../node_handle" title="cpp/container/node handle">node handle</a>giá trị của bất kỳ loại nào có thể được so sánh trong suốt với khóa xác định nút sẽ được trích xuất<span class="t-v">sở hữu phần tử được trích xuất hoặc xử lý nút trống trong trường hợp phần tử không được tìm thấy trong</span>.</p>
<h3 id="Exceptions">Ngoại lệ</h3> <div class="t-li1">
<span class="t-li">1)</span>Không ném gì.</div> <div class="t-li1">
<span class="t-li">          std :: Indirect_strict_weak_order &lt;</span>Số lượng các yếu tố bị loại bỏ.<code>Compare</code>Giống như các tài liệu tham khảo ngôn ngữ, sự ổn định là nông cạn đối với</div> <h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <div class="t-li1">
<span class="t-li">1)</span>(2,3)</div> <div class="t-li1">
<span class="t-li">          std :: Indirect_strict_weak_order &lt;</span>Hằng số được khấu hao.<code><a href="size" title="cpp/container/multiset/size">size()</a></code>)</div> <h3 id="Notes">Ghi chú</h3> <p>Trích xuất là cách duy nhất để đưa một đối tượng chỉ di chuyển ra khỏi một bộ:</p>
<div class="cpp source-cpp"><pre data-language="cpp">std :: Đặt &lt;move_only_type&gt; s;</pre></div> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../../feature_test#cpp_lib_associative_heterogeneous_erasure" title="cpp/feature test"><code>__cpp_lib_associative_heterogeneous_erasure</code></a></td> <td><span class="nu0">3)</span></td> <td><span class="t-mark">Phạm vi :: IOTA</span></td> <td>Erasure không đồng nhất trong<a href="../../container#Associative_containers" title="cpp/container">associative containers</a>Và<a href="../../container#Unordered_associative_containers" title="cpp/container">unordered associative containers</a>Thì<span class="t-v">.<a href="#Version_3">3</a>)</span> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">S.Emplace (...);</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Move_only_type mot = std :: di chuyển (s.extract (s.begin ()). value ());</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="merge" title="cpp/container/multiset/merge"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>(ít nhất là lớn nhất nếu sử dụng so sánh mặc định).<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="insert" title="cpp/container/multiset/insert"> <span class="t-lines"><span>get_allocator</span></span></a></div> </td> <td>Trả về người phân bổ liên quan<span class="t-rev-inl t-since-cxx17"><span>, các trình lặp lại có thể điều chỉnh được</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span> <br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="erase" title="cpp/container/multiset/erase"> <span class="t-lines"><span>Prepend_range</span></span></a></div> </td> <td>chèn các yếu tố<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/multiset/extract">https://en.cppreference.com/w/cpp/container/multiset/extract</a>
</p>
</div>
