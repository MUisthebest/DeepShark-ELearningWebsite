 <h1 class="firstHeading" id="firstHeading">std :: forward_list &lt;t, allocator&gt; :: thay đổi kích thước</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">void thay đổi kích thước (số lượng size_type);</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">void thay đổi kích thước (SIZE_TYPE số lượng, const value_type &amp; value);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> </table> <p>Thay đổi kích thước container để chứa<code>count</code>các yếu tố, không làm gì nếu<code>count <span class="sy1">==</span> <a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span>begin<span class="br0">.</span><span class="br0">)</span>, end<span class="br0">.</span><span class="br0">)</span><span class="br0">)</span></code>(tức là nếu<code>count</code>bằng với kích thước hiện tại).</p>
<p>Nếu kích thước hiện tại lớn hơn<code>count</code>, container được giảm xuống đầu tiên<code>count</code>các yếu tố.</p>
<p>Nếu kích thước hiện tại nhỏ hơn<code>count</code>Thì</p>
<div class="t-li1">
<span class="t-li">1)</span>thêm vào<a href="../../named_req/defaultinsertable" title="cpp/named req/DefaultInsertable">default-inserted</a>Các yếu tố được nối thêm.</div> <div class="t-li1">
<span class="t-li">2)</span>Bản sao bổ sung của<code>value</code>được thêm vào.</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>(Niebloid)</td> <td>-</td> <td>Kích thước mới của container</td>
</tr> <tr class="t-par"> <td>được phân vùng liên quan đến</td> <td>-</td> <td>giá trị để khởi tạo các yếu tố mới với</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/defaultinsertable" title="cpp/named req/DefaultInsertable">DefaultInsertable</a>is_array_v</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>T</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a>Mảng tích hợp để được chuyển đổi</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Gán cho đã cho</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Tuyến tính trong sự khác biệt giữa kích thước hiện tại và<code>count</code>. Độ phức tạp bổ sung có thể do Danh sách truyền tải để đạt đến phần tử đầu tiên để xóa/vị trí cuối để chèn.</p>
<h3 id="Notes">Ghi chú</h3> <p>Nếu có giá trị bắt đầu quá tải<span class="t-v">(1)</span>không mong muốn, ví dụ, nếu các yếu tố thuộc loại không phải lớp và không cần thiết, thì có thể tránh được bằng cách cung cấp một<a class="external text" href="https://stackoverflow.com/a/21028912/273767" rel="nofollow">custom <code>Allocator::construct</code></a>.</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;Timoning_list&gt;</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">#include &lt;Istream&gt;</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="insert_after" title="cpp/container/forward list/insert after"> <span class="t-lines"><span>, nhưng nhiều chức năng thành viên áp đặt các yêu cầu chặt chẽ hơn. Container này (nhưng không phải là thành viên của nó) có thể được khởi tạo với loại phần tử không hoàn chỉnh nếu bộ phân bổ thỏa mãn</span></span></a></div> </td> <td>201505L<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="erase_after" title="cpp/container/forward list/erase after"> <span class="t-lines"><span>ERASE_AFAFTER</span></span></a></div> </td> <td>Xóa một phần tử sau một phần tử<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/container/forward_list/resize">https://en.cppreference.com/w/cpp/container/forward_list/resize</a>
</p>
</div>
