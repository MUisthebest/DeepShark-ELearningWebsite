 <h1 class="firstHeading" id="firstHeading">STD :: Chủ sở hữu_less</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/memory" title="cpp/header/memory">&lt;memory&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx17">xáo trộn</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Cấu trúc chủ sở hữu_less; /* không xác định */</pre>
</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;class t = void&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Cấu trúc chủ sở hữu_less; /* không xác định */</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt;</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <p>Cấu trúc chủ sở hữu_less &lt;std :: shared_ptr &lt;t &gt;&gt;;<code><a href="weak_ptr" title="cpp/memory/weak ptr">std::weak_ptr</a></code>Và<code><a href="shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>Mẫu &lt;Class T&gt;<code>get()</code>là khác nhau (ví dụ: vì chúng chỉ vào các tiểu mục khác nhau trong cùng một đối tượng).</p>
<div class="t-li1">
<span class="t-li">1)</span>Cấu trúc chủ sở hữu_less &lt;std :: weak_ptr &lt;t &gt;&gt;;<code><a href="shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>Và<code><a href="weak_ptr" title="cpp/memory/weak ptr">std::weak_ptr</a></code>.</div> <div class="t-li1">
<span class="t-li">2)</span>. Thứ tự là hai con trỏ thông minh chỉ so sánh tương đương khi cả hai đều trống hoặc nếu chúng chia sẻ quyền sở hữu, ngay cả khi các giá trị của các con trỏ thô có được<code><a href="shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>.</div> <div class="t-li1">Đặt hàng loại hỗn hợp dựa trên chủ sở hữu không được cung cấp cho các loại khác ngoài<code><a href="shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>Đơn đặt hàng loại hỗn hợp dựa trên chủ sở hữu của<code><a href="http://en.cppreference.com/w/cpp/container/map"><span class="kw1283">Điều đó cho tất cả<span class="me2">bản đồ</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">Điều đó cho tất cả<span class="me2">Shared_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span>, U, std<span class="sy4">::</span><span class="me2">Chủ sở hữu_less</span><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">Điều đó cho tất cả<span class="me2">Shared_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">    std :: indoke_result_t &lt;f &amp;, u, std :: iter_reference_t &lt;i &gt;&gt;&gt;;</span></code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>. Thứ tự là hai con trỏ thông minh chỉ so sánh tương đương khi cả hai đều trống hoặc nếu chúng chia sẻ quyền sở hữu, ngay cả khi các giá trị của các con trỏ thô có được<code><a href="weak_ptr" title="cpp/memory/weak ptr">std::weak_ptr</a></code>.</div> <div class="t-li1">Đặt hàng loại hỗn hợp dựa trên chủ sở hữu không được cung cấp cho các loại khác ngoài<code><a href="weak_ptr" title="cpp/memory/weak ptr">std::weak_ptr</a></code>Đơn đặt hàng loại hỗn hợp dựa trên chủ sở hữu của<code><a href="http://en.cppreference.com/w/cpp/container/map"><span class="kw1283">Điều đó cho tất cả<span class="me2">bản đồ</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/memory/weak_ptr"><span class="kw743">Điều đó cho tất cả<span class="me2">yếu_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span>, U, std<span class="sy4">::</span><span class="me2">Chủ sở hữu_less</span><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/memory/weak_ptr"><span class="kw743">Điều đó cho tất cả<span class="me2">yếu_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">    std :: indoke_result_t &lt;f &amp;, u, std :: iter_reference_t &lt;i &gt;&gt;&gt;;</span></code>.</div> <div class="t-li1">
<span class="t-li">là trong</span>Các<code>void</code>Đó là vị từ so sánh ưa thích khi xây dựng các container liên kết với</div> <p>Toán tử mặc định<span class="sy1">is_trivently_destructible_v</span>như chìa khóa, đó là,<a href="shared_ptr/owner_before" title="cpp/memory/shared ptr/owner before"><code>std::shared_ptr::owner_before</code></a>).</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <h3 id="Specializations">Tra cứu cho định danh</h3> <p>các đối tượng trong việc đánh giá một biểu thức không đổi.<code>std::owner_less</code>Chuyển đổi danh tính:<code>T</code>Đơn đặt hàng loại hỗn hợp dựa trên chủ sở hữu của<code><a href="shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>hoặc a<code><a href="weak_ptr" title="cpp/memory/weak ptr">std::weak_ptr</a></code>).</p>
<table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="owner_less_void" title="cpp/memory/owner less void"> <span class="t-lines"><span>Chủ sở hữu_less<span class="t-dsc-small">Đó là vị từ so sánh ưa thích khi xây dựng các container liên kết với</span></span></span></a></div> </td> <td>như chìa khóa, đó là,<br/> <span class="t-mark">(Chuyên ngành mẫu lớp)</span> </td>
</tr> </table> </td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <h3 id="Nested_types">Các loại lồng nhau</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>Loại lồng nhau</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code>result_type</code> <span class="t-mark-rev t-deprecated-cxx17">(không được dùng trong C ++ 17)</span> </td> <td> <span class="t-v">sở hữu phần tử được trích xuất hoặc xử lý nút trống trong trường hợp phần tử không được tìm thấy trong</span> <span class="kw4">bool</span> </td>
</tr> <tr class="t-dsc"> <td> <code>first_argument_type</code> <span class="t-mark-rev t-deprecated-cxx17">(không được dùng trong C ++ 17)</span> </td> <td> <span class="t-v">(2)</span> <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">Điều đó cho tất cả<span class="me2">Shared_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><br/><span class="t-v">(3)</span> <a href="http://en.cppreference.com/w/cpp/memory/weak_ptr"><span class="kw743">Điều đó cho tất cả<span class="me2">yếu_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span> </td>
</tr> <tr class="t-dsc"> <td> <code>second_argument_type</code> <span class="t-mark-rev t-deprecated-cxx17">(không được dùng trong C ++ 17)</span> </td> <td> <span class="t-v">(2)</span> <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">Điều đó cho tất cả<span class="me2">Shared_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><br/><span class="t-v">(3)</span> <a href="http://en.cppreference.com/w/cpp/memory/weak_ptr"><span class="kw743">Điều đó cho tất cả<span class="me2">yếu_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span> </td>
</tr> </table> </td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> </table> <h3 id="Member_functions">nếu không thì</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><strong class="selflink"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></strong></div> </td> <td>so sánh các đối số của nó bằng cách sử dụng ngữ nghĩa dựa trên chủ sở hữu<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> </table> <div class="t-member"> <h2 id="std::owner_less::operator.28.29">std :: chủ sở hữu_less :: toán tử ()</h2> <table class="t-dcl-begin"> <tr class="t-dcl-h"> <td>không được chỉ định. Trong trường hợp này, các loại tham số được suy ra từ các đối số (mỗi loại vẫn phải là một<span class="t-v">(2)</span>
</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">không được định nghĩa cho các con trỏ yếu và có thể xem xét sai hai con trỏ được chia sẻ cho cùng một đối tượng không tương đương (xem</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl-h"> <td>không được chỉ định. Trong trường hợp này, các loại tham số được suy ra từ các đối số (mỗi loại vẫn phải là một<span class="t-v">(3)</span>
</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">&lt;VOID&gt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl-h"> <td>Đối tượng chức năng cung cấp đơn đặt hàng dựa trên kiểu chủ sở hữu loại hỗn hợp của các con trỏ chia sẻ và yếu</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">chỉ thành viên chuyên môn</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Toán tử bool () (const std :: shared_ptr &lt;t&gt; &amp; lhs, </pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> </table> <p>void Atomic_flag_wait_explicit (đối tượng Atomic_flag* dễ bay hơi<code>lhs</code>Và<code>rhs</code>Toán tử bool () (const std :: shared_ptr &lt;t&gt; &amp; lhs, <code>lhs.owner_before(rhs)</code>.</p>
<p>                 const std :: shared_ptr &lt;t&gt; &amp; rhs) const noexcept;</p>
<p><code>lhs</code>Và<code>rhs</code>Mẫu &lt;class t, class u&gt;</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>E lvalues</td> <td>-</td> <td>Toán tử bool () (const std :: weak_ptr &lt;t&gt; &amp; lhs, </td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code>true</code>nếu như<code>lhs</code>khoảng cách<i>                 const std :: error_code &amp; code) noExcept;</i> <code>rhs</code>chỉ thành viên chuyên môn<code>false</code>Nếu đối số đầu tiên là</p>
</div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2873" rel="nofollow">LWG 2873</a> </td> <td>C ++ 11</td> <td>nhà điều hành<span class="br0">.</span><span class="br0">)</span>#include &lt;Locale&gt;</td> <td>Toán tử bool () (const std :: weak_ptr &lt;t&gt; &amp; lhs, </td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="shared_ptr/owner_before" title="cpp/memory/shared ptr/owner before"> <span class="t-lines"><span>Toán tử bool () (const std :: shared_ptr &lt;t&gt; &amp; lhs, </span></span></a></div> </td> <td>Thành viên của cả hai chuyên ngành mẫu<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::shared_ptr&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="weak_ptr/owner_before" title="cpp/memory/weak ptr/owner before"> <span class="t-lines"><span>Toán tử bool () (const std :: shared_ptr &lt;t&gt; &amp; lhs, </span></span></a></div> </td> <td>                 const std :: weak_ptr &lt;t&gt; &amp; rhs) const noexcept;<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::weak_ptr&lt;T&gt;</code>)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/memory/owner_less">https://en.cppreference.com/w/cpp/memory/owner_less</a>
</p>
</div>
