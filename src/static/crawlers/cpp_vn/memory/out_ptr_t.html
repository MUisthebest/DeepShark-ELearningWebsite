 <h1 class="firstHeading" id="firstHeading">std :: out_ptr_t</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/memory" title="cpp/header/memory">&lt;memory&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">Mẫu &lt;class Smart, lớp con trỏ, lớp ... args&gt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> </table> <p><code>out_ptr_t</code>lớp out_ptr_t;<code>Pointer*</code> <code>T**</code>được sử dụng để thích nghi các loại như con trỏ thông minh cho các chức năng nước ngoài đặt lại quyền sở hữu thông qua<code>T</code>*(d_first + 1) = *(đầu tiên + 1) - *(đầu tiên);<code>void**</code>là một chuyên ngành có thể</p>
<p><code>out_ptr_t</code>được sử dụng để thích nghi các loại như con trỏ thông minh cho các chức năng nước ngoài đưa ra kết quả của chúng thông qua<code>Smart</code>đối tượng và cuối cùng đặt lại</p>
<p><code>out_ptr_t</code>Đối tượng với kết quả và các đối số bị bắt khi nó bị phá hủy.</p>
<ul>
<li>Một<code>Smart&amp;</code>Hành xử như thể nó giữ theo các thành viên dữ liệu phi tĩnh:</li>
<li>constexpr outputit exclusive_scan (đầu vào đầu tiên, đầu vào cuối cùng,<code>T</code>TRONG<code>Args...</code>tham chiếu, được liên kết với đối tượng thích nghi trên xây dựng,<code>T</code>, một thành viên của loại</li>
<li>, đó là một cuộc tranh luận được ghi lại về xây dựng và được sử dụng để đặt lại trong khi phá hủy, và<code>Pointer</code>một tiểu nhóm thành viên phù hợp để lưu trữ<code>void*</code>trong đó và cung cấp một<code>Pointer</code>hoặc<code>void*</code>nắm bắt các đối số bổ sung về xây dựng, cung cấp lưu trữ cho kết quả mà một chức năng nước ngoài đã nói ở trên, và cuối cùng đặt lại</li>
</ul> <p>Giá trị không phải là null.<code>Args...</code>tương ứng.</p>
<h3 id="Template_parameters">là không xác định.</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Người dùng có thể kiểm soát xem mỗi đối số để đặt lại được ghi lại bằng cách sao chép hoặc bằng tham chiếu, bằng cách chỉ định loại đối tượng hoặc loại tham chiếu trong</td> <td>-</td> <td>Thông minh</td>
</tr> <tr class="t-par"> <td>&gt; Cấu trúc Iterator;</td> <td>-</td> <td>Đối tượng thường được tiếp xúc với một chức năng nước ngoài để khởi tạo lại.</td>
</tr> <tr class="t-par"> <td>loại đối tượng (thường là một con trỏ thô) mà một chức năng nước ngoài truy cập để đặt lại quyền sở hữu</td> <td>-</td> <td>Args ...</td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>Pointer</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/nullablepointer" title="cpp/named req/NullablePointer">NullablePointer</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">loại đối số được nắm bắt được sử dụng để đặt lại đối tượng được điều chỉnh<code>Smart</code>Điều đó như vậy<code><a href="shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>loại đối tượng (thường là một con trỏ thô) mà một hàm nước ngoài ghi kết quả của nó<code>sizeof...(Args) == 0</code>.</td>
</tr>
</table> <h3 id="Specializations">Tra cứu cho định danh</h3> <p>chuyên môn.<code>out_ptr_t</code>Không giống như hầu hết các mẫu lớp trong thư viện tiêu chuẩn, các chuyên ngành được xác định theo chương trình</p>
<p>Điều đó phụ thuộc vào ít nhất một loại do chương trình xác định không cần đáp ứng các yêu cầu cho mẫu chính.</p>
<h3 id="Member_functions">nếu không thì</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="out_ptr_t/out_ptr_t" title="cpp/memory/out ptr t/out ptr t"> <span class="t-lines"><span>chuyên môn)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td>Xem bên dưới<code>out_ptr_t</code> <br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>chuyên môn)</span></span></div>
<div><span class="t-lines"><span><span class="t-cmark">[Đã xóa]</span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td> <code>out_ptr_t</code>Giấy phép này cho phép một chuyên môn được xác định bởi chương trình để lộ con trỏ thô được lưu trữ trong một con trỏ thông minh không chuẩn đến các chức năng nước ngoài.<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="out_ptr_t/~out_ptr_t" title="cpp/memory/out ptr t/~out ptr t"> <span class="t-lines"><span>một đối tượng ngoại lệ khác để gán với</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td>chuyên môn hóa và<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="out_ptr_t/operator_ptr" title="cpp/memory/out ptr t/operator ptr"> <span class="t-lines"><span>Đặt lại con trỏ thông minh thích nghi sau khi phát hành quyền sở hữu của mình</span><span>con trỏ vận hành*</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td>Nhà điều hành void **<code>out_ptr_t</code>Chuyển đổi<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <h3 id="Non-member_functions">Các chức năng không phải thành viên</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="out_ptr_t/out_ptr" title="cpp/memory/out ptr t/out ptr"> <span class="t-lines"><span>out_ptr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td>tạo ra một<code>out_ptr_t</code>với một con trỏ thông minh liên quan và đặt lại các đối số<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <h3 id="Notes">Ghi chú</h3> <p><code>out_ptr_t</code>Đặt lại con trỏ thông minh thích nghi<code>Pointer</code>mong đợi rằng các chức năng nước ngoài không sử dụng giá trị của</p>
<p>bị cấm.<code>out_ptr_t</code>Cách sử dụng điển hình của<code>std::out_ptr</code>đang tạo ra các đối tượng tạm thời của nó bởi<code>int foreign_setter(T**);</code>Và<code><a href="http://en.cppreference.com/w/cpp/memory/unique_ptr"><span class="kw735">Điều đó cho tất cả<span class="me2">độc đáo_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T, D<span class="sy1">&lt;</span> up<span class="sy4">Số lượng các yếu tố để sao chép</span></code>Khái niệm __comparisonCommontyPewith =</p>
<div class="cpp source-cpp"><pre data-language="cpp">, và chỉ tái tạo lại nó. Giá trị của con trỏ thông minh trước khi điều chỉnh không được sử dụng.</pre></div> <p>if (int ec = foreign_resetter (std :: inout_ptr (up))))</p>
<div class="cpp source-cpp"><pre data-language="cpp">int foreign_setter (t **);</pre></div> <p>gần như tương đương với<code>out_ptr_t</code>T *raw_p = up.get ();<a href="../language/storage_duration" title="cpp/language/storage duration">storage duration</a>tăng.Release ();</p>
<p><code>out_ptr_t</code>std :: độc đáo_ptr &lt;t, d&gt; up;<code><a href="shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code> <code><a href="shared_ptr/reset" title="cpp/memory/shared ptr/reset">std::shared_ptr::reset</a></code>if (int ec = foreign_setter (std :: out_ptr (up))))</p>
<p>int ec = foreign_resetter (&amp; RAW_P);<code><a href="http://en.cppreference.com/w/cpp/utility/tuple"><span class="kw1101">Điều đó cho tất cả<span class="me2">Tuple</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args...<span class="sy1">&lt;</span></code>up.reset (RAW_P);<code>Pointer</code>hoặc<code>void*</code>if (ec! = 0)</p>
<table class="wikitable sortable ftm-begin ftm-has-value"> <tr> <th>
<a href="../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td rowspan="2"><a href="../feature_test#cpp_lib_out_ptr" title="cpp/feature test"><code>__cpp_lib_out_ptr</code></a></td> <td><span class="nu0">Chỉ giải thích*</span></td> <td><span class="t-mark">Phạm vi :: IOTA</span></td> <td>
<code>std::out_ptr</code>Thì<code>std::inout_ptr</code> </td>
</tr> <tr> <td><span class="nu0">202311l</span></td> <td><span class="t-mark">(C ++ 26)</span></td> <td>tự do<code>std::out_ptr</code>Và<code>std::inout_ptr</code> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="inout_ptr_t" title="cpp/memory/inout ptr t"> <span class="t-lines"><span>INOUT_PTR_T</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td>Tương tác với các setters con trỏ nước ngoài, có được giá trị con trỏ ban đầu từ một con trỏ thông minh và đặt lại nó khi phá hủy<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unique_ptr" title="cpp/memory/unique ptr"> <span class="t-lines"><span>độc đáo_ptr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>Con trỏ thông minh với ngữ nghĩa sở hữu đối tượng độc đáo<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_ptr" title="cpp/memory/shared ptr"> <span class="t-lines"><span>Shared_ptr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>Con trỏ thông minh với ngữ nghĩa sở hữu đối tượng được chia sẻ<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/memory/out_ptr_t">https://en.cppreference.com/w/cpp/memory/out_ptr_t</a>
</p>
</div>
