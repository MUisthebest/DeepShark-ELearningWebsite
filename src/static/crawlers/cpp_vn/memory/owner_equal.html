 <h1 class="firstHeading" id="firstHeading">STD :: Chủ sở hữu_equal</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/memory" title="cpp/header/memory">&lt;memory&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx26"> <td> <pre data-language="cpp">Cấu trúc chủ sở hữu_equal;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx26">(kể từ C ++ 26)</span> </td> </tr> </table> <p>Đối tượng chức năng này cung cấp so sánh bằng loại hỗn hợp dựa trên chủ sở hữu (trái ngược với giá trị) của cả hai<code><a href="weak_ptr" title="cpp/memory/weak ptr">std::weak_ptr</a></code>Và<code><a href="shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>. Sự so sánh là hai con trỏ thông minh chỉ so sánh tương đương khi cả hai đều trống hoặc nếu chúng chia sẻ quyền sở hữu, ngay cả khi các giá trị của các con trỏ thô có được bởi<code>get()</code>là khác nhau (ví dụ: vì chúng chỉ vào các tiểu mục khác nhau trong cùng một đối tượng).</p>
<div class="t-li1">
<span class="t-li">1)</span>So sánh loại hỗn hợp dựa trên chủ sở hữu không được cung cấp cho các loại khác ngoài<code><a href="shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>Và<code><a href="weak_ptr" title="cpp/memory/weak ptr">std::weak_ptr</a></code>.</div> <div class="t-li1">
<span class="t-li">2)</span>So sánh bằng loại hỗn hợp dựa trên chủ sở hữu của<code><a href="shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>Và<code><a href="weak_ptr" title="cpp/memory/weak ptr">std::weak_ptr</a></code>.</div> <div class="t-li1">Đó là vị từ so sánh ưa thích khi xây dựng các container liên kết không có thứ tự với<code><a href="shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>Và<code><a href="weak_ptr" title="cpp/memory/weak ptr">std::weak_ptr</a></code>như chìa khóa cùng với<code>std::owner_hash</code>, đó là,<code><a href="http://en.cppreference.com/w/cpp/container/unordered_map"><span class="kw1296">Điều đó cho tất cả<span class="me2">unetered_map</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">Điều đó cho tất cả<span class="me2">Shared_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span>, U, std<span class="sy4">::</span><span class="me2">Chủ sở hữu_hash</span>, std<span class="sy4">::</span><span class="me2">Chủ sở hữu_equal</span><span class="sy1">&lt;</span></code>hoặc<code><a href="http://en.cppreference.com/w/cpp/container/unordered_map"><span class="kw1296">Điều đó cho tất cả<span class="me2">unetered_map</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/memory/weak_ptr"><span class="kw743">Điều đó cho tất cả<span class="me2">yếu_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span>, U, std<span class="sy4">::</span><span class="me2">Chủ sở hữu_hash</span>, std<span class="sy4">::</span><span class="me2">Chủ sở hữu_equal</span><span class="sy1">&lt;</span></code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span> <code>std::owner_equal</code>suy ra các loại tham số từ các đối số.</div> <h3 id="Nested_types">Các loại lồng nhau</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>Loại lồng nhau</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code>is_transparent</code> </td> <td> <a href="../utility/functional#Transparent_function_objects" title="cpp/utility/functional">unspecified</a> </td>
</tr> </table> <h3 id="Member_functions">nếu không thì</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><strong class="selflink"> <span class="t-lines"><span>chuyển đổi đối tượng thành</span></span></strong></div> </td> <td>so sánh các đối số của nó bằng cách sử dụng ngữ nghĩa dựa trên chủ sở hữu<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> </table> <div class="t-member"> <h2 id="std::owner_equal::operator.28.29">std :: chủ sở hữu_equal :: toán tử ()</h2> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx26"> <td> <pre data-language="cpp">Mẫu &lt;class t, class u&gt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx26">(kể từ C ++ 26)</span> </td> </tr> <tr class="t-dcl t-since-cxx26"> <td> <pre data-language="cpp">Toán tử bool () (const std :: shared_ptr &lt;t&gt; &amp; lhs, </pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx26">(kể từ C ++ 26)</span> </td> </tr> <tr class="t-dcl t-since-cxx26"> <td> <pre data-language="cpp">                 const std :: shared_ptr &lt;u&gt; &amp; rhs) const noexcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx26">(kể từ C ++ 26)</span> </td> </tr> <tr class="t-dcl t-since-cxx26"> <td> <pre data-language="cpp">Mẫu &lt;class t, class u&gt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx26">(kể từ C ++ 26)</span> </td> </tr> </table> <p>void Atomic_flag_wait_explicit (đối tượng Atomic_flag* dễ bay hơi<code>lhs</code>Và<code>rhs</code>Toán tử bool () (const std :: shared_ptr &lt;t&gt; &amp; lhs, <code>lhs.owner_equal(rhs)</code>.</p>
<p>                 const std :: weak_ptr &lt;u&gt; &amp; rhs) const noexcept;</p>
<p><code>lhs</code>Và<code>rhs</code>Mẫu &lt;class t, class u&gt;</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>E lvalues</td> <td>-</td> <td>Toán tử bool () (const std :: weak_ptr &lt;t&gt; &amp; lhs, </td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code>true</code>nếu như<code>lhs</code>Và<code>rhs</code>                 const std :: shared_ptr &lt;u&gt; &amp; rhs) const noexcept;<code>false</code>Nếu đối số đầu tiên là</p>
</div> <h3 id="Notes">Ghi chú</h3> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../feature_test#cpp_lib_smart_ptr_owner_equality" title="cpp/feature test"><code>__cpp_lib_smart_ptr_owner_equality</code></a></td> <td><span class="nu0">202306L</span></td> <td><span class="t-mark">(C ++ 26)</span></td> <td>Cho phép sử dụng<code>std::shared_ptr</code>Và<code>std::weak_ptr</code>như chìa khóa trong<a href="../container#Unordered_associative_containers" title="cpp/container">unordered associative containers</a> </td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="shared_ptr/owner_equal" title="cpp/memory/shared ptr/owner equal"> <span class="t-lines"><span>Chủ sở hữu_equal</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C ++ 26)</span></span></span></div> </td> <td>Mẫu &lt;class t, class u&gt;<br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::shared_ptr&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="weak_ptr/owner_equal" title="cpp/memory/weak ptr/owner equal"> <span class="t-lines"><span>Chủ sở hữu_equal</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C ++ 26)</span></span></span></div> </td> <td>Toán tử bool () (const std :: weak_ptr &lt;t&gt; &amp; lhs, <br/> <span class="t-mark">std :: cặp &lt;forwardit, forwardit&gt; <code>std::weak_ptr&lt;T&gt;</code>)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/memory/owner_equal">https://en.cppreference.com/w/cpp/memory/owner_equal</a>
</p>
</div>
