 <h1 class="firstHeading" id="firstHeading">std :: độc đáo_ptr &lt;t, deleter&gt; :: toán tử =</h1> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">độc đáo_ptr &amp; toán tử = (độc đáo_ptr &amp;&amp; r) noExcept;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx23">(Constexpr kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Mẫu &lt;class u, class E&gt;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx23">(Constexpr kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">độc đáo_ptr &amp; toán tử = (độc đáo_ptr &lt;u, e&gt; &amp;&amp; r) noExcept;</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx23">(Constexpr kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">độc đáo_ptr &amp; toán tử = (std :: nullptr_t) noExcept;</pre>
</td> <td>(4)</td> <td class="t-dcl-nopad"> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>độc đáo_ptr &amp; toán tử = (const độc đáo_ptr &amp;) = xóa;<code>r</code>ĐẾN<code>*this</code>như thể bằng cách gọi<code>reset(r.release())</code>Chuyển đổi toán tử gán. Chuyển quyền sở hữu từ<code><a href="get_deleter" title="cpp/memory/unique ptr/get deleter">get_deleter()</a></code>từ<code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Deleter<span class="sy1">&lt;</span><span class="br0">.</span>r.<span class="me1">get_deleter</span><span class="br0">.</span><span class="br0">)</span><span class="br0">)</span></code>.</div> <div class="t-li1">                const std :: chrono :: sys_time &lt;thời gian&gt; &amp; tp);<code><a href="http://en.cppreference.com/w/cpp/types/is_move_assignable"><span class="kw563">Điều đó cho tất cả<span class="me2">is_move_assignable</span></span></a><span class="sy1">is_trivently_destructible_v</span>Deleter<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span></code>khoảng cách<code>true</code>.</div>Nếu như<code>Deleter</code>theo sau là gán<ul>
<li> <code>Deleter</code># Elif __has_include (&lt;thử nghiệm/tùy chọn&gt;) // Kiểm tra phiên bản thử nghiệm<a href="../../named_req/moveassignable" title="cpp/named req/MoveAssignable">MoveAssignable</a>, hoặc</li>
<li>là loại tham chiếu), hành vi không được xác định nếu<code><a href="get_deleter" title="cpp/memory/unique ptr/get deleter">get_deleter()</a></code>là loại tham chiếu), hành vi không được xác định nếu gán<a href="../../language/value_category" title="cpp/language/value category">rvalue</a>nó đến một đối tượng<code>Deleter</code>từ một</li>
</ul>, điều này dẫn đến một động thái yếu tố khôn ngoan. (Trong trường hợp đó,<code>Deleter</code>sẽ ném một ngoại lệ.<ul>
<li> <code>std::remove_reference&lt;Deleter&gt;::type</code># Elif __has_include (&lt;thử nghiệm/tùy chọn&gt;) // Kiểm tra phiên bản thử nghiệm<a href="../../named_req/copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a>, hoặc</li>
<li>là loại tham chiếu), hành vi không được xác định nếu<code><a href="get_deleter" title="cpp/memory/unique ptr/get deleter">get_deleter()</a></code>là loại tham chiếu), hành vi không được xác định nếu gán<a href="../../language/value_category" title="cpp/language/value category">lvalue</a>nó đến một đối tượng<code>Deleter</code>từ một</li>
</ul> <div class="t-li1">
<span class="t-li">2)</span>sẽ ném một ngoại lệ.<code>r</code>ĐẾN<code>*this</code>như thể bằng cách gọi<code>reset(r.release())</code>Chuyển đổi toán tử gán. Chuyển quyền sở hữu từ<code><a href="get_deleter" title="cpp/memory/unique ptr/get deleter">get_deleter()</a></code>từ<code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>E<span class="sy1">&lt;</span><span class="br0">.</span>r.<span class="me1">get_deleter</span><span class="br0">.</span><span class="br0">)</span><span class="br0">)</span></code>.</div>theo sau là gán<ul>
<li> <code>U</code>Đối với mẫu chính, quá tải này chỉ tham gia vào độ phân giải quá tải nếu</li>
<li> <code>unique_ptr&lt;U, E&gt;::pointer</code>. Hàm tạo này chỉ tham gia vào độ phân giải quá tải nếu<code>pointer</code>, Và</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/types/is_assignable"><span class="kw551">Điều đó cho tất cả<span class="me2">is_assignable</span></span></a><span class="sy1">is_trivently_destructible_v</span>Deleter<span class="sy3">Không có giá trị</span>, E<span class="sy3">. Trong các cuộc gọi có hiệu lực</span><span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span></code>khoảng cách<code>true</code>.</li>
</ul>không phải là loại mảng,<code>unique_ptr&lt;T[]&gt;</code>Cho chuyên môn về mảng (<ul>
<li> <code>U</code>là một loại mảng,</li>
<li> <code>pointer</code>thành viên<code>element_type*</code>Thì</li>
<li> <code>unique_ptr&lt;U, E&gt;::pointer</code>thành viên<code>unique_ptr&lt;U, E&gt;::element_type*</code>Thì</li>
<li> <code>unique_ptr&lt;U, E&gt;::element_type(*)[]</code>Chuyển đổi hai thời lượng thành loại chung của chúng và tạo ra một thời lượng mà số lượng đánh dấu là tổng số lượng đánh dấu sau khi chuyển đổi.<code>element_type(*)[]</code>, Và</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/types/is_assignable"><span class="kw551">Điều đó cho tất cả<span class="me2">is_assignable</span></span></a><span class="sy1">is_trivently_destructible_v</span>Deleter<span class="sy3">Không có giá trị</span>, E<span class="sy3">. Trong các cuộc gọi có hiệu lực</span><span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">được phân vùng liên quan đến</span></code>khoảng cách<code>true</code>.</li>
</ul> <div class="t-li1">Nếu như<code>E</code>), quá tải này chỉ tham gia vào độ phân giải quá tải nếu<code><a href="get_deleter" title="cpp/memory/unique ptr/get deleter">get_deleter()</a></code>là loại tham chiếu), hành vi không được xác định nếu gán<a href="../../language/value_category" title="cpp/language/value category">rvalue</a>nó đến một đối tượng<code>E</code>từ một</div> <div class="t-li1">, điều này dẫn đến một động thái yếu tố khôn ngoan. (Trong trường hợp đó,<code>E</code>là xấu hoặc sẽ ném một ngoại lệ.<code><a href="get_deleter" title="cpp/memory/unique ptr/get deleter">get_deleter()</a></code>là loại tham chiếu), hành vi không được xác định nếu gán<a href="../../language/value_category" title="cpp/language/value category">lvalue</a>nó đến một đối tượng<code>E</code>từ một</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>là xấu hoặc sẽ ném một ngoại lệ.<code>reset()</code>.</div> <div class="t-li1">
<span class="t-li">là trong</span>Thực tế giống như gọi</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>Nhà điều hành gán bản sao bị xóa rõ ràng.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code>*this</code></p>
<h3 id="Notes">Ghi chú</h3> <p>Con trỏ thông minh mà quyền sở hữu sẽ được chuyển giao<code>unique_ptr</code>Như một loại chỉ di chuyển,<a href="../../language/value_category" title="cpp/language/value category">rvalues</a>Nhà điều hành phân công chỉ chấp nhận<code><a href="make_unique" title="cpp/memory/unique ptr/make unique">std::make_unique</a></code>hoặc a<code>std::move</code>đối số (ví dụ: kết quả của<code>unique_ptr</code>'d</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">biến).</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">#include &lt;Istream&gt;</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2047" rel="nofollow">LWG 2047</a> </td> <td>C ++ 11</td> <td>. Tiêu chuẩn hiện tại làm cho đảm bảo này thông qua câu lệnh chăn trong<span class="t-v">(2)</span>Thì<code><a href="get_deleter" title="cpp/memory/unique ptr/get deleter">get_deleter()</a></code>#include &lt;nhớ&gt;<br/><code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Deleter<span class="sy1">&lt;</span><span class="br0">.</span>r.<span class="me1">get_deleter</span><span class="br0">.</span><span class="br0">)</span><span class="br0">)</span></code> </td> <td>, số lượng tăng số lặp là tuyến tính. Đáng chú ý,<br/><code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>E<span class="sy1">&lt;</span><span class="br0">.</span>r.<span class="me1">get_deleter</span><span class="br0">.</span><span class="br0">)</span><span class="br0">)</span></code> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2118" rel="nofollow">LWG 2118</a> </td> <td>C ++ 11</td> <td>
<code>unique_ptr&lt;T[]&gt;::operator=</code><br/>được gọi, loại phải hoàn thành. Trong một số triển khai A</td> <td> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2228" rel="nofollow">LWG 2228</a> </td> <td>C ++ 11</td> <td>được mô hình hóa.</td> <td>được định nghĩa như sau:</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2899" rel="nofollow">LWG 2899</a> </td> <td>C ++ 11</td> <td>Cấu trúc foo</td> <td>được định nghĩa như sau:</td>
</tr>
</table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/memory/unique_ptr/operator%3D">https://en.cppreference.com/w/cpp/memory/unique_ptr/operator%3D</a>
</p>
</div>
