 <h1 class="firstHeading" id="firstHeading">std :: unininitialized_fill</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/memory" title="cpp/header/memory">&lt;memory&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Mẫu &lt;class forwardit, class t&gt;</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void uninitialized_fill (forwardIt đầu tiên, forwardit cuối cùng, const t &amp; value);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Mẫu &lt;class execPolicy, class forwardit, class t&gt;<code>value</code>void uninitialized_fill (execPolicy &amp;&amp; chính sách,<code>[</code><code>first</code><code>, </code><code>last</code><code>)</code>Mẫu &lt;Class T&gt;<code>for (; first != last; ++first)<br/> ::new (/* VOIDIFY */(*first))<br/> <span class="kw1">            Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng);</span> <a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw654">Điều đó cho tất cả<span class="me2">iterator_traits</span></span></a><span class="sy1">is_trivently_destructible_v</span>ForwardIt<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">// hoặc *(d_first + 1) = op (val1, std :: di chuyển (acc)); cho quá tải (2)</span><span class="br0">.</span>value<span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>
</div> <div class="t-li1">Ở đâu<code>/* VOIDIFY */(e)</code>Nếu phạm vi trống.<table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <code>static_cast&lt;void*&gt;(&amp;e)</code> </td> <td><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> <code><span class="kw1">Mẫu &lt;Biểu đồ lớp, Đặc điểm lớp, Alloc Class, Class Parsable&gt;</span><span class="sy1">is_trivently_destructible_v</span><span class="kw4">Vô hiệu</span><span class="sy2">*</span><span class="sy1">&lt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/memory/addressof"><span class="kw758">Điều đó cho tất cả<span class="me2">địa chỉ</span></span></a><span class="br0">.</span>e<span class="br0">)</span><span class="br0">)</span></code> </td> <td><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></td>
</tr> </table>
</div> <div class="t-li1">Mẫu &lt;class execPolicy, class forwardit, class nothrowforwardit&gt;</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>Mẫu &lt;class execPolicy, class forwardit, lớp nhị phân&gt;<code>policy</code>, hành vi là không xác định. Trong trường hợp này,<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1567">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p><code><a href="http://en.cppreference.com/w/cpp/algorithm/is_execution_policy"><span class="kw1567">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2643">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>ExecutionPolicy<span class="sy1">2,4)</span></code>khoảng cách<code>true</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table>
</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>                                      Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng);</td>
</tr> <tr class="t-par"> <td>được phân vùng liên quan đến</td> <td>-</td> <td>                         Chuyển tiếp đầu tiên, chuyển tiếp cuối cùng, const t &amp; value);</td>
</tr> <tr class="t-par"> <td>std :: iterator_traits &lt;buputit&gt; :: value_type acc = *first;</td> <td>-</td> <td>*d_first = acc;<a href="../algorithm/execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">execution policy</a> </td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>ForwardIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">Phá hủy các đối tượng trong phạm vi<code>ForwardIt</code>for (; đầu tiên! = cuối cùng; ++ đầu tiên)<span class="t-rev-inl t-until-cxx11"><span>(resp.<code>&amp;*</code>Mẫu &lt;class forwardit, class t&gt;<code>ForwardIt</code>                                     Nothrowforwardit d_first);</span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span> </td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Gán cho đã cho</p>
<h3 id="Complexity">Không hợp lệ bất kỳ trình lặp lại nào (bao gồm bất kỳ trình lặp cuối nào) hoặc sửa đổi bất kỳ yếu tố nào của các phạm vi liên quan, hành vi không được xác định.</h3> <p>Mẫu &lt;class execPolicy, class forwardit, class so sánh&gt;<code>first</code>Và<code>last</code>.</p>
<h3 id="Exceptions">Ngoại lệ</h3> <p>Trình lặp trong phạm vi đích, chỉ qua phần tử cuối cùng được sao chép nếu<code>ExecutionPolicy</code>Bài tập bằng không nếu</p>
<ul>
<li>Chính sách thực thi để sử dụng. Nhìn thấy<code>ExecutionPolicy</code>Để biết chi tiết.<a href="../algorithm/execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">standard policies</a>Thì<code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code>Loại loại 1 và type2 phải sao cho một đối tượng của loại iterator_traits<code>ExecutionPolicy</code>Đầu vào</li>
<li>value_type<code><a href="new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>có thể được chuyển đổi hoàn toàn thành cả hai. Loại</li>
</ul> <h3 id="Possible_implementation">. ​</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">Bản sao đã cho</pre></div> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">đến một khu vực bộ nhớ không được chỉ định, được xác định bởi phạm vi</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">giá trị để xây dựng các yếu tố với</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue866" rel="nofollow">LWG 866</a> </td> <td>C ++ 98</td> <td>Phạm vi của các yếu tố để sao chép<code>T</code>Giá trị phải mang lại một con trỏ cho loại giá trị của nó.<code>ForwardIt</code>Sử dụng chức năng nhị phân đã cho<br/>T<span class="sy4">::</span><a href="http://en.cppreference.com/w/cpp/memory/new/operator_new"><span class="kw690">nhà điều hành mới</span></a>Mẫu &lt;class inputit, class nothrowforwardit&gt;</td> <td>Nothrowforwardit uninitialized_copy (đầu vào đầu tiên, đầu vào cuối cùng, nothrowforwardit d_first)<br/>{</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2433" rel="nofollow">LWG 2433</a> </td> <td>C ++ 11</td> <td>    sử dụng t = typename std :: iterator_traits &lt;nothrowforwardit&gt; :: value_type;<span class="sy3">Không có giá trị</span> </td> <td>Sử dụng<code><a href="addressof" title="cpp/memory/addressof">std::addressof</a></code> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3870" rel="nofollow">LWG 3870</a> </td> <td>C ++ 20</td> <td>    Nothrowforwardit current = d_first;<span class="kw4">hằng số</span>kho</td> <td>    thử</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="uninitialized_fill_n" title="cpp/memory/uninitialized fill n"> <span class="t-lines"><span>(Niebloid)</span></span></a></div> </td> <td>(C ++ 20)<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="ranges/uninitialized_fill" title="cpp/memory/ranges/uninitialized fill"> <span class="t-lines"><span>(Mẫu chức năng)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>(C ++ 20)<br/><span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/memory/uninitialized_fill">https://en.cppreference.com/w/cpp/memory/uninitialized_fill</a>
</p>
</div>
