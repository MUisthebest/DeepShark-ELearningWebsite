 <h1 class="firstHeading" id="firstHeading">STD :: Shared_ptr</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/memory" title="cpp/header/memory">&lt;memory&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;class T&gt; class chia sẻ_ptr;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> </table> <p><code>std::shared_ptr</code>là một con trỏ thông minh giữ lại quyền sở hữu chung của một đối tượng thông qua một con trỏ. Một số<code>shared_ptr</code>Đối tượng có thể sở hữu cùng một đối tượng. Đối tượng bị phá hủy và bộ nhớ của nó được giải quyết khi một trong hai điều sau đây xảy ra:</p>
<ul>
<li>cuối cùng còn lại<code>shared_ptr</code>Sở hữu đối tượng bị phá hủy;</li>
<li>cuối cùng còn lại<code>shared_ptr</code>Sở hữu đối tượng được gán một con trỏ khác thông qua<code><a href="shared_ptr/operator=" title="cpp/memory/shared ptr/operator=">operator=</a></code>hoặc<code><a href="shared_ptr/reset" title="cpp/memory/shared ptr/reset">reset()</a></code>.</li>
</ul> <p>Đối tượng bị phá hủy bằng cách sử dụng<a href="../language/delete" title="cpp/language/delete">delete-expression</a>hoặc một lần phân phối tùy chỉnh được cung cấp cho<code>shared_ptr</code>Trong quá trình xây dựng.</p>
<p>MỘT<code>shared_ptr</code>có thể chia sẻ quyền sở hữu của một đối tượng trong khi lưu trữ một con trỏ đến một đối tượng khác. Tính năng này có thể được sử dụng để trỏ đến các đối tượng thành viên trong khi sở hữu đối tượng mà chúng thuộc về. Con trỏ được lưu trữ là một con được truy cập bởi<code><a href="shared_ptr/get" title="cpp/memory/shared ptr/get">get()</a></code>, các nhà khai thác so sánh và so sánh. Con trỏ được quản lý là một con được truyền cho Deleter khi số lượng sử dụng đạt đến 0.</p>
<p>MỘT<code>shared_ptr</code>cũng có thể sở hữu không có đối tượng, trong trường hợp đó nó được gọi là<i>trống</i>(Một trống rỗng<code>shared_ptr</code>Có thể có một con trỏ không lưu trữ không null nếu hàm tạo bí danh được sử dụng để tạo nó).</p>
<p>được cung cấp (mặc dù chúng được đánh vần khác nhau trong tiêu chuẩn, chúng biểu thị cùng một loại):<code>shared_ptr</code>            Nhị phân p);<a href="../named_req/copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>Thì<a href="../named_req/copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a>, Và<a href="../named_req/lessthancomparable" title="cpp/named req/LessThanComparable">LessThanComparable</a> <a class="mw-redirect" href="../language/implicit_cast" title="cpp/language/implicit cast">contextually convertible</a>ĐẾN<code>bool</code>.</p>
<p>Tất cả các chức năng thành viên (bao gồm trình xây dựng bản sao và gán bản sao) có thể được gọi bằng nhiều luồng trên các trường hợp khác nhau của<code>shared_ptr</code>Nếu không có thêm đồng bộ hóa ngay cả khi các trường hợp này là bản sao và chia sẻ quyền sở hữu của cùng một đối tượng. Nếu nhiều luồng thực thi truy cập cùng một thể hiện của<code>shared_ptr</code>không có đồng bộ hóa và bất kỳ quyền truy cập nào trong số đó đều sử dụng chức năng thành viên không phải là cuộc<code>shared_ptr</code>Sau đó, một cuộc đua dữ liệu sẽ xảy ra; các<a href="shared_ptr/atomic" title="cpp/memory/shared ptr/atomic"><code>shared_ptr</code> overloads of atomic functions</a>có thể được sử dụng để ngăn chặn cuộc đua dữ liệu.</p>
<h3 id="Member_types">nhà điều hành ()</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>ATOMIC_UNSIGNED_LOCK_FREE</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code>element_type</code> </td> <td> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td><code>T</code></td> <td><span class="t-mark-rev t-until-cxx17">xáo trộn</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td><code><a href="http://en.cppreference.com/w/cpp/types/remove_extent"><span class="kw624">Điều đó cho tất cả<span class="me2">Mẫu &lt;/*has-thành viên-loại giá trị*/ t&gt;</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code></td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> </td>
</tr> <tr class="t-dsc"> <td> <code>weak_type</code> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> <td> <code><a href="http://en.cppreference.com/w/cpp/memory/weak_ptr"><span class="kw742">Điều đó cho tất cả<span class="me2">yếu_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code> </td>
</tr> </table> <h3 id="Member_functions">nếu không thì</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="shared_ptr/shared_ptr" title="cpp/memory/shared ptr/shared ptr"> <span class="t-lines"><span>chuyên môn)</span></span></a></div> </td> <td>xây dựng mới<code>shared_ptr</code> <br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_ptr/~shared_ptr" title="cpp/memory/shared ptr/~shared ptr"> <span class="t-lines"><span>một đối tượng ngoại lệ khác để gán với</span></span></a></div> </td> <td>phá hủy đối tượng sở hữu nếu không còn<code>shared_ptr</code>liên kết với nó<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_ptr/operator=" title="cpp/memory/shared ptr/operator="> <span class="t-lines"><span>chuyên môn)</span></span></a></div> </td> <td>Đề cập đến Coroutines No-Op. Nó không thể được tạo ra từ một đối tượng hứa hẹn.<code>shared_ptr</code> <br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Modifiers">Sửa đổi</h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_ptr/reset" title="cpp/memory/shared ptr/reset"> <span class="t-lines"><span>cài lại</span></span></a></div> </td> <td>Thay thế đối tượng được quản lý<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_ptr/swap" title="cpp/memory/shared ptr/swap"> <span class="t-lines"><span>Được xác định trong tiêu đề</span></span></a></div> </td> <td>hoán đổi các đối tượng được quản lý<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Observers">Quan sát viên</h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_ptr/get" title="cpp/memory/shared ptr/get"> <span class="t-lines"><span>Điền vào thùng chứa với giá trị được chỉ định</span></span></a></div> </td> <td>Trả về con trỏ được lưu trữ<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_ptr/operator*" title="cpp/memory/shared ptr/operator*"> <span class="t-lines"><span>toán tử/=</span><span>toán tử-&gt;</span></span></a></div> </td> <td>    tĩnh t* ptr () {trả về mới t; }<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_ptr/operator_at" title="cpp/memory/shared ptr/operator at"> <span class="t-lines"><span>nhà điều hành []</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>cung cấp quyền truy cập được lập chỉ mục vào mảng được lưu trữ<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_ptr/use_count" title="cpp/memory/shared ptr/use count"> <span class="t-lines"><span>use_count</span></span></a></div> </td> <td>do_unshift<code>shared_ptr</code>Các đối tượng đề cập đến cùng một đối tượng được quản lý<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_ptr/unique" title="cpp/memory/shared ptr/unique"> <span class="t-lines"><span>(Niebloid)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></span></span></div> </td> <td>kiểm tra xem đối tượng được quản lý chỉ được quản lý bởi hiện tại<code>shared_ptr</code>giữa<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_ptr/operator_bool" title="cpp/memory/shared ptr/operator bool"> <span class="t-lines"><span>(hằng số thành viên tĩnh công cộng)</span></span></a></div> </td> <td>Kiểm tra xem con trỏ được lưu trữ không phải là NULL<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_ptr/owner_before" title="cpp/memory/shared ptr/owner before"> <span class="t-lines"><span>Toán tử bool () (const std :: shared_ptr &lt;t&gt; &amp; lhs, </span></span></a></div> </td> <td>Thành viên của cả hai chuyên ngành mẫu<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_ptr/owner_hash" title="cpp/memory/shared ptr/owner hash"> <span class="t-lines"><span>Chủ sở hữu_hash</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C ++ 26)</span></span></span></div> </td> <td>Giá trị băm giống hệt nhau cho bất kỳ<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_ptr/owner_equal" title="cpp/memory/shared ptr/owner equal"> <span class="t-lines"><span>Chủ sở hữu_equal</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C ++ 26)</span></span></span></div> </td> <td>Mẫu &lt;class t, class u&gt;<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <h3 id="Non-member_functions">Các chức năng không phải thành viên</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="shared_ptr/make_shared" title="cpp/memory/shared ptr/make shared"> <span class="t-lines"><span>make_shared</span><span>make_shared_for_overwrite</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Tạo một con trỏ được chia sẻ để quản lý một đối tượng mới<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_ptr/allocate_shared" title="cpp/memory/shared ptr/allocate shared"> <span class="t-lines"><span>Phân bổ_shared</span><span>phân bổ_shared_for_overwrite</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Tạo một con trỏ được chia sẻ để quản lý một đối tượng mới được phân bổ bằng cách sử dụng bộ phân bổ<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_ptr/pointer_cast" title="cpp/memory/shared ptr/pointer cast"> <span class="t-lines"><span>static_pulum_cast</span><span>Dynamic_Pulum_cast</span><span>const_pulum_cast</span><span>reinterpret_pulum_cast</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>mà không có bất kỳ đúc.<a href="../language/static_cast" title="cpp/language/static cast"><code>static_cast</code></a>Thì<a href="../language/dynamic_cast" title="cpp/language/dynamic cast"><code>dynamic_cast</code></a>Thì<a href="../language/const_cast" title="cpp/language/const cast"><code>const_cast</code></a>, hoặc<a href="../language/reinterpret_cast" title="cpp/language/reinterpret cast"><code>reinterpret_cast</code></a>Đến con trỏ được lưu trữ<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_ptr/get_deleter" title="cpp/memory/shared ptr/get deleter"> <span class="t-lines"><span>get_deleter</span></span></a></div> </td> <td>Trả về việc xóa loại được chỉ định, nếu được sở hữu<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_ptr/operator_cmp" title="cpp/memory/shared ptr/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span><span>người vận hành*</span><span>toán tử &lt;=</span><span>toán tử&gt;</span><span>toán tử&gt; =</span><span>Nhà điều hành &lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>So sánh với người khác<code>shared_ptr</code>là một Symlink hiện có, bản thân nó bị xóa, không phải là mục tiêu của nó.<code>nullptr</code> <br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_ptr/operator_ltlt" title="cpp/memory/shared ptr/operator ltlt"> <span class="t-lines"><span>toán tử &lt;&lt;<span class="t-dsc-small">Thuật toán</span></span></span></a></div> </td> <td>đầu ra giá trị của con trỏ được lưu trữ vào luồng đầu ra<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_ptr/swap2" title="cpp/memory/shared ptr/swap2"> <span class="t-lines"><span>chuyên về<span class="t-dsc-small">Thuật toán</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>quá tải<code><a href="../algorithm/swap" title="cpp/algorithm/swap">std::swap</a></code>Thuật toán<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="shared_ptr/atomic" title="cpp/memory/shared ptr/atomic"> <span class="t-lines"><span>Tất cả các loại nguyên tử ngoại trừ<span class="t-dsc-small">Thuật toán</span></span><span>như thể bằng<span class="t-dsc-small">Thuật toán</span></span><span>Về mặt nguyên tử có được giá trị được chỉ ra bởi<span class="t-dsc-small">Thuật toán</span></span><span>void Atomic_store (STD dễ bay hơi :: Atomic &lt;T&gt;* obj,<span class="t-dsc-small">Thuật toán</span></span><span>                   Tên std :: Atomic &lt;T&gt; :: value_type mong muốn) NOEXCEPT;<span class="t-dsc-small">Thuật toán</span></span><span>và trả về giá trị<span class="t-dsc-small">Thuật toán</span></span><span>tổ chức trước đó, như thể bằng cách<span class="t-dsc-small">Thuật toán</span></span><span>bộ nhớ_order_seq_cst<span class="t-dsc-small">Thuật toán</span></span><span>(5-8)<span class="t-dsc-small">Thuật toán</span></span><span>std :: Atomic_compare_exchange_weak_explict<span class="t-dsc-small">Thuật toán</span></span><span>std :: Atomic_compare_exchange_strong_explict<span class="t-dsc-small">Thuật toán</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-deprecated-cxx20">(Không dùng nữa trong C ++ 20)</span></span></span></div> </td> <td>con trỏ đến đối tượng nguyên tử để sửa đổi<code>std::shared_ptr</code> <br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <h3 id="Helper_classes">Lớp học trợ giúp</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="shared_ptr/atomic2" title="cpp/memory/shared ptr/atomic2"> <span class="t-lines"><span>    {<span class="t-dsc-small">{</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>    for (int n = 0; n &lt;10000; ++ n)<br/> <span class="t-mark">(Chuyên ngành mẫu lớp)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_ptr/hash" title="cpp/memory/shared ptr/hash"> <span class="t-lines"><span>STD :: Hash<span class="t-dsc-small">{</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>Hỗ trợ băm cho<strong class="selflink"><code>std::shared_ptr</code></strong> <br/> <span class="t-mark">(Chuyên ngành mẫu lớp)</span> </td>
</tr> </table> <h3 id="Deduction_guides_.28since_C.2B.2B17.29"> <a href="shared_ptr/deduction_guides" title="cpp/memory/shared ptr/deduction guides">Deduction guides</a> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span>
</h3> <h3 id="Notes">Ghi chú</h3> <p>Quyền sở hữu của một đối tượng chỉ có thể được chia sẻ với người khác<code>shared_ptr</code>bằng cách sao chép xây dựng hoặc sao chép việc gán giá trị của nó cho một<code>shared_ptr</code>. Xây dựng một cái mới<code>shared_ptr</code>sử dụng con trỏ cơ bản thô thuộc sở hữu của người khác<code>shared_ptr</code>dẫn đến hành vi không xác định.</p>
<p><code>std::shared_ptr</code>có thể được sử dụng với một<a class="mw-redirect" href="../language/incomplete_type" title="cpp/language/incomplete type">incomplete type</a> <code>T</code>. Tuy nhiên, hàm tạo từ một con trỏ thô (<code>template&lt;class Y&gt; shared_ptr(Y*)</code>) và<code>template&lt;class Y&gt; void reset(Y*)</code>Chức năng thành viên chỉ có thể được gọi bằng một con trỏ tới một loại hoàn chỉnh (lưu ý rằng<code><a href="unique_ptr" title="cpp/memory/unique ptr">std::unique_ptr</a></code>có thể được xây dựng từ một con trỏ thô sang một loại không đầy đủ).</p>
<p>Các<code>T</code>trong std<span class="sy4">::</span><span class="me2">Shared_ptr</span><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span>Có thể là một loại chức năng: trong trường hợp này, nó quản lý một con trỏ để hoạt động, thay vì một con trỏ đối tượng. Điều này đôi khi được sử dụng để giữ một thư viện động hoặc một plugin được tải miễn là bất kỳ chức năng nào của nó được tham chiếu:</p>
<div class="cpp source-cpp"><pre data-language="cpp">void del (void (*) ()) {}</pre></div> <h3 id="Implementation_notes"> </h3> <p>void fun () {}<code>shared_ptr</code> </p>
<ul>
<li>int main ()<code><a href="shared_ptr/get" title="cpp/memory/shared ptr/get">get()</a></code>);</li>
<li>bên trong<i>{</i>.</li>
</ul> <p>    std :: shared_ptr &lt;void ()&gt; ee (vui, del);</p>
<ul>
<li>    (*ee) ();</li>
<li>}</li>
<li>Ghi chú thực hiện</li>
<li>trong bộ đệm do người dùng cung cấp hoặc null<code>shared_ptr</code>Trong một triển khai điển hình,</li>
<li>trong bộ đệm do người dùng cung cấp hoặc null<code>weak_ptr</code>Chỉ giữ hai con trỏ:</li>
</ul> <p>      std :: memory_order order = std :: memory_order_seq_cst) noexcept dễ bay hơi;<code>shared_ptr</code>con trỏ được lưu trữ (một con được trả lại bởi<code><a href="shared_ptr/make_shared" title="cpp/memory/shared ptr/make shared">std::make_shared</a></code>hoặc<code><a href="shared_ptr/allocate_shared" title="cpp/memory/shared ptr/allocate shared">std::allocate_shared</a></code>Khối điều khiển<code>shared_ptr</code>Khối điều khiển là một đối tượng được phân bổ động giữ:<code>shared_ptr</code>hoặc là một con trỏ tới đối tượng được quản lý hoặc chính đối tượng được quản lý;</p>
<p>DELETER (loại có loại);<code>shared_ptr</code>người phân bổ (loại truy cập loại);<code><a href="shared_ptr/get" title="cpp/memory/shared ptr/get">get()</a></code>s sở hữu đối tượng được quản lý;</p>
<p>s đề cập đến đối tượng được quản lý.<code>shared_ptr</code>được tạo bằng cách gọi<code><a href="weak_ptr" title="cpp/memory/weak ptr">std::weak_ptr</a></code>, bộ nhớ cho cả khối điều khiển và đối tượng được quản lý được tạo với một phân bổ duy nhất. Đối tượng được quản lý được xây dựng tại chỗ trong một thành viên dữ liệu của khối điều khiển. Khi</p>
<p>được tạo thông qua một trong những<a class="external autonumber" href="https://stackoverflow.com/questions/43297517/stdshared-ptr-internals-weak-count-more-than-expected" rel="nofollow">[1]</a>Thì<a class="external autonumber" href="https://www.reddit.com/r/cpp/comments/3eia29/stdshared_ptrs_secret_constructor/ctfeh1p" rel="nofollow">[2]</a>Các hàm tạo, đối tượng được quản lý và khối điều khiển phải được phân bổ riêng. Trong trường hợp này, khối điều khiển lưu trữ một con trỏ đến đối tượng được quản lý.</p>
<p>Con trỏ được giữ bởi<code><a href="../atomic/atomic/fetch_add" title="cpp/atomic/atomic/fetch add">std::atomic::fetch_add</a></code>với<code><a href="../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_relaxed</a></code>trực tiếp là người được trả lại bởi</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">, trong khi con trỏ/đối tượng được giữ bởi khối điều khiển là một trong số sẽ bị xóa khi số lượng chủ sở hữu được chia sẻ đạt bằng không. Những gợi ý này không nhất thiết phải bằng nhau.</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">Kẻ hủy diệt của</pre></div> </div> <h3 id="Example_2">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Giảm số lượng chủ sở hữu được chia sẻ của khối điều khiển. Nếu bộ đếm đó đạt được số 0, khối điều khiển sẽ gọi bộ hủy của đối tượng được quản lý. Khối điều khiển không tự giải quyết cho đến khi</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Bộ đếm cũng không đạt được.</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="unique_ptr" title="cpp/memory/unique ptr"> <span class="t-lines"><span>độc đáo_ptr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>Con trỏ thông minh với ngữ nghĩa sở hữu đối tượng độc đáo<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="weak_ptr" title="cpp/memory/weak ptr"> <span class="t-lines"><span>yếu_ptr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>tham chiếu yếu đến một đối tượng được quản lý bởi<code>std::shared_ptr</code> <br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/memory/shared_ptr">https://en.cppreference.com/w/cpp/memory/shared_ptr</a>
</p>
</div>
