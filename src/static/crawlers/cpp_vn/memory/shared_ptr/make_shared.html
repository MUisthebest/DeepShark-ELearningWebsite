 <h1 class="firstHeading" id="firstHeading">std :: make_shared, std :: make_shared_for_overwrite</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/memory" title="cpp/header/memory">&lt;memory&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;class t, class ... args&gt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark">Shared_ptr &lt;t&gt; make_shared (args &amp;&amp; ... args);</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td><pre data-language="cpp">(T không phải là mảng)</pre></td> <td>(2)</td> <td>
<span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark">Mẫu &lt;class t, class alloc&gt;</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt;</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark">Mẫu &lt;class t, class alloc&gt;</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Shared_ptr &lt;t&gt; make_shared (std :: size_t n);</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark">Mẫu &lt;class t, class alloc&gt;</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt;</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark">Mẫu &lt;class t, class alloc&gt;</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td><pre data-language="cpp">Shared_ptr &lt;t&gt; make_shared ();</pre></td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td>
<span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark">                               const std :: remove_extent_t &lt;t&gt; &amp; u);</span>
</td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt;</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> <br/><span class="t-mark">Mẫu &lt;class t, class alloc&gt;</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>void cấu trúc (u* p, args &amp;&amp; ... args);<code>T</code>Shared_ptr &lt;t&gt; phân bổ_shared (Const ALLOC &amp; ALLOC,<code><a href="../shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>    Count_if (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);<code>args</code>                               const std :: remove_extent_t &lt;t&gt; &amp; u);<code>T</code>(T là u [n])<code><span class="sy4">::</span><span class="me2">mới</span> <span class="br0">.</span>pv<span class="br0">)</span> T<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span>args<span class="br0">)</span>...<span class="br0">)</span></code>là<code>pv</code>Mẫu &lt;class t, class alloc&gt;<code>void*</code>Shared_ptr &lt;t&gt; allocate_shared_for_overwrite (const alloc &amp; alloc);<code>T</code>Mẫu &lt;class t, class alloc&gt;<code>sizeof(T)</code>Shared_ptr &lt;t&gt; allocate_shared_for_overwrite (const alloc &amp; alloc, std :: size_t n);<code>T</code>(T là u [])<code>std::shared_ptr</code>và bọc nó trong một<code>shared_from_this</code>là danh sách tham số cho hàm tạo của<code>T</code>.<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>Shared_ptr &lt;t&gt; make_shared (std :: size_t n, const std :: remove_extent_t &lt;t&gt; &amp; u);</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table>
</div> <div class="t-li1">
<span class="t-li">          std :: Indirect_strict_weak_order &lt;</span>                                   Nhị phân p);<span class="t-v">(1)</span>Mẫu &lt;Class T&gt;<code><a href="http://en.cppreference.com/w/cpp/types/remove_all_extents"><span class="kw626">Điều đó cho tất cả<span class="me2">Tạo một mảng có kích thước</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>Shared_ptr &lt;t&gt; make_shared (const std :: remove_extent_t &lt;t&gt; &amp; u);<code><span class="sy4">::</span><span class="me2">mới</span><span class="br0">.</span>pv<span class="br0">)</span> <a href="http://en.cppreference.com/w/cpp/types/remove_all_extents"><span class="kw626">Điều đó cho tất cả<span class="me2">Tạo một mảng có kích thước</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="br0">.</span><span class="br0">)</span></code>dọc theo chiều đầu tiên của nó. Các yếu tố mảng được khởi tạo theo thứ tự tăng dần của địa chỉ của chúng và khi kết thúc trọn đời của chúng bị phá hủy theo thứ tự ngược lại của công trình ban đầu của chúng.<span class="t-v">(2)</span>, nhưng các phần tử của mảng được khởi tạo từ giá trị mặc định<code>N</code>Bản thân nó không phải là loại mảng, thì điều này được thực hiện như thể bởi cùng một biểu thức phân bổ như trong</div> <div class="t-li1">
<span class="t-li">cluct clock_time_conversion &lt;clock, std :: Chrono :: System_Clock&gt;;</span>                                   Nhị phân p);<span class="t-v">sở hữu phần tử được trích xuất hoặc xử lý nút trống trong trường hợp phần tử không được tìm thấy trong</span>Mẫu &lt;Class T&gt;<code>u</code>. Nếu như<code>U</code>Shared_ptr &lt;t&gt; make_shared_for_overwrite ();<span class="t-v">(1)</span>Mẫu &lt;Class T&gt;<code>u</code>Shared_ptr &lt;t&gt; make_shared_for_overwrite (std :: size_t n);<span class="t-v">(1)</span>dọc theo chiều đầu tiên của nó. Các yếu tố mảng được khởi tạo theo thứ tự tăng dần của địa chỉ của chúng và khi kết thúc trọn đời của chúng bị phá hủy theo thứ tự ngược lại của công trình ban đầu của chúng.<span class="t-v">(4)</span>, nhưng các phần tử của mảng được khởi tạo từ giá trị mặc định<code>N</code>Bản thân nó không phải là loại mảng, thì điều này được thực hiện như thể bởi cùng một biểu thức phân bổ như trong</div> <div class="t-li1">
<span class="t-li">từ_sys</span>                                   Nhị phân p);<span class="t-v">(1)</span>nếu như<code>T</code>, ngoại trừ việc người phân bổ được bật lại cho<span class="t-v">(3)</span>nếu như<code>T</code>khoảng cách<code>U[N]</code>Remove_all_extents_t<a href="../../language/default_initialization" title="cpp/language/default initialization">default-initialized</a>.</div> <div class="t-li1">
<span class="t-li">6)</span>                                   Nhị phân p);<span class="t-v">(2)</span>. Mặt khác, điều này được thực hiện như thể bằng cách khởi tạo mọi phần tử không phải của mảng (có thể đa chiều) với phần tử tương ứng từ<a href="../../language/default_initialization" title="cpp/language/default initialization">default-initialized</a>.</div> <p>Quá tải này chỉ tham gia vào độ phân giải quá tải nếu t không phải là loại mảng.<span class="t-rev-inl t-since-cxx20"><span>, nhưng đối tượng được xây dựng là một mảng có thể đa dạng<code>T</code>được cung cấp giá trị như thể bằng biểu thức mới</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>, nhưng mọi phần tử đều được khởi tạo từ giá trị mặc định<code>p-&gt;~X()</code>là<code>p</code>, đối tượng<code>X</code>(hoặc các yếu tố mảng riêng lẻ cho</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>iterator trước đó phần tử mới sẽ được xây dựng</td> <td>-</td> <td>bị phá hủy thông qua biểu thức<code>T</code>là một con trỏ đến đối tượng và</td>
</tr> <tr class="t-par"> <td>N</td> <td>-</td> <td>là bản sao của bộ phân bổ được chuyển cho</td>
</tr> <tr class="t-par"> <td>                       std :: chuyển tiếp &lt;declType (args1)&gt; (args1) ...);</td> <td>-</td> <td>, phục hồi cho loại đối tượng bị phá hủy.</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code><a href="../shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>, đối tượng (hoặc các yếu tố cá nhân nếu<code>T</code>.</p>
<h3 id="Exceptions">Ngoại lệ</h3> <p>Sao chép hàm tạo. Nếu như<code><a href="../new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>không phải là một loại mảng, thì điều này được thực hiện như thể bởi cùng một biểu thức mới vị trí như trong<code>T</code>; Mặt khác, điều này được thực hiện như thể bằng cách khởi tạo mọi phần tử không phải của mảng (có thể đa chiều) với phần tử tương ứng từ<span class="t-rev-inl t-since-cxx20"><span>với cùng một biểu thức mới như trong</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span></p>
<h3 id="Notes">Ghi chú</h3> <p>Trong mỗi trường hợp, đối tượng<code><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">Điều đó cho tất cả<span class="me2">Shared_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="br0">.</span>new T<span class="br0">.</span>args...<span class="br0">)</span><span class="br0">)</span></code>(hoặc các yếu tố cá nhân nếu</p>
<ul>
<li> <code><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">Điều đó cho tất cả<span class="me2">Shared_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="br0">.</span>new T<span class="br0">.</span>args...<span class="br0">)</span><span class="br0">)</span></code>là một loại mảng)<code>T</code>sẽ bị phá hủy bởi<code>std::make_shared&lt;T&gt;</code>hoặc bất kỳ ngoại lệ nào được ném bởi nhà xây dựng của</li>
<li>Nếu có<code><a href="../weak_ptr" title="cpp/memory/weak ptr">std::weak_ptr</a></code>. Nếu một ngoại lệ được ném, các chức năng không có hiệu lực.<code>std::make_shared</code>Nếu một ngoại lệ được ném trong quá trình xây dựng mảng, các yếu tố đã được cung cấp đã bị phá hủy theo thứ tự ngược lại.<code>T</code>Chức năng này có thể được sử dụng như một giải pháp thay thế cho<code>sizeof(T)</code>. Sự đánh đổi là:</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">Điều đó cho tất cả<span class="me2">Shared_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="br0">.</span>new T<span class="br0">.</span>args...<span class="br0">)</span><span class="br0">)</span></code>thực hiện ít nhất hai phân bổ (một cho đối tượng<code>T</code>và một cho khối điều khiển của con trỏ được chia sẻ), trong khi<code>std::make_shared</code>Thông thường chỉ thực hiện một phân bổ (tiêu chuẩn khuyến nghị, nhưng không yêu cầu điều này; tất cả các triển khai đã biết làm điều này).</li>
<li>Chỉ định khái niệm của tất cả các loại mà các trường hợp có thể bị phá hủy một cách an toàn vào cuối đời (bao gồm cả các loại tham chiếu).<code><a href="../shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>Tài liệu tham khảo Khối điều khiển được tạo bởi<code>std::make_shared</code>Sau khi cuộc đời của tất cả các chủ sở hữu được chia sẻ kết thúc, bộ nhớ bị chiếm giữ bởi</li>
<li> <code>std::make_shared</code>Sử dụng<code>::new</code>vẫn tồn tại cho đến khi tất cả các chủ sở hữu yếu bị phá hủy, điều này có thể không mong muốn nếu<a href="../new/operator_new" title="cpp/memory/new/operator new"><code>operator new</code></a>là lớn.<code><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">Điều đó cho tất cả<span class="me2">Shared_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="br0">.</span>new T<span class="br0">.</span>args...<span class="br0">)</span><span class="br0">)</span></code>.</li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <ul><li> <code><a href="../shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>một ví dụ của loại<code>std::make_shared</code>Có thể ném các ngoại lệ ném từ<a class="external text" href="https://www.boost.org/doc/libs/1_66_0/libs/smart_ptr/doc/html/smart_ptr.html#make_shared" rel="nofollow"><code>boost::make_shared</code></a>.</li></ul> </td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <ul><li>có thể gọi một nhà xây dựng không công khai của<code>f<span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">Điều đó cho tất cả<span class="me2">Shared_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">int</span><span class="sy1">&lt;</span><span class="br0">.</span>new <span class="kw4">int</span><span class="br0">.</span><span class="nu0">đối tượng mà từ đó gán cho</span><span class="br0">)</span><span class="br0">)</span>, g<span class="br0">.</span><span class="br0">)</span><span class="br0">)</span></code>Nếu được thực hiện trong bối cảnh có thể truy cập được, trong khi<code>g</code>yêu cầu truy cập công khai vào hàm tạo được chọn.<code>new int(42)</code>người xây dựng,<code>f(std::make_shared&lt;int&gt;(42), g())</code>không cho phép một lần xóa tùy chỉnh.<a href="../../language/eval_order" title="cpp/language/eval order">never interleaved</a>.</li></ul> </td> <td><span class="t-mark-rev t-until-cxx17">xáo trộn</span></td>
</tr> </table> <p>Một nhà xây dựng<i>. Nếu một ngoại lệ bị ném,<code>shared_from_this</code></i>Nếu một ngoại lệ được ném trong quá trình xây dựng mảng, các yếu tố đã được cung cấp đã bị phá hủy theo thứ tự ngược lại<code>ptr</code>nó đến một đối tượng<code>U*</code>, chức năng này thường chỉ thực hiện một phân bổ và đặt cả hai<code>U</code>có một<span class="t-rev-inl t-since-cxx17"><span>Đối tượng và khối điều khiển trong khối bộ nhớ được phân bổ (tiêu chuẩn khuyến nghị nhưng không yêu cầu điều này, tất cả các triển khai đã biết đều làm điều này). Một bản sao của</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>được lưu trữ như một phần của khối điều khiển để nó có thể được sử dụng để giải quyết nó một khi cả số lượng tham chiếu chia sẻ và yếu đạt đến 0.<code><a href="../enable_shared_from_this" title="cpp/memory/enable shared from this">std::enable_shared_from_this</a></code>Không chấp nhận một trình phân phối tùy chỉnh riêng biệt: Bộ phân bổ được cung cấp được sử dụng để phá hủy khối điều khiển và</p>
<div class="cpp source-cpp"><pre data-language="cpp">đối tượng và để giải quyết khối bộ nhớ chia sẻ của họ.</pre></div> <p>Ở đâu<code><i>    ptr-&gt; stress_this = std :: shared_ptr &lt;std :: remove_cv_t &lt;u &gt;&gt; (</i></code>Không. Chức năng này được hỗ trợ bởi<code><a href="../weak_ptr" title="cpp/memory/weak ptr">std::weak_ptr</a></code>Việc triển khai thực tế khác nhau:<code><a href="../enable_shared_from_this" title="cpp/memory/enable shared from this">std::enable_shared_from_this</a></code>cho phép<code><i>    ptr-&gt; stress_this = std :: shared_ptr &lt;std :: remove_cv_t &lt;u &gt;&gt; (</i></code>có nghĩa là nó xác định nếu<a href="../enable_shared_from_this/shared_from_this" title="cpp/memory/enable shared from this/shared from this"><code>shared_from_this()</code></a>không rõ ràng và dễ tiếp cận<code><a href="../shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>lớp cơ sở là một chuyên ngành của</p>
<p>và nếu vậy, hàm tạo đánh giá câu lệnh:<code>ptr-&gt;weak_this.expired()</code>if (ptr! = nullptr &amp;&amp; ptr-&gt; stress_this.bed ())<code><i>    ptr-&gt; stress_this = std :: shared_ptr &lt;std :: remove_cv_t &lt;u &gt;&gt; (</i></code>                         *this, const_cast &lt;std :: remove_cv_t &lt;u&gt;*&gt; (ptr));</p>
<table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../../feature_test#cpp_lib_shared_ptr_arrays" title="cpp/feature test"><code>__cpp_lib_shared_ptr_arrays</code></a></td> <td><span class="nu0">Nếu không, chương trình là xấu.</span></td> <td><span class="t-mark">Phạm vi :: Construct_at</span></td> <td>Hỗ trợ mảng của<a href="#top"><code>std::make_shared</code></a>. Nếu không tìm thấy yếu tố như vậy, quá khứ (xem<span class="t-v">.<a href="#Version_2">2-5</a>)</span> </td>
</tr> <tr> <td><a href="../../feature_test#cpp_lib_smart_ptr_for_overwrite" title="cpp/feature test"><code>__cpp_lib_smart_ptr_for_overwrite</code></a></td> <td><span class="nu0">Chuyên môn này của</span></td> <td><span class="t-mark">Phạm vi :: Construct_at</span></td> <td>Tạo con trỏ thông minh với khởi tạo mặc định (<code><a href="allocate_shared" title="cpp/memory/shared ptr/allocate shared">std::allocate_shared_for_overwrite</a></code>Thì<code>std::make_shared_for_overwrite</code>Thì<code><a href="../unique_ptr/make_unique" title="cpp/memory/unique ptr/make unique">std::make_unique_for_overwrite</a></code>yếu_ này<span class="t-v">.<a href="#Version_6">6,7</a>)</span> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">, vì vậy nếu bất kỳ hành vi đặc biệt nào đã được thiết lập bằng cách sử dụng một lớp cụ thể</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">, nó sẽ khác với</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="shared_ptr" title="cpp/memory/shared ptr/shared ptr"> <span class="t-lines"><span>chuyên môn)</span></span></a></div> </td> <td>xây dựng mới<code>shared_ptr</code> <br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="allocate_shared" title="cpp/memory/shared ptr/allocate shared"> <span class="t-lines"><span>Phân bổ_shared</span><span>phân bổ_shared_for_overwrite</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Tạo một con trỏ được chia sẻ để quản lý một đối tượng mới được phân bổ bằng cách sử dụng bộ phân bổ<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../enable_shared_from_this" title="cpp/memory/enable shared from this"> <span class="t-lines"><span>enable_shared_from_this</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>cho phép một đối tượng tạo một<code>shared_ptr</code>đề cập đến chính nó<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../unique_ptr/make_unique" title="cpp/memory/unique ptr/make unique"> <span class="t-lines"><span>make_unique</span><span>make_unique_for_overwrite</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C ++ 14)</span></span><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Tạo một con trỏ độc đáo quản lý một đối tượng mới<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../new/operator_new" title="cpp/memory/new/operator new"> <span class="t-lines"><span>nhà điều hành mới</span><span>nhà điều hành mới []</span></span></a></div> </td> <td>chức năng phân bổ<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared">https://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared</a>
</p>
</div>
