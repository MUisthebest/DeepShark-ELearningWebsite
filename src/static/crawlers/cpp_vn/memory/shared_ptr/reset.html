 <h1 class="firstHeading" id="firstHeading">std :: Shared_ptr &lt;t&gt; :: Đặt lại</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">void reset () noExcept;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;Class Y&gt; </pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Đặt lại khoảng trống (y* ptr);</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;class Y, class Deleter&gt; </pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> </table> <p>đã được sở hữu, chức năng thường dẫn đến hành vi không xác định.<code>ptr</code>Mẫu &lt;Class Y, Class Deleter, Class Alloc&gt; <code>d</code>void reset (y* ptr, deleter d, alloc alloc);<code>shared_ptr</code>Thay thế đối tượng được quản lý bằng một đối tượng được trỏ bởi<a href="../../language/delete" title="cpp/language/delete"><code>delete</code></a>. Deleter tùy chọn<a href="../../language/delete" title="cpp/language/delete"><code>delete</code></a>có thể được cung cấp, sau này được sử dụng để phá hủy đối tượng mới khi không<code>Y</code>.</p>
<p>Nếu như<code>*this</code>Mẫu &lt;Class Y&gt; <code>shared_ptr</code>Đối tượng sở hữu nó. Theo mặc định,</p>
<p>Biểu thức được sử dụng làm Deleter. Thích hợp<code>ptr</code>Biểu thức tương ứng với loại được cung cấp luôn được chọn, đây là lý do tại sao hàm được thực hiện làm mẫu bằng cách sử dụng một tham số riêng biệt</p>
<div class="t-li1">
<span class="t-li">1)</span>Sở hữu nó, đối tượng bị phá hủy thông qua Deleter sở hữu.<code>*this</code>Nếu đối tượng được chỉ ra bởi<code>shared_ptr().swap(*this);</code>.</div> <div class="t-li1">
<span class="t-li">    const std :: chrono :: giây* offset;     // Chỉ giải thích</span>đã được sở hữu, chức năng thường dẫn đến hành vi không xác định.<code>ptr</code>.<code>Y</code>Phát hành quyền sở hữu của đối tượng được quản lý, nếu có. Sau cuộc gọi,<code>T</code>quản lý không có đối tượng. Tương đương với</div> <div class="t-li2">
<span class="t-li">2)</span>Thay thế đối tượng được quản lý bằng một đối tượng được trỏ bởi<code>delete ptr</code>phải là một loại hoàn chỉnh và có thể chuyển đổi hoàn toàn<code>shared_ptr&lt;T&gt;(ptr).swap(*this);</code>.</div> <div class="t-li2">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>. Ngoài ra:<code>d</code>Sử dụng biểu thức xóa làm DELETER. Một biểu thức xóa hợp lệ phải có sẵn, tức là<code>Deleter</code>Phải được hình thành tốt, có hành vi được xác định rõ và không ném bất kỳ ngoại lệ nào. Tương đương với<code>T</code>là UTF-8, tương đương với:<code>d(ptr)</code>Sử dụng Deleter được chỉ định<code>Deleter</code>// thực hiện đầu tiên<a href="../../named_req/copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>như Deleter.<code>shared_ptr&lt;T&gt;(ptr, d).swap(*this);</code>.</div> <div class="t-li2">
<span class="t-li">là trong</span>                                   Nhị phân p);<span class="t-v">(3)</span>phải được gọi cho loại<code>alloc</code>Phải được hình thành tốt, có hành vi được xác định rõ và không ném bất kỳ ngoại lệ nào.<code>Alloc</code>Phải là một<a href="../../named_req/allocator" title="cpp/named req/Allocator">Allocator</a>, và hàm tạo bản sao và phá hủy của nó không được đưa ra các ngoại lệ. Tương đương với<code>shared_ptr&lt;T&gt;(ptr, d, alloc).swap(*this);</code>.</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Nếu mảng chứa một số yếu tố</td> <td>-</td> <td>, nhưng cũng sử dụng một bản sao của</td>
</tr> <tr class="t-par"> <td>d</td> <td>-</td> <td>Để phân bổ dữ liệu để sử dụng nội bộ.</td>
</tr> <tr class="t-par"> <td>Sử dụng ngữ nghĩa di chuyển. Người phân bổ có được bằng cách xây dựng di chuyển từ bộ phân bổ thuộc</td> <td>-</td> <td>. Trình xây dựng bản sao và bộ hủy không được ném ngoại lệ. Tương đương với</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Gán cho đã cho</p>
<h3 id="Exceptions">Ngoại lệ</h3> <div class="t-li1">
<span class="t-li">2)</span> <code><a href="../new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>người phân bổ sử dụng để phân bổ nội bộ<code>delete ptr</code>Nếu không thể lấy được bộ nhớ bổ sung. Có thể ném ngoại lệ do thực hiện các lỗi khác.</div> <div class="t-li1">
<span class="t-li">, hành vi là không xác định.</span> <code><a href="../new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>người phân bổ sử dụng để phân bổ nội bộ<code>d(ptr)</code>Nếu không thể lấy được bộ nhớ bổ sung. Có thể ném ngoại lệ do thực hiện các lỗi khác.</div> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">được gọi nếu một ngoại lệ xảy ra.</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">Nếu không thể lấy được bộ nhớ bổ sung. Có thể ném ngoại lệ do thực hiện các lỗi khác.</pre></div> </div> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="shared_ptr" title="cpp/memory/shared ptr/shared ptr"> <span class="t-lines"><span>chuyên môn)</span></span></a></div> </td> <td>xây dựng mới<code>shared_ptr</code> <br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/memory/shared_ptr/reset">https://en.cppreference.com/w/cpp/memory/shared_ptr/reset</a>
</p>
</div>
