 <h1 class="firstHeading" id="firstHeading">std :: Atomic _...<span class="t-dsc-small">{</span>
</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/memory" title="cpp/header/memory">&lt;memory&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark">(Không dùng nữa trong C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">bool ATOMIC_IS_LOCK_FREE (const std :: shared_ptr &lt;t&gt;* p);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark">(Không dùng nữa trong C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt;</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark">(Không dùng nữa trong C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">std :: shared_ptr &lt;t&gt; Atomic_Load (const std :: shared_ptr &lt;t&gt;* p);</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark">(Không dùng nữa trong C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt;</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark">(Không dùng nữa trong C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">std :: Shared_ptr &lt;t&gt; Atomic_Load_Explicit</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark">(Không dùng nữa trong C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">    (const std :: shared_ptr &lt;t&gt;* p, std :: memory_order mo);</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark">(Không dùng nữa trong C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt;</pre>
</td> <td>            Nhị phân p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark">(Không dùng nữa trong C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">void Atomic_Store (std :: shared_ptr &lt;t&gt;* p, std :: shared_ptr &lt;t&gt; r);</pre>
</td> <td>(9)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark">(Không dùng nữa trong C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt;</pre>
</td> <td>(10)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark">(Không dùng nữa trong C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Void Atomic_store_explicit</pre>
</td> <td>(11)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark">(Không dùng nữa trong C ++ 20)</span> </td> </tr> </table> <p>    .<code><a href="../shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>      std :: memory_order mo);<code>shared_ptr</code>Mẫu &lt;Class T&gt;<code><a href="../../atomic/atomic_load" title="cpp/atomic/atomic load">std::atomic_load</a></code>Thì<code><a href="../../atomic/atomic_store" title="cpp/atomic/atomic store">std::atomic_store</a></code>không phải là std</p>
<p>std :: Shared_ptr &lt;t&gt; Atomic_exchange<code>shared_ptr</code>    .<code><a href="../shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>Mẫu &lt;Class T&gt;<span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span>hoặc<code>reset</code>std :: Shared_ptr &lt;t&gt; Atomic_Exchange_Explicit</p>
<div class="t-li1">
<span class="t-li">1)</span>    .<code>p</code>      std :: memory_order mo);</div> <div class="t-li1">
<span class="t-li">2)</span>Mẫu &lt;class inputit1, class inputit2,<code>atomic_load_explicit<span class="br0">.</span>p, <a href="http://en.cppreference.com/w/cpp/atomic/memory_order"><span class="kw2102">Điều đó cho tất cả<span class="me2">bool Atomic_compare_exchange_weak_explict</span></span></a><span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Mẫu &lt;Class T&gt;<code>p</code>.</div> <div class="t-li1">bool Atomic_compare_exchange_strong<code><a href="../../atomic/atomic_load" title="cpp/atomic/atomic load">std::atomic_load_explicit</a></code>Sử dụng chức năng nhị phân đã cho<code>mo</code>khoảng cách<code><a href="http://en.cppreference.com/w/cpp/atomic/memory_order"><span class="kw2100">Điều đó cho tất cả<span class="me2">    (STD dễ bay hơi :: Atomic &lt;T&gt;* obj,</span></span></a></code>hoặc<code><a href="http://en.cppreference.com/w/cpp/atomic/memory_order"><span class="kw2101">Điều đó cho tất cả<span class="me2">      Typename std :: Atomic &lt;T&gt; :: value_type* mong đợi, </span></span></a></code>Hoạt động tương đương cho quá tải</div> <div class="t-li1">
<span class="t-li">là trong</span>Mẫu &lt;class inputit1, class inputit2,<code>atomic_store_explicit<span class="br0">.</span>p, r, <a href="http://en.cppreference.com/w/cpp/atomic/memory_order"><span class="kw2102">Điều đó cho tất cả<span class="me2">bool Atomic_compare_exchange_weak_explict</span></span></a><span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>    .<code>r</code>      std :: Shared_ptr &lt;t&gt; mong muốn);<code>p</code>Mẫu &lt;Class T&gt;<code>p-&gt;swap(r)</code>.</div> <div class="t-li1">bool Atomic_compare_exchange_strong<code><a href="../../atomic/atomic_store" title="cpp/atomic/atomic store">std::atomic_store_explicit</a></code>Sử dụng chức năng nhị phân đã cho<code>mo</code>khoảng cách<code><a href="http://en.cppreference.com/w/cpp/atomic/memory_order"><span class="kw2100">Điều đó cho tất cả<span class="me2">    (STD dễ bay hơi :: Atomic &lt;T&gt;* obj,</span></span></a></code>hoặc<code><a href="http://en.cppreference.com/w/cpp/atomic/memory_order"><span class="kw2101">Điều đó cho tất cả<span class="me2">      Typename std :: Atomic &lt;T&gt; :: value_type* mong đợi, </span></span></a></code>Hoạt động tương đương cho quá tải</div> <div class="t-li1">
<span class="t-li">từ_sys</span>Mẫu &lt;class inputit1, class inputit2,<code>atomic_exchange_explicit<span class="br0">.</span>p, r, <a href="http://en.cppreference.com/w/cpp/atomic/memory_order"><span class="kw2102">Điều đó cho tất cả<span class="me2">bool Atomic_compare_exchange_weak_explict</span></span></a><span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">6)</span>    .<code>r</code>      std :: Shared_ptr &lt;t&gt; mong muốn);<code>p</code>Mẫu &lt;Class T&gt;<code>p</code>bool Atomic_compare_exchange_strong_explict<code>p-&gt;swap(r)</code>    .<code>r</code>      STD :: Shared_ptr &lt;t&gt; mong muốn,</div> <div class="t-li1">
<span class="t-li">. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu biểu thức</span>Mẫu &lt;class inputit1, class inputit2,</div> <div class="t-li1">
<code>atomic_compare_exchange_weak_explicit<br/> <span class="br0">.</span>p, expected, desired, <a href="http://en.cppreference.com/w/cpp/atomic/memory_order"><span class="kw2102">Điều đó cho tất cả<span class="me2">bool Atomic_compare_exchange_weak_explict</span></span></a>,<br/> <a href="http://en.cppreference.com/w/cpp/atomic/memory_order"><span class="kw2102">Điều đó cho tất cả<span class="me2">bool Atomic_compare_exchange_weak_explict</span></span></a><span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">được hình thành tốt. Chương trình không được hình thành nếu</span>Mẫu &lt;class inputit1, class inputit2,</div> <div class="t-li1">
<code>atomic_compare_exchange_strong_explicit<br/> <span class="br0">.</span>p, expected, desired, <a href="http://en.cppreference.com/w/cpp/atomic/memory_order"><span class="kw2102">Điều đó cho tất cả<span class="me2">bool Atomic_compare_exchange_weak_explict</span></span></a>,<br/> <a href="http://en.cppreference.com/w/cpp/atomic/memory_order"><span class="kw2102">Điều đó cho tất cả<span class="me2">bool Atomic_compare_exchange_weak_explict</span></span></a><span class="br0">)</span></code>.</div> <span class="t-li">Xây dựng một thùng chứa trống.</span>      std :: memory_order thành công, std :: memory_order thất bại);<code>p</code>Và<code>expected</code>.<ul>
<li>Mẫu &lt;Class T&gt;<code>desired</code>Mẫu &lt;Class T&gt;<code>*p</code>      STD :: Shared_ptr &lt;t&gt; mong muốn,<code>success</code>Nếu lỗi ngăn chặn ngay cả khi biết liệu<code>true</code>.</li>
<li>    .<code>*p</code>Mẫu &lt;Class T&gt;<code>*expected</code>      STD :: Shared_ptr &lt;t&gt; mong muốn,<code>failure</code>Nếu lỗi ngăn chặn ngay cả khi biết liệu<code>false</code>.</li>
</ul> <div class="t-li1">
<code>atomic_compare_exchange_weak_explicit</code>      std :: memory_order thành công, std :: memory_order thất bại);</div> <div class="t-li1">Nếu như<code>expected</code>Nếu nhiều luồng thực thi truy cập giống nhau<code>failure</code>khoảng cách<code><a href="http://en.cppreference.com/w/cpp/atomic/memory_order"><span class="kw2100">Điều đó cho tất cả<span class="me2">    (STD dễ bay hơi :: Atomic &lt;T&gt;* obj,</span></span></a></code>hoặc<code><a href="http://en.cppreference.com/w/cpp/atomic/memory_order"><span class="kw2101">Điều đó cho tất cả<span class="me2">      Typename std :: Atomic &lt;T&gt; :: value_type* mong đợi, </span></span></a></code>Hoạt động tương đương cho quá tải</div> <p>Nếu như<code>p</code>đối tượng không đồng bộ hóa và bất kỳ quyền truy cập nào trong số đó đều sử dụng chức năng thành viên không phải lúc của</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Sau đó, một cuộc đua dữ liệu sẽ xảy ra trừ khi tất cả các truy cập như vậy được thực hiện thông qua các chức năng này, đó là quá tải của các hàm truy cập nguyên tử tương ứng (</td> <td>-</td> <td>Lưu ý rằng khối điều khiển của một<code><a href="../shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code> </td>
</tr> <tr class="t-par"> <td>là an toàn cho chủ đề: khác nhau</td> <td>-</td> <td>Một<code><a href="../shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code> </td>
</tr> <tr class="t-par"> <td>Các đối tượng có thể được truy cập bằng các hoạt động có thể thay đổi, chẳng hạn như toán tử</td> <td>-</td> <td>, đồng thời bởi nhiều luồng, ngay cả khi các trường hợp này là bản sao và chia sẻ cùng một khối điều khiển bên trong.<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order</a></code> </td>
</tr>
</table> <h3 id="Exceptions">Ngoại lệ</h3> <p>Xác định xem có quyền truy cập nguyên tử vào con trỏ được chia sẻ được chỉ ra bởi</p>
<h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">1)</span> <code>true</code>không khóa.</div> <div class="t-li1">
<span class="t-li">          std :: Indirect_strict_weak_order &lt;</span>Trả về con trỏ được chia sẻ được chỉ ra bởi</div> <div class="t-li1">
<span class="t-li">cluct clock_time_conversion &lt;clock, std :: Chrono :: System_Clock&gt;;</span>Gán cho đã cho</div> <div class="t-li1">
<span class="t-li">cluct clock_time_conversion &lt;std :: Chrono :: System_Clock, Clock&gt;;</span>Cũng như không chuyên hóa</div> <div class="t-li1">
<span class="t-li">Cửa hàng con trỏ được chia sẻ</span> <code>true</code>trong con trỏ được chia sẻ chỉ bằng<code>false</code>Nếu đối số đầu tiên là</div> <h3 id="Notes">Ghi chú</h3> <p>Về mặt nguyên tử, tương đương với</p>
<p>Các<a href="https://en.cppreference.com/w/cpp/experimental/concurrency" title="cpp/experimental/concurrency">Concurrency TS</a>Cũng như không chuyên hóa<code>atomic_shared_ptr</code>Và<code>atomic_weak_ptr</code>Cửa hàng con trỏ được chia sẻ</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>trong con trỏ được chia sẻ chỉ bằng<code><a href="../../atomic/atomic" title="cpp/atomic/atomic">std::atomic</a></code>và trả về giá trị trước đây được chỉ ra bởi<a href="http://en.cppreference.com/w/cpp/atomic/atomic"><span class="kw2070">Điều đó cho tất cả<span class="me2">nguyên tử</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">Điều đó cho tất cả<span class="me2">Shared_ptr</span></span></a><span class="sy1">&lt;</span>Và<a href="http://en.cppreference.com/w/cpp/atomic/atomic"><span class="kw2070">Điều đó cho tất cả<span class="me2">nguyên tử</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/memory/weak_ptr"><span class="kw743">Điều đó cho tất cả<span class="me2">yếu_ptr</span></span></a><span class="sy1">&lt;</span>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <h3 id="Example">Ví dụ</h3> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2980" rel="nofollow">LWG 2980</a> </td> <td>C ++ 11</td> <td>trống<code>shared_ptr</code>, về mặt nguyên tử. Tương đương với</td> <td>và trả về một bản sao của</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../../atomic/atomic_is_lock_free" title="cpp/atomic/atomic is lock free"> <span class="t-lines"><span>ATOMIC_IS_LOCK_FREE</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>Kiểm tra xem các hoạt động của loại nguyên tử có khóa không<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../atomic/atomic_store" title="cpp/atomic/atomic store"> <span class="t-lines"><span>Atomic_store</span><span>Atomic_store_explicit</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>thay thế nguyên tử giá trị của đối tượng nguyên tử bằng đối số không nguyên tử<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../atomic/atomic_load" title="cpp/atomic/atomic load"> <span class="t-lines"><span>Atomic_load</span><span>ATOMIC_LOAD_EXPLICIT</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>về mặt nguyên tử có được giá trị được lưu trữ trong một đối tượng nguyên tử<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../atomic/atomic_exchange" title="cpp/atomic/atomic exchange"> <span class="t-lines"><span>Atomic_exchange</span><span>ATOMIC_EXCHANGE_EXPLICIT</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>thay thế nguyên tử giá trị của đối tượng nguyên tử bằng đối số không nguyên tử và trả về giá trị cũ của nguyên tử<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../atomic/atomic_compare_exchange" title="cpp/atomic/atomic compare exchange"> <span class="t-lines"><span>Atomic_compare_exchange_weak</span><span>Atomic_compare_exchange_weak_explict</span><span>Atomic_compare_exchange_strong</span><span>Atomic_compare_exchange_strong_explict</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>so sánh về mặt nguyên tử với giá trị của đối tượng nguyên tử với đối số không nguyên tử và thực hiện trao đổi nguyên tử nếu tải trọng hoặc nguyên tử nếu không<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/memory/shared_ptr/atomic">https://en.cppreference.com/w/cpp/memory/shared_ptr/atomic</a>
</p>
</div>
