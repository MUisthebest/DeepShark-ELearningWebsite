 <h1 class="firstHeading" id="firstHeading">std :: Shared_ptr &lt;t&gt; :: Shared_ptr</h1> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">constexpr shared_ptr () noexcept;</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">constexpr shared_ptr (std :: nullptr_t) noexcept;</pre>
</td> <td>(2)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Mẫu &lt;Class Y&gt; </pre>
</td> <td>(3)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">rõ ràng chia sẻ_ptr (y* ptr);</pre>
</td> <td>(4)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Mẫu &lt;class Y, class Deleter&gt; </pre>
</td> <td>             Không có p);</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Shared_ptr (y* ptr, deleter d);</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Mẫu &lt;Class Deleter&gt; </pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Shared_ptr (std :: nullptr_t ptr, deleter d);</pre>
</td> <td>            Nhị phân p);</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Class Y, Class Deleter, Class Alloc&gt; </pre>
</td> <td>            Nhị phân p);</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Shared_ptr (y* ptr, deleter d, alloc alloc);</pre>
</td> <td>(9)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Mẫu &lt;class deleter, class alloc&gt; </pre>
</td> <td>(9)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Shared_ptr (std :: nullptr_t ptr, deleter d, alloc alloc);</pre>
</td> <td>(10)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Mẫu &lt;Class Y&gt; </pre>
</td> <td>(10)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Shared_ptr (const shared_ptr &lt;y&gt; &amp; r, Element_type* ptr) noExcept;</pre>
</td> <td>(11)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-until-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;Class Y&gt; </pre>
</td> <td>(12)</td> <td> <span class="t-mark-rev t-until-cxx17">(Đã xóa trong C ++ 17)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Shared_ptr (Shared_ptr &lt;Y&gt; &amp;&amp; r, Element_Type* ptr) noExcept;</pre>
</td> <td>(13)</td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Xây dựng mới<code>shared_ptr</code>Shared_ptr (const shared_ptr &amp; r) noExcept;</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>Mẫu &lt;Class Y&gt; <code>Y*</code>(Constexpr kể từ C ++ 26)<i>Tương thích với</i>Shared_ptr (Shared_ptr &amp;&amp; r) NoExcept;<code>T*</code>bằng nhau.<code>Y*</code>Chuyển đổi hai thời lượng thành loại chung của chúng và tạo ra một thời lượng mà số lượng đánh dấu là tổng số lượng đánh dấu sau khi chuyển đổi.<code>T*</code>hoặc<code>Y</code>Mẫu &lt;Class Y&gt; <code>U[N]</code>Và<code>T</code>khoảng cách<code>U cv []</code>Shared_ptr (Shared_ptr &lt;Y&gt; &amp;&amp; r) NoExcept;</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <div class="t-li1">
<span class="t-li">Đầu vào</span>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>shared_ptr</code>Mẫu &lt;Class Y&gt; <code>shared_ptr</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class t, class alloc&gt;</span>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>shared_ptr</code>với<code>ptr</code>rõ ràng chia sẻ_ptr (const std :: weak_ptr &lt;y&gt; &amp; r);<table class="t-rev-begin">
<tr class="t-rev t-until-cxx17">
<td> <p>Bool Binary_Search (Forwardit First, Forwardit Last,<span class="t-v">có thể được sử dụng cho cùng một mục đích: sự khác biệt là hàm tạo này ném một ngoại lệ nếu đối số trống, trong khi</span>Thì<code>Y*</code>(6)<code>T*</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx17">xáo trộn</span></td>
</tr>
<tr class="t-rev t-since-cxx17">
<td> <p>Nếu như<code>T</code>Không có đối tượng được quản lý, tức là trống<code>U[N]</code>Thì<span class="t-v">có thể được sử dụng cho cùng một mục đích: sự khác biệt là hàm tạo này ném một ngoại lệ nếu đối số trống, trong khi</span>is_copy_constructible_v<code>Y(*)[N]</code>Tương thích với<code>T*</code>. Nếu như<code>T</code>Không có đối tượng được quản lý, tức là trống<code>U[]</code>Thì<span class="t-v">có thể được sử dụng cho cùng một mục đích: sự khác biệt là hàm tạo này ném một ngoại lệ nếu đối số trống, trong khi</span>is_copy_constructible_v<code>Y(*)[]</code>Tương thích với<code>T*</code>Nếu danh mục lỗi hoặc giá trị lỗi không bằng nhau.<span class="t-v">có thể được sử dụng cho cùng một mục đích: sự khác biệt là hàm tạo này ném một ngoại lệ nếu đối số trống, trong khi</span>is_copy_constructible_v<code>Y*</code>là sai.<code>T*</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr>
</table>là loại mảng</div> <div class="t-li2">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>    IOTA (o đầu tiên, s, giá trị t);<a href="../../language/delete" title="cpp/language/delete">delete-expression</a> <code>delete ptr</code> <span class="t-rev-inl t-since-cxx17"><span>nếu như<code>T</code>(trong đó CV là một số bộ trình điều trị CV).<code>delete[] ptr</code>nếu như<code>T</code>Không có đối tượng được quản lý, tức là trống</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>Sử dụng biểu thức xóa làm DELETER. Một biểu thức xóa hợp lệ phải có sẵn, tức là<code>Y</code>Là con trỏ đến đối tượng được quản lý.<span class="t-rev-inl t-since-cxx17"><span>(3,4,6)</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>
</div> <div class="t-li2">
<span class="t-li">cluct clock_time_conversion &lt;clock, std :: Chrono :: System_Clock&gt;;</span>. Ngoài ra:<code>d</code>là một loại mảng<code>d(ptr)</code>(3,4,6)<code>d</code>là một loại không hợp lệ hoặc không thể chuyển đổi thành<table class="t-rev-begin">
<tr class="t-rev t-until-cxx17">
<td> <p><code>Deleter</code>// thực hiện đầu tiên<a href="../../named_req/copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>.</p>
</td> <td><span class="t-mark-rev t-until-cxx17">xáo trộn</span></td>
</tr>
<tr class="t-rev t-since-cxx17">
<td> <p>là một loại mảng<code>d(ptr)</code>(3,4,6)<code><a href="http://en.cppreference.com/w/cpp/types/is_move_constructible"><span class="kw546">Điều đó cho tất cả<span class="me2">hoán đổi void (t2 (&amp; a) [n], t2 (&amp; b) [n]) noExcept ( / * xem bên dưới * /);</span></span></a><span class="sy1">is_trivently_destructible_v</span>D<span class="sy1">&lt;</span></code>khoảng cách<code>false</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr>
</table>
</div> <div class="t-li2">
<span class="t-li">cluct clock_time_conversion &lt;std :: Chrono :: System_Clock, Clock&gt;;</span>                                   Nhị phân p);<span class="t-v">                      std :: vector &lt;/*iter-value-type*/&lt;inputit&gt;, alloc&gt;,</span>phải được gọi cho loại<code>alloc</code>Phải được hình thành tốt, có hành vi được xác định rõ và không ném bất kỳ ngoại lệ nào.<code>Alloc</code>Phải là một<a href="../../named_req/allocator" title="cpp/named req/Allocator">Allocator</a>.</div> <div class="t-li1">
<span class="t-li">. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu biểu thức</span>Các<i>là một loại không hợp lệ hoặc không thể chuyển đổi thành</i>(3,4,6)<code>shared_ptr</code>Ngoài ra:<code>r</code>không phải là một loại mảng;<code>ptr</code>là một loại mảng<code>shared_ptr</code>Phải là một loại hoàn chỉnh. Biểu thức xóa phải được hình thành tốt, có hành vi được xác định rõ và không đưa ra bất kỳ ngoại lệ nào.<code>r</code>Chất xây dựng này cũng không tham gia vào độ phân giải quá tải nếu biểu thức xóa không được hình thành tốt.<code>get()</code>như Deleter. Biểu thức<code>shared_ptr</code>Phải được hình thành tốt, có hành vi được xác định rõ và không ném bất kỳ ngoại lệ nào. Việc xây dựng<code>ptr</code>và của phần Deleter được lưu trữ được sao chép từ nó không được ném ngoại lệ.<code>ptr</code>Các hàm tạo này cũng không tham gia vào độ phân giải quá tải nếu biểu thức<code>ptr</code>không được hình thành tốt, hoặc nếu<code>r</code>Nhà xây dựng răng cưa<code>r.get()</code> <span class="t-rev-inl t-since-cxx20"><span>: xây dựng a<code>r</code>là trống rỗng và<code>r.get() == nullptr</code>sau cuộc gọi.</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>
</div> <div class="t-li1">
<span class="t-li">được hình thành tốt. Chương trình không được hình thành nếu</span>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>shared_ptr</code>sẽ luôn trả lại một bản sao của<code>r</code>. Nếu như<code>r</code>. Sau khi chuyển nhượng,<code>*this</code>, nhưng giữ một con trỏ không liên quan và không được quản lý<code>Y*</code># Elif __has_include (&lt;thử nghiệm/tùy chọn&gt;) // Kiểm tra phiên bản thử nghiệm<span class="t-rev-inl t-until-cxx17"><span>hoàn toàn có thể chuyển đổi thành</span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span><span class="t-rev-inl t-since-cxx17"><span><i>Tương thích với</i></span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span> <code>T*</code>.</div> <div class="t-li1">
<span class="t-li">Toán tử bool constexpr&gt; (const std :: Chrono :: sys_time &lt;fending&gt; &amp; x,</span>Di chuyển-xây dựng a<code>shared_ptr</code>từ<code>r</code>là người cuối cùng của nhóm đi ra khỏi phạm vi, nó sẽ gọi là người được lưu trữ cho đối tượng ban đầu được quản lý bởi<code>*this</code>quản lý không có đối tượng,<code>r</code>Thì<code>r</code>. Tuy nhiên, gọi<code>Y*</code># Elif __has_include (&lt;thử nghiệm/tùy chọn&gt;) // Kiểm tra phiên bản thử nghiệm<span class="t-rev-inl t-until-cxx17"><span>hoàn toàn có thể chuyển đổi thành</span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span><span class="t-rev-inl t-since-cxx17"><span><i>Tương thích với</i></span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span> <code>T*</code>.</div> <div class="t-li1">
<span class="t-li">                           const std :: Chrono :: Leap_Second &amp; y) noExcept;</span>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>shared_ptr</code>sẽ luôn trả lại một bản sao của<code>r</code>.<span class="t-rev-inl t-until-cxx17"><span><code>Y*</code> <code>T*</code>.</span><span><span class="t-mark-rev t-until-cxx17">xáo trộn</span></span></span><span class="t-rev-inl t-since-cxx17"><span>                const std :: chrono :: sys_time &lt;thời gian&gt; &amp; tp);<code>Y*</code>trả lại mô hình<code>T*</code>.</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>Lưu ý rằng<code>r.lock()</code>. Trách nhiệm của lập trình viên là đảm bảo rằng điều này<code><a href="http://en.cppreference.com/w/cpp/memory/weak_ptr"><span class="kw743">Điều đó cho tất cả<span class="me2">yếu_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">khóa</span><span class="br0">.</span><span class="br0">)</span></code>vẫn còn hiệu lực miễn là chia sẻ_ptr này, chẳng hạn như trong các trường hợp sử dụng điển hình trong đó<code>std::shared_ptr</code>là bên trong</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;Lớp thời lượng&gt;</span>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>shared_ptr</code>là một thành viên của đối tượng được quản lý bởi<code>r</code>.<code>Y*</code>(6)<code>T*</code>. Sau khi xây dựng,<code>r</code>...</div> <div class="t-li1">
<span class="t-li">. Di chuyển-constructs</span>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>shared_ptr</code>hoặc là một bí danh (ví dụ: downcast) của<code>r</code>Cho quá tải thứ hai lấy rvalue,<code>r</code>; Mà còn<code>r</code>chia sẻ quyền sở hữu đối tượng được quản lý bởi<table class="t-rev-begin"><tr class="t-rev t-since-cxx17">
<td>quản lý cũng không có đối tượng. Quá tải mẫu không tham gia vào độ phân giải quá tải nếu<code>std::unique_ptr&lt;Y, Deleter&gt;::pointer</code># Elif __has_include (&lt;thử nghiệm/tùy chọn&gt;) // Kiểm tra phiên bản thử nghiệm<i>Tương thích với</i> <code>T*</code>. Nếu như<code>r.get()</code>. Sau khi xây dựng,<span class="t-v">(1)</span>.</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr></table>Nếu như<code>Deleter</code>là trống và con trỏ được lưu trữ của nó là null. Quá tải mẫu không tham gia vào độ phân giải quá tải nếu<code>shared_ptr<span class="br0">.</span>r.<span class="me1">giải phóng</span><span class="br0">.</span><span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/functional/ref"><span class="kw1071">Điều đó cho tất cả<span class="me2">Tham khảo</span></span></a><span class="br0">.</span>r.<span class="me1">get_deleter</span><span class="br0">.</span><span class="br0">)</span><span class="br0">)</span></code>Tương thích với<code>shared_ptr(r.release(), std::move(r.get_deleter()))</code>.</div> <p>      std :: memory_order order = std :: memory_order_seq_cst) noexcept dễ bay hơi;<code>T</code>chia sẻ quyền sở hữu đối tượng được quản lý bởi<span class="t-v">có thể được sử dụng cho cùng một mục đích: sự khác biệt là hàm tạo này ném một ngoại lệ nếu đối số trống, trong khi</span>xây dựng một trống rỗng<code>shared_from_this</code>với<code>ptr</code>lưu trữ và sở hữu đối tượng trước đây thuộc sở hữu của<span class="t-v">(13)</span>. Nếu một ngoại lệ bị ném,<code>shared_from_this</code>mà quản lý đối tượng hiện được quản lý bởi<code>r.release()</code>.</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>Nếu mảng chứa một số yếu tố</td> <td>-</td> <td>Loại này. Việc triển khai được phép cung cấp cho mẫu một tên khác hoặc thực hiện chức năng tương đương theo các cách khác.</td>
</tr> <tr class="t-par"> <td>d</td> <td>-</td> <td>. Deleter liên quan đến</td>
</tr> <tr class="t-par"> <td>Sử dụng ngữ nghĩa di chuyển. Người phân bổ có được bằng cách xây dựng di chuyển từ bộ phân bổ thuộc</td> <td>-</td> <td>quản lý không có đối tượng sau cuộc gọi.</td>
</tr> <tr class="t-par"> <td>thường được sử dụng.</td> <td>-</td> <td>Chuyển quyền sở hữu đối tượng được quản lý bởi</td>
</tr>
</table> <h3 id="Exceptions">Ngoại lệ</h3> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span> <code><a href="../new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>Quá tải này không tham gia vào độ phân giải quá tải nếu<code>delete ptr</code><span class="t-rev-inl t-since-cxx17"><span>nếu như<code>T</code>Tương thích với<code>delete[] ptr</code>[tĩnh]</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>.</div> <div class="t-li1">
<span class="t-li">    STD :: FileSystem :: Thư mục_options Tùy chọn,</span> <code><a href="../new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>người phân bổ sử dụng để phân bổ nội bộ<code>d(ptr)</code>Nếu không thể lấy được bộ nhớ bổ sung. Có thể ném ngoại lệ do thực hiện các lỗi khác.</div> <div class="t-li1">
<span class="t-li">                           const std :: Chrono :: Leap_Second &amp; y) noExcept;</span> <code><a href="../bad_weak_ptr" title="cpp/memory/bad weak ptr">std::bad_weak_ptr</a></code>nếu như<code>r.expired() == true</code>là một con trỏ null, quá tải này tương đương với hàm tạo mặc định</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;Lớp thời lượng&gt;</span> <code><a href="../new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>là một loại tham chiếu, nó tương đương với</div> <div class="t-li1">
<span class="t-li">. Di chuyển-constructs</span>. Nếu không, nó tương đương với</div> <h3 id="Notes">Ghi chú</h3> <p>Một nhà xây dựng<i>. Nếu một ngoại lệ bị ném,<code>shared_from_this</code></i>Nếu một ngoại lệ được ném trong quá trình xây dựng mảng, các yếu tố đã được cung cấp đã bị phá hủy theo thứ tự ngược lại<code>ptr</code>nó đến một đối tượng<code>U*</code>, chức năng này thường chỉ thực hiện một phân bổ và đặt cả hai<code>U</code>có một<span class="t-rev-inl t-since-cxx17"><span>Đối tượng và khối điều khiển trong khối bộ nhớ được phân bổ (tiêu chuẩn khuyến nghị nhưng không yêu cầu điều này, tất cả các triển khai đã biết đều làm điều này). Một bản sao của</span><span><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></span></span>được lưu trữ như một phần của khối điều khiển để nó có thể được sử dụng để giải quyết nó một khi cả số lượng tham chiếu chia sẻ và yếu đạt đến 0.<code><a href="../enable_shared_from_this" title="cpp/memory/enable shared from this">std::enable_shared_from_this</a></code>Không chấp nhận một trình phân phối tùy chỉnh riêng biệt: Bộ phân bổ được cung cấp được sử dụng để phá hủy khối điều khiển và</p>
<div class="cpp source-cpp"><pre data-language="cpp">đối tượng và để giải quyết khối bộ nhớ chia sẻ của họ.</pre></div> <p>Ở đâu<code><i>    ptr-&gt; stress_this = std :: shared_ptr &lt;std :: remove_cv_t &lt;u &gt;&gt; (</i></code>Không. Chức năng này được hỗ trợ bởi<code><a href="../weak_ptr" title="cpp/memory/weak ptr">std::weak_ptr</a></code>Việc triển khai thực tế khác nhau:<code><a href="../enable_shared_from_this" title="cpp/memory/enable shared from this">std::enable_shared_from_this</a></code>cho phép<code><i>    ptr-&gt; stress_this = std :: shared_ptr &lt;std :: remove_cv_t &lt;u &gt;&gt; (</i></code>có nghĩa là nó xác định nếu<a href="../enable_shared_from_this/shared_from_this" title="cpp/memory/enable shared from this/shared from this"><code>shared_from_this()</code></a>không rõ ràng và dễ tiếp cận<code><a href="../shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>lớp cơ sở là một chuyên ngành của</p>
<p>và nếu vậy, hàm tạo đánh giá câu lệnh:<code>ptr-&gt;weak_this.expired()</code>if (ptr! = nullptr &amp;&amp; ptr-&gt; stress_this.bed ())<code><i>    ptr-&gt; stress_this = std :: shared_ptr &lt;std :: remove_cv_t &lt;u &gt;&gt; (</i></code>                         *this, const_cast &lt;std :: remove_cv_t &lt;u&gt;*&gt; (ptr));</p>
<p>không phải là loại mảng, quá tải<code>shared_ptr</code>(3,4,6)<code>shared_ptr</code>cho phép<code>shared_ptr(ptr.get())</code>và quá tải<code><a href="../enable_shared_from_this" title="cpp/memory/enable shared from this">std::enable_shared_from_this</a></code>.</p>
<p>với con trỏ được trả lại bởi<code>constexpr</code>một lần phân phối để sử dụng để phá hủy đối tượng<a href="../../language/initialization#Non-local_variables" title="cpp/language/initialization">static non-local initialization</a>một người phân bổ để sử dụng để phân bổ dữ liệu để sử dụng nội bộ</p>
<p>Nếu không thể lấy được bộ nhớ bổ sung. Có thể ném ngoại lệ do thực hiện các lỗi khác. Nếu một ngoại lệ xảy ra, điều này sẽ gọi<code><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">Điều đó cho tất cả<span class="me2">Shared_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>từ a<code><a href="http://en.cppreference.com/w/cpp/memory/unique_ptr"><span class="kw735">Điều đó cho tất cả<span class="me2">độc đáo_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span><span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span><span class="sy1">&lt;</span></code>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">không phải là loại mảng và cuộc gọi</pre></div> <p>Không chỉ ra các yếu tố của cùng một chuỗi. Nghĩa là, phải tồn tại một số<code>shared_ptr</code>. Các hàm tạo không có tác dụng trong trường hợp này.<code><a href="http://en.cppreference.com/w/cpp/memory/default_delete"><span class="kw748">Điều đó cho tất cả<span class="me2">Default_delete</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span><span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span><span class="sy1">&lt;</span></code>Nếu không thể lấy được bộ nhớ bổ sung. Có thể ném ngoại lệ do thực hiện các lỗi khác. Hàm tạo này không có tác dụng nếu xảy ra ngoại lệ.<code><a href="../unique_ptr" title="cpp/memory/unique ptr">std::unique_ptr</a></code>Nếu một ngoại lệ được ném, hàm tạo không có hiệu ứng.</p>
<p>Các con trỏ thô quá tải đảm nhận quyền sở hữu đối tượng nhọn. Do đó, xây dựng a<code><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">Điều đó cho tất cả<span class="me2">Shared_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span><span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span><span class="sy1">&lt;</span></code>sử dụng quá tải con trỏ thô cho một đối tượng đã được quản lý bởi một</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">, chẳng hạn như</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">có khả năng dẫn đến hành vi không xác định, ngay cả khi đối tượng thuộc loại có nguồn gốc từ</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3548" rel="nofollow">LWG 3548</a> </td> <td>C ++ 11</td> <td>Vì hàm tạo mặc định là<code>unique_ptr</code>, static chia sẻ_ptrs được khởi tạo như một phần của</td> <td>, trước khi bất kỳ khởi tạo phi địa phương nào bắt đầu. Điều này làm cho an toàn khi sử dụng Shared_ptr trong một hàm tạo của bất kỳ đối tượng tĩnh nào.</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="make_shared" title="cpp/memory/shared ptr/make shared"> <span class="t-lines"><span>make_shared</span><span>make_shared_for_overwrite</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Tạo một con trỏ được chia sẻ để quản lý một đối tượng mới<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="allocate_shared" title="cpp/memory/shared ptr/allocate shared"> <span class="t-lines"><span>Phân bổ_shared</span><span>phân bổ_shared_for_overwrite</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">Phạm vi :: Construct_at</span></span></span></div> </td> <td>Tạo một con trỏ được chia sẻ để quản lý một đối tượng mới được phân bổ bằng cách sử dụng bộ phân bổ<br/> <span class="t-mark">tạo một đối tượng tại một địa chỉ nhất định</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../enable_shared_from_this" title="cpp/memory/enable shared from this"> <span class="t-lines"><span>enable_shared_from_this</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>cho phép một đối tượng tạo một<code>shared_ptr</code>đề cập đến chính nó<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/memory/shared_ptr/shared_ptr">https://en.cppreference.com/w/cpp/memory/shared_ptr/shared_ptr</a>
</p>
</div>
