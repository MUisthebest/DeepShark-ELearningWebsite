 <h1 class="firstHeading" id="firstHeading">    {<small>{</small>
</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../../header/memory" title="cpp/header/memory">&lt;memory&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>struct std :: Atomic &lt;std :: shared_ptr &lt;t &gt;&gt;;<code><a href="../../atomic/atomic" title="cpp/atomic/atomic">std::atomic</a></code>vì<code><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">Điều đó cho tất cả<span class="me2">Shared_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>Chuyên ngành một phần của<code>shared_ptr</code>cho phép người dùng thao tác</p>
<p>    .<code><a href="../shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>      std :: memory_order mo);<code>shared_ptr</code>đối tượng nguyên tử.<code><a href="http://en.cppreference.com/w/cpp/atomic/atomic"><span class="kw2070">Điều đó cho tất cả<span class="me2">nguyên tử</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">Điều đó cho tất cả<span class="me2">Shared_ptr</span></span></a><span class="sy1">&lt;</span></code>sau đó một cuộc đua dữ liệu sẽ xảy ra trừ khi tất cả các truy cập như vậy được thực hiện thông qua một thể hiện<a href="atomic" title="cpp/memory/shared ptr/atomic">standalone functions</a>(hoặc, không được dùng khi C ++ 20, thông qua<code><a href="../shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>).</p>
<p>để truy cập nguyên tử vào<code>use_count</code>Có liên quan<code>use_count</code>Sự gia tăng được đảm bảo là một phần của hoạt động nguyên tử. Có liên quan<code>use_count</code>Giảm được giải trình tự sau hoạt động nguyên tử, nhưng không bắt buộc phải là một phần của nó, ngoại trừ<code>expected</code>thay đổi khi ghi đè</p>
<p>std :: Shared_ptr &lt;t&gt; Atomic_exchange<code>shared_ptr</code>trong một CAS thất bại. Bất kỳ xóa và xử lý liên quan nào được giải trình tự sau bước cập nhật nguyên tử và không phải là một phần của hoạt động nguyên tử.<code><a href="../shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>là an toàn cho chủ đề: không phải nguyên tử khác nhau<code>operator=</code>hoặc<code>reset</code>std :: Shared_ptr &lt;t&gt; Atomic_Exchange_Explicit</p>
<p>các đối tượng có thể được truy cập bằng các hoạt động có thể thay đổi, chẳng hạn như</p>
<h3 id="Member_types">nhà điều hành ()</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>ATOMIC_UNSIGNED_LOCK_FREE</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code>value_type</code> </td> <td> <code><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">Điều đó cho tất cả<span class="me2">Shared_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code> </td>
</tr> </table> <h3 id="Member_functions">nếu không thì</h3> <p>Loại T có thể là một loại không đầy đủ.<code><a href="../../atomic/atomic" title="cpp/atomic/atomic">std::atomic</a></code>Tất cả không chuyên hóa</p>
<div class="t-member"> <h2 id="atomic.3Cshared_ptr.3CT.3E.3E::atomic">Các chức năng cũng được cung cấp bởi chuyên môn này và không có chức năng thành viên bổ sung.</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">Nguyên tử &lt;Shared_ptr &lt;t &gt;&gt; :: Atomic</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">ConstExpr Atomic () NoExcept = Mặc định;</pre>
</td> <td>(2)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Consexpr Atomic (std :: nullptr_t) noexcept: Atomic () {}</pre>
</td> <td>(3)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">nguyên tử (const nguyên tử &amp;) = xóa;</pre>
</td> <td>(4)</td> <td class="t-dcl-nopad"> </td> </tr> </table> <div class="t-li1">
<span class="t-li">Đầu vào</span>đến giá trị null.<code>shared_ptr&lt;T&gt;</code>Khởi tạo cơ bản</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>đến giá trị null.<code>shared_ptr&lt;T&gt;</code>Khởi tạo cơ bản<code>desired</code>đến một bản sao của<code><a href="../../atomic/atomic" title="cpp/atomic/atomic">std::atomic</a></code>. Như với bất kỳ</div> <div class="t-li1">
<span class="t-li">là trong</span>Loại, khởi tạo không phải là một hoạt động nguyên tử.</div>
</div> <div class="t-member"> <h2 id="atomic.3Cshared_ptr.3CT.3E.3E::operator.3D">Các loại nguyên tử không được sao chép/di chuyển có thể xây dựng.</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">Nguyên tử &lt;Shared_ptr &lt;t &gt;&gt; :: Toán tử =</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">toán tử void = (const Atomic &amp;) = xóa;</pre>
</td> <td>(2)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">toán tử void = (std :: shared_ptr &lt;t&gt; mong muốn) noExcept;</pre>
</td> <td>(3)</td> <td class="t-dcl-nopad"> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>toán tử void = (std :: nullptr_t) noExcept;</div> <div class="t-li1">
<span class="t-li">2)</span>Các loại nguyên tử không được sao chép/di chuyển có thể gán.<code>store(desired)</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Gán giá trị, tương đương với<code>store(nullptr);</code>.</div>
</div> <div class="t-member"> <h2 id="atomic.3Cshared_ptr.3CT.3E.3E::is_lock_free">Đặt lại con trỏ chia sẻ nguyên tử thành giá trị con trỏ null. Tương đương với</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool is_lock_free () const noexcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Mẫu &lt;Class execPolicy,<code>true</code>Nguyên tử &lt;Shared_ptr &lt;T &gt;&gt; :: IS_LOCK_FREE<code>false</code>Nếu đối số đầu tiên là</p>
</div> <div class="t-member"> <h2 id="atomic.3Cshared_ptr.3CT.3E.3E::store">Nếu các hoạt động nguyên tử trên tất cả các đối tượng thuộc loại này không có khóa,</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">Nguyên tử &lt;Shared_ptr &lt;T &gt;&gt; :: Lưu trữ</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Void Store (STD :: Shared_ptr &lt;t&gt; mong muốn,<code>*this</code>                            STD :: Memory_order Order) NoExcept;<code>desired</code>Mẫu &lt;Class T&gt;<code>p.swap(desired)</code>Ở đâu<code>p</code>std :: Shared_ptr &lt;t&gt; exchange (std :: shared_ptr &lt;t&gt; mong muốn,<code><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">Điều đó cho tất cả<span class="me2">Shared_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>Thay thế nguyên tử giá trị của<code>order</code>    sao chép (r &amp;&amp; r, o kết quả);<code>order</code>khoảng cách<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_consume</a></code>Thì<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_acquire</a></code>, hoặc<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_acq_rel</a></code>.</p>
</div> <div class="t-member"> <h2 id="atomic.3Cshared_ptr.3CT.3E.3E::load">là cơ bản</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">. Bộ nhớ được đặt hàng theo</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Atomic &lt;Shared_ptr &lt;T &gt;&gt; :: Tải<code>order</code>    sao chép (r &amp;&amp; r, o kết quả);<code>order</code>khoảng cách<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_release</a></code>hoặc<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_acq_rel</a></code>.</p>
</div> <div class="t-member"> <h2 id="atomic.3Cshared_ptr.3CT.3E.3E::operator_std::shared_ptr.3CT.3E">std :: shared_ptr &lt;t&gt; load (std :: memory_order order = std :: memory_order_seq_cst) const noexcept;</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">Về mặt nguyên tử trả về một bản sao của con trỏ chia sẻ cơ bản. Bộ nhớ được đặt hàng theo</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Mẫu &lt;class inputit1, class inputit2,<code>return load();</code>.</p>
</div> <div class="t-member"> <h2 id="atomic.3Cshared_ptr.3CT.3E.3E::exchange">Atomic &lt;shared_ptr &lt;t &gt;&gt; :: Nhà điều hành std :: shared_ptr &lt;t&gt;</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">toán tử std :: shared_ptr &lt;t&gt; () const noexcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Nguyên tử &lt;Shared_ptr &lt;t &gt;&gt; :: Exchange<code><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">Điều đó cho tất cả<span class="me2">Shared_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>với<code>desired</code>Mẫu &lt;Class T&gt;<code>p.swap(desired)</code>Ở đâu<code>p</code>std :: Shared_ptr &lt;t&gt; exchange (std :: shared_ptr &lt;t&gt; mong muốn,<code><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">Điều đó cho tất cả<span class="me2">Shared_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>                             std :: memory_order order = std :: memory_order_seq_cst) noExcept;<code>p</code>Thay thế nguyên tử<code>order</code>là cơ bản</p>
</div> <div class="t-member"> <h2 id="atomic.3Cshared_ptr.3CT.3E.3E::compare_exchange_weak.2C_compare_exchange_strong">và trả về một bản sao của giá trị</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">đã ngay trước khi hoán đổi. Bộ nhớ được đặt hàng theo</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">. Đây là một hoạt động đọc biến đổi nguyên tử.</pre>
</td> <td>(2)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Atomic &lt;shared_ptr &lt;t &gt;&gt; :: compare_exchange_weak, compare_exchange_strong</pre>
</td> <td>(3)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">bool compare_exchange_strong (std :: shared_ptr &lt;t&gt; &amp; mong đợi, std :: shared_ptr &lt;t&gt; mong muốn,</pre>
</td> <td>(4)</td> <td class="t-dcl-nopad"> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>                              std :: memory_order thành công, std :: memory_order thất bại) NoExcept;<code><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">Điều đó cho tất cả<span class="me2">Shared_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>bool compare_exchange_weak (std :: shared_ptr &lt;t&gt; &amp; mong đợi, std :: shared_ptr &lt;t&gt; mong muốn,<code>T*</code>(1,3)<code>expected</code>                            std :: memory_order thành công, std :: memory_order thất bại) NoExcept;<code>expected</code>bool compare_exchange_strong (std :: shared_ptr &lt;t&gt; &amp; mong đợi, std :: shared_ptr &lt;t&gt; mong muốn,<code>desired</code>                              std :: memory_order order = std :: memory_order_seq_cst) noExcept;<code><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">Điều đó cho tất cả<span class="me2">Shared_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>; Nếu không nếu<code>true</code>Nếu cơ bản<code>success</code>                            std :: memory_order order = std :: memory_order_seq_cst) noExcept;<code><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">Điều đó cho tất cả<span class="me2">Shared_ptr</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>ĐẾN<code>expected</code>; Nếu không nếu<code>false</code>Nếu cơ bản<code>failure</code>    sao chép (r &amp;&amp; r, o kết quả);<code>failure</code>khoảng cách<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_release</a></code>hoặc<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_acq_rel</a></code>Lưu trữ giống nhau<code>*this</code>Và<code>expected</code>và chia sẻ quyền sở hữu với nó, hoặc nếu cả cơ bản và<code>*this</code>Và<code>expected</code>trống rỗng, gán từ<code>expected</code>                                   OUTPUTITIT D_FIRST, PRECEPREDATICATE P);<code>use_count</code>đến cơ bản</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>, và đặt hàng bộ nhớ theo</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>                                                  Inputit2 First2, Inputit2 Last2);<code>return compare_exchange_strong(expected, desired, order, fail_order);</code>là<code>fail_order</code>giống như<code>order</code>Ngoại trừ điều đó<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_acq_rel</a></code>không được truy cập sau bản cập nhật nguyên tử. Về thất bại, hoạt động là một hoạt động tải nguyên tử trên<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_acquire</a></code>Và<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_release</a></code>không được truy cập sau bản cập nhật nguyên tử. Về thất bại, hoạt động là một hoạt động tải nguyên tử trên<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_relaxed</a></code>.</div> <div class="t-li1">
<span class="t-li">là trong</span>                                                  Inputit2 First2, Inputit2 Last2);<code>return compare_exchange_weak(expected, desired, order, fail_order);</code>là<code>fail_order</code>giống như<code>order</code>Ngoại trừ điều đó<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_acq_rel</a></code>không được truy cập sau bản cập nhật nguyên tử. Về thất bại, hoạt động là một hoạt động tải nguyên tử trên<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_acquire</a></code>Và<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_release</a></code>không được truy cập sau bản cập nhật nguyên tử. Về thất bại, hoạt động là một hoạt động tải nguyên tử trên<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_relaxed</a></code>.</div>
</div> <div class="t-member"> <h2 id="atomic.3Cshared_ptr.3CT.3E.3E::wait">được cập nhật với giá trị hiện có được đọc từ đối tượng nguyên tử. Bản cập nhật này cho</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">là một phần của hoạt động nguyên tử này, mặc dù bản thân viết (và bất kỳ sự phân giải/phá hủy nào sau đó) không bắt buộc.</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>, nhưng cũng có thể thất bại một cách mạnh mẽ.</p>
<p>void Atomic_flag_wait_explicit (đối tượng Atomic_flag* dễ bay hơi<code>load(order)</code>với<code>old</code>được thay thế bởi<code>*this</code>Thực hiện các hoạt động chờ đợi nguyên tử.<code>notify_one()</code>hoặc<code>notify_all()</code>được thay thế bởi<code>load(order)</code>được thay thế bởi</p>
<p>được thay thế bởi<code>order</code>    sao chép (r &amp;&amp; r, o kết quả);<code>order</code>khoảng cách<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_release</a></code>hoặc<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order_acq_rel</a></code>.</p>
<p>Nguyên tử &lt;Shared_ptr &lt;T &gt;&gt; :: Đợi đã<code>shared_ptr</code>void Wait (std :: Shared_ptr &lt;t&gt; cũ,</p>
</div> <div class="t-member"> <h2 id="atomic.3Cshared_ptr.3CT.3E.3E::notify_one">           std :: memory_order order = std :: memory_order_seq_cst) const noexcept;</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">void notify_one () noExcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Bộ nhớ được đặt hàng theo</p>
<p>và nếu chúng tương đương thì các khối cho đến khi<code>wait()</code>) TRÊN<code>*this</code>. Điều này được lặp lại cho đến khi</p>
</div> <div class="t-member"> <h2 id="atomic.3Cshared_ptr.3CT.3E.3E::notify_all">thay đổi. Chức năng này được đảm bảo chỉ trả lại nếu giá trị đã thay đổi, ngay cả khi việc thực hiện cơ bản không bị chặn một cách dai dẳng.</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">void notify_all () noExcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> <p>Bộ nhớ được đặt hàng theo</p>
<p>Hút tất cả các luồng bị chặn trong các hoạt động chờ nguyên tử (tức là.<code>wait()</code>) TRÊN<code>*this</code>, nếu có bất kỳ; nếu không thì không có gì.</p>
</div> <h3 id="Member_constants">Inline Consexpr bool is_execut_policy_v = std :: is_execut_policy &lt;t&gt; :: value;</h3> <p>Ghi chú: Hai<code><a href="../../atomic/atomic" title="cpp/atomic/atomic">std::atomic</a></code>S là tương đương nếu chúng lưu trữ cùng một con trỏ và chia sẻ quyền sở hữu hoặc cả hai đều trống.<code>is_always_lock_free</code>Nguyên tử &lt;Shared_ptr &lt;T &gt;&gt; :: Thông báo_one</p>
<div class="t-member"> <h2 id="atomic.3Cshared_ptr.3CT.3E.3E::is_always_lock_free">Thực hiện một hoạt động thông báo nguyên tử.</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">constic static bool is_always_lock_free = /*do thực hiện xác định* /;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> </table> </div> <h3 id="Notes">Ghi chú</h3> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../../utility/feature_test" title="cpp/utility/feature test">Feature-test</a>(Mẫu lớp)</th> <th>vĩ mô</th> <th><span title="Standard in which the feature is introduced">Giá trị</span></th> <th>STD</th>
</tr> <tr> <td><a href="../../feature_test#cpp_lib_atomic_shared_ptr" title="cpp/feature test"><code>__cpp_lib_atomic_shared_ptr</code></a></td> <td><span class="nu0">là một biểu hiện mà đánh giá là</span></td> <td><span class="t-mark">Phạm vi :: Construct_at</span></td> <td>
<a href="#top"><code>std::atomic&lt;std::shared_ptr&gt;</code></a> </td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3661" rel="nofollow">LWG 3661</a> </td> <td>C ++ 20</td> <td>
<code>atomic&lt;shared_ptr&lt;T&gt;&gt;</code>Nếu có một luồng bị chặn trong các hoạt động chờ nguyên tử (nghĩa là<code>nullptr</code> </td> <td>, sau đó bỏ chặn ít nhất một chủ đề như vậy; nếu không thì không có gì.</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3893" rel="nofollow">LWG 3893</a> </td> <td>C ++ 20</td> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3661" rel="nofollow">LWG3661</a>làm ra<code>atomic&lt;shared_ptr&lt;T&gt;&gt;</code>Nguyên tử &lt;Shared_ptr &lt;t &gt;&gt; :: notify_all<code>nullptr_t</code> </td> <td>Thực hiện một hoạt động thông báo nguyên tử.</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../../atomic/atomic" title="cpp/atomic/atomic"> <span class="t-lines"><span>nguyên tử</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>Mẫu lớp nguyên tử và các chuyên ngành cho bool, tích phân,<span class="t-rev-inl t-since-cxx20"><span>điểm nổi,</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span>và loại con trỏ<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/memory/shared_ptr/atomic2">https://en.cppreference.com/w/cpp/memory/shared_ptr/atomic2</a>
</p>
</div>
