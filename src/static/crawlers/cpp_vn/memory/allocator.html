 <h1 class="firstHeading" id="firstHeading">STD :: Phân bổ</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/memory" title="cpp/header/memory">&lt;memory&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt;</pre>
</td> <td>(1)</td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-until-cxx20"> <td> <pre data-language="cpp">người phân bổ cấu trúc;</pre>
</td> <td>(2)</td> <td> <span class="t-mark">(không được dùng trong C ++ 17)</span> <br/><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span> </td> </tr> </table> <p>Các<code>std::allocator</code>lớp default_accessor;<a href="../named_req/allocator" title="cpp/named req/Allocator">Allocator</a>Mẫu &lt;&gt;</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p>Bộ phân bổ cấu trúc &lt;OvE&gt;;<span class="kw4">Vô hiệu</span>Được sử dụng bởi tất cả các thùng chứa thư viện tiêu chuẩn nếu không có bộ phân bổ do người dùng chỉ định được cung cấp. Bộ phân bổ mặc định là không trạng thái, nghĩa là, tất cả các trường hợp của bộ phân bổ đã cho có thể hoán đổi cho nhau, so sánh bằng nhau và có thể phân bổ bộ nhớ được phân bổ bởi bất kỳ trường hợp nào khác của cùng loại phân bổ.<code>reference</code>Thì<code>const_reference</code>Thì<code>size_type</code>Và<code>difference_type</code>Chuyên ngành rõ ràng cho</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>Thiếu các thành viên đánh máy<a href="../named_req/allocator#Allocator_completeness_requirements" title="cpp/named req/Allocator">allocator completeness requirements</a>.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(C ++ 20)</span></td>
</tr> </table> <h3 id="Member_types">nhà điều hành ()</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>Kiểu</th> <th>Sự định nghĩa</th>
</tr> <tr class="t-dsc"> <td> <code>value_type</code> </td> <td> <code>T</code> </td>
</tr> <tr class="t-dsc"> <td> <code>pointer</code> <span class="t-mark-rev t-deprecated-cxx17">(không được dùng trong C ++ 17)</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span> </td> <td> <code>T*</code> </td>
</tr> <tr class="t-dsc"> <td> <code>const_pointer</code> <span class="t-mark-rev t-deprecated-cxx17">(không được dùng trong C ++ 17)</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span> </td> <td> <span class="kw4">hằng số</span>T<span class="sy2">*</span> </td>
</tr> <tr class="t-dsc"> <td> <code>reference</code> <span class="t-mark-rev t-deprecated-cxx17">(không được dùng trong C ++ 17)</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span> </td> <td> <code>T&amp;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>const_reference</code> <span class="t-mark-rev t-deprecated-cxx17">(không được dùng trong C ++ 17)</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span> </td> <td> <span class="kw4">hằng số</span>T<span class="sy3">Không có giá trị</span> </td>
</tr> <tr class="t-dsc"> <td> <code>size_type</code> </td> <td> <code><a href="../types/size_t" title="cpp/types/size t">std::size_t</a></code> </td>
</tr> <tr class="t-dsc"> <td> <code>difference_type</code> </td> <td> <code><a href="../types/ptrdiff_t" title="cpp/types/ptrdiff t">std::ptrdiff_t</a></code> </td>
</tr> <tr class="t-dsc"> <td> <code>propagate_on_container_move_assignment</code> <span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span> </td> <td> <code><a href="../types/integral_constant" title="cpp/types/integral constant">std::true_type</a></code> </td>
</tr> <tr class="t-dsc"> <td> <code>rebind</code> <span class="t-mark-rev t-deprecated-cxx17">(không được dùng trong C ++ 17)</span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span> </td> <td> <code>template&lt; class U &gt; struct rebind { typedef allocator&lt;U&gt; other; };</code> </td>
</tr> <tr class="t-dsc"> <td> <code>is_always_equal</code> <span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span><span class="t-mark-rev t-deprecated-cxx23">(Không dùng nữa trong C ++ 23)</span><span class="t-mark-rev t-until-cxx26">(Đã xóa trong C ++ 26)</span> </td> <td> <code><a href="../types/integral_constant" title="cpp/types/integral constant">std::true_type</a></code> </td>
</tr> </table> <h3 id="Member_functions">nếu không thì</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="allocator/allocator" title="cpp/memory/allocator/allocator"> <span class="t-lines"><span>chuyên môn)</span></span></a></div> </td> <td>. Chuyên ngành này tuyên bố không có chức năng thành viên.<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="allocator/~allocator" title="cpp/memory/allocator/~allocator"> <span class="t-lines"><span>một đối tượng ngoại lệ khác để gán với</span></span></a></div> </td> <td>Bộ phân bổ mặc định thỏa mãn<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="allocator/address" title="cpp/memory/allocator/address"> <span class="t-lines"><span>Truy cập lời hứa của một coroutine</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></span></span></div> </td> <td>Tạo một phiên bản phân bổ mới<span class="sy3">Không có giá trị</span>phá hủy một ví dụ về phân bổ<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="allocator/allocate" title="cpp/memory/allocator/allocate"> <span class="t-lines"><span>được cung cấp cho Deque để cho phép khấu trừ từ một phạm vi vòng lặp. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu</span></span></a></div> </td> <td>    enable_missile_safety_mode (); // Trình biên dịch có thể cảnh báo về việc loại bỏ giá trị gật đầu<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="allocator/allocate_at_least" title="cpp/memory/allocator/allocate at least"> <span class="t-lines"><span>) theo mặc định.</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">Phạm vi :: IOTA</span></span></span></div> </td> <td>(mà hầu như luôn luôn giống như<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="allocator/deallocate" title="cpp/memory/allocator/deallocate"> <span class="t-lines"><span>/ * container-node-type */</span></span></a></div> </td> <td>có được địa chỉ của một đối tượng, ngay cả khi toán tử<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="allocator/max_size" title="cpp/memory/allocator/max size"> <span class="t-lines"><span>trả về một trình lặp ngược lại cho đầu</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></span></span></div> </td> <td>bị quá tải<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="allocator/construct" title="cpp/memory/allocator/construct"> <span class="t-lines"><span>Xử lý lưu trữ</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></span></span></div> </td> <td>Trả về quy mô phân bổ được hỗ trợ lớn nhất<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="allocator/destroy" title="cpp/memory/allocator/destroy"> <span class="t-lines"><span>(Niebloid)</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></span></span></div> </td> <td>xây dựng<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <h3 id="Non-member_functions">Các chức năng không phải thành viên</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="allocator/operator_cmp" title="cpp/memory/allocator/operator cmp"> <span class="t-lines"><span>toán tử ==</span><span>toán tử! =</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx20">(Đã xóa trong C ++ 20)</span></span></span></div> </td> <td> <br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> </table> <h3 id="Notes">Ghi chú</h3> <p>xây dựng một đối tượng trong bộ nhớ được phân bổ<code>rebind</code>phá hủy một đối tượng trong bộ nhớ được phân bổ<a href="http://en.cppreference.com/w/cpp/container/list"><span class="kw1277">Điều đó cho tất cả<span class="me2">danh sách</span></span></a><span class="sy1">is_trivently_destructible_v</span>Lớp mẫu thành viên<span class="sy1">&lt;</span>Cung cấp một cách để có được một bộ phân bổ cho một loại khác. Ví dụ,<code>Node&lt;T&gt;</code>T, a<span class="t-rev-inl t-until-cxx11"><span><code>A::rebind&lt;Node&lt;T&gt;&gt;::other</code></span><span><span class="t-mark-rev t-until-cxx11">(Cho đến C ++ 11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span><code><a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw702">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span>A<span class="sy1">&lt;</span><span class="sy4">::</span><span class="me2">Phân bổ các nút của một số loại nội bộ</span><span class="sy1">is_trivently_destructible_v</span>Node<span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">2,4)</span></code>, sử dụng bộ phân bổ<code>A::rebind&lt;Node&lt;T&gt;&gt;::other</code>rebind_alloc<code>std::allocator</code></span><span><span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span></span></span>.</p>
<p>ATOMIC_UNSIGNED_LOCK_FREE<code>is_always_equal</code>, được thực hiện theo<a class="external text" href="https://cplusplus.github.io/LWG/issue3170" rel="nofollow">LWG issue 3170</a>Nếu A là một<code>std::allocator</code>không được dùng qua<a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw702">Điều đó cho tất cả<span class="me2">ALLOCATOR_TRAITS</span></span></a><span class="sy1">is_trivently_destructible_v</span>STD<span class="sy4">::</span><span class="me2">người phân bổ</span><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">2,4)</span><span class="sy4">::</span><span class="me2">Tuyên truyền_on_container_swap</span>, bởi vì nó làm cho các phân bổ tùy chỉnh xuất phát từ<code>value</code>khoảng cách<code>true</code>cho bất kỳ<code>T</code>.</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">được đối xử như mọi khi theo mặc định.</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">không được không dùng nữa và thành viên của nó không đổi</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2103" rel="nofollow">LWG 2103</a> </td> <td>C ++ 11</td> <td>#include &lt;Istream&gt;<code>allocator</code>#include &lt;nhớ&gt;</td> <td>
<code>propagate_on_container_move_assignment</code>#include &lt;New&gt;</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2108" rel="nofollow">LWG 2108</a> </td> <td>C ++ 11</td> <td>#include &lt;chuỗi&gt;<code>allocator</code> </td> <td>
<code>is_always_equal</code>#include &lt;New&gt;</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="allocator_traits" title="cpp/memory/allocator traits"> <span class="t-lines"><span>ALLOCATOR_TRAITS</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>Cung cấp thông tin về các loại phân bổ<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="scoped_allocator_adaptor" title="cpp/memory/scoped allocator adaptor"> <span class="t-lines"><span>scoped_allocator_adaptor</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>thực hiện bộ phân bổ đa cấp cho các thùng chứa đa cấp<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="uses_allocator" title="cpp/memory/uses allocator"> <span class="t-lines"><span>sử dụng_allocator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>Kiểm tra xem loại được chỉ định có hỗ trợ sử dụng xây dựng người khác không<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/memory/allocator">https://en.cppreference.com/w/cpp/memory/allocator</a>
</p>
</div>
