 <h1 class="firstHeading" id="firstHeading">std :: out_ptr_t &lt;smart, con trỏ, args ...&gt; :: con trỏ vận hành*, std :: out_ptr_t &lt;smart, con trỏ, args ...&gt; :: nhà điều hành void **</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">con trỏ toán tử*() const noexcept;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">toán tử void ** () const noexcept;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> </table> <p>Phơi bày địa chỉ của một<code>Pointer</code>hoặc<code>void*</code>phản đối một chức năng nước ngoài thường sẽ khởi tạo lại nó.</p>
<div class="t-li1">
<span class="t-li">1)</span>Yêu cầu STD :: Convertible_to &lt;Const I &amp;, I2&gt;<code>*this</code>đến địa chỉ được lưu trữ<code>Pointer</code>Giống như các tài liệu tham khảo ngôn ngữ, sự ổn định là nông cạn đối với</div> <div class="t-li1">
<span class="t-li">2)</span>Yêu cầu STD :: Convertible_to &lt;Const I &amp;, I2&gt;<code>*this</code>đến địa chỉ của một<code>void*</code>sự vật. Hàm chuyển đổi này chỉ tham gia vào độ phân giải quá tải nếu<code>Pointer</code>Các đối số để đặt lại để bắt giữ<code>void*</code>, và chương trình không được hình thành nếu<code>Pointer</code>không phải là một loại con trỏ.<br/>Giá trị ban đầu của<code>void*</code>đối tượng bằng giá trị của được lưu trữ<code>Pointer</code>đối tượng được chuyển đổi thành<code>void*</code>và bất kỳ sửa đổi nào đối với nó đều ảnh hưởng đến<code>Pointer</code>giá trị được sử dụng trong<a href="~out_ptr_t" title="cpp/memory/out ptr t/~out ptr t">destructor</a>. Truy cập<code>void*</code>đối tượng ngoài đời của<code>*this</code>có hành vi không xác định.</div> <p>Khi một trong hai chức năng chuyển đổi này đã được gọi trên<code>out_ptr_t</code>Đối tượng, người kia sẽ không được gọi trên nó, nếu không, hành vi không được xác định.</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <p>Gán cho đã cho</p>
<h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">1)</span>Địa chỉ được lưu trữ<code>Pointer</code>Giống như các tài liệu tham khảo ngôn ngữ, sự ổn định là nông cạn đối với</div> <div class="t-li1">
<span class="t-li">2)</span>Địa chỉ của<code>void*</code>Đối tượng thỏa mãn các yêu cầu đã nói ở trên.</div> <h3 id="Notes">Ghi chú</h3> <p>Nếu đối tượng được trỏ bởi giá trị trả về chưa được viết lại, nó bằng<code>nullptr</code>.</p>
<p>Về các triển khai chung, biểu diễn đối tượng của mỗi<code>Pointer</code>đó là một loại con trỏ tương thích với<code>void*</code>và do đó, các triển khai này thường lưu trữ<code>void*</code>đối tượng trong bộ lưu trữ cho<code>Pointer</code>Đối tượng, không cần lưu trữ bổ sung:</p>
<ul>
<li>Nếu việc triển khai cho phép phân tích bí danh dựa trên loại (dựa trên<a href="../../language/reinterpret_cast#Type_aliasing" title="cpp/language/reinterpret cast">strict aliasing rule</a>), một điều chỉnh đúng<code><a href="http://en.cppreference.com/w/cpp/types/byte"><span class="kw2642">Điều đó cho tất cả<span class="me2">Byte</span></span></a><span class="br0">              STD :: Dự kiến ​​&lt;phạm vi :: iterator_t &lt;r&gt;, proj &gt;&gt; Pred&gt;</span>sizeof<span class="br0">.</span><span class="kw4">Vô hiệu</span><span class="sy2">*</span><span class="br0">)</span><span class="br0">Phạm vi constexpr :: mượn_iterator_t &lt;r&gt;</span></code>Subobject thành viên có thể được sử dụng và cả hai hàm chuyển đổi trả về địa chỉ của các đối tượng<a href="../../language/object#Object_creation" title="cpp/language/object">implicitly created</a>trong mảng.</li>
<li>Nếu không, a<code>Pointer</code>Subobject thành viên có thể được sử dụng cho cả hai chức năng chuyển đổi và<span class="t-v">(2)</span>Có thể trực tiếp trả lại địa chỉ của nó<a href="../../language/reinterpret_cast" title="cpp/language/reinterpret cast"><code>reinterpret_cast</code></a>ĐẾN<code>void**</code>.</li>
</ul> <p>Nếu như<code>Pointer</code>là loại con trỏ có biểu diễn đối tượng không tương thích với<code>void*</code>, một bổ sung<code>bool</code>cờ có thể cần thiết để ghi lại cho dù<span class="t-v">(1)</span>ForwardItIT2 exclusive_scan (execPolicy &amp;&amp; chính sách,<span class="t-v">(2)</span>) đã được gọi.</p>
<h3 id="Example">Ví dụ</h3> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/memory/out_ptr_t/operator_ptr">https://en.cppreference.com/w/cpp/memory/out_ptr_t/operator_ptr</a>
</p>
</div>
