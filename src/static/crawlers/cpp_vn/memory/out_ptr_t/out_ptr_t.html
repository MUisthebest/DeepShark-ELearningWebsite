 <h1 class="firstHeading" id="firstHeading">std :: out_ptr_t &lt;thông minh, con trỏ, args ...&gt; :: out_ptr_t</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">rõ ràng out_ptr_t (Smart &amp; sp, args ... args);</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">out_ptr_t (const out_ptr_t &amp;) = xóa;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>STD :: Exception_ptr make_exception_ptr (e e) noExcept;<code>out_ptr_t</code>. Thích nghi<code>sp</code>như thể ràng buộc nó với<code>Smart&amp;</code>thành viên, nắm bắt mọi lập luận<code>t</code>TRONG<code>args...</code>như thể khởi tạo thành viên tương ứng của loại<code>T</code>TRONG<code>Args...</code>với<code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="br0">.</span>t<span class="br0">)</span></code>, sau đó khởi tạo giá trị<code>Pointer</code>.<br/>Sau đó gọi<code>sp.reset()</code>Nếu biểu thức được hình thành tốt; Nếu không, các cuộc gọi<code>sp = Smart()</code>nếu như<code><a href="http://en.cppreference.com/w/cpp/types/is_default_constructible"><span class="kw534">Điều đó cho tất cả<span class="me2">is_default_constructible_v</span></span></a><span class="sy1">is_trivently_destructible_v</span>Smart<span class="sy1">&lt;</span></code>khoảng cách<code>true</code>. Chương trình không được hình thành nếu cả hai hoạt động đặt lại đều không được hình thành.</div> <div class="t-li1">
<span class="t-li">2)</span>Sao chép Constructor bị xóa rõ ràng.<code>out_ptr_t</code>Mỗi lần khởi tạo và chuyên môn đầy đủ của</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>không có được bằng cách gọi</td> <td>-</td> <td>Chương trình không được hình thành nếu việc xây dựng giá trị trả lại (xem bên dưới) không được hình thành.</td>
</tr> <tr class="t-par"> <td>, không cho phép định dạng định dạng.</td> <td>-</td> <td>Các đối số được sử dụng để đặt lại để bắt giữ</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p>Gán cho đã cho</p>
<h3 id="Exceptions">Ngoại lệ</h3> <p>Có thể ném các trường hợp ngoại lệ do thực hiện.</p>
<h3 id="Notes">Ghi chú</h3> <p>Sau khi xây dựng,<code>Pointer</code>hoặc<code>void*</code>đối tượng được trỏ bởi giá trị trả về của chức năng chuyển đổi bằng<code>nullptr</code>.</p>
<p>Mỗi cuộc tranh luận trong<code>args...</code>được chuyển vào được tạo ra<code>out_ptr_t</code>Nếu nó thuộc loại đối tượng hoặc được chuyển vào<code>out_ptr_t</code>AS-IS nếu nó thuộc loại tham chiếu.</p>
<p>Các hàm tạo của<code>out_ptr_t</code>được phép ném ngoại lệ. Ví dụ, khi nào<code>sp</code>Điều đó như vậy<code><a href="../shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>, phân bổ cho khối điều khiển mới có thể được thực hiện trong hàm tạo chứ không phải là chất phá hủy.</p>
<h3 id="Example">Ví dụ</h3> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/memory/out_ptr_t/out_ptr_t">https://en.cppreference.com/w/cpp/memory/out_ptr_t/out_ptr_t</a>
</p>
</div>
