 <h1 class="firstHeading" id="firstHeading">STD :: Equality_comparable, std :: Aquality_comparable_with</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/concepts" title="cpp/header/concepts">&lt;concepts&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;Class T&gt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">khái niệm bình đẳng_comparable = __weaklyequalitycomparedablewith &lt;t, t&gt;;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">Mẫu &lt;class t, class u&gt;</pre>
</td> <td>(3)</td> <td> <span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(4)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx23"> <td> <pre data-language="cpp">Khái niệm bình đẳng_comparable_with =</pre>
</td> <td> <span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span> <br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">    STD :: Equality_Comparable &lt;T&gt; &amp;&amp;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span> <br/><span class="t-mark t-mark-expos">.<span title="This definition is for illustration purposes only. An implementation does not need to define an entity in this manner. The name of this entity is unspecified.">    .</span>)</span> </td> </tr> </table> <div class="t-li1">
<span class="t-li">1)</span>Khái niệm gán được_from =<code>std::equality_comparable</code>            const std :: remove_reference_t &lt;u&gt; &amp; &gt;&gt; &amp;&amp;<code>==</code>Và<code>!=</code>    __ComparisonCommOnTyPewith &lt;t, u&gt; &amp;&amp;<code>T</code>    STD :: Equality_comparable &lt;<code>==</code>        std :: Common_Reference_T &lt;<code>true</code>            const std :: remove_reference_t &lt;t&gt; &amp;,</div> <div class="t-li1">
<span class="t-li">2)</span>Khái niệm gán được_from =<code>std::equality_comparable_with</code>            const std :: remove_reference_t &lt;u&gt; &amp; &gt;&gt; &amp;&amp;<code>==</code>Và<code>!=</code>    __WeaklyequalityComparedablewith &lt;t, u&gt;;<code>T</code>Và<code>U</code>Mẫu &lt;class t, class u&gt;</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>Mẫu &lt;Class B&gt;<code><i>Khái niệm __WeaklyequalityComparableWith =</i></code>    Yêu cầu (const std :: remove_reference_t &lt;t&gt; &amp; t,<code>T</code>             const std :: remove_reference_t &lt;u&gt; &amp; u) {<code>U</code>        {t == u} -&gt; Boolean -Testable;<code>==</code>Và<code>!=</code>        {T! = U} -&gt; Boolean -Testable;</div> <div class="t-li1">
<span class="t-li">là trong</span>Mẫu &lt;Class B&gt;<code><i>        {u == t} -&gt; Boolean -Testable;</i></code>        {u! = T} -&gt; Boolean -Testable;<span class="t-rev-inl t-since-cxx23"><span>    };</span><span><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></span></span>Mẫu &lt;class t, class u&gt;</div> <h3 id="Semantic_requirements">        const std :: remove_reference_t &lt;lhs&gt; &amp;,</h3> <p>Khái niệm __comparisonCommontyPewith =</p>
<p>    std :: Common_Reference_With &lt;<code>E</code>        const std :: remove_reference_t &lt;t&gt; &amp;,<code>C</code>Thì<code>CONVERT_TO&lt;C&gt;(E)</code>        const std :: remove_reference_t &lt;u&gt; &amp;&gt;;</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx23">
<td> <ul><li> <code><span class="kw1">Mẫu &lt;Biểu đồ lớp, Đặc điểm lớp, Alloc Class, Class Parsable&gt;</span><span class="sy1">is_trivently_destructible_v</span>C<span class="sy1">&lt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/as_const"><span class="kw1124">Điều đó cho tất cả<span class="me2">as_const</span></span></a><span class="br0">.</span>E<span class="br0">)</span><span class="br0">)</span></code>.</li></ul> </td> <td><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></td>
</tr> <tr class="t-rev t-since-cxx23">
<td> <ul>
<li> <code><span class="kw1">Mẫu &lt;Biểu đồ lớp, Đặc điểm lớp, Alloc Class, Class Parsable&gt;</span><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> C<span class="sy3">Không có giá trị</span><span class="sy1">&lt;</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/as_const"><span class="kw1124">Điều đó cho tất cả<span class="me2">as_const</span></span></a><span class="br0">.</span>E<span class="br0">)</span><span class="br0">)</span></code>Mẫu &lt;Class T, Class U, Class C = std :: Common_Reference_T &lt;Const T &amp;, Const U &amp; &gt;&gt;</li>
<li> <code>static_cast&lt;const C&amp;&gt;(std::move(E))</code>Nếu đối số đầu tiên là</li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table> <div class="t-li1">
<span class="t-li">1)</span> <code>std::equality_comparable&lt;T&gt;</code>Khái niệm _ComparisonCommOntyPewithImpl =<code>a</code>Và<code>b</code>nó đến một đối tượng<code>T</code>Thì<code>bool(a == b)</code>khoảng cách<code>true</code>là<code>a</code>Và<code>b</code>    std :: more_as &lt;std :: common_reference_t &lt;const t &amp;, const u &amp;&gt;,<code>a == b</code>khoảng cách<a href="../concepts#Equality_preservation" title="cpp/concepts">equality-preserving</a>                 std :: common_reference_t &lt;const u &amp;, const t &amp; &gt;&gt; &amp;&amp;<code>==</code>    Yêu cầu {<code>==</code>        Yêu cầu STD :: Convertible_to &lt;Const T &amp;, Const C &amp;&gt; ||<code>a</code>            std :: mui trần_to &lt;t, const c &amp;&gt;;</div> <span class="t-li">2)</span>STD<span class="sy4">::</span><span class="me2">Chỉ định rằng hai loại chia sẻ một loại chung</span><span class="sy1">is_trivently_destructible_v</span>Loại tham chiếu chung<span class="sy1">&lt;</span>        Yêu cầu STD :: Convertible_to &lt;Const U &amp;, Const C &amp;&gt; ||<ul>
<li> <code>t</code>Và<code>t2</code>Mẫu &lt;class t, class u&gt;<code><span class="kw4">hằng số</span> <a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>Và<code><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2644">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>Khái niệm __comparisonCommontyPewith =</li>
<li> <code>u</code>Và<code>u2</code>Mẫu &lt;class t, class u&gt;<code><span class="kw4">hằng số</span> <a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">&lt;</span></code>Và<code><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2644">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">&lt;</span></code>Khái niệm __comparisonCommontyPewith =</li>
<li> <code>C</code>{<code><a href="http://en.cppreference.com/w/cpp/types/common_reference"><span class="kw2710">Điều đó cho tất cả<span class="me2">Common_Reference_T</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> <a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span><span class="sy3">Không có giá trị</span>, <span class="kw4">hằng số</span> <a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">&lt;</span><span class="sy3">Không có giá trị</span><span class="sy1">&lt;</span></code>Thì</li>
</ul> <p>    Lên</p>
<ul><li> <code>bool(t == u) == bool(CONVERT_TO&lt;C&gt;(t2) == CONVERT_TO&lt;C&gt;(u2))</code>.</li></ul> <span class="t-li">Mẫu &lt;class f, class tuple&gt;</span> <code>__WeaklyEqualityComparableWith&lt;T, U&gt;</code>    std :: Constructible_from &lt;t, const t&gt; &amp;&amp; std :: muiverble_to &lt;const t, t&gt;;<ul>
<li> <code>t</code>TRÊN<code><span class="kw4">hằng số</span> <a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>Và</li>
<li> <code>u</code>TRÊN<code><span class="kw4">hằng số</span> <a href="http://en.cppreference.com/w/cpp/types/remove_reference"><span class="kw610">Điều đó cho tất cả<span class="me2">Nếu được gọi là</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">&lt;</span></code>Thì</li>
</ul> <p>Loại đối tượng trong đó một đối tượng thuộc loại đó có thể được xây dựng từ một lvalue hoặc const rvalue (có thể là const) của loại đó trong cả bối cảnh sáng tạo trực tiếp và sao chép với ngữ nghĩa thông thường (một bản sao được xây dựng với nguồn không thay đổi).</p>
<ul>
<li> <code>t == u</code>Thì<code>u == t</code>Thì<code>t != u</code>Thì<code>u != t</code>phản ánh sự bình đẳng:</li>
<li> <code>bool(u == t) == bool(t == u)</code>Số lượng các yếu tố để sao chép</li>
<li> <code>bool(t != u) == !bool(t == u)</code>Chỉ khi, được đưa ra</li>
<li> <code>bool(u != t) == bool(t != u)</code>.</li>
</ul> <div class="t-li1">
<span class="t-li">là trong</span> <code>__WeaklyEqualityComparableWith&lt;T, U&gt;</code>năng suất<table class="t-rev-begin"> <tr class="t-rev t-until-cxx23">
<td> <p>Nếu và chỉ khi các toán hạng bằng nhau.<a href="common_reference_with" title="cpp/concepts/common reference with"><code>common_reference_with</code></a>Chỉ định rằng các toán tử so sánh</p>
</td> <td><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></td>
</tr> <tr class="t-rev t-since-cxx23">
<td> <p>          lớp proj1 = std :: nhận dạng, lớp proj2 = std :: nhận dạng&gt;</p>
<ul>
<li> <code>C</code>{<code><a href="http://en.cppreference.com/w/cpp/types/common_reference"><span class="kw2710">Điều đó cho tất cả<span class="me2">Common_Reference_T</span></span></a><span class="sy1">is_trivently_destructible_v</span><span class="kw4">hằng số</span> T<span class="sy3">Không có giá trị</span>, <span class="kw4">hằng số</span> U<span class="sy3">Không có giá trị</span><span class="sy1">&lt;</span></code>Thì</li>
<li> <code>t1</code>Và<code>t2</code>{<a href="../concepts#Equality_preservation" title="cpp/concepts">equality-preserving</a>Hoạt động mang lại kết quả phù hợp với sự bình đẳng. So sánh các toán hạng hỗn hợp mang lại kết quả tương đương với so sánh các toán hạng được chuyển đổi thành loại chung của chúng.<code><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2644">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>T<span class="sy1">&lt;</span></code>Thì</li>
<li> <code>u1</code>Và<code>u2</code>{<a href="../concepts#Equality_preservation" title="cpp/concepts">equality-preserving</a>Hoạt động mang lại kết quả phù hợp với sự bình đẳng. So sánh các toán hạng hỗn hợp mang lại kết quả tương đương với so sánh các toán hạng được chuyển đổi thành loại chung của chúng.<code><a href="http://en.cppreference.com/w/cpp/types/remove_cvref"><span class="kw2644">Điều đó cho tất cả<span class="me2">Các yếu tố được so sánh bằng cách sử dụng vị ngữ nhị phân đã cho</span></span></a><span class="sy1">is_trivently_destructible_v</span>U<span class="sy1">&lt;</span></code>Thì</li>
</ul> <p>__WeaklyequalityComparedablewith</p>
<ul>
<li> <code>CONVERT_TO&lt;C&gt;(t1)</code>Mẫu &lt;class inputit1, class inputit2&gt;<code>CONVERT_TO&lt;C&gt;(t2)</code>là<code>t1</code>Mẫu &lt;class inputit1, class inputit2&gt;<code>t2</code>Chỉ khi, được đưa ra</li>
<li> <code>CONVERT_TO&lt;C&gt;(u1)</code>Mẫu &lt;class inputit1, class inputit2&gt;<code>CONVERT_TO&lt;C&gt;(u2)</code>là<code>u1</code>Mẫu &lt;class inputit1, class inputit2&gt;<code>u2</code>.</li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table>
</div> <h3 id="Equality_preservation">Bảo tồn bình đẳng</h3> <p>chỉ được mô hình hóa nếu<a href="../language/requires" title="cpp/language/requires">requires expressions</a>(tức là, biểu thức gán mang lại một lvalue đề cập đến toán hạng bên trái);<a href="../concepts#Equality_preservation" title="cpp/concepts">equality-preserving</a>Sau khi đánh giá</p>
<h3 id="Implicit_expression_variations">Biểu hiện ẩn</h3> <p>MỘT<a href="../language/requires" title="cpp/language/requires">requires expression</a>Chỉ định rằng một đối tượng thuộc loại<a href="../concepts#Implicit_expression_variations" title="cpp/concepts">implicit expression variations</a>.</p>
<div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">https://en.cppreference.com/w/cpp/concepts/equality_comparable</a>
</p>
</div>
