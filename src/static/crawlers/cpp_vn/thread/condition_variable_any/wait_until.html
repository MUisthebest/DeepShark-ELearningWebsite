 <h1 class="firstHeading" id="firstHeading">std :: điều kiện_varable_any :: Wait_until</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;lớp khóa lớp, đồng hồ lớp, thời lượng lớp&gt;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">STD :: CV_Status </pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">    Wait_until (Lock &amp; Lock,</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p><code>wait_until</code>    Wait_until (STD :: Unique_lock &lt;std :: Mutex&gt; &amp; Lock,<code>bool(stop_waiting()) == true</code>).</p>
<div class="t-li1">
<span class="t-li">1)</span>                         const std :: Chrono :: Thời lượng &lt;Rep, Thời gian&gt; &amp; rel_time);<code>lock</code>Mở khóa nguyên tử<code>*this</code>, chặn luồng thực thi hiện tại và thêm nó vào danh sách các luồng đang chờ<code><a href="notify_all" title="cpp/thread/condition variable any/notify all">notify_all()</a></code>hoặc<code><a href="notify_one" title="cpp/thread/condition variable any/notify one">notify_one()</a></code>                const std :: Chrono :: Time_Point &lt;Đồng hồ, Thời lượng&gt; &amp; Timeout_Time);<code>timeout_time</code>Mẫu &lt;Đồng hồ lớp, Thời lượng lớp, Vị ngữ lớp&gt; Lớp&gt;<code>lock</code>được thực hiện. Nó cũng có thể được bỏ chặn một cách mạnh mẽ. Khi bỏ chặn, bất kể lý do,<code>wait_until</code>được phản ứng lại và</div> <div class="t-li1">
<span class="t-li">2)</span>Mẫu &lt;class inputit1, class inputit2,</div> <div class="cpp source-cpp"><pre data-language="cpp">Bool Wait_until (STD :: độc đáo_lock &lt;std :: mutex&gt; &amp; lock,</pre></div> <div class="t-li1">                 const std :: Chrono :: Time_Point &lt;Đồng hồ, Thời lượng&gt; &amp; TIMEOUT_TIME,</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>void Wait (Khóa &amp; Khóa, Vị ngữ Stop_Waiting);<code>condition_variable_any</code>Mẫu &lt;LOCK LOCK, CLASE PRESATION&gt;<code>wait_until()</code>Bool Wait (Lock &amp; Lock, Std :: Stop_Token Stoken, Inplicate Stop_Waiting);<code>stoken</code>Chờ đợi bị gián đoạn: đăng ký<div class="cpp source-cpp"><pre data-language="cpp">                const std :: Chrono :: Time_Point &lt;Đồng hồ, Thời lượng&gt; &amp; Timeout_Time);</pre></div>
</div> <p>Phát hành nguyên tử<code>lock</code>Phải có được trước khi vào phương pháp này và nó được làm lại sau<code><a href="../../error/terminate" title="cpp/error/terminate">std::terminate</a></code>thoát ra, có nghĩa là</p>
<p><code>Clock</code>          khoảng cách lớp = std :: ptrdiff_t&gt;<a href="../../named_req/clock" title="cpp/named req/Clock">Clock</a>yêu cầu.<span class="t-rev-inl t-since-cxx20"><span>là nó luôn luôn đề cập đến một múi giờ hợp lệ và đại diện cho một điểm thời gian hiện có và rõ ràng trong múi giờ đó. Phù hợp với bất biến này,<code><a href="http://en.cppreference.com/w/cpp/chrono/is_clock"><span class="kw2552">Điều đó cho tất cả<span class="me2">Chrono</span><span class="sy4">::</span><span class="me2">IS_CLOCK_V</span></span></a><span class="sy1">is_trivently_destructible_v</span>Clock<span class="sy1">&lt;</span></code>khoảng cách<code>false</code>.</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span></p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>khóa</td> <td>-</td> <td>một đối tượng của loại<code>Lock</code>Mẫu &lt;lớp khóa lớp, đồng hồ lớp, thời lượng lớp, vị trí lớp&gt;<a href="../../named_req/basiclockable" title="cpp/named req/BasicLockable">BasicLockable</a>có thể được sử dụng để bảo vệ quyền truy cập vào</td>
</tr> <tr class="t-par"> <td>    if (stop_waiting ())</td> <td>-</td> <td>Một<code>std::stop_token</code>        trả lại đúng;</td>
</tr> <tr class="t-par"> <td>khiến luồng hiện tại bị chặn cho đến khi biến điều kiện được thông báo, đạt được thời gian cụ thể hoặc xảy ra đánh thức giả, tùy chọn lặp lại cho đến khi một số vị ngữ được thỏa mãn (</td> <td>-</td> <td>một đối tượng của loại<code><a href="../../chrono/time_point" title="cpp/chrono/time point">std::chrono::time_point</a></code>được thực hiện hoặc khi điểm thời gian tuyệt đối</td>
</tr> <tr class="t-par"> <td>Nếu các chức năng này không đáp ứng được các điều kiện hậu (</td> <td>-</td> <td>bị khóa bởi luồng gọi),<code>false</code>được gọi. Ví dụ, điều này có thể xảy ra nếu tái sử dụng Mutex ném một ngoại lệ.<code>bool(stop_waiting()) == false</code>).<br/> <p>Decay_t</p>
<p><span class="t-cc"><code> bool pred();</code></span>hơn thứ hai và không nếu các đối số là tương đương.</p>
</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <div class="t-li1">
<span class="t-li">1)</span> <code><a href="../cv_status" title="cpp/thread/cv status">std::cv_status::timeout</a></code>đạt được. Nó cũng có thể được bỏ chặn một cách mạnh mẽ. Khi bỏ chặn, bất kể lý do,<code>timeout_time</code>while (! stop_waiting ()))<code><a href="../cv_status" title="cpp/thread/cv status">std::cv_status::no_timeout</a></code>Nếu đối số đầu tiên là</div> <div class="t-li1">
<span class="t-li">2)</span> <code>false</code>Nếu các chức năng này không đáp ứng được điều kiện hậu (<code>stop_waiting</code>rel_time<code>false</code>đại diện cho thời gian tối đa để chi tiêu chờ đợi. Lưu ý rằng rel_time phải đủ nhỏ để không tràn khi thêm vào<code>timeout_time</code>Nếu thời gian chờ tương đối được chỉ định bởi<code>true</code>{<code>stop_waiting</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span> <code>stop_waiting()</code>Mẫu &lt;lớp khóa lớp, đại diện lớp, giai đoạn lớp, vị trí lớp&gt;</div> <h3 id="Exceptions">Ngoại lệ</h3> <div class="t-li1">
<span class="t-li">1)</span>    if (Wait_until (khóa, thời gian chờ_time) == std :: cv_status :: hết thời gian chờ)</div> <div class="t-li1">
<span class="t-li">2)</span>                                   Nhị phân p);<span class="t-v">(1)</span>, phải bị khóa bởi luồng hiện tại<code>stop_waiting</code>.</div> <div class="t-li1">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>                                   Nhị phân p);<span class="t-v">(2)</span>.</div> <h3 id="Notes">Ghi chú</h3> <p>đã đạt được.<code>timeout_time</code>        return stop_waiting ();<code>timeout_time</code>từ<code>Clock</code>ĐẾN<code><a href="../../chrono/system_clock" title="cpp/chrono/system clock">std::chrono::system_clock</a></code>}<a class="external text" href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_timedwait.html" rel="nofollow"><code>pthread_cond_timedwait</code></a>trả lại đúng;<code>Clock</code>Quá tải này có thể được sử dụng để bỏ qua các đánh thức giả.<code>timeout_time</code>một đối tượng của loại std :: độc đáo_lock &lt;std :: mutex&gt;, phải bị khóa bởi luồng hiện tại</p>
<p>Thời gian chờ_time<code><a href="../../chrono/steady_clock" title="cpp/chrono/steady clock">std::chrono::steady_clock</a></code>đại diện cho thời gian khi ngừng chờ đợi</p>
<p>Những ảnh hưởng của<code>notify_one()</code>/<code>notify_all()</code>và mỗi trong ba phần nguyên tử của<code>wait()</code>/<code>wait_for()</code>/<code>wait_until()</code>(Mở khóa+Chờ, Wakeup và khóa) diễn ra trong một thứ tự tổng thể có thể được xem là<a href="../../atomic/memory_order#Modification_order" title="cpp/atomic/memory order">modification order</a>của một biến nguyên tử: thứ tự là cụ thể cho biến điều kiện riêng lẻ này. Điều này làm cho nó không thể cho<code>notify_one()</code>Ví dụ, bị trì hoãn và bỏ chặn một chủ đề bắt đầu chờ đợi ngay sau khi cuộc gọi đến<code>notify_one()</code>đã được thực hiện.</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Nếu thời kỳ tuyệt đối được chỉ định bởi</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">Thời gian chờ đã hết hạn, nếu không</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2093" rel="nofollow">LWG 2093</a> </td> <td>C ++ 11</td> <td>Các trường hợp ngoại lệ liên quan đến thời gian chờ bị thiếu trong đặc điểm kỹ thuật</td> <td>được nhắc đến</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2135" rel="nofollow">LWG 2135</a> </td> <td>C ++ 11</td> <td>
<code>wait_until</code>stop_waiting</td> <td>cuộc gọi<code><a href="../../error/terminate" title="cpp/error/terminate">std::terminate</a></code> </td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="wait" title="cpp/thread/condition variable any/wait"> <span class="t-lines"><span>toán tử t</span></span></a></div> </td> <td>chặn luồng hiện tại cho đến khi biến điều kiện được đánh thức<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="wait_for" title="cpp/thread/condition variable any/wait for"> <span class="t-lines"><span>Wait_for</span></span></a></div> </td> <td>chặn luồng hiện tại cho đến khi biến điều kiện được đánh thức hoặc sau thời gian chờ được chỉ định<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/thread/cnd_timedwait" title="c/thread/cnd timedwait">C documentation</a></span>vì<code>cnd_timedwait</code> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/thread/condition_variable_any/wait_until">https://en.cppreference.com/w/cpp/thread/condition_variable_any/wait_until</a>
</p>
</div>
