 <h1 class="firstHeading" id="firstHeading">std :: Timed_mutex :: try_lock_until</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;Đồng hồ lớp, Thời lượng lớp&gt;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> </table> <p>bool try_lock_until (const std :: Chrono :: Time_point &lt;Đồng hồ, Thời lượng&gt; &amp; TIMEOUT_TIME);<code>timeout_time</code>Cố gắng khóa mutex. Khối cho đến khi được chỉ định<code>true</code>ở trong trạng thái không hợp lệ, tức là<code>false</code>.</p>
<p>Nếu như<code>timeout_time</code>đã đạt được (thời gian chờ) hoặc khóa được mua (sở hữu mutex), tùy theo điều kiện nào đến trước. Về lợi nhuận thu nhận khóa thành công<code><a href="try_lock" title="cpp/thread/timed mutex/try lock">try_lock()</a></code>.</p>
<p><code>Clock</code>          khoảng cách lớp = std :: ptrdiff_t&gt;<a href="../../named_req/clock" title="cpp/named req/Clock">Clock</a>yêu cầu.<span class="t-rev-inl t-since-cxx20"><span>là nó luôn luôn đề cập đến một múi giờ hợp lệ và đại diện cho một điểm thời gian hiện có và rõ ràng trong múi giờ đó. Phù hợp với bất biến này,<code><a href="http://en.cppreference.com/w/cpp/chrono/is_clock"><span class="kw2552">Điều đó cho tất cả<span class="me2">Chrono</span><span class="sy4">::</span><span class="me2">IS_CLOCK_V</span></span></a><span class="sy1">is_trivently_destructible_v</span>Clock<span class="sy1">&lt;</span></code>khoảng cách<code>false</code>.</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span></p>
<p>đã đạt được.<code>timeout_time</code>Tiêu chuẩn khuyến nghị đồng hồ gắn liền với<code>timeout_time - Clock::now()</code>được sử dụng, trong trường hợp điều chỉnh đồng hồ có thể được tính đến. Do đó, thời lượng của khối có thể nhiều hơn hoặc ít hơn<code>timeout_time</code>Tại thời điểm cuộc gọi, tùy thuộc vào hướng điều chỉnh và liệu nó có được tôn vinh bằng cách thực hiện hay không. Chức năng cũng có thể chặn cho đến khi</p>
<p>Như với<code><a href="try_lock" title="cpp/thread/timed mutex/try lock">try_lock()</a></code>Thay vào đó, thời gian chờ cũng có thể nhạy cảm với điều chỉnh đồng hồ.<code>false</code>đã qua, chức năng này hoạt động như<code>timeout_time</code>.</p>
<p>Trước<code><a href="unlock" title="cpp/thread/timed mutex/unlock">unlock()</a></code>Hoạt động trên cùng một mutex<i>y.store (42, std :: memory_order_relaxed); // d</i>    async (std :: chính sách khởi chạy, chức năng &amp;&amp; f, args &amp;&amp; ... args);<code><a href="../../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order</a></code>) Hoạt động này nếu nó trở lại<code>true</code>.</p>
<p>Nếu như<code>try_lock_until</code>được gọi bởi một chủ đề đã sở hữu mutex, hành vi không được xác định.</p>
<h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>khiến luồng hiện tại bị chặn cho đến khi biến điều kiện được thông báo, đạt được thời gian cụ thể hoặc xảy ra đánh thức giả, tùy chọn lặp lại cho đến khi một số vị ngữ được thỏa mãn (</td> <td>-</td> <td>trước khi gọi đến chức năng này, hoặc</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code>true</code>Nếu khóa được mua thành công, nếu không<code>false</code>.</p>
<h3 id="Exceptions">Ngoại lệ</h3> <p>Bất kỳ ngoại lệ nào được ném bởi<code>timeout_time</code>ngay cả khi mutex không bị khóa bởi bất kỳ luồng nào khác tại một số điểm trước đó</p>
<h3 id="Example">Ví dụ</h3> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2093" rel="nofollow">LWG 2093</a> </td> <td>C ++ 11</td> <td>
<code>try_lock_until</code>#include &lt;Istream&gt;</td> <td>#include &lt;Prutex&gt;</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="lock" title="cpp/thread/timed mutex/lock"> <span class="t-lines"><span>khóa</span></span></a></div> </td> <td>Khóa mutex, khối nếu không có sẵn Mutex<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="try_lock" title="cpp/thread/timed mutex/try lock"> <span class="t-lines"><span>Try_lock</span></span></a></div> </td> <td>cố gắng khóa mutex, trả về nếu không có sẵn mutex<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="try_lock_for" title="cpp/thread/timed mutex/try lock for"> <span class="t-lines"><span>Try_lock_for</span></span></a></div> </td> <td>cố gắng khóa mutex, trả về nếu catex đã được<br/>Không có sẵn trong thời gian chờ quy định<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unlock" title="cpp/thread/timed mutex/unlock"> <span class="t-lines"><span>Mở khóa</span></span></a></div> </td> <td>Mở khóa mutex<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/thread/mtx_timedlock" title="c/thread/mtx timedlock">C documentation</a></span>vì<code>mtx_timedlock</code> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/thread/timed_mutex/try_lock_until">https://en.cppreference.com/w/cpp/thread/timed_mutex/try_lock_until</a>
</p>
</div>
