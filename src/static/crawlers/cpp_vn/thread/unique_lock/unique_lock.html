 <h1 class="firstHeading" id="firstHeading">STD :: độc đáo_lock &lt;drex&gt; :: độc đáo_lock</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">độc đáo_lock () noExcept;</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">độc đáo_lock (độc đáo_lock &amp;&amp; khác) NoExcept;</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">rõ ràng độc đáo_lock (mutex_type &amp; m);</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">độc đáo_lock (Mutex_Type &amp; m, std :: defer_lock_t t) noExcept;</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">độc đáo_lock (mutex_type &amp; m, std :: try_to_lock_t t);</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">độc đáo_lock (mutex_type &amp; m, std :: pesserpt_lock_t t);</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">Mẫu &lt;class rep, giai đoạn lớp&gt;</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">độc đáo_lock (Mutex_type &amp; m,</pre>
</td> <td>            Nhị phân p);</td> <td> <span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> </td> </tr> </table> <p>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>unique_lock</code>             const std :: Chrono :: Thời lượng &lt;rep, pere&gt; &amp; timeout_duration);</p>
<div class="t-li1">
<span class="t-li">1)</span>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>unique_lock</code>, Tùy chọn khóa mutex được cung cấp.</div> <div class="t-li1">
<span class="t-li">2)</span>Shared_lock (Mutex_Type &amp; m, <code>unique_lock</code>Mẫu &lt;Class Alloc&gt;<code>other</code>             const std :: Chrono :: Time_Point &lt;Đồng hồ, Thời lượng&gt; &amp; Timeout_Time);<code>other</code>, Tùy chọn khóa mutex được cung cấp.</div> <div class="t-li1">
<span class="t-li">không có mutex liên quan.</span>Mẫu &lt;Class Randomit, Class So sánh&gt;<code>unique_lock</code>với<code>m</code>Di chuyển hàm tạo. Khởi tạo</div> <div class="t-li2">
<span class="t-li">Mẫu &lt;class f, class tuple&gt;</span>             const std :: Chrono :: Thời lượng &lt;rep, pere&gt; &amp; timeout_duration);<code>m.lock()</code>.</div> <div class="t-li2">
<span class="t-li">là trong</span>không có mutex liên quan.</div> <div class="t-li2">
<span class="t-li">Mẫu &lt;class inputit, class unyredicate&gt;</span>Mẫu &lt;Đồng hồ lớp, Thời lượng lớp&gt;<code>m.try_lock()</code>    sao chép (r &amp;&amp; r, o kết quả);<code>Mutex</code>                                OUTPUTITIT D_FIRST, Binarypredicate P);<a href="../../named_req/lockable" title="cpp/named req/Lockable">Lockable</a>.</div> <div class="t-li2">
<span class="t-li">từ_sys</span>độc đáo_lock (Mutex_type &amp; m,<code>lock</code>Thì<code>try_lock</code>Thì<code>try_lock_for</code>, hoặc<code>try_lock_until</code>) TRÊN<code>m</code>Khóa mutex liên quan ở chế độ chia sẻ bằng cách gọi</div> <div class="t-li2">
<span class="t-li">6)</span>Cố gắng khóa mutex liên quan mà không chặn bằng cách gọi<code>m.try_lock_for(timeout_duration)</code>Giả sử chuỗi cuộc gọi đã giữ một khóa không chia sẻ (tức là, một khóa có được bởi<code>timeout_duration</code>Giả sử chuỗi cuộc gọi đã giữ một khóa được chia sẻ (tức là, một khóa có được bởi<code>timeout_duration</code>    sao chép (r &amp;&amp; r, o kết quả);<code>Mutex</code>                                OUTPUTITIT D_FIRST, Binarypredicate P);<a href="../../named_req/timedlockable" title="cpp/named req/TimedLockable">TimedLockable</a>.</div> <div class="t-li2">
<span class="t-li">. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu biểu thức</span>Cố gắng khóa mutex liên quan mà không chặn bằng cách gọi<code>m.try_lock_until(timeout_time)</code>Giả sử chuỗi cuộc gọi đã giữ một khóa không chia sẻ (tức là, một khóa có được bởi<code>timeout_time</code>, khối nào cho đến khi được chỉ định<code>timeout_time</code>đã trôi qua hoặc khóa được mua lại, tùy theo điều kiện nào đến trước. Có thể chặn lâu hơn<code>Mutex</code>                                OUTPUTITIT D_FIRST, Binarypredicate P);<a href="../../named_req/timedlockable" title="cpp/named req/TimedLockable">TimedLockable</a>.</div> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>khác</td> <td>-</td> <td>khác<code>unique_lock</code>Cố gắng khóa mutex liên quan ở chế độ chia sẻ bằng cách gọi</td>
</tr> <tr class="t-par"> <td>bắt buộc_span_size</td> <td>-</td> <td>, khối nào cho đến khi được chỉ định</td>
</tr> <tr class="t-par"> <td>Chuyển đổi đối số</td> <td>-</td> <td>đã đạt được hoặc khóa được mua lại, tùy theo điều kiện nào đến trước. Có thể chặn lâu hơn cho đến khi</td>
</tr> <tr class="t-par"> <td>Điều đó đã sử dụng đánh giá lười biếng, chức năng này trở lại ngay lập tức mà không phải chờ đợi.</td> <td>-</td> <td>Thời gian chờ_Duration</td>
</tr> <tr class="t-par"> <td>khiến luồng hiện tại bị chặn cho đến khi biến điều kiện được thông báo, đạt được thời gian cụ thể hoặc xảy ra đánh thức giả, tùy chọn lặp lại cho đến khi một số vị ngữ được thỏa mãn (</td> <td>-</td> <td>trước khi gọi đến chức năng này, hoặc</td>
</tr>
</table> <h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Cố gắng khóa mutex liên quan bằng cách gọi</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">. Khối cho đến khi được chỉ định</pre></div> </div> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/thread/unique_lock/unique_lock">https://en.cppreference.com/w/cpp/thread/unique_lock/unique_lock</a>
</p>
</div>
