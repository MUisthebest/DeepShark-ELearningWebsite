 <h1 class="firstHeading" id="firstHeading">STD :: Async</h1> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th>C Thư viện<code><a href="../header/future" title="cpp/header/future">&lt;future&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="4">(1)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx17"> <td><pre data-language="cpp">Mẫu &lt;chức năng lớp, lớp ... args&gt;</pre></td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx17">xáo trộn</span>
</td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td> <pre data-language="cpp">std :: Tương lai &lt;typename std :: result_of &lt;typename std :: decay &lt;function&gt; :: type (</pre>
</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">        Typename std :: Decay &lt;args&gt; :: type ...)&gt; :: type&gt;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="4">(2)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx17"> <td><pre data-language="cpp">    async (hàm &amp;&amp; f, args &amp;&amp; ... args);</pre></td> <td>
<span class="t-mark-rev t-since-cxx11">(kể từ C ++ 11)</span> <br/><span class="t-mark-rev t-until-cxx17">xáo trộn</span>
</td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td> <pre data-language="cpp">Mẫu &lt;chức năng lớp, lớp ... args&gt;</pre>
</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> <br/><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">STD :: Tương lai &lt;std :: indoke_result_t &lt;std :: decay_t &lt;function&gt;,</pre>
</td> <td> <span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span> </td> </tr> </table> <p>                                 std :: decay_t &lt;args&gt; ... &gt;&gt;<code>std::async</code>    async (hàm &amp;&amp; f, args &amp;&amp; ... args);<code>f</code>Mẫu &lt;chức năng lớp, lớp ... args&gt;<code><a href="future" title="cpp/thread/future">std::future</a></code>[[Nodiscard]] std :: Tương lai &lt;std :: indoke_result_t &lt;std :: decay_t &lt;function&gt;,</p>
<div class="t-li1">
<span class="t-li">1)</span>                                               std :: decay_t &lt;args&gt; ... &gt;&gt;<span class="t-v">(2)</span>được gọi với<code>policy</code>hiện tại<code><a href="http://en.cppreference.com/w/cpp/thread/launch"><span class="kw2188">Điều đó cho tất cả<span class="me2">phóng</span><span class="sy4">::</span><span class="me2">không đồng bộ</span></span></a> <span class="sy3">|</span> <a href="http://en.cppreference.com/w/cpp/thread/launch"><span class="kw2189">Điều đó cho tất cả<span class="me2">phóng</span><span class="sy4">::</span><span class="me2">là bản sao được lưu trữ của</span></span></a></code>.</div> <div class="t-li1">
<span class="t-li">2)</span>Mẫu &lt;chức năng lớp, lớp ... args&gt;<code>f</code>std :: Tương lai &lt;typename std :: result_of &lt;typename std :: decay &lt;function&gt; :: type (<code>args</code>        Typename std :: Decay &lt;args&gt; :: type ...)&gt; :: type&gt;<code>policy</code>    std :: chuỗi* p = new std :: chuỗi ("xin chào");<a href="#Launch_policies">below</a>).</div> <p>Cuộc gọi đến<code>std::async</code> <i>y.store (42, std :: memory_order_relaxed); // d</i>    async (std :: chính sách khởi chạy, chức năng &amp;&amp; f, args &amp;&amp; ... args);<code><a href="../atomic/memory_order" title="cpp/atomic/memory order">std::memory_order</a></code>Mẫu &lt;chức năng lớp, lớp ... args&gt;<code>f</code>STD :: Tương lai &lt;std :: indoke_result_t &lt;std :: decay_t &lt;function&gt;,<code>f</code>khoảng cách<i>{</i>                                 std :: decay_t &lt;args&gt; ... &gt;&gt;</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p>Nếu như<code><a href="../utility/functional" title="cpp/utility/functional">INVOKE</a>(<a href="../standard_library/decay-copy" title="cpp/standard library/decay-copy">decay-copy</a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span><span class="br0">.</span>f<span class="br0">)</span><span class="br0">)</span>,<br/> <a href="../standard_library/decay-copy" title="cpp/standard library/decay-copy">decay-copy</a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span>args<span class="br0">)</span><span class="br0">)</span>...<span class="br0">)</span></code>    async (std :: chính sách khởi chạy, chức năng &amp;&amp; f, args &amp;&amp; ... args);</p>
</td> <td><span class="t-mark-rev t-until-cxx20">chỉ vào một yếu tố của chuỗi,</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p>là nó luôn luôn đề cập đến một múi giờ hợp lệ và đại diện cho một điểm thời gian hiện có và rõ ràng trong múi giờ đó. Phù hợp với bất biến này,</p>
<ul>
<li> <code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw528">Điều đó cho tất cả<span class="me2">, sao chép-khởi tạo phần tử tương ứng của kết quả với</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span>, F<span class="sy1">&lt;</span></code>khoảng cách<code>false</code>Thì</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw528">Điều đó cho tất cả<span class="me2">, sao chép-khởi tạo phần tử tương ứng của kết quả với</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>Arg_i<span class="sy1">&lt;</span>, Arg_i<span class="sy1">&lt;</span></code>khoảng cách<code>false</code>Mẫu &lt;class inputit, class alloc&gt;<code>Arg_i</code>TRONG<code>Args</code>, hoặc</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/types/is_invocable"><span class="kw2714">Điều đó cho tất cả<span class="me2">Mẫu &lt;chức năng lớp, lớp ... args&gt;</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span>, <a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span>...<span class="sy1">&lt;</span></code>khoảng cách<code>false</code>.</li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></td>
</tr> </table> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>có thể sửa đổi các phần tử của phạm vi thông qua trình lặp được thu hút. Nếu như</td> <td>-</td> <td> <a href="../named_req/callable" title="cpp/named req/Callable">Callable</a>[[Nodiscard]] std :: Tương lai &lt;std :: indoke_result_t &lt;std :: decay_t &lt;function&gt;,</td>
</tr> <tr class="t-par"> <td>, không cho phép định dạng định dạng.</td> <td>-</td> <td>                                               std :: decay_t &lt;args&gt; ... &gt;&gt;<code>f</code> </td>
</tr> <tr class="t-par"> <td>std :: iterator_traits &lt;buputit&gt; :: value_type acc = *first;</td> <td>-</td> <td>    async (std :: chính sách khởi chạy, chức năng &amp;&amp; f, args &amp;&amp; ... args);<table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th>Mẫu chức năng</th> <th>Lưu ý: Đồng bộ hóa giữa các luồng tập trung vào việc ngăn chặn các chủng tộc dữ liệu (bằng cách thiết lập các mối quan hệ xảy ra trước khi) và xác định các tác dụng phụ nào có thể nhìn thấy được trong các điều kiện nào.</th>
</tr> <tr class="t-dsc"> <td> <code><a href="launch" title="cpp/thread/launch">std::launch::async</a></code> </td> <td>Chạy chức năng</td>
</tr> <tr class="t-dsc"> <td> <code><a href="launch" title="cpp/thread/launch">std::launch::deferred</a></code> </td> <td>Không đồng bộ (có khả năng trong một luồng riêng biệt có thể là một phần của nhóm luồng) và trả về</td>
</tr> </table> </td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code><a href="future" title="cpp/thread/future">std::future</a></code>Điều đó cuối cùng sẽ giữ kết quả của cuộc gọi chức năng đó.<code>std::async</code>.</p>
<h3 id="Launch_policies">Hành xử như thể</h3> <h4 id="Async_invocation">hoãn lại</h4> <p>Consexpr ForwardIT Remove_if (ForwardIt First, ForwardIt Last,<i>không đồng bộ</i>Giá trị bitmask, trong đó các bit riêng lẻ kiểm soát các phương pháp thực thi được phép<code><span class="br0">.</span>policy <span class="sy3">Không có giá trị</span> <a href="http://en.cppreference.com/w/cpp/thread/launch"><span class="kw2188">Điều đó cho tất cả<span class="me2">phóng</span><span class="sy4">::</span><span class="me2">không đồng bộ</span></span></a><span class="br0">)</span> <span class="sy3">Nếu tồn tại một</span><span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <span class="nu0">. Không làm gì khác.</span></code>cũng mở cho đầu vào (</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx23">
<td> <p><code>std::async</code>cuộc gọi<code><a href="../utility/functional" title="cpp/utility/functional">INVOKE</a>(<a href="../standard_library/decay-copy" title="cpp/standard library/decay-copy">decay-copy</a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span><span class="br0">.</span>f<span class="br0">)</span><span class="br0">)</span>,<br/> <a href="../standard_library/decay-copy" title="cpp/standard library/decay-copy">decay-copy</a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span>args<span class="br0">)</span><span class="br0">)</span>...<span class="br0">)</span></code>Theo chính sách ra mắt cụ thể<code><a href="thread" title="cpp/thread/thread">std::thread</a></code>Giống như các tài liệu tham khảo ngôn ngữ, sự ổn định là nông cạn đối với</p>
</td> <td><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></td>
</tr> <tr class="t-rev t-since-cxx23">
<td> <p><code>std::async</code>cuộc gọi<code><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1063">Điều đó cho tất cả<span class="me2">STD ::</span></span></a><span class="br0">.</span><span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span><span class="br0">.</span>f<span class="br0">)</span><span class="br0">)</span>,<br/> <span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span>args<span class="br0">)</span><span class="br0">)</span>...<span class="br0">)</span></code>Theo chính sách ra mắt cụ thể<code><a href="thread" title="cpp/thread/thread">std::thread</a></code>Giống như các tài liệu tham khảo ngôn ngữ, sự ổn định là nông cạn đối với</p>
</td> <td><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></td>
</tr> </table>
<br/> <p><span class="t-rev-inl t-until-cxx23"><span>(như được định nghĩa trong<a href="../standard_library/decay-copy" title="cpp/standard library/decay-copy"><code>decay-copy</code></a>) cuộc gọi đến</span><span><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></span></span><span class="t-rev-inl t-since-cxx23"><span>và sự hoàn thành của<code>auto</code>&gt;<a href="../language/implicit_conversion#Temporary_materialization" title="cpp/language/implicit conversion">materialized</a></span><span><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></span></span>Làm cho nhà nước được chia sẻ sẵn sàng.<code>f</code>không phải là một biểu thức hợp lệ, chương trình không được hình thành.<code><a href="future" title="cpp/thread/future">std::future</a></code>cái đó<code>std::async</code>is_invocable_v</p>
<h4 id="Deferred_invocation">phản đối cuộc gọi</h4> <p>Consexpr ForwardIT Remove_if (ForwardIt First, ForwardIt Last,<i>là bản sao được lưu trữ của</i>Giá trị bitmask, trong đó các bit riêng lẻ kiểm soát các phương pháp thực thi được phép<code><span class="br0">.</span>policy <span class="sy3">Không có giá trị</span> <a href="http://en.cppreference.com/w/cpp/thread/launch"><span class="kw2189">Điều đó cho tất cả<span class="me2">phóng</span><span class="sy4">::</span><span class="me2">là bản sao được lưu trữ của</span></span></a><span class="br0">)</span> <span class="sy3">Nếu tồn tại một</span><span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <span class="nu0">. Không làm gì khác.</span></code>cũng mở cho đầu vào (<code>std::async</code>Cho phép đánh giá không đồng bộ<span class="t-rev-inl t-until-cxx23"><span><code><a href="../standard_library/decay-copy" title="cpp/standard library/decay-copy">decay-copy</a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span><span class="br0">.</span>f<span class="br0">)</span><span class="br0">)</span></code>Và<code><a href="../standard_library/decay-copy" title="cpp/standard library/decay-copy">decay-copy</a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span>args<span class="br0">)</span><span class="br0">)</span>...</code></span><span><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></span></span><span class="t-rev-inl t-since-cxx23"><span><code><span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span><span class="br0">.</span>f<span class="br0">)</span><span class="br0">)</span></code>Và<code><span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span>args<span class="br0">)</span><span class="br0">)</span>...</code></span><span><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></span></span>Cho phép đánh giá lười biếng</p>
<p><i>đề cập đến trạng thái chia sẻ được tạo bởi cuộc gọi này đến</i>Ra mắt chính sách</p>
<ul>
<li>Nhu cầu không đồng bộ<code><a href="future" title="cpp/thread/future">std::future</a></code>cái đó<code>std::async</code>Cờ được đặt (tức là<code><a href="../utility/functional" title="cpp/utility/functional">INVOKE</a>(std::move(g), std::move(xyz))</code>như thể trong một luồng thực thi mới được đại diện bởi một<code>std::async</code>Mẫu &lt;Class Randomit, Class So sánh&gt;</li>
<ul>
<li> <code>g</code>__istream_fn<span class="t-rev-inl t-until-cxx23"><span><code><a href="../standard_library/decay-copy" title="cpp/standard library/decay-copy">decay-copy</a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span><span class="br0">.</span>f<span class="br0">)</span><span class="br0">)</span></code></span><span><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></span></span><span class="t-rev-inl t-since-cxx23"><span><code><span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>F<span class="sy1">&lt;</span><span class="br0">.</span>f<span class="br0">)</span><span class="br0">)</span></code></span><span><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></span></span>Và</li>
<li> <code>xyz</code>như thể trong một luồng thực thi mới được đại diện bởi một<span class="t-rev-inl t-until-cxx23"><span><code><a href="../standard_library/decay-copy" title="cpp/standard library/decay-copy">decay-copy</a><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span>args<span class="br0">)</span><span class="br0">)</span>...</code></span><span><span class="t-mark-rev t-until-cxx23">(Cho đến C ++ 23)</span></span></span><span class="t-rev-inl t-since-cxx23"><span><code><span class="kw4">    phân vùng_point (r &amp;&amp; r, pred, proj proj = {});</span><span class="br0">.</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">Điều đó cho tất cả<span class="me2">phía trước</span></span></a><span class="sy1">is_trivently_destructible_v</span>Args<span class="sy1">&lt;</span><span class="br0">.</span>args<span class="br0">)</span><span class="br0">)</span>...</code></span><span><span class="t-mark-rev t-since-cxx23">(kể từ C ++ 23)</span></span></span>.</li>
</ul>
<li>Các cuộc gọi của<code><a href="future" title="cpp/thread/future">std::future</a></code>được đánh giá<code><a href="future" title="cpp/thread/future">std::future</a></code>Các giá trị được tạo ra bởi</li>
</ul> <h4 id="Other_policies">trong chủ đề hiện tại. Nếu chức năng</h4> <p>Nếu không<code><a href="launch" title="cpp/thread/launch">std::launch::async</a></code>constexpr outputit độc đáo_copy (đầu vào đầu tiên, đầu vào cuối cùng,<code><a href="launch" title="cpp/thread/launch">std::launch::deferred</a></code>Trả về một giá trị hoặc ném một ngoại lệ, nó được lưu trữ ở trạng thái chia sẻ có thể truy cập được thông qua<code>policy</code>Hoạt động tương đương cho quá tải</p>
<h3 id="Policy_selection">trả lại cho người gọi.</h3> <p>Lời cầu khẩn trì hoãn<code><a href="launch" title="cpp/thread/launch">std::launch::async</a></code>Và<code><a href="launch" title="cpp/thread/launch">std::launch::deferred</a></code>hoãn lại<code>policy</code>Cờ được đặt (tức là</p>
<p>Consexpr ForwardIT Remove_if (ForwardIt First, ForwardIt Last,<code><a href="launch" title="cpp/thread/launch">std::launch::async</a></code>hoãn lại</p>
<ul>
<li>cửa hàng<code>std::async</code>ở trạng thái chia sẻ.</li>
<li>Đánh giá lười biếng<i>y.store (42, std :: memory_order_relaxed); // d</i>được thực hiện:</li>
</ul> <h3 id="Exceptions">Ngoại lệ</h3> <p>Ném</p>
<ul>
<li> <code><a href="../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>Cuộc gọi đầu tiên đến chức năng chờ không đúng giờ trên</li>
<li> <code><a href="../error/system_error" title="cpp/error/system error">std::system_error</a></code>trả lại cho người gọi sẽ đánh giá<code><a href="../error/errc" title="cpp/error/errc">std::errc::resource_unavailable_try_again</a></code>Sử dụng chức năng nhị phân đã cho<code>policy <span class="sy1">==</span> <a href="http://en.cppreference.com/w/cpp/thread/launch"><span class="kw2188">Điều đó cho tất cả<span class="me2">phóng</span><span class="sy4">::</span><span class="me2">không đồng bộ</span></span></a></code>trong luồng hiện tại (không phải là luồng ban đầu được gọi<ul><li>Nếu như<code>policy</code>khoảng cách<code><a href="http://en.cppreference.com/w/cpp/thread/launch"><span class="kw2188">Điều đó cho tất cả<span class="me2">phóng</span><span class="sy4">::</span><span class="me2">không đồng bộ</span></span></a> <span class="sy3">|</span> <a href="http://en.cppreference.com/w/cpp/thread/launch"><span class="kw2189">Điều đó cho tất cả<span class="me2">phóng</span><span class="sy4">::</span><span class="me2">là bản sao được lưu trữ của</span></span></a></code>Kết quả hoặc ngoại lệ được đặt ở trạng thái chia sẻ liên quan đến</li></ul> </li>
</ul> <h3 id="Notes">Ghi chú</h3> <p>Và chỉ sau đó nó được làm sẵn. Tất cả các quyền truy cập tiếp theo với cùng một<code>std::async</code>sẽ trả lại kết quả ngay lập tức.</p>
<p>Các chính sách khác<code>std::async</code>, cũng như bất kỳ lá cờ chính sách được xác định thực hiện nào được đặt trong<code>std::async</code>Lựa chọn chính sách</p>
<p>Consexpr ForwardIT Remove_if (ForwardIt First, ForwardIt Last,<code><a href="future" title="cpp/thread/future">std::future</a></code>bằng nhau nếu các điều kiện sau giữ:<code>std::async</code>Nếu có nhiều cờ được đặt, nó được xác định là chính sách được xác định. Cho mặc định (cả hai<code><a href="future" title="cpp/thread/future">std::future</a></code>cờ được đặt trong</p>
<div class="cpp source-cpp"><pre data-language="cpp">), Tiêu chuẩn khuyến nghị (nhưng không yêu cầu) sử dụng đồng thời có sẵn và trì hoãn mọi nhiệm vụ bổ sung.</pre></div> <p>Chính sách được chọn,<code><a href="future" title="cpp/thread/future">std::future</a></code>một cuộc gọi đến một hàm chờ trên một đối tượng trả về không đồng bộ chia sẻ trạng thái được chia sẻ do điều này<code>std::async</code>Các khối gọi cho đến khi luồng liên kết đã hoàn thành, như thể tham gia, hoặc thời gian khác; Và</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">sự hoàn thành chủ đề liên quan</pre></div> <p>#include &lt;Istream&gt;</p>
<div class="text source-text"><pre data-language="c">Lợi nhuận thành công từ chức năng đầu tiên đang chờ đợi trạng thái được chia sẻ hoặc với sự trở lại của hàm cuối cùng phát hành trạng thái chia sẻ, tùy theo điều kiện nào đến trước.</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2021" rel="nofollow">LWG 2021</a> </td> <td>C ++ 11</td> <td>, nếu bộ nhớ cho các cấu trúc dữ liệu nội bộ không thể được phân bổ hoặc<br/>với điều kiện lỗi</td> <td>và việc thực hiện không thể bắt đầu một chủ đề mới.<br/>hoãn lại</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2078" rel="nofollow">LWG 2078</a> </td> <td>C ++ 11</td> <td>Constexpr unanyfunction for_each (đầu vào đầu tiên, đầu vào cuối cùng, không có chức năng f)<code><a href="../error/system_error" title="cpp/error/system error">std::system_error</a></code><br/>Hoặc có các bit bổ sung được đặt, nó sẽ quay trở lại để gọi trì hoãn hoặc các chính sách được xác định theo thực hiện trong trường hợp này.<code>policy</code>Việc thực hiện có thể mở rộng hành vi của quá tải đầu tiên của<br/>bằng cách cho phép các bit bổ sung (do triển khai xác định) trong chính sách khởi chạy mặc định.<code><a href="launch" title="cpp/thread/launch">std::launch::async</a></code> </td> <td>Ví dụ về các chính sách khởi động được xác định theo thực hiện là chính sách đồng bộ hóa (thực thi ngay lập tức, trong<br/><code>policy <span class="sy1">==</span> <a href="http://en.cppreference.com/w/cpp/thread/launch"><span class="kw2188">Điều đó cho tất cả<span class="me2">phóng</span><span class="sy4">::</span><span class="me2">không đồng bộ</span></span></a></code> </td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2100" rel="nofollow">LWG 2100</a> </td> <td>C ++ 11</td> <td>gọi) và chính sách nhiệm vụ (tương tự như<br/>nếu như<code><a href="launch" title="cpp/thread/launch">std::launch::async</a></code>, nhưng các địa điểm chủ đề không được xóa)</td> <td>cho phép</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2120" rel="nofollow">LWG 2120</a> </td> <td>C ++ 11</td> <td>không được chuyển từ hoặc ràng buộc sang một tài liệu tham khảo, bộ hủy diệt của<br/>sẽ chặn ở cuối biểu thức đầy đủ cho đến khi hoạt động không đồng bộ hoàn thành, về cơ bản tạo ra mã như đồng bộ sau:</td> <td>là giá trị trả về, vẫn có thể giảm được, nhưng bản thân các yếu tố có giá trị không xác định. Một cuộc gọi đến<br/>kích cỡ.</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue2752" rel="nofollow">LWG 2752</a> </td> <td>C ++ 11</td> <td>
<code>std::async</code>std :: async (std :: ra mắt :: async, [] {f ();}); // DTOR tạm thời chờ f ()<code><a href="../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code>về lỗi.<br/>std :: async (std :: ra mắt :: async, [] {g ();}); // không bắt đầu cho đến khi f () hoàn thành</td> <td>ném</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3476" rel="nofollow">LWG 3476</a> </td> <td>C ++ 11</td> <td>
<code>Function</code>Và<code>Args...</code>Lưu ý rằng những kẻ hủy diệt của<a href="../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a><br/>s thu được bằng các phương tiện khác với cuộc gọi đến</td> <td>Không bao giờ chặn.</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="future" title="cpp/thread/future"> <span class="t-lines"><span>tương lai</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">unininitialized_copy_n</span></span></span></div> </td> <td>Chờ một giá trị được đặt không đồng bộ<br/> <span class="t-mark">Kiểm tra xem một lớp có đại diện cho chính sách thực thi không</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/thread/async">https://en.cppreference.com/w/cpp/thread/async</a>
</p>
</div>
