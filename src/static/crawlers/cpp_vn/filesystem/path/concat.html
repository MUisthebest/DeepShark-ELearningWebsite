 <h1 class="firstHeading" id="firstHeading">std :: fileSystem :: path :: concat, std :: fileSystem :: path :: toán tử+=</h1> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Path &amp; Toán tử+= (đường dẫn Const &amp; P);</pre>
</td> <td>(1)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Path &amp; Toán tử+= (Const String_Type &amp; Str);</pre>
</td> <td>(2)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Path &amp; Toán tử+= (STD :: basic_string_view &lt;value_type&gt; str);</pre>
</td> <td>(3)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">đường dẫn &amp; toán tử+= (const value_type* ptr);</pre>
</td> <td>(4)</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">đường dẫn &amp; toán tử+= (value_type x);</pre>
</td> <td>             Không có p);</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;biểu đồ lớp&gt;</pre>
</td> <td>Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Path &amp; Toán tử+= (Biểu đồ x);</pre>
</td> <td>            Chuyển tiếp 2 First2);</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">Mẫu &lt;class Source&gt;</pre>
</td> <td>            Nhị phân p);</td> <td> <span class="t-mark-rev t-since-cxx17">(C ++ 20)</span> </td> </tr> </table> <p>Path &amp; Toán tử+= (Const Nguồn &amp; Nguồn);</p>
<div class="t-li1">
<span class="t-li">Mẫu &lt;class Source&gt;</span>Path &amp; Concat (Const Nguồn &amp; Nguồn);<code>path(p).native()</code>Mẫu &lt;Class Inputit&gt;<code>*this</code>Path &amp; Concat (đầu vào đầu tiên, đầu vào cuối cùng);<code>native()</code>Kết hợp đường dẫn hiện tại và đối số</div> <div class="t-li1">
<span class="t-li">cluct clock_time_conversion &lt;clock, std :: Chrono :: System_Clock&gt;;</span>                                   Nhị phân p);<code><span class="kw1">Không chính thức,</span> <span class="sy2">*</span>this <span class="sy2">gọi</span><span class="sy1">Đầu của phạm vi được sắp xếp đầu tiên</span> <a href="http://en.cppreference.com/w/cpp/string/basic_string_view"><span class="kw1249">Điều đó cho tất cả<span class="me2">BASIC_STRING_VIEW</span></span></a><span class="br0">.</span><span class="sy3">Không có giá trị</span>x, <span class="nu0">, nếu như</span><span class="br0">)</span><span class="sy4">Số lượng các yếu tố để sao chép</span></code>.</div> <div class="t-li1">
<span class="t-li">. Quá tải này chỉ tham gia vào độ phân giải quá tải nếu biểu thức</span>                                   Nhị phân p);<code>return *this += path(first, last);</code>.</div> <p><span class="t-v">Consexpr bool any_of (đầu vào đầu tiên, đầu vào cuối cùng, không được tính p);</span>Và<span class="t-v">            Chuyển tiếp 2 First2);</span>đường dẫn ("// máy chủ")/"foo" // kết quả là "// host/foo" (nối với dấu tách)<code>Source</code>Và<code>path</code>đường dẫn ("// host/")/"foo" // kết quả cũng là "// host/foo" (cộng đồng không có dấu tách)</p>
<ul>
<li> <code>Source</code>lớn hơn hoặc bằng<code><a href="../../string/basic_string" title="cpp/string/basic string">std::basic_string</a></code>hoặc<code><a href="../../string/basic_string_view" title="cpp/string/basic string view">std::basic_string_view</a></code>, hoặc</li>
<li> <code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw654">Điều đó cho tất cả<span class="me2">iterator_traits</span></span></a><span class="sy1">is_trivently_destructible_v</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw632">Điều đó cho tất cả<span class="me2">Tìm kiếm phạm vi</span></span></a><span class="sy1">is_trivently_destructible_v</span>Source&gt;&gt;::value_type</code> <code>char</code>Thì<span class="t-rev-inl t-since-cxx20"><span><code>char8_t</code>Thì</span><span><span class="t-mark-rev t-since-cxx20">(phép chiếu danh tính).</span></span></span><code>char16_t</code>Thì<code>char32_t</code>, hoặc<code>wchar_t</code>).</li>
</ul> <h3 id="Parameters">) với giá trị ban đầu</h3> <table class="t-par-begin"> <tr class="t-par"> <td>, nhưng được thực hiện theo</td> <td>-</td> <td>1-3,6,7)</td>
</tr> <tr class="t-par"> <td>STR</td> <td>-</td> <td>Cộng lại</td>
</tr> <tr class="t-par"> <td>Nếu mảng chứa một số yếu tố</td> <td>-</td> <td>đến tên đường dẫn được lưu trữ trong</td>
</tr> <tr class="t-par"> <td>x</td> <td>-</td> <td>ở định dạng gốc. Điều này trực tiếp thao túng giá trị của</td>
</tr> <tr class="t-par"> <td>. Nếu có một yếu tố trong</td> <td>-</td> <td> <code><a href="../../string/basic_string" title="cpp/string/basic string">std::basic_string</a></code>Thì<code><a href="../../string/basic_string_view" title="cpp/string/basic string view">std::basic_string_view</a></code>đường dẫn ("foo") / "" // kết quả là "foo /" (appends)</td>
</tr> <tr class="t-par"> <td>và sau đó sửa đổi nó với</td> <td>-</td> <td>đường dẫn ("foo") / " / thanh"; // Kết quả là "/bar" (thay thế)<a href="../../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterators</a> </td>
</tr> <tr class="t-par-hitem"> <td colspan="3">Chữ ký của hàm phải tương đương với các điều sau:</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>InputIt</code>Loại loại 1 phải sao cho một đối tượng loại T có thể được chuyển đổi hoàn toàn thành Type1. Loại loại2 phải sao cho một đối tượng loại đầu vào có thể được bỏ qua và sau đó được chuyển đổi hoàn toàn thành type2. Loại<a href="../../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</td>
</tr> <tr class="t-par-req"> <td colspan="3">// trên Windows,<code>InputIt</code>đường dẫn ("foo") / "c: / thanh";  // Kết quả là "C:/Bar" (thay thế)<code>char</code>Thì<code>wchar_t</code>Thì<code>char16_t</code>Và<code>char32_t</code>).</td>
</tr> <tr class="t-par-req"> <td colspan="3">-<code>CharT</code>đường dẫn ("foo") / "c: / thanh";  // Kết quả là "C:/Bar" (thay thế)<code>char</code>Thì<code>wchar_t</code>Thì<code>char16_t</code>Và<code>char32_t</code>).</td>
</tr>
</table> <h3 id="Return_value">phải sao cho một đối tượng thuộc loại</h3> <p><code>*this</code></p>
<h3 id="Exceptions">Ngoại lệ</h3> <p>Sao chép hàm tạo. Nếu như<code><a href="http://en.cppreference.com/w/cpp/memory/new/bad_alloc"><span class="kw696">Điều đó cho tất cả<span class="me2">đường dẫn ("foo") / "c:";      // Kết quả là "C:" (thay thế)</span></span></a></code>Nếu phân bổ bộ nhớ không thành công.</p>
<h3 id="Notes">Ghi chú</h3> <p>và có thể không di động giữa các hệ điều hành.<code><a href="append" title="cpp/filesystem/path/append">append()</a></code>hoặc<code><a href="append" title="cpp/filesystem/path/append">operator/=</a></code>Đường dẫn để nối thêm</p>
<h3 id="Example">Ví dụ</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">Chế độ xem chuỗi hoặc chuỗi để nối thêm</pre></div> <p>Nếu (sai)</p>
<div class="text source-text"><pre data-language="c">Con trỏ đến đầu chuỗi kết thúc không</pre></div> </div> <h3 id="Defect_reports">Báo cáo khiếm khuyết</h3> <p>Các báo cáo khiếm khuyết thay đổi hành vi sau đây được áp dụng hồi tố cho các tiêu chuẩn C ++ được công bố trước đó.</p>
<table class="dsctable"> <tr> <th>Dr</th> <th>Áp dụng cho</th> <th>Hành vi như được công bố</th> <th>Hành vi chính xác</th>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3055" rel="nofollow">LWG 3055</a> </td> <td>C ++ 17</td> <td>nhân vật duy nhất để nối</td> <td>Không giống như với</td>
</tr> <tr> <td>
<a class="external text" href="https://cplusplus.github.io/LWG/issue3244" rel="nofollow">LWG 3244</a> </td> <td>C ++ 17</td> <td>Chỉ tham gia vào độ phân giải quá tải nếu<code>Source</code>không phải là cùng một loại, và một trong hai:<code>path</code>bị mất tích</td> <td>Được cho</td>
</tr>
</table> <h3 id="See_also">(chức năng)</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="append" title="cpp/filesystem/path/append"> <span class="t-lines"><span>nối lại</span><span>thực hiện Unary + và Unary -</span></span></a></div> </td> <td>nối các phần tử vào đường dẫn với bộ phân cách thư mục<br/> <span class="t-mark">(chức năng thành viên công cộng)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="operator_slash" title="cpp/filesystem/path/operator slash"> <span class="t-lines"><span>người vận hành/</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">Dest_at</span></span></span></div> </td> <td>Concatenates hai đường dẫn với bộ phân cách thư mục<br/> <span class="t-mark">Tìm kiếm một mảng cho một yếu tố thuộc loại không xác định</span> </td>
</tr> </table> <div class="_attribution">
<p class="_attribution-p">© CPPReference.com<br/>Được cấp phép theo giấy phép Creative Commons Attribution-Sharealike không được chứng minh v3.0.<br/>
<a class="_attribution-link" href="https://en.cppreference.com/w/cpp/filesystem/path/concat">https://en.cppreference.com/w/cpp/filesystem/path/concat</a>
</p>
</div>
